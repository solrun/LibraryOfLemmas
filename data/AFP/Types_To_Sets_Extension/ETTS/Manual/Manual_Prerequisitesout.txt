Loading theory "Draft.ETTS_Tools" (required by "Draft.Manual_PrerequisitesTemplates" via "Draft.Manual_Prerequisites" via "Draft.ETTS")
Loading theory "HOL-Library.Function_Algebras" (required by "Draft.Manual_PrerequisitesTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
Loading theory "HOL-Library.Set_Algebras" (required by "Draft.Manual_PrerequisitesTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
Loading theory "HOL-Library.Stream" (required by "Draft.Manual_PrerequisitesTemplates" via "Draft.ExtrEqs")
instantiation
  set :: (plus) plus
  plus_set == plus :: 'a set => 'a set => 'a set
instantiation
  fun :: (type, plus) plus
  plus_fun == plus :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  set :: (times) times
  times_set == times :: 'a set => 'a set => 'a set
instantiation
  fun :: (type, zero) zero
  zero_fun == zero_class.zero :: 'a => 'b
signature LIBRARY =
  sig
    val ? : bool * ('a -> 'a) -> 'a -> 'a
    structure Any: sig type T end
    val I: 'a -> 'a
    val K: 'a -> 'b -> 'a
    val align_right: string -> int -> string -> string
    val andf: ('a -> bool) * ('a -> bool) -> 'a -> bool
    val apdupl: ('a -> 'b) -> 'a -> 'b * 'a
    val apdupr: ('a -> 'b) -> 'a -> 'a * 'b
    val apfst: ('a -> 'b) -> 'a * 'c -> 'b * 'c
    val apply2: ('a -> 'b) -> 'a * 'a -> 'b * 'b
    val apsnd: ('a -> 'b) -> 'c * 'a -> 'c * 'b
    val bool_ord: bool ord
    val build: ('a list -> 'a list) -> 'a list
    val build_rev: ('a list -> 'a list) -> 'a list
    val burrow: ('a list -> 'b list) -> 'a list list -> 'b list list
    val burrow_fst: ('a list -> 'b list) -> ('a * 'c) list -> ('b * 'c) list
    val burrow_options:
       ('a list -> 'b list) -> 'a option list -> 'b option list
    val cartouche: string -> string
    val cat_lines: string list -> string
    val chop: int -> 'a list -> 'a list * 'a list
    val chop_common_prefix:
       ('a * 'b -> bool) ->
         'a list * 'b list -> 'a list * ('a list * 'b list)
    val chop_groups: int -> 'a list -> 'a list list
    val chop_prefix: ('a -> bool) -> 'a list -> 'a list * 'a list
    val chop_suffix: ('a -> bool) -> 'a list -> 'a list * 'a list
    val combine: ('a * 'a -> bool) -> 'a list -> 'a list -> 'a list
    val commas: string list -> string
    val commas_quote: string list -> string
    val compare_each: ('a * 'b -> 'c) -> 'a list -> 'b list -> 'c list
    val curry: ('a * 'b -> 'c) -> 'a -> 'b -> 'c
    val decode_lines: string -> string
    val dict_ord: ('a * 'b -> order) -> 'a list * 'b list -> order
    val distinct: ('a * 'a -> bool) -> 'a list -> 'a list
    val divide_and_conquer: ('a -> 'a list * ('b list -> 'b)) -> 'a -> 'b
    val divide_and_conquer':
       ('a -> 'b -> ('a list * ('c list * 'b -> 'c * 'b)) * 'b) ->
         'a -> 'b -> 'c * 'b
    val downto: int * int -> int list
    val drop: int -> 'a list -> 'a list
    val drop_prefix: ('a -> bool) -> 'a list -> 'a list
    val drop_suffix: ('a -> bool) -> 'a list -> 'a list
    val dup: 'a -> 'a * 'a
    val duplicates: ('a * 'a -> bool) -> 'a list -> 'a list
    val enclose: string -> string -> string -> string
    val encode_lines: string -> string
    val eq_fst: ('a * 'b -> bool) -> ('a * 'c) * ('b * 'd) -> bool
    val eq_list: ('a * 'a -> bool) -> 'a list * 'a list -> bool
    val eq_pair:
       ('a * 'b -> bool) ->
         ('c * 'd -> bool) -> ('a * 'c) * ('b * 'd) -> bool
    val eq_set: ('a * 'a -> bool) -> 'a list * 'a list -> bool
    val eq_snd: ('a * 'b -> bool) -> ('c * 'a) * ('d * 'b) -> bool
    val equal: ''a -> ''a -> bool
    val exists: ('a -> bool) -> 'a list -> bool
    val exists_string: (string -> bool) -> string -> bool
    val fast_string_ord: string ord
    val filter: ('a -> bool) -> 'a list -> 'a list
    val filter_out: ('a -> bool) -> 'a list -> 'a list
    val find_first: ('a -> bool) -> 'a list -> 'a option
    val find_index: ('a -> bool) -> 'a list -> int
    val find_indices: ('a -> bool) -> 'a list -> int list
    val first_field: string -> string -> (string * string) option
    val flat: 'a list list -> 'a list
    val flip: ('a -> 'b -> 'c) -> 'b -> 'a -> 'c
    val fold2: ('a -> 'b -> 'c -> 'c) -> 'a list -> 'b list -> 'c -> 'c
    val fold_burrow:
       ('a list -> 'b -> 'c list * 'd) ->
         'a list list -> 'b -> 'c list list * 'd
    val fold_index: (int * 'a -> 'b -> 'b) -> 'a list -> 'b -> 'b
    val fold_product:
       ('a -> 'b -> 'c -> 'c) -> 'a list -> 'b list -> 'c -> 'c
    val fold_range: (int -> 'a -> 'a) -> int -> 'a -> 'a
    val fold_string: (string -> 'a -> 'a) -> string -> 'a -> 'a
    val foldl: ('a * 'b -> 'a) -> 'a * 'b list -> 'a
    val foldl1: ('a * 'a -> 'a) -> 'a list -> 'a
    val foldr: ('a * 'b -> 'b) -> 'a list * 'b -> 'b
    val foldr1: ('a * 'a -> 'a) -> 'a list -> 'a
    val forall: ('a -> bool) -> 'a list -> bool
    val forall_string: (string -> bool) -> string -> bool
    val fst: 'a * 'b -> 'a
    val funpow: int -> ('a -> 'a) -> 'a -> 'a
    val funpow_yield: int -> ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val get_first: ('a -> 'b option) -> 'a list -> 'b option
    val get_index: ('a -> 'b option) -> 'a list -> (int * 'b) option
    val getenv: string -> string
    val getenv_strict: string -> string
    val grouped:
       int ->
         (('a list -> 'b list) -> 'c list list -> 'd list list) ->
           ('a -> 'b) -> 'c list -> 'd list
    val has_duplicates: ('a * 'a -> bool) -> 'a list -> bool
    val hex_digit: int -> string
    val insert: ('a * 'a -> bool) -> 'a -> 'a list -> 'a list
    val int_ord: int ord
    val inter: ('a * 'b -> bool) -> 'b list -> 'a list -> 'a list
    val is_equal: order -> bool
    val is_greater: order -> bool
    val is_greater_equal: order -> bool
    val is_less: order -> bool
    val is_less_equal: order -> bool
    val is_prefix: ('a * 'a -> bool) -> 'a list -> 'a list -> bool
    val kw_bc: string parser
    val kw_bo: string parser
    val kw_col: string parser
    val length_ord: 'a list * 'b list -> order
    val list_of_pair: 'a * 'a -> 'a list
    val list_of_triple: 'a * 'a * 'a -> 'a list
    val list_ord: ('a * 'b -> order) -> 'a list * 'b list -> order
    val make_ord: ('a * 'a -> bool) -> 'a ord
    val map2: ('a -> 'b -> 'c) -> 'a list -> 'b list -> 'c list
    val map_filter: ('a -> 'b option) -> 'a list -> 'b list
    val map_index: (int * 'a -> 'b) -> 'a list -> 'b list
    val map_product: ('a -> 'b -> 'c) -> 'a list -> 'b list -> 'c list
    val map_range: (int -> 'a) -> int -> 'a list
    val map_slice_l:
       ('a list -> 'b list) -> ('a * 'c) list -> ('b * 'c) list
    val map_slice_r:
       ('a list -> 'b list) -> ('c * 'a) list -> ('c * 'b) list
    val map_slice_side_l:
       ('a list -> 'b list * 'c) -> ('a * 'd) list -> ('b * 'd) list * 'c
    val map_slice_side_r:
       ('a list -> 'b list * 'c) -> ('d * 'a) list -> ('d * 'b) list * 'c
    val map_split: ('a -> 'b * 'c) -> 'a list -> 'b list * 'c list
    val map_transpose: ('a list -> 'b) -> 'a list list -> 'b list
    val maps: ('a -> 'b list) -> 'a list -> 'b list
    val match_string: string -> string -> bool
    val member: ('a * 'b -> bool) -> 'b list -> 'a -> bool
    val member_string: string -> string -> bool
    val merge: ('a * 'a -> bool) -> 'a list * 'a list -> 'a list
    val min_list: int list -> int
    val mk_opt_id: ('a -> 'b) -> ('a -> 'b option) -> 'a -> 'b
    val normalize_lines: string -> string
    val not_equal: ''a -> ''a -> bool
    val nth: 'a list -> int -> 'a
    val nth_drop: int -> 'a list -> 'a list
    val nth_list: 'a list list -> int -> 'a list
    val nth_map: int -> ('a -> 'a) -> 'a list -> 'a list
    val nth_string: string -> int -> string
    val numdup: ('a * 'a -> bool) -> 'a list -> int
    val oct_char: string -> string
    val oo: ('a -> 'b) * ('c -> 'd -> 'a) -> 'c -> 'd -> 'b
    val ooo: ('a -> 'b) * ('c -> 'd -> 'e -> 'a) -> 'c -> 'd -> 'e -> 'b
    val oooo:
       ('a -> 'b) * ('c -> 'd -> 'e -> 'f -> 'a) ->
         'c -> 'd -> 'e -> 'f -> 'b
    val option_ord: ('a * 'b -> order) -> 'a option * 'b option -> order
    type 'a ord = 'a * 'a -> order
    val order_list: (int * 'a) list -> 'a list
    val orf: ('a -> bool) * ('a -> bool) -> 'a -> bool
    val pair: 'a -> 'b -> 'a * 'b
    val pair_of_list: 'a list -> 'a * 'a
    val partition_eq: ('a * 'a -> bool) -> 'a list -> 'a list list
    val partition_list:
       (int -> 'a -> bool) -> int -> int -> 'a list -> 'a list list
    val perhaps_apply: ('a -> 'a option) list -> 'a -> 'a option
    val perhaps_loop: ('a -> 'a option) -> 'a -> 'a option
    val plain_words: string -> string
    val pointer_eq_ord: ('a * 'a -> order) -> 'a * 'a -> order
    val prefix: string -> string -> string
    val prefix_lines: string -> string -> string
    val prefixes: 'a list -> 'a list list
    val prefixes1: 'a list -> 'a list list
    val prod_ord:
       ('a * 'b -> order) ->
         ('c * 'd -> order) -> ('a * 'c) * ('b * 'd) -> order
    val quote: string -> string
    val radixpand: int * int -> int list
    val radixstring: int * string * int -> string
    val read_int: string list -> int * string list
    val read_radix_int: int -> string list -> int * string list
    val remove: ('a * 'b -> bool) -> 'a -> 'b list -> 'b list
    val remove1: ('a * 'b -> bool) -> 'a -> 'b list -> 'b list
    val replicate: int -> 'a -> 'a list
    val replicate_string: int -> string -> string
    val reroute_ps_sp: ('a * 'b) * 'c -> 'a * ('b * 'c)
    val reroute_ps_triple: ('a * 'b) * 'c -> 'a * 'b * 'c
    val reroute_sp_ps: 'a * ('b * 'c) -> ('a * 'b) * 'c
    val reroute_sp_triple: 'a * ('b * 'c) -> 'a * 'b * 'c
    val reroute_triple_ps: 'a * 'b * 'c -> ('a * 'b) * 'c
    val reroute_triple_sp: 'a * 'b * 'c -> 'a * ('b * 'c)
    val rev_order: order -> order
    val rotate_list: 'a list -> 'a list
    val rpair: 'a -> 'b -> 'b * 'a
    val separate: 'a -> 'a list -> 'a list
    val serial: unit -> serial
    eqtype serial
    val serial_string: unit -> string
    val signed_string_of_int: int -> string
    val signed_string_of_real: real -> string
    val single: 'a -> 'a list
    val singleton: ('a list -> 'b list) -> 'a -> 'b
    val size_ord: string ord
    val snd: 'a * 'b -> 'b
    val sort: 'a ord -> 'a list -> 'a list
    val sort_by: ('a -> string) -> 'a list -> 'a list
    val sort_distinct: 'a ord -> 'a list -> 'a list
    val sort_strings: string list -> string list
    val space_explode: string -> string -> string list
    val space_implode: string -> string list -> string
    val split_last: 'a list -> 'a list * 'a
    val split_lines: string -> string list
    val split_list: ('a * 'b) list -> 'a list * 'b list
    val stamp: unit -> stamp
    eqtype stamp
    val string_of_indexname: string * int -> string
    val string_of_int: int -> string
    val string_of_real: real -> string
    val string_ord: string ord
    val submultiset: ('a * 'b -> bool) -> 'a list * 'b list -> bool
    val subset: ('a * 'b -> bool) -> 'a list * 'b list -> bool
    val subtract: ('a * 'b -> bool) -> 'a list -> 'b list -> 'b list
    val suffix: string -> string -> string
    val suffixes: 'a list -> 'a list list
    val suffixes1: 'a list -> 'a list list
    val surround: 'a -> 'a list -> 'a list
    val swap: 'a * 'b -> 'b * 'a
    val tabulate: string -> string
    val tag_list: int -> 'a list -> (int * 'a) list
    val take: int -> 'a list -> 'a list
    val take_prefix: ('a -> bool) -> 'a list -> 'a list
    val take_suffix: ('a -> bool) -> 'a list -> 'a list
    val the_single: 'a list -> 'a
    val translate_string: (string -> string) -> string -> string
    val trim: ('a -> bool) -> 'a list -> 'a list
    val trim_line: string -> string
    val trim_split_lines: string -> string list
    val triple_of_list: 'a list -> 'a * 'a * 'a
    val uncurry: ('a -> 'b -> 'c) -> 'a * 'b -> 'c
    val undefined: 'a -> 'b
    val unenclose: string -> string
    val unflat: 'a list list -> 'b list -> 'b list list
    val union: ('a * 'a -> bool) -> 'a list -> 'a list -> 'a list
    val unprefix: string -> string -> string
    val unsuffix: string -> string -> string
    val untag_list: (int * 'a) list -> 'a list
    val update: ('a * 'a -> bool) -> 'a -> 'a list -> 'a list
    val upto: int * int -> int list
    val yield_singleton:
       ('a list -> 'b -> 'c list * 'b) -> 'a -> 'b -> 'c * 'b
    val zip_options: 'a list -> 'b option list -> ('a * 'b) list
    val ||| : ('a -> order) * ('a -> order) -> 'a -> order
    val ~~ : 'a list * 'b list -> ('a * 'b) list
  end
structure Library: LIBRARY
type 'a ord = 'a * 'a -> order
eqtype serial
eqtype stamp
structure Any: sig type T end
val apfst = fn: ('a -> 'b) -> 'a * 'c -> 'b * 'c
val equal = fn: ''a -> ''a -> bool
val normalize_lines = fn: string -> string
val build = fn: ('a list -> 'a list) -> 'a list
val dup = fn: 'a -> 'a * 'a
val funpow_yield = fn: int -> ('a -> 'b * 'a) -> 'a -> 'b list * 'a
val order_list = fn: (int * 'a) list -> 'a list
val trim_split_lines = fn: string -> string list
val suffixes = fn: 'a list -> 'a list list
val eq_fst = fn: ('a * 'b -> bool) -> ('a * 'c) * ('b * 'd) -> bool
val quote = fn: string -> string
val map_slice_side_r = fn:
   ('a list -> 'b list * 'c) -> ('d * 'a) list -> ('d * 'b) list * 'c
val numdup = fn: ('a * 'a -> bool) -> 'a list -> int
val snd = fn: 'a * 'b -> 'b
val commas = fn: string list -> string
val the_single = fn: 'a list -> 'a
val partition_eq = fn: ('a * 'a -> bool) -> 'a list -> 'a list list
val ||| = fn: ('a -> order) * ('a -> order) -> 'a -> order
val prefix = fn: string -> string -> string
val is_less = fn: order -> bool
val find_indices = fn: ('a -> bool) -> 'a list -> int list
val drop_prefix = fn: ('a -> bool) -> 'a list -> 'a list
val inter = fn: ('a * 'b -> bool) -> 'b list -> 'a list -> 'a list
val cat_lines = fn: string list -> string
val map_index = fn: (int * 'a -> 'b) -> 'a list -> 'b list
val take = fn: int -> 'a list -> 'a list
val align_right = fn: string -> int -> string -> string
val eq_snd = fn: ('a * 'b -> bool) -> ('c * 'a) * ('d * 'b) -> bool
val compare_each = fn: ('a * 'b -> 'c) -> 'a list -> 'b list -> 'c list
val ~~ = fn: 'a list * 'b list -> ('a * 'b) list
val downto = fn: int * int -> int list
val rotate_list = fn: 'a list -> 'a list
val update = fn: ('a * 'a -> bool) -> 'a -> 'a list -> 'a list
val translate_string = fn: (string -> string) -> string -> string
val union = fn: ('a * 'a -> bool) -> 'a list -> 'a list -> 'a list
val fold_index = fn: (int * 'a -> 'b -> 'b) -> 'a list -> 'b -> 'b
val separate = fn: 'a -> 'a list -> 'a list
val build_rev = fn: ('a list -> 'a list) -> 'a list
val radixstring = fn: int * string * int -> string
val apdupl = fn: ('a -> 'b) -> 'a -> 'b * 'a
val match_string = fn: string -> string -> bool
val signed_string_of_int = fn: int -> string
val ? = fn: bool * ('a -> 'a) -> 'a -> 'a
val map2 = fn: ('a -> 'b -> 'c) -> 'a list -> 'b list -> 'c list
val drop_suffix = fn: ('a -> bool) -> 'a list -> 'a list
val suffixes1 = fn: 'a list -> 'a list list
val K = fn: 'a -> 'b -> 'a
val rev_order = fn: order -> order
val nth_list = fn: 'a list list -> int -> 'a list
val uncurry = fn: ('a -> 'b -> 'c) -> 'a * 'b -> 'c
val fold_product = fn:
   ('a -> 'b -> 'c -> 'c) -> 'a list -> 'b list -> 'c -> 'c
val merge = fn: ('a * 'a -> bool) -> 'a list * 'a list -> 'a list
val I = fn: 'a -> 'a
val is_less_equal = fn: order -> bool
val subtract = fn: ('a * 'b -> bool) -> 'a list -> 'b list -> 'b list
val map_slice_side_l = fn:
   ('a list -> 'b list * 'c) -> ('a * 'd) list -> ('b * 'd) list * 'c
val map_transpose = fn: ('a list -> 'b) -> 'a list list -> 'b list
val nth_map = fn: int -> ('a -> 'a) -> 'a list -> 'a list
val chop_common_prefix = fn:
   ('a * 'b -> bool) -> 'a list * 'b list -> 'a list * ('a list * 'b list)
val string_ord = fn: string ord
val pointer_eq_ord = fn: ('a * 'a -> order) -> 'a * 'a -> order
val has_duplicates = fn: ('a * 'a -> bool) -> 'a list -> bool
val reroute_triple_sp = fn: 'a * 'b * 'c -> 'a * ('b * 'c)
val replicate_string = fn: int -> string -> string
val perhaps_apply = fn: ('a -> 'a option) list -> 'a -> 'a option
val remove = fn: ('a * 'b -> bool) -> 'a -> 'b list -> 'b list
val remove1 = fn: ('a * 'b -> bool) -> 'a -> 'b list -> 'b list
val apdupr = fn: ('a -> 'b) -> 'a -> 'a * 'b
val suffix = fn: string -> string -> string
val zip_options = fn: 'a list -> 'b option list -> ('a * 'b) list
val submultiset = fn: ('a * 'b -> bool) -> 'a list * 'b list -> bool
val nth_string = fn: string -> int -> string
val kw_bc = fn: string parser
val foldl1 = fn: ('a * 'a -> 'a) -> 'a list -> 'a
val take_prefix = fn: ('a -> bool) -> 'a list -> 'a list
val andf = fn: ('a -> bool) * ('a -> bool) -> 'a -> bool
val not_equal = fn: ''a -> ''a -> bool
val string_of_indexname = fn: string * int -> string
val reroute_sp_ps = fn: 'a * ('b * 'c) -> ('a * 'b) * 'c
val unprefix = fn: string -> string -> string
val undefined = fn: 'a -> 'b
val reroute_sp_triple = fn: 'a * ('b * 'c) -> 'a * 'b * 'c
val kw_bo = fn: string parser
val read_int = fn: string list -> int * string list
val tabulate = fn: string -> string
val map_slice_l = fn:
   ('a list -> 'b list) -> ('a * 'c) list -> ('b * 'c) list
val pair_of_list = fn: 'a list -> 'a * 'a
val curry = fn: ('a * 'b -> 'c) -> 'a -> 'b -> 'c
val prod_ord = fn:
   ('a * 'b -> order) ->
     ('c * 'd -> order) -> ('a * 'c) * ('b * 'd) -> order
val foldr1 = fn: ('a * 'a -> 'a) -> 'a list -> 'a
val find_index = fn: ('a -> bool) -> 'a list -> int
val filter_out = fn: ('a -> bool) -> 'a list -> 'a list
val reroute_ps_triple = fn: ('a * 'b) * 'c -> 'a * 'b * 'c
val eq_pair = fn:
   ('a * 'b -> bool) -> ('c * 'd -> bool) -> ('a * 'c) * ('b * 'd) -> bool
val map_filter = fn: ('a -> 'b option) -> 'a list -> 'b list
val yield_singleton = fn:
   ('a list -> 'b -> 'c list * 'b) -> 'a -> 'b -> 'c * 'b
val take_suffix = fn: ('a -> bool) -> 'a list -> 'a list
val enclose = fn: string -> string -> string -> string
val orf = fn: ('a -> bool) * ('a -> bool) -> 'a -> bool
val map_product = fn: ('a -> 'b -> 'c) -> 'a list -> 'b list -> 'c list
val burrow = fn: ('a list -> 'b list) -> 'a list list -> 'b list list
val space_explode = fn: string -> string -> string list
val make_ord = fn: ('a * 'a -> bool) -> 'a ord
val dict_ord = fn: ('a * 'b -> order) -> 'a list * 'b list -> order
val getenv = fn: string -> string
val map_range = fn: (int -> 'a) -> int -> 'a list
val list_of_triple = fn: 'a * 'a * 'a -> 'a list
val unflat = fn: 'a list list -> 'b list -> 'b list list
val insert = fn: ('a * 'a -> bool) -> 'a -> 'a list -> 'a list
val mk_opt_id = fn: ('a -> 'b) -> ('a -> 'b option) -> 'a -> 'b
val surround = fn: 'a -> 'a list -> 'a list
val divide_and_conquer' = fn:
   ('a -> 'b -> ('a list * ('c list * 'b -> 'c * 'b)) * 'b) ->
     'a -> 'b -> 'c * 'b
val split_list = fn: ('a * 'b) list -> 'a list * 'b list
val hex_digit = fn: int -> string
val singleton = fn: ('a list -> 'b list) -> 'a -> 'b
val unsuffix = fn: string -> string -> string
val subset = fn: ('a * 'b -> bool) -> 'a list * 'b list -> bool
val fast_string_ord = fn: string ord
val find_first = fn: ('a -> bool) -> 'a list -> 'a option
val is_prefix = fn: ('a * 'a -> bool) -> 'a list -> 'a list -> bool
val sort_by = fn: ('a -> string) -> 'a list -> 'a list
val decode_lines = fn: string -> string
val upto = fn: int * int -> int list
val is_greater = fn: order -> bool
val rpair = fn: 'a -> 'b -> 'b * 'a
val commas_quote = fn: string list -> string
val sort = fn: 'a ord -> 'a list -> 'a list
val plain_words = fn: string -> string
val apsnd = fn: ('a -> 'b) -> 'c * 'a -> 'c * 'b
val cartouche = fn: string -> string
val signed_string_of_real = fn: real -> string
val untag_list = fn: (int * 'a) list -> 'a list
val grouped = fn:
   int ->
     (('a list -> 'b list) -> 'c list list -> 'd list list) ->
       ('a -> 'b) -> 'c list -> 'd list
val member = fn: ('a * 'b -> bool) -> 'b list -> 'a -> bool
val fst = fn: 'a * 'b -> 'a
val fold2 = fn: ('a -> 'b -> 'c -> 'c) -> 'a list -> 'b list -> 'c -> 'c
val option_ord = fn: ('a * 'b -> order) -> 'a option * 'b option -> order
val chop = fn: int -> 'a list -> 'a list * 'a list
val triple_of_list = fn: 'a list -> 'a * 'a * 'a
val apply2 = fn: ('a -> 'b) -> 'a * 'a -> 'b * 'b
val string_of_int = fn: int -> string
val exists = fn: ('a -> bool) -> 'a list -> bool
val tag_list = fn: int -> 'a list -> (int * 'a) list
val member_string = fn: string -> string -> bool
val combine = fn: ('a * 'a -> bool) -> 'a list -> 'a list -> 'a list
val is_equal = fn: order -> bool
val eq_list = fn: ('a * 'a -> bool) -> 'a list * 'a list -> bool
val map_split = fn: ('a -> 'b * 'c) -> 'a list -> 'b list * 'c list
val length_ord = fn: 'a list * 'b list -> order
val getenv_strict = fn: string -> string
val exists_string = fn: (string -> bool) -> string -> bool
val funpow = fn: int -> ('a -> 'a) -> 'a -> 'a
val sort_strings = fn: string list -> string list
val radixpand = fn: int * int -> int list
val trim_line = fn: string -> string
val oct_char = fn: string -> string
val divide_and_conquer = fn: ('a -> 'a list * ('b list -> 'b)) -> 'a -> 'b
val serial = fn: unit -> serial
val chop_groups = fn: int -> 'a list -> 'a list list
val pair = fn: 'a -> 'b -> 'a * 'b
val fold_string = fn: (string -> 'a -> 'a) -> string -> 'a -> 'a
val oooo = fn:
   ('a -> 'b) * ('c -> 'd -> 'e -> 'f -> 'a) -> 'c -> 'd -> 'e -> 'f -> 'b
val fold_range = fn: (int -> 'a -> 'a) -> int -> 'a -> 'a
val encode_lines = fn: string -> string
val read_radix_int = fn: int -> string list -> int * string list
val trim = fn: ('a -> bool) -> 'a list -> 'a list
val ooo = fn: ('a -> 'b) * ('c -> 'd -> 'e -> 'a) -> 'c -> 'd -> 'e -> 'b
val oo = fn: ('a -> 'b) * ('c -> 'd -> 'a) -> 'c -> 'd -> 'b
val flip = fn: ('a -> 'b -> 'c) -> 'b -> 'a -> 'c
val split_lines = fn: string -> string list
val foldl = fn: ('a * 'b -> 'a) -> 'a * 'b list -> 'a
val distinct = fn: ('a * 'a -> bool) -> 'a list -> 'a list
val partition_list = fn:
   (int -> 'a -> bool) -> int -> int -> 'a list -> 'a list list
val is_greater_equal = fn: order -> bool
val space_implode = fn: string -> string list -> string
val filter = fn: ('a -> bool) -> 'a list -> 'a list
val get_index = fn: ('a -> 'b option) -> 'a list -> (int * 'b) option
val nth = fn: 'a list -> int -> 'a
val kw_col = fn: string parser
val serial_string = fn: unit -> string
val foldr = fn: ('a * 'b -> 'b) -> 'a list * 'b -> 'b
val get_first = fn: ('a -> 'b option) -> 'a list -> 'b option
val prefixes = fn: 'a list -> 'a list list
val fold_burrow = fn:
   ('a list -> 'b -> 'c list * 'd) ->
     'a list list -> 'b -> 'c list list * 'd
val drop = fn: int -> 'a list -> 'a list
val bool_ord = fn: bool ord
val swap = fn: 'a * 'b -> 'b * 'a
val flat = fn: 'a list list -> 'a list
val forall = fn: ('a -> bool) -> 'a list -> bool
val maps = fn: ('a -> 'b list) -> 'a list -> 'b list
val min_list = fn: int list -> int
val chop_prefix = fn: ('a -> bool) -> 'a list -> 'a list * 'a list
val burrow_options = fn:
   ('a list -> 'b list) -> 'a option list -> 'b option list
val sort_distinct = fn: 'a ord -> 'a list -> 'a list
val unenclose = fn: string -> string
val map_slice_r = fn:
   ('a list -> 'b list) -> ('c * 'a) list -> ('c * 'b) list
val reroute_ps_sp = fn: ('a * 'b) * 'c -> 'a * ('b * 'c)
val first_field = fn: string -> string -> (string * string) option
val stamp = fn: unit -> stamp
val split_last = fn: 'a list -> 'a list * 'a
val burrow_fst = fn:
   ('a list -> 'b list) -> ('a * 'c) list -> ('b * 'c) list
val single = fn: 'a -> 'a list
val forall_string = fn: (string -> bool) -> string -> bool
val list_ord = fn: ('a * 'b -> order) -> 'a list * 'b list -> order
val eq_set = fn: ('a * 'a -> bool) -> 'a list * 'a list -> bool
val list_of_pair = fn: 'a * 'a -> 'a list
val size_ord = fn: string ord
val prefix_lines = fn: string -> string -> string
val replicate = fn: int -> 'a -> 'a list
val prefixes1 = fn: 'a list -> 'a list list
val int_ord = fn: int ord
val chop_suffix = fn: ('a -> bool) -> 'a list -> 'a list * 'a list
val reroute_triple_ps = fn: 'a * 'b * 'c -> ('a * 'b) * 'c
val nth_drop = fn: int -> 'a list -> 'a list
val string_of_real = fn: real -> string
val perhaps_loop = fn: ('a -> 'a option) -> 'a -> 'a option
val duplicates = fn: ('a * 'a -> bool) -> 'a list -> 'a list
instantiation
  set :: (zero) zero
  zero_set == zero_class.zero :: 'a set
instantiation
  fun :: (type, times) times
  times_fun == times :: ('a => 'b) => ('a => 'b) => 'a => 'b
signature TERM =
  sig
    val ---> : typ list * typ -> typ
    val --> : typ * typ -> typ
    exception TERM of string * term list
    exception TYPE of string * typ list * term list
    exception USED_FREE of string * term
    val aT: sort -> typ
    val a_itselfT: typ
    val abs: string * typ -> term -> term
    val absdummy: typ -> term -> term
    val absfree: string * typ -> term -> term
    val abstract_over: term * term -> term
    val aconv: term * term -> bool
    val aconv_untyped: term * term -> bool
    val add_const_names: term -> string list -> string list
    val add_consts: term -> (string * typ) list -> (string * typ) list
    val add_free_names: term -> string list -> string list
    val add_frees: term -> (string * typ) list -> (string * typ) list
    val add_loose_bnos: term * int * int list -> int list
    val add_tfree_names: term -> string list -> string list
    val add_tfree_namesT: typ -> string list -> string list
    val add_tfrees: term -> (string * sort) list -> (string * sort) list
    val add_tfreesT: typ -> (string * sort) list -> (string * sort) list
    val add_tvar_names: term -> indexname list -> indexname list
    val add_tvar_namesT: typ -> indexname list -> indexname list
    val add_tvars:
       term -> (indexname * sort) list -> (indexname * sort) list
    val add_tvarsT:
       typ -> (indexname * sort) list -> (indexname * sort) list
    val add_var_names: term -> indexname list -> indexname list
    val add_vars: term -> (indexname * typ) list -> (indexname * typ) list
    val args_of: term -> term list
    val argument_type_of: term -> int -> typ
    type arity = string * sort list * sort
    val betapply: term * term -> term
    val betapplys: term * term list -> term
    val binder_types: typ -> typ list
    val body_type: typ -> typ
    val burrow_types: (typ list -> typ list) -> term list -> term list
    eqtype class
    val close_schematic_term: term -> term
    val could_beta_contract: term -> bool
    val could_beta_eta_contract: term -> bool
    val could_eta_contract: term -> bool
    val could_match_const: (''a * typ) * (''a * typ) -> bool
    val could_unify: term * term -> bool
    val declare_term_frees: term -> Name.context -> Name.context
    val declare_term_names: term -> Name.context -> Name.context
    val declare_typ_names: typ -> Name.context -> Name.context
    val dependent_lambda_name: string * term -> term -> term
    val dest_Const: term -> string * typ
    val dest_Free: term -> string * typ
    val dest_TFree: typ -> string * sort
    val dest_TVar: typ -> indexname * sort
    val dest_Type: typ -> string * typ list
    val dest_Var: term -> indexname * typ
    val dest_abs_fresh: string -> term -> (string * typ) * term
    val dest_abs_global: term -> (string * typ) * term
    val dest_comb: term -> term * term
    val dest_funT: typ -> typ * typ
    val domain_type: typ -> typ
    val dummy: term
    val dummyS: sort
    val dummyT: typ
    val dummy_pattern: typ -> term
    val dummy_prop: term
    val eq_ix: indexname * indexname -> bool
    val eq_tvar: (indexname * sort) * (indexname * sort) -> bool
    val eq_var: (indexname * typ) * (indexname * typ) -> bool
    val exists_Const: (string * typ -> bool) -> term -> bool
    val exists_subterm: (term -> bool) -> term -> bool
    val exists_subtype: (typ -> bool) -> typ -> bool
    val exists_type: (typ -> bool) -> term -> bool
    val fastype_of: term -> typ
    val fastype_of1: typ list * term -> typ
    val fold_aterms: (term -> 'a -> 'a) -> term -> 'a -> 'a
    val fold_atyps: (typ -> 'a -> 'a) -> typ -> 'a -> 'a
    val fold_atyps_sorts: (typ * sort -> 'a -> 'a) -> typ -> 'a -> 'a
    val fold_subtypes: (typ -> 'a -> 'a) -> typ -> 'a -> 'a
    val fold_term_types: (term -> typ -> 'a -> 'a) -> term -> 'a -> 'a
    val fold_types: (typ -> 'a -> 'a) -> term -> 'a -> 'a
    val free_dummy_patterns: term -> Name.context -> term * Name.context
    val has_tfreesT: typ -> bool
    val head_of: term -> term
    val hidden_polymorphism: term -> (indexname * sort) list
    val incr_boundvars: int -> term -> term
    val incr_bv: int * int * term -> term
    type indexname = string * int
    val is_Bound: term -> bool
    val is_Const: term -> bool
    val is_Free: term -> bool
    val is_TFree: typ -> bool
    val is_TVar: typ -> bool
    val is_Type: typ -> bool
    val is_Var: term -> bool
    val is_comb: term -> bool
    val is_cv: term -> bool
    val is_dependent: term -> bool
    val is_dummy_pattern: term -> bool
    val is_first_order: string list -> term -> bool
    val is_open: term -> bool
    val itselfT: typ -> typ
    val lambda: term -> term -> term
    val lambda_name: string * term -> term -> term
    val list_comb: term * term list -> term
    val loose_bnos: term -> int list
    val loose_bvar: term * int -> bool
    val loose_bvar1: term * int -> bool
    val map_abs_vars: (string -> string) -> term -> term
    val map_aterms: (term -> term) -> term -> term
    val map_atyps: (typ -> typ) -> typ -> typ
    val map_const: (string * typ -> term) -> term -> term
    val map_fv: (string * typ -> term) -> term -> term
    val map_sv: (indexname * typ -> term) -> term -> term
    val map_tfree: (string * sort -> typ) -> term -> term
    val map_type_tfree: (string * sort -> typ) -> typ -> typ
    val map_type_tvar: (indexname * sort -> typ) -> typ -> typ
    val map_types: (typ -> typ) -> term -> term
    val match_bvars:
       term * term -> (string * string) list -> (string * string) list
    val maxidx_of_term: term -> int
    val maxidx_of_typ: typ -> int
    val maxidx_of_typs: typ list -> int
    val maxidx_term: term -> int -> int
    val maxidx_typ: typ -> int -> int
    val maxidx_typs: typ list -> int -> int
    val no_dummyT: typ -> typ
    val no_dummy_patterns: term -> term
    val propT: typ
    val range_type: typ -> typ
    val rename_abs: term -> term -> term -> term option
    val rename_wrt_term: term -> (string * 'a) list -> (string * 'a) list
    val replace_dummy_patterns: term -> int -> term * int
    val show_dummy_patterns: term -> term
    val size_of_term: term -> int
    val size_of_typ: typ -> int
    type sort = class list
    val sort_eqT: theory -> typ * typ -> bool
    val sort_of_tvar: typ -> sort
    val string_of_vname: indexname -> string
    val string_of_vname': indexname -> string
    val strip_abs: term -> (string * typ) list * term
    val strip_abs_body: term -> term
    val strip_abs_eta: int -> term -> (string * typ) list * term
    val strip_abs_vars: term -> (string * typ) list
    val strip_all_body: term -> term
    val strip_all_vars: term -> (string * typ) list
    val strip_comb: term -> term * term list
    val strip_qnt_body: string -> term -> term
    val strip_qnt_vars: string -> term -> (string * typ) list
    val strip_type: typ -> typ list * typ
    val subst_TVars: (indexname * typ) list -> term -> term
    val subst_Vars: (indexname * term) list -> term -> term
    val subst_atomic: (term * term) list -> term -> term
    val subst_atomic_types: (typ * typ) list -> term -> term
    val subst_bound: term * term -> term
    val subst_bounds: term list * term -> term
    val subst_free: (term * term) list -> term -> term
    val subst_vars:
       (indexname * typ) list * (indexname * term) list -> term -> term
    datatype term
    =
         $ of term * term
       | Abs of string * typ * term
       | Bound of int
       | Const of string * typ
       | Free of string * typ
       | Var of indexname * typ
    val term_name: term -> string
    datatype typ
    =
         TFree of string * sort
       | TVar of indexname * sort
       | Type of string * typ list
    val typ_subst_TVars: (indexname * typ) list -> typ -> typ
    val typ_subst_atomic: (typ * typ) list -> typ -> typ
    val type_of: term -> typ
    val type_of1: typ list * term -> typ
    val used_free: string -> term -> bool
    val variant_frees: term -> (string * 'a) list -> (string * 'a) list
  end
structure Term: TERM
instantiation
  set :: (one) one
  one_set == one_class.one :: 'a set
instantiation
  fun :: (type, one) one
  one_fun == one_class.one :: 'a => 'b
signature LOGIC =
  sig
    val all: term -> term -> term
    val all_const: typ -> term
    val all_constraint:
       (string -> typ option) -> string * string -> term -> term
    val assum_pairs: int * term -> (term * term) list
    val assum_problems: int * term -> (term -> term) * term list * term
    val bad_fixed: string -> string
    val bad_schematic: indexname -> string
    val class_of_const: string -> class
    val close_form: term -> term
    val close_prop: (string * term) list -> term list -> term -> term
    val close_prop_constraint:
       (string -> typ option) ->
         (string * string) list -> term list -> term -> term
    val close_term: (string * term) list -> term -> term
    val combound: term * int * int -> term
    val concl_of_goal: term -> int -> term
    val conjunction: term
    val const_of_class: class -> string
    val count_prems: term -> int
    val dependent_all_constraint:
       (string -> typ option) -> string * string -> term -> term
    val dependent_all_name: string * term -> term -> term
    val dest_all_global: term -> (string * typ) * term
    val dest_arity: term -> string * sort list * class
    val dest_classrel: term -> class * class
    val dest_conjunction: term -> term * term
    val dest_conjunction_balanced: int -> term -> term list
    val dest_conjunction_list: term -> term list
    val dest_conjunctions: term -> term list
    val dest_equals: term -> term * term
    val dest_implies: term -> term * term
    val dest_of_class: term -> typ * class
    val dest_term: term -> term
    val dest_type: term -> typ
    val dummy_tfree: sort -> typ
    val flatten_params: int -> term -> term
    val forall_elim_all: term -> term * (string * typ) list
    val get_forall_ftv_permute:
       term -> term * ((string * typ) list * int list)
    val get_goal: term -> int -> term
    val goal_params: term -> int -> term * term list
    val has_meta_prems: term -> bool
    val implies: term
    val incr_indexes: string list * typ list * int -> term -> term
    val incr_indexes_same:
       string list * typ list * int -> term Same.operation
    val incr_tvar: int -> typ -> typ
    val incr_tvar_same: int -> typ Same.operation
    val is_all: term -> bool
    val is_equals: term -> bool
    val lift_abs: int -> term -> term -> term
    val lift_all: int -> term -> term -> term
    val list_all: (string * typ) list * term -> term
    val list_implies: term list * term -> term
    val list_rename_params: string list -> term -> term
    val mk_arities: arity -> term list
    val mk_arity: string * sort list * class -> term
    val mk_classrel: class * class -> term
    val mk_conjunction: term * term -> term
    val mk_conjunction_balanced: term list -> term
    val mk_conjunction_list: term list -> term
    val mk_equals: term * term -> term
    val mk_implies: term * term -> term
    val mk_of_class: typ * class -> term
    val mk_of_sort: typ * sort -> term list
    val mk_term: term -> term
    val mk_type: typ -> term
    val name_arities: arity -> string list
    val name_arity: string * sort list * class -> string
    val name_classrel: string * string -> string
    val no_prems: term -> bool
    val nth_prem: int * term -> term
    val occs: term * term -> bool
    val prems_of_goal: term -> int -> term list
    val protect: term -> term
    val protectC: term
    val rlist_abs: (string * typ) list * term -> term
    val strip_assums_concl: term -> term
    val strip_assums_hyp: term -> term list
    val strip_horn: term -> term list * term
    val strip_imp_concl: term -> term
    val strip_imp_prems: term -> term list
    val strip_params: term -> (string * typ) list
    val strip_prems: int * term list * term -> term list * term
    val true_prop: term
    val type_map: (term -> term) -> typ -> typ
    val unconstrainT: sort list -> term -> unconstrain_context * term
    type unconstrain_context =
       {atyp_map: typ -> typ,
        constraints: ((typ * class) * term) list,
        constraints_map: (sort * typ) list,
        map_atyps: typ -> typ,
        outer_constraints: (typ * class) list,
        present_map: (typ * typ) list}
    val unoverload_types_term: theory -> term -> term
    val unprotect: term -> term
    val unvarifyT_global: typ -> typ
    val unvarify_global: term -> term
    val unvarify_local_term: Proof.context -> term -> term * Proof.context
    val unvarify_types_global: term -> term
    val unvarify_types_local_term:
       Proof.context -> term -> term * Proof.context
    val varifyT_global: typ -> typ
    val varifyT_mixed_global: typ -> typ
    val varify_global: term -> term
    val varify_mixed_global: term -> term
    val varify_types_global: term -> term
  end
structure Logic: LOGIC
signature TACTICAL =
  sig
    val ALLGOALS: (int -> tactic) -> tactic
    val APPEND: tactic * tactic -> tactic
    val APPEND': ('a -> tactic) * ('a -> tactic) -> 'a -> tactic
    val ASSERT_SUBGOAL: (int -> tactic) -> int -> tactic
    val CHANGED: tactic -> tactic
    val CHANGED_GOAL: (int -> tactic) -> int -> tactic
    val CHANGED_PROP: tactic -> tactic
    val COND: (thm -> bool) -> tactic -> tactic -> tactic
    val CONVERSION: conv -> int -> tactic
    val CSUBGOAL: (cterm * int -> tactic) -> int -> tactic
    val DETERM: tactic -> tactic
    val EVERY: tactic list -> tactic
    val EVERY': ('a -> tactic) list -> 'a -> tactic
    val EVERY1: (int -> tactic) list -> tactic
    val FILTER: (thm -> bool) -> tactic -> tactic
    val FIRST: tactic list -> tactic
    val FIRST': ('a -> tactic) list -> 'a -> tactic
    val FIRST1: (int -> tactic) list -> tactic
    val FIRSTGOAL: (int -> tactic) -> tactic
    val FIRST_APPEND': ('a -> tactic) list -> 'a -> tactic
    val HEADGOAL: (int -> tactic) -> tactic
    val ORELSE: tactic * tactic -> tactic
    val ORELSE': ('a -> tactic) * ('a -> tactic) -> 'a -> tactic
    val PRIMITIVE: (thm -> thm) -> tactic
    val PRIMSEQ: (thm -> thm Seq.seq) -> tactic
    val RANGE: (int -> tactic) list -> int -> tactic
    val REPEAT: tactic -> tactic
    val REPEAT1: tactic -> tactic
    val REPEAT_ALL_NEW: (int -> tactic) -> int -> tactic
    val REPEAT_DETERM: tactic -> tactic
    val REPEAT_DETERM1: tactic -> tactic
    val REPEAT_DETERM_FIRST: (int -> tactic) -> tactic
    val REPEAT_DETERM_N: int -> tactic -> tactic
    val REPEAT_DETERM_SOME: (int -> tactic) -> tactic
    val REPEAT_FIRST: (int -> tactic) -> tactic
    val REPEAT_SOME: (int -> tactic) -> tactic
    val SINGLE: tactic -> thm -> thm option
    val SOLVED': (int -> tactic) -> int -> tactic
    val SOMEGOAL: (int -> tactic) -> tactic
    val SUBGOAL: (term * int -> tactic) -> int -> tactic
    val THEN: tactic * tactic -> tactic
    val THEN': ('a -> tactic) * ('a -> tactic) -> 'a -> tactic
    val THEN_ALL_NEW: (int -> tactic) * (int -> tactic) -> int -> tactic
    val THEN_ELSE: tactic * (tactic * tactic) -> tactic
    val TRY: tactic -> tactic
    val TRYALL: (int -> tactic) -> tactic
    val all_tac: tactic
    val no_tac: tactic
    val print_tac: Proof.context -> string -> tactic
    type tactic = thm -> thm Seq.seq
  end
structure Tactical: TACTICAL
type tactic = thm -> thm Seq.seq
val FILTER = fn: (thm -> bool) -> tactic -> tactic
val REPEAT1 = fn: tactic -> tactic
val TRYALL = fn: (int -> tactic) -> tactic
val THEN = fn: tactic * tactic -> tactic
val COND = fn: (thm -> bool) -> tactic -> tactic -> tactic
val REPEAT = fn: tactic -> tactic
val ASSERT_SUBGOAL = fn: (int -> tactic) -> int -> tactic
val REPEAT_SOME = fn: (int -> tactic) -> tactic
val ORELSE' = fn: ('a -> tactic) * ('a -> tactic) -> 'a -> tactic
val print_tac = fn: Proof.context -> string -> tactic
val REPEAT_DETERM1 = fn: tactic -> tactic
val CONVERSION = fn: conv -> int -> tactic
val EVERY = fn: tactic list -> tactic
val ORELSE = fn: tactic * tactic -> tactic
val FIRST_APPEND' = fn: ('a -> tactic) list -> 'a -> tactic
val FIRST = fn: tactic list -> tactic
val SOMEGOAL = fn: (int -> tactic) -> tactic
val REPEAT_FIRST = fn: (int -> tactic) -> tactic
val APPEND' = fn: ('a -> tactic) * ('a -> tactic) -> 'a -> tactic
val SINGLE = fn: tactic -> thm -> thm option
val THEN_ELSE = fn: tactic * (tactic * tactic) -> tactic
val no_tac = fn: tactic
val ALLGOALS = fn: (int -> tactic) -> tactic
val THEN' = fn: ('a -> tactic) * ('a -> tactic) -> 'a -> tactic
val SUBGOAL = fn: (term * int -> tactic) -> int -> tactic
val REPEAT_DETERM = fn: tactic -> tactic
val CSUBGOAL = fn: (cterm * int -> tactic) -> int -> tactic
val APPEND = fn: tactic * tactic -> tactic
val PRIMITIVE = fn: (thm -> thm) -> tactic
val THEN_ALL_NEW = fn: (int -> tactic) * (int -> tactic) -> int -> tactic
val REPEAT_ALL_NEW = fn: (int -> tactic) -> int -> tactic
val EVERY1 = fn: (int -> tactic) list -> tactic
val FIRSTGOAL = fn: (int -> tactic) -> tactic
val RANGE = fn: (int -> tactic) list -> int -> tactic
val all_tac = fn: tactic
val FIRST1 = fn: (int -> tactic) list -> tactic
val REPEAT_DETERM_N = fn: int -> tactic -> tactic
val PRIMSEQ = fn: (thm -> thm Seq.seq) -> tactic
val CHANGED_GOAL = fn: (int -> tactic) -> int -> tactic
val TRY = fn: tactic -> tactic
val EVERY' = fn: ('a -> tactic) list -> 'a -> tactic
val HEADGOAL = fn: (int -> tactic) -> tactic
val FIRST' = fn: ('a -> tactic) list -> 'a -> tactic
val CHANGED_PROP = fn: tactic -> tactic
val REPEAT_DETERM_SOME = fn: (int -> tactic) -> tactic
val REPEAT_DETERM_FIRST = fn: (int -> tactic) -> tactic
val SOLVED' = fn: (int -> tactic) -> int -> tactic
val DETERM = fn: tactic -> tactic
val CHANGED = fn: tactic -> tactic
structure More_Simplifier:
  sig
    val asm_full_var_simplify: Proof.context -> thm -> thm
    val rewrite_simp_opt: Proof.context -> thm list option -> thm -> thm
    val rewrite_simp_opt':
       Proof.context -> (Facts.ref * Token.src list) option -> thm -> thm
    val var_simplified:
       Context.generic * Token.T list ->
         attribute * (Context.generic * Token.T list)
    val var_simplify_only: Proof.context -> thm list -> thm -> thm
  end
signature HOLOGIC =
  sig
    val Collect_const: typ -> term
    val Not: term
    val Suc_zero: term
    val Trueprop: term
    val Trueprop_conv: conv -> conv
    val add_numerals: term -> (term * typ) list -> (term * typ) list
    val all_const: typ -> term
    val bit0_const: term
    val bit1_const: term
    val boolN: string
    val boolT: typ
    val case_prod_const: typ * typ * typ -> term
    val charT: typ
    val choice_const: typ -> term
    val class_equal: string
    val class_size: string
    val code_integerT: typ
    val code_naturalT: typ
    val conj: term
    val conj_conv: conv -> conv -> conv
    val conj_elim: Proof.context -> thm -> thm * thm
    val conj_elims: Proof.context -> thm -> thm list
    val conj_intr: Proof.context -> thm -> thm -> thm
    val conjuncts: term -> term list
    val cons_const: typ -> term
    val dest_SetT: typ -> typ
    val dest_SetTFree: typ -> string * sort
    val dest_Suc: term -> term
    val dest_Trueprop: term -> term
    val dest_bin: string -> typ -> term -> term * term
    val dest_binrelT: typ -> typ * typ
    val dest_char: term -> int
    val dest_conj: term -> term list
    val dest_disj: term -> term list
    val dest_eq: term -> term * term
    val dest_exists: term -> string * typ * term
    val dest_imp: term -> term * term
    val dest_list: term -> term list
    val dest_literal: term -> string
    val dest_mem: term -> term * term
    val dest_nat: term -> int
    val dest_not: term -> term
    val dest_number: term -> typ * int
    val dest_numeral: term -> int
    val dest_prod: term -> term * term
    val dest_prodT: typ -> typ * typ
    val dest_set: term -> term list
    val dest_setT: typ -> typ
    val dest_string: term -> string
    val dest_type_definition: term -> term * term * term
    val disj: term
    val disjuncts: term -> term list
    val eq_const: typ -> term
    val eq_conv: conv -> conv -> conv
    val exists_const: typ -> term
    val flat_tupleT_paths: typ -> int list list
    val flat_tuple_paths: term -> int list list
    val flatten_tupleT: typ -> typ list
    val id_const: typ -> term
    val imp: term
    val intT: typ
    val is_binrelT: typ -> bool
    val is_binrelvarT: typ -> bool
    val is_conj: term -> bool
    val is_setT: typ -> bool
    val is_unit: term -> bool
    val is_unitT: typ -> bool
    val is_var_setT: typ -> bool
    val is_zero: term -> bool
    val listT: typ -> typ
    val list_all: (string * typ) list * term -> term
    val literalT: typ
    val mk_Collect: string * typ * term -> term
    val mk_ST:
       ((term * typ) * (string * typ) option) list ->
         term -> typ -> typ option * typ -> term
    val mk_Suc: term -> term
    val mk_Trueprop: term -> term
    val mk_UNIV: typ -> term
    val mk_all: string * typ * term -> term
    val mk_binop: string -> term * term -> term
    val mk_binrel: string -> term * term -> term
    val mk_binrelT: typ * typ -> typ
    val mk_case_prod: term -> term
    val mk_char: int -> term
    val mk_comp: term * term -> term
    val mk_conj: term * term -> term
    val mk_disj: term * term -> term
    val mk_eq: term * term -> term
    val mk_exists: string * typ * term -> term
    val mk_fst: term -> term
    val mk_imp: term * term -> term
    val mk_induct_forall: typ -> term
    val mk_list: typ -> term list -> term
    val mk_literal: string -> term
    val mk_mem: term * term -> term
    val mk_nat: int -> term
    val mk_not: term -> term
    val mk_number: typ -> int -> term
    val mk_numeral: int -> term
    val mk_obj_eq: thm -> thm
    val mk_prod: term * term -> term
    val mk_prodT: typ * typ -> typ
    val mk_ptuple: int list list -> typ -> term list -> term
    val mk_ptupleT: int list list -> typ list -> typ
    val mk_ptupleabs: int list list -> typ -> typ -> term -> term
    val mk_random: typ -> term -> term
    val mk_rel: string * (typ * typ) -> term
    val mk_return: typ -> typ -> term -> term
    val mk_set: typ -> term list -> term
    val mk_setT: typ -> typ
    val mk_snd: term -> term
    val mk_string: string -> term
    val mk_term_of: typ -> term -> term
    val mk_tuple: term list -> term
    val mk_tupleT: typ list -> typ
    val mk_type_definition_pred: typ -> typ -> term
    val mk_typerep: typ -> term
    val mk_valtermify_app: string -> (string * typ) list -> typ -> term
    val natT: typ
    val nil_const: typ -> term
    val numeral_const: typ -> term
    val one_const: term
    val pair_const: typ -> typ -> term
    val realT: typ
    val reflect_term: term -> term
    val size_const: typ -> term
    val stringT: typ
    val strip_ptuple: int list list -> term -> term list
    val strip_ptupleT: int list list -> typ -> typ list
    val strip_ptupleabs: term -> term * typ list * int list list
    val strip_tuple: term -> term list
    val strip_tupleT: typ -> typ list
    val termT: typ
    val term_of_const: typ -> term
    val tupled_lambda: term -> term -> term
    val unit: term
    val unitT: typ
    val zero: term
  end
structure HOLogic: HOLOGIC
signature TRANSFER =
  sig
    val eq_tac: Proof.context -> int -> tactic
    val fold_relator_eqs_conv: Proof.context -> conv
    val gen_frees_tac: (string * typ) list -> Proof.context -> int -> tactic
    val get_relator_domain: Proof.context -> thm list
    val get_relator_eq: Proof.context -> thm list
    val get_relator_eq_raw: Proof.context -> thm list
    val get_sym_relator_eq: Proof.context -> thm list
    val get_transfer_raw: Proof.context -> thm list
    val is_compound_lhs: Proof.context -> term -> bool
    val is_compound_rhs: Proof.context -> term -> bool
    val is_is_equality: term -> bool
    val lookup_pred_data: Proof.context -> string -> pred_data option
    val mk_bi_unique: term -> term
    val mk_pred_data: thm -> thm -> thm list -> pred_data
    val mk_rel_sc: string -> term -> term
    val mk_right_total: term -> term
    val mk_transfer_rels: thm list -> thm list
    val morph_pred_data: morphism -> pred_data -> pred_data
    type pred_data
    val pred_def: pred_data -> thm
    val pred_simps: pred_data -> thm list
    val prep_conv: conv
    val prep_transfer_domain_thm: Proof.context -> thm -> thm
    val rel_eq_onp: pred_data -> thm
    val retrieve_relator_eq: Proof.context -> term -> thm list
    val transfer_add: attribute
    val transfer_del: attribute
    val transfer_domain_add: attribute
    val transfer_domain_del: attribute
    val transfer_end_tac: Proof.context -> int -> tactic
    val transfer_prover_end_tac: Proof.context -> int -> tactic
    val transfer_prover_start_tac: Proof.context -> int -> tactic
    val transfer_prover_tac: Proof.context -> int -> tactic
    val transfer_raw_add: thm -> Context.generic -> Context.generic
    val transfer_raw_del: thm -> Context.generic -> Context.generic
    val transfer_rule_of_lhs: Proof.context -> term -> thm
    val transfer_rule_of_term: Proof.context -> bool -> term -> thm
    val transfer_start_tac: bool -> Proof.context -> int -> tactic
    val transfer_step_tac: Proof.context -> int -> tactic
    val transfer_tac: bool -> Proof.context -> int -> tactic
    val transferred_attribute: thm list -> attribute
    val unfold_relator_eqs_conv: Proof.context -> conv
    val untransferred_attribute: thm list -> attribute
    val update_pred_data:
       string -> pred_data -> Context.generic -> Context.generic
    val update_pred_simps: thm list -> pred_data -> pred_data
  end
structure Transfer: TRANSFER
signature ETTS_WRITER =
  sig
    val increment_index: int -> int list -> int list
    val initialize: int -> int list
    val write_action: string -> int list -> int list
  end
structure ETTS_Writer: ETTS_WRITER
### theory "Draft.ETTS_Tools"
### 0.144s elapsed time, 0.549s cpu time, 0.052s GC time
Loading theory "HOL-Library.Tree" (required by "Draft.Manual_PrerequisitesTemplates" via "Draft.ExtrEqs" via "Draft.Templates")
### theory "HOL-Library.Function_Algebras"
### 0.157s elapsed time, 0.599s cpu time, 0.052s GC time
Loading theory "Draft.ETTS" (required by "Draft.Manual_PrerequisitesTemplates" via "Draft.Manual_Prerequisites")
### theory "HOL-Library.Set_Algebras"
### 0.247s elapsed time, 0.962s cpu time, 0.052s GC time
Loading theory "HOL-Library.BigO" (required by "Draft.Manual_PrerequisitesTemplates" via "Draft.ExtrEqs")
consts
  shift :: "'a list => 'a stream => 'a stream"
Proofs for coinductive predicate(s) "streamsp"
  Proving monotonicity ...
signature ETTS_TACTICS =
  sig
    val cond_red_tac:
       Proof.context ->
         term -> (Proof.context -> tactic) -> thm -> int -> tactic
    val id_tac: thm -> int -> tactic
    val prem_red:
       Proof.context -> term list * (Proof.context -> tactic) -> thm -> thm
  end
structure ETTS_Tactics: ETTS_TACTICS
signature ETTS_UTILITIES =
  sig
    val string_of_token_src_list: Token.src list -> string
    val term_name_of_type_name: string -> string
  end
structure ETTS_Utilities: ETTS_UTILITIES
val string_of_token_src_list = fn: Token.src list -> string
val term_name_of_type_name = fn: string -> string
signature ETTS_RI =
  sig
    val dest_rissetFree: term -> string * (string * sort)
    val dest_rissetT: typ -> string * sort
    val ftv_spec_of_rissetT_spec: string -> string * string list
    val fv_spec_of_rissetFree: string * string -> string * typ
    val is_risset: term -> bool
    val mk_Domainp_sc: term -> term -> term
    val risset_input: Proof.context -> string -> term list -> unit
    val type_of_rissetT_spec: string -> typ
  end
structure ETTS_RI: ETTS_RI
consts
  snth :: "'a stream => nat => 'a"
consts
  stake :: "nat => 'a stream => 'a list"
consts
  sdrop :: "nat => 'a stream => 'a stream"
signature ETTS_SUBSTITUTION =
  sig
    val is_sbt_data_key: Proof.context -> cterm -> bool
    val process_tts_register_sbts:
       string * string list -> Proof.context -> Proof.state
    val sbt_data_of: Proof.context -> Ctermtab.key -> thm option
  end
structure ETTS_Substitution: ETTS_SUBSTITUTION
consts
  sfilter :: "('a => bool) => 'a stream => 'a stream"
consts
  cycle :: "'a list => 'a stream"
consts
  left :: "'a tree => 'a tree"
consts
  right :: "'a tree => 'a tree"
signature ETTS_CONTEXT =
  sig
    val amend_context_data:
       amend_ctxt_data_input_type ->
         Proof.context -> ctxt_def_type * Proof.context
    type amend_ctxt_data_input_type
    type ctxt_def_type
    val get_tts_ctxt_data: Proof.context -> ctxt_def_type
    val process_tts_context:
       amend_ctxt_data_input_type ->
         Toplevel.transition -> Toplevel.transition
    val rule_attrb: string list
    val string_of_amend_context_data_args:
       Proof.context -> amend_ctxt_data_input_type -> string
    val string_of_mpespc_opt:
       Proof.context ->
         (term list * (Proof.context -> tactic)) option -> string
    val string_of_sbrr_opt: (Facts.ref * Token.src list) option -> string
    val string_of_subst_thms: (Facts.ref * Token.src list) list -> string
    val string_of_tts_ctxt_data: Proof.context -> ctxt_def_type -> string
    val update_tts_ctxt_data:
       ctxt_def_type -> Proof.context -> Proof.context
  end
structure ETTS_Context: ETTS_CONTEXT
consts
  siterate :: "('a => 'a) => 'a => 'a stream"
Found termination order: "size <*mlex*> {}"
consts
  flat :: "'a list stream => 'a stream"
Found termination order: "size <*mlex*> {}"
consts
  sinterleave :: "'a stream => 'a stream => 'a stream"
consts
  szip :: "'a stream => 'b stream => ('a * 'b) stream"
Found termination order: "size <*mlex*> {}"
consts
  smap2 :: "('a => 'b => 'c) => 'a stream => 'b stream => 'c stream"
signature ETTS_ALGORITHM =
  sig
    val dest_local_typedef_ex: term -> typ * term
    val etts_algorithm:
       Proof.context ->
         etts_output_type ->
           int list ->
             (indexname * term) list ->
               (term * term) list ->
                 (Facts.ref * Token.src list) option ->
                   (Facts.ref * Token.src list) list ->
                     (term list * (Proof.context -> tactic)) option ->
                       Token.src list ->
                         thm -> (thm * int list) * Proof.context
    val etts_fact:
       Proof.context ->
         etts_output_type ->
           int list ->
             (indexname * term) list ->
               (term * term) list ->
                 (Facts.ref * Token.src list) option ->
                   (Facts.ref * Token.src list) list ->
                     (term list * (Proof.context -> tactic)) option ->
                       Token.src list ->
                         thm list -> (thm list * int list) * Proof.context
    datatype etts_output_type = active | default | verbose
    val etts_output_type_of_string: string -> etts_output_type
    val is_active: etts_output_type -> bool
    val is_default: etts_output_type -> bool
    val is_verbose: etts_output_type -> bool
    val mk_local_typedef_ex: (string * sort) * term -> term
    val string_of_etts_output_type: etts_output_type -> string
  end
structure ETTS_Algorithm: ETTS_ALGORITHM
class height = type +
  fixes height :: "'a => nat"
instantiation
  tree :: (type) height
  height_tree == height :: 'a tree => nat
signature ETTS_ACTIVE =
  sig
    val etts_indent: int Config.T
    datatype etts_thm_type
    = tts_corollary | tts_lemma | tts_proposition | tts_theorem
    val theorem_string_of_term:
       Proof.context ->
         etts_thm_type ->
           string ->
             Token.src list -> string -> Token.src list -> term -> string
  end
structure ETTS_Active: ETTS_ACTIVE
### theory "HOL-Library.Stream"
### 0.882s elapsed time, 3.423s cpu time, 0.317s GC time
Found termination order: "size <*mlex*> {}"
signature ETTS_LEMMA =
  sig val tts_lemma: Outer_Syntax.command_keyword -> string -> unit end
structure ETTS_Lemma: ETTS_LEMMA
Found termination order: "size <*mlex*> {}"
signature TTS_LEMMAS =
  sig
    val tts_lemmas:
       Proof.context ->
         ETTS_Algorithm.etts_output_type ->
           ((binding * Token.src list) *
            (thm list * (string * Token.src list))
           )
           list
             -> Proof.context * int list
  end
structure TTS_Lemmas: TTS_LEMMAS
val it = (): unit
val it = (): unit
val it = (): unit
val it = (): unit
### theory "HOL-Library.BigO"
### 0.951s elapsed time, 3.447s cpu time, 0.800s GC time
Found termination order: "size <*mlex*> {}"
### theory "Draft.ETTS"
### 1.142s elapsed time, 4.029s cpu time, 0.800s GC time
Loading theory "Draft.Manual_Prerequisites" (required by "Draft.Manual_PrerequisitesTemplates")
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
structure Antiquote_Setup: sig end
### theory "Draft.Manual_Prerequisites"
### 0.210s elapsed time, 0.444s cpu time, 0.055s GC time
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
### theory "HOL-Library.Tree"
### 1.836s elapsed time, 5.044s cpu time, 0.908s GC time
Loading theory "Draft.Templates" (required by "Draft.Manual_PrerequisitesTemplates" via "Draft.ExtrEqs")
datatype template_term
=
     t_empty
   | template_app of template_term * template_term
   | template_hole of int
   | template_var of int
datatype sign
= equals | greater_equals | greater_than | less_equals | less_than
datatype template
=
     template_bimplication of template * template
   | template_dunno
   | template_equation of template_term * template_term
   | template_implication of template list * template
   | template_inequation of sign * template_term * template_term
   | template_negation of template
   | template_predicate of template_term
constructor t_empty: template_term
constructor template_app: template_term * template_term -> template_term
constructor template_hole: int -> template_term
constructor template_var: int -> template_term
constructor equals: sign
constructor greater_equals: sign
constructor greater_than: sign
constructor less_equals: sign
constructor less_than: sign
constructor template_bimplication: template * template -> template
constructor template_dunno: template
constructor template_equation: template_term * template_term -> template
constructor template_implication: template list * template -> template
constructor template_inequation:
   sign * template_term * template_term -> template
constructor template_negation: template -> template
constructor template_predicate: template_term -> template
val vfs = fn: term -> (indexname * typ) list * (string * typ) list
val indexOf = fn: ''a list -> ''a -> int -> int
val has_eq = fn: term -> bool
val term2template = fn:
   (indexname * typ) list -> (string * typ) list -> term -> template_term
val lemma2predicate = fn: term -> term -> template
val makeTemplatewithContext = fn: term -> term -> template
val lemma2template = fn: term -> template
val thm2template = fn: thm -> template
val tterm2string = fn: template_term -> string
val template2string = fn: template -> string
val t = "height ?t <= size ?t": thm
val th =
   Const ("HOL.Trueprop", "bool => prop") $
     (Const ("Orderings.ord_class.less_eq", "nat => nat => bool") $
       (Const ("Tree.height_class.height", "?'a tree => nat") $
         Var (("t", 0), "?'a tree")) $
       (Const ("Nat.size_class.size", "?'a tree => nat") $
         Var (("t", 0), "?'a tree"))):
   term
### theory "Draft.Templates"
### 0.048s elapsed time, 0.063s cpu time, 0.000s GC time
Loading theory "Draft.ExtrEqs" (required by "Draft.Manual_PrerequisitesTemplates")
val eqpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Var (("_dummy_", 2), "?'a"))
       ):
   term Find_Theorems.criterion
val badeqpattern = Pattern (Const ("Pure.eq", "?'a => ?'a => prop")):
   term Find_Theorems.criterion
val undefpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Const ("HOL.undefined", "?'a"))
       ):
   term Find_Theorems.criterion
val thmpattern =
   Pattern
    (Const ("HOL.Trueprop", "bool => prop") $ Var (("_dummy_", 1), "bool")):
   term Find_Theorems.criterion
val badnames =
   ["*nitpick*", "*Nitpick*", "*full_exhaustive*", "*_def*", "Enum.finite*",
    "*Quickcheck*", "ATP*", "*Nunchaku*", "*Code*", "*BNF*", "*SMT*",
    "*.*.*"]:
   string list
val unwanted_names =
   [(false, Name "*nitpick*"), (false, Name "*Nitpick*"),
    (false, Name "*full_exhaustive*"), (false, Name "*_def*"),
    (false, Name "Enum.finite*"), (false, Name "*Quickcheck*"),
    (false, Name "ATP*"), (false, Name "*Nunchaku*"),
    (false, Name "*Code*"), (false, Name "*BNF*"), (false, Name "*SMT*"),
    (false, Name "*.*.*")]:
   (bool * term Find_Theorems.criterion) list
val has_vars = fn: term -> bool
val get_all_eqs = fn: string -> Proof.context -> (string * thm) list
val get_all_thms = fn: string -> Proof.context -> (string * thm) list
val get_noneq_thms = fn: string -> Proof.context -> (string * thm) list
val template_eqs = fn:
   string -> Proof.context -> (string * thm * template) list
val template_thms = fn:
   string -> Proof.context -> (string * thm * template) list
### theory "Draft.ExtrEqs"
### 0.459s elapsed time, 0.514s cpu time, 0.070s GC time
Loading theory "Draft.Manual_PrerequisitesTemplates"
val templateLemmas = []: (string * thm * template) list
### theory "Draft.Manual_PrerequisitesTemplates"
### 0.286s elapsed time, 0.374s cpu time, 0.000s GC time
val it = (): unit
