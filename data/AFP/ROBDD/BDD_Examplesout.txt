Loading theory "Draft.Bool_Func" (required by "Draft.BDD_ExamplesTemplates" via "Draft.BDD_Examples" via "Draft.Level_Collapse" via "Draft.Conc_Impl" via "Draft.Middle_Impl" via "Draft.Abstract_Impl" via "Draft.BDT")
Loading theory "Draft.Pointer_Map" (required by "Draft.BDD_ExamplesTemplates" via "Draft.BDD_Examples" via "Draft.Level_Collapse" via "Draft.Conc_Impl" via "Draft.Pointer_Map_Impl")
Loading theory "Draft.Option_Helpers" (required by "Draft.BDD_ExamplesTemplates" via "Draft.BDD_Examples" via "Draft.Level_Collapse" via "Draft.Conc_Impl" via "Draft.Middle_Impl" via "Draft.Abstract_Impl")
Loading theory "HOL-Library.Function_Algebras" (required by "Draft.BDD_ExamplesTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
instantiation
  fun :: (type, plus) plus
  plus_fun == plus :: ('a => 'b) => ('a => 'b) => 'a => 'b
consts
  oassert :: "bool => unit option"
instantiation
  fun :: (type, zero) zero
  zero_fun == zero_class.zero :: 'a => 'b
consts
  ospec :: "'a option => ('a => bool) => bool"
instantiation
  fun :: (type, times) times
  times_fun == times :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  fun :: (type, one) one
  one_fun == one_class.one :: 'a => 'b
### theory "HOL-Library.Function_Algebras"
### 0.149s elapsed time, 0.599s cpu time, 0.056s GC time
Loading theory "HOL-Library.Stream" (required by "Draft.BDD_ExamplesTemplates" via "Draft.ExtrEqs")
### theory "Draft.Bool_Func"
### 0.168s elapsed time, 0.671s cpu time, 0.056s GC time
Loading theory "Draft.BDT" (required by "Draft.BDD_ExamplesTemplates" via "Draft.BDD_Examples" via "Draft.Level_Collapse" via "Draft.Conc_Impl" via "Draft.Middle_Impl" via "Draft.Abstract_Impl")
### theory "Draft.Option_Helpers"
### 0.196s elapsed time, 0.785s cpu time, 0.056s GC time
Loading theory "HOL-Library.Set_Algebras" (required by "Draft.BDD_ExamplesTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
instantiation
  set :: (plus) plus
  plus_set == plus :: 'a set => 'a set => 'a set
instantiation
  set :: (times) times
  times_set == times :: 'a set => 'a set => 'a set
instantiation
  set :: (zero) zero
  zero_set == zero_class.zero :: 'a set
instantiation
  set :: (one) one
  one_set == one_class.one :: 'a set
### theory "Draft.Pointer_Map"
### 0.365s elapsed time, 1.440s cpu time, 0.163s GC time
Loading theory "HOL-Library.Tree" (required by "Draft.BDD_ExamplesTemplates" via "Draft.ExtrEqs" via "Draft.Templates")
### theory "HOL-Library.Set_Algebras"
### 0.249s elapsed time, 0.969s cpu time, 0.107s GC time
Loading theory "HOL-Library.BigO" (required by "Draft.BDD_ExamplesTemplates" via "Draft.ExtrEqs")
consts
  shift :: "'a list => 'a stream => 'a stream"
Proofs for coinductive predicate(s) "streamsp"
  Proving monotonicity ...
consts
  snth :: "'a stream => nat => 'a"
consts
  stake :: "nat => 'a stream => 'a list"
consts
  sdrop :: "nat => 'a stream => 'a stream"
consts
  sfilter :: "('a => bool) => 'a stream => 'a stream"
consts
  cycle :: "'a list => 'a stream"
consts
  siterate :: "('a => 'a) => 'a => 'a stream"
consts
  flat :: "'a list stream => 'a stream"
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
consts
  left :: "'a tree => 'a tree"
consts
  right :: "'a tree => 'a tree"
consts
  sinterleave :: "'a stream => 'a stream => 'a stream"
Found termination order: "size <*mlex*> {}"
consts
  szip :: "'a stream => 'b stream => ('a * 'b) stream"
Found termination order: "size <*mlex*> {}"
consts
  smap2 :: "('a => 'b => 'c) => 'a stream => 'b stream => 'c stream"
### theory "HOL-Library.Stream"
### 1.063s elapsed time, 4.009s cpu time, 0.949s GC time
Loading theory "Draft.Array_List" (required by "Draft.BDD_ExamplesTemplates" via "Draft.BDD_Examples" via "Draft.Level_Collapse" via "Draft.Conc_Impl" via "Draft.Pointer_Map_Impl")
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
### theory "Draft.Array_List"
### 0.099s elapsed time, 0.373s cpu time, 0.060s GC time
Loading theory "Draft.Pointer_Map_Impl" (required by "Draft.BDD_ExamplesTemplates" via "Draft.BDD_Examples" via "Draft.Level_Collapse" via "Draft.Conc_Impl")
Found termination order: "size <*mlex*> {}"
class height = type +
  fixes height :: "'a => nat"
instantiation
  tree :: (type) height
  height_tree == height :: 'a tree => nat
Found termination order: "size <*mlex*> {}"
### theory "HOL-Library.BigO"
### 1.065s elapsed time, 3.982s cpu time, 0.986s GC time
[| distinct ?xs; ?i < length ?xs; ?j < length ?xs |]
==> (?xs ! ?i = ?xs ! ?j) = (?i = ?j)
Found termination order: "size <*mlex*> {}"
find_consts
  "assn \<Rightarrow> bool"
found 9 constant(s):
Automation.FI ::
  "(assn * assn) list => assn => assn => assn => assn => assn => bool"
Automation.FI_RESULT :: "(assn * assn) list => assn => assn => assn => bool"
Assertions.models :: "heap * nat set => assn => bool"
Automation.FI_QUERY :: "assn => assn => assn => bool"
Assertions.entails :: "assn => assn => bool"
Assertions.entailst :: "assn => assn => bool"
Assertions.ord_assn_inst.less_assn :: "assn => assn => bool"
Assertions.ord_assn_inst.less_eq_assn :: "assn => assn => bool"
Assertions.is_pure_assn :: "assn => bool"
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "{}"
Found termination order: "size <*mlex*> {}"
Found termination order: "{}"
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "size_list size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
### theory "Draft.Pointer_Map_Impl"
### 1.092s elapsed time, 3.471s cpu time, 0.341s GC time
Found termination order: "size <*mlex*> {}"
Found termination order: "(%p. size_list size (fst p)) <*mlex*> {}"
### theory "HOL-Library.Tree"
### 2.195s elapsed time, 7.344s cpu time, 1.292s GC time
Loading theory "Draft.Templates" (required by "Draft.BDD_ExamplesTemplates" via "Draft.ExtrEqs")
datatype template_term
=
     t_empty
   | template_app of template_term * template_term
   | template_hole of int
   | template_var of int
datatype sign
= equals | greater_equals | greater_than | less_equals | less_than
datatype template
=
     template_bimplication of template * template
   | template_dunno
   | template_equation of template_term * template_term
   | template_implication of template list * template
   | template_inequation of sign * template_term * template_term
   | template_negation of template
   | template_predicate of template_term
constructor t_empty: template_term
constructor template_app: template_term * template_term -> template_term
constructor template_hole: int -> template_term
constructor template_var: int -> template_term
constructor equals: sign
constructor greater_equals: sign
constructor greater_than: sign
constructor less_equals: sign
constructor less_than: sign
constructor template_bimplication: template * template -> template
constructor template_dunno: template
constructor template_equation: template_term * template_term -> template
constructor template_implication: template list * template -> template
constructor template_inequation:
   sign * template_term * template_term -> template
constructor template_negation: template -> template
constructor template_predicate: template_term -> template
val vfs = fn: term -> (indexname * typ) list * (string * typ) list
val indexOf = fn: ''a list -> ''a -> int -> int
val has_eq = fn: term -> bool
val term2template = fn:
   (indexname * typ) list -> (string * typ) list -> term -> template_term
val lemma2predicate = fn: term -> term -> template
val makeTemplatewithContext = fn: term -> term -> template
val lemma2template = fn: term -> template
val thm2template = fn: thm -> template
val tterm2string = fn: template_term -> string
val template2string = fn: template -> string
val t = "height ?t <= size ?t": thm
val th =
   Const ("HOL.Trueprop", "bool => prop") $
     (Const ("Orderings.ord_class.less_eq", "nat => nat => bool") $
       (Const ("Tree.height_class.height", "?'a tree => nat") $
         Var (("t", 0), "?'a tree")) $
       (Const ("Nat.size_class.size", "?'a tree => nat") $
         Var (("t", 0), "?'a tree"))):
   term
### theory "Draft.Templates"
### 0.057s elapsed time, 0.113s cpu time, 0.000s GC time
Loading theory "Draft.ExtrEqs" (required by "Draft.BDD_ExamplesTemplates")
Found termination order: "size_list size <*mlex*> {}"
### theory "Draft.BDT"
### 2.507s elapsed time, 8.348s cpu time, 1.468s GC time
Loading theory "Draft.Abstract_Impl" (required by "Draft.BDD_ExamplesTemplates" via "Draft.BDD_Examples" via "Draft.Level_Collapse" via "Draft.Conc_Impl" via "Draft.Middle_Impl")
val eqpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Var (("_dummy_", 2), "?'a"))
       ):
   term Find_Theorems.criterion
val badeqpattern = Pattern (Const ("Pure.eq", "?'a => ?'a => prop")):
   term Find_Theorems.criterion
val undefpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Const ("HOL.undefined", "?'a"))
       ):
   term Find_Theorems.criterion
val thmpattern =
   Pattern
    (Const ("HOL.Trueprop", "bool => prop") $ Var (("_dummy_", 1), "bool")):
   term Find_Theorems.criterion
val badnames =
   ["*nitpick*", "*Nitpick*", "*full_exhaustive*", "*_def*", "Enum.finite*",
    "*Quickcheck*", "ATP*", "*Nunchaku*", "*Code*", "*BNF*", "*SMT*",
    "*.*.*"]:
   string list
val unwanted_names =
   [(false, Name "*nitpick*"), (false, Name "*Nitpick*"),
    (false, Name "*full_exhaustive*"), (false, Name "*_def*"),
    (false, Name "Enum.finite*"), (false, Name "*Quickcheck*"),
    (false, Name "ATP*"), (false, Name "*Nunchaku*"),
    (false, Name "*Code*"), (false, Name "*BNF*"), (false, Name "*SMT*"),
    (false, Name "*.*.*")]:
   (bool * term Find_Theorems.criterion) list
val has_vars = fn: term -> bool
val get_all_eqs = fn: string -> Proof.context -> (string * thm) list
val get_all_thms = fn: string -> Proof.context -> (string * thm) list
val get_noneq_thms = fn: string -> Proof.context -> (string * thm) list
val template_eqs = fn:
   string -> Proof.context -> (string * thm * template) list
val template_thms = fn:
   string -> Proof.context -> (string * thm * template) list
### theory "Draft.ExtrEqs"
### 0.810s elapsed time, 2.011s cpu time, 0.906s GC time
locale bdd_impl_pre
  fixes R :: "'s => ('ni * 'a ifex) set"
    and I :: "'s => bool"
locale bdd_impl
  fixes I :: "'s => bool"
    and R :: "'s => ('ni * 'a ifex) set"
    and Timpl :: "'s => ('ni * 's) option"
    and Fimpl :: "'s => ('ni * 's) option"
    and IFimpl :: "'a => 'ni => 'ni => 's => ('ni * 's) option"
    and DESTRimpl :: "'ni => 's => ('a, 'ni) IFEXD option"
  assumes "bdd_impl I R Timpl Fimpl IFimpl DESTRimpl"
consts
  lowest_tops_impl :: "'ni list => 's => ('a option * 's) option"
Found termination order: "size_list size <*mlex*> {}"
locale bdd_impl_cmp_pre
  fixes R :: "'a => ('b * 'c ifex) set"
    and I :: "'a => bool"
locale bdd_impl_cmp
  fixes I :: "'a => bool"
    and R :: "'a => ('b * 'c ifex) set"
    and Timpl :: "'a => ('b * 'a) option"
    and Fimpl :: "'a => ('b * 'a) option"
    and IFimpl :: "'c => 'b => 'b => 'a => ('b * 'a) option"
    and DESTRimpl :: "'b => 'a => ('c, 'b) IFEXD option"
    and M :: "'a => 'b * 'b * 'b => 'b option"
    and U :: "'a => 'b * 'b * 'b => 'b => 'a"
    and cmp :: "'b => 'b => bool"
  assumes "bdd_impl_cmp I R Timpl Fimpl IFimpl DESTRimpl M U cmp"
Found termination order: "{}"
### theory "Draft.Abstract_Impl"
### 1.750s elapsed time, 2.917s cpu time, 0.932s GC time
Loading theory "Draft.Middle_Impl" (required by "Draft.BDD_ExamplesTemplates" via "Draft.BDD_Examples" via "Draft.Level_Collapse" via "Draft.Conc_Impl")
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "(%p. size (fst (snd p))) <*mlex*> {}"
### Ignoring duplicate rewrite rule:
### Rmi_g (Suc (Suc ?va1)) Trueif ?uw1 == False
?P (case ?nat of 0 => ?f1.0 | Suc x => ?f2.0 x) =
((?nat = 0 --> ?P ?f1.0) & (ALL x2. ?nat = Suc x2 --> ?P (?f2.0 x2)))
[| !!bdd. ?P 0 Falseif bdd; !!bdd. ?P (Suc 0) Trueif bdd;
   !!n v t e bdd.
      [| !!x y xa ya.
            [| (x, y) = pm_pth (dpm bdd) n; (xa, ya) = y |] ==> ?P xa t bdd;
         !!x y xa ya.
            [| (x, y) = pm_pth (dpm bdd) n; (xa, ya) = y |]
            ==> ?P ya e bdd |]
      ==> ?P (Suc (Suc n)) (IF v t e) bdd;
   !!va uw_. ?P (Suc (Suc va)) Trueif uw_;
   !!va uw_. ?P (Suc (Suc va)) Falseif uw_; !!v uw_. ?P (Suc v) Falseif uw_;
   !!va vb vc uw_. ?P (Suc 0) (IF va vb vc) uw_; !!uw_. ?P 0 Trueif uw_;
   !!va uw_. ?P (Suc (Suc va)) Trueif uw_;
   !!v va vb uw_. ?P 0 (IF v va vb) uw_;
   !!v va vb uw_. ?P (Suc 0) (IF v va vb) uw_ |]
==> ?P ?a0.0 ?a1.0 ?a2.0
### theory "Draft.Middle_Impl"
### 1.202s elapsed time, 1.981s cpu time, 1.002s GC time
Loading theory "Draft.Conc_Impl" (required by "Draft.BDD_ExamplesTemplates" via "Draft.BDD_Examples" via "Draft.Level_Collapse")
instantiation
  prod :: (default, default) default
  default_prod == default :: 'a * 'b
instantiation
  nat :: default
  default_nat == default :: nat
"mi.les"
  :: "bdd => bdd => bool"
"mi.restrict_top_impl"
  :: "nat => nat => bool => bdd => (nat * bdd) option"
mi.case_ifexi ?fti ?ffi ?fii ?ni ?s ==
destrmi' ?ni ?s >>=
(%dest.
    case dest of TD => ?fti ?s | FD => ?ffi ?s
    | IFD v ti ei => ?fii v ti ei ?s)
Found termination order: "(%p. size_list size (fst p)) <*mlex*> {}"
"hm_lookup"
  :: "'a => ('a, 'b) hashtable => 'b option Heap"
### Ambiguous input (line 278 of "$AFP/ROBDD/Conc_Impl.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" iteci_lu_code)
###       ("_cargs" ("_position" i)
###         ("_cargs" ("_position" t)
###           ("_cargs" ("_position" e) ("_position" s)))))
###     ("_do_block"
###       ("_do_cons"
###         ("_do_bind" ("_position" lu)
###           ("_applC" ("_position" hm_lookup)
###             ("_cargs"
###               ("_tuple" ("_position" i)
###                 ("_tuple_args" ("_position" t)
###                   ("_tuple_arg" ("_position" e))))
###               ("_applC" ("_position" dcli) ("_position" s)))))
###         ("_do_final"
###           ("_case_syntax" ("_position" lu)
###             ("_case1" ("_position" None)
###               ("_Let"
###                 ("_bind" ("_position" po)
###                   ("\<^const>HOL.If"
###                     ("\<^const>HOL.eq" ("_position" i)
###                       ("\<^const>Groups.one_class.one"))
###                     ("_applC" ("_position" Some) ("_position" t))
###                     ("\<^const>HOL.If"
###                       ("\<^const>HOL.eq" ("_position" i)
###                         ("\<^const>Groups.zero_class.zero"))
###                       ("_applC" ("_position" Some) ("_position" e))
###                       ("\<^const>HOL.If"
###                         ("\<^const>HOL.conj"
###                           ("\<^const>HOL.eq" ("_position" t)
###                             ("\<^const>Groups.one_class.one"))
###                           ("\<^const>HOL.eq" ("_position" e)
###                             ("\<^const>Groups.zero_class.zero")))
###                         ("_applC" ("_position" Some) ("_position" i))
###                         ("\<^const>HOL.If"
###                           ("\<^const>HOL.eq" ("_position" t)
###                             ("_position" e))
###                           ("_applC" ("_position" Some) ("_position" t))
###                           ("\<^const>HOL.If"
###                             ("\<^const>HOL.conj"
###                               ("\<^const>HOL.eq" ("_position" e)
###                                 ("\<^const>Groups.one_class.one"))
###                               ("\<^const>HOL.eq" ("_position" i)
###                                 ("_position" t)))
###                             ("_applC" ("_position" Some)
###                               ("\<^const>Groups.one_class.one"))
###                             ("\<^const>HOL.If"
###                               ("\<^const>HOL.conj"
###                                 ("\<^const>HOL.eq" ("_position" t)
###                                   ("\<^const>Groups.zero_class.zero"))
###                                 ("\<^const>HOL.eq" ("_position" i)
###                                   ("_position" e)))
###                               ("_applC" ("_position" Some)
###                                 ("\<^const>Groups.zero_class.zero"))
###                               ("_position" None))))))))
###                 ("_case_syntax" ("_position" po)
###                   ("_case2"
###                     ("_case1" ("_position" None)
###                       ("_do_block"
###                         ("_do_cons"
###                           ("_do_bind" ("_position" id)
###                             ("_applC" ("_position" destrci)
###                               ("_cargs" ("_position" i) ("_position" s))))
###                           ("_do_cons"
###                             ("_do_bind" ("_position" td)
###                               ("_applC" ("_position" destrci)
###                                 ("_cargs" ("_position" t) ("_position" s))))
###                             ("_do_cons"
###                               ("_do_bind" ("_position" ed)
###                                 ("_applC" ("_position" destrci)
###                                   ("_cargs" ("_position" e)
###                                     ("_position" s))))
###                               ("_do_cons"
###                                 ("_do_let" ("_position" a)
###                                   ("_case_syntax" ("_position" id)
###                                     ("_case1"
### ("_applC" ("_position" IFD)
###   ("_cargs" ("_position" v) ("_cargs" ("_position" t) ("_position" e))))
### ("_position" v))))
###                                 ("_do_cons"
###                                   ("_do_let" ("_position" a)
###                                     ("_case_syntax" ("_position" td)
### ("_case2"
###   ("_case1"
###     ("_applC" ("_position" IFD)
###       ("_cargs" ("_position" v) ("_cargs" ("_position" t) ("_position" e))))
###     ("_applC" ("_position" min) ("_cargs" ("_position" a) ("_position" v))))
###   ("_case1" ("\<^const>Pure.dummy_pattern") ("_position" a)))))
###                                   ("_do_cons"
###                                     ("_do_let" ("_position" a)
### ("_case_syntax" ("_position" ed)
###   ("_case2"
###     ("_case1"
###       ("_applC" ("_position" IFD)
###         ("_cargs" ("_position" v)
###           ("_cargs" ("_position" t) ("_position" e))))
###       ("_applC" ("_position" min)
###         ("_cargs" ("_position" a) ("_position" v))))
###     ("_case1" ("\<^const>Pure.dummy_pattern") ("_position" a)))))
###                                     ("_do_cons"
### ("_do_let" ("_position" ti)
###   ("_case_syntax" ("_position" id)
###     ("_case2"
###       ("_case1"
###         ("_applC" ("_position" IFD)
###           ("_cargs" ("_position" v)
###             ("_cargs" ("_position" ti) ("_position" ei))))
###         ("\<^const>HOL.If"
###           ("\<^const>HOL.eq" ("_position" v) ("_position" a))
###           ("_position" ti) ("_position" i)))
###       ("_case1" ("\<^const>Pure.dummy_pattern") ("_position" i)))))
### ("_do_cons"
###   ("_do_let" ("_position" tt)
###     ("_case_syntax" ("_position" td)
###       ("_case2"
###         ("_case1"
###           ("_applC" ("_position" IFD)
###             ("_cargs" ("_position" v)
###               ("_cargs" ("_position" ti) ("_position" ei))))
###           ("\<^const>HOL.If"
###             ("\<^const>HOL.eq" ("_position" v) ("_position" a))
###             ("_position" ti) ("_position" t)))
###         ("_case1" ("\<^const>Pure.dummy_pattern") ("_position" t)))))
###   ("_do_cons"
###     ("_do_let" ("_position" te)
###       ("_case_syntax" ("_position" ed)
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" IFD)
###               ("_cargs" ("_position" v)
###                 ("_cargs" ("_position" ti) ("_position" ei))))
###             ("\<^const>HOL.If"
###               ("\<^const>HOL.eq" ("_position" v) ("_position" a))
###               ("_position" ti) ("_position" e)))
###           ("_case1" ("\<^const>Pure.dummy_pattern") ("_position" e)))))
###     ("_do_cons"
###       ("_do_let" ("_position" fi)
###         ("_case_syntax" ("_position" id)
###           ("_case2"
###             ("_case1"
###               ("_applC" ("_position" IFD)
###                 ("_cargs" ("_position" v)
###                   ("_cargs" ("_position" ti) ("_position" ei))))
###               ("\<^const>HOL.If"
###                 ("\<^const>HOL.eq" ("_position" v) ("_position" a))
###                 ("_position" ei) ("_position" i)))
###             ("_case1" ("\<^const>Pure.dummy_pattern") ("_position" i)))))
###       ("_do_cons"
###         ("_do_let" ("_position" ft)
###           ("_case_syntax" ("_position" td)
###             ("_case2"
###               ("_case1"
###                 ("_applC" ("_position" IFD)
###                   ("_cargs" ("_position" v)
###                     ("_cargs" ("_position" ti) ("_position" ei))))
###                 ("\<^const>HOL.If"
###                   ("\<^const>HOL.eq" ("_position" v) ("_position" a))
###                   ("_position" ei) ("_position" t)))
###               ("_case1" ("\<^const>Pure.dummy_pattern") ("_position" t)))))
###         ("_do_cons"
###           ("_do_let" ("_position" fe)
###             ("_case_syntax" ("_position" ed)
###               ("_case2"
###                 ("_case1"
###                   ("_applC" ("_position" IFD)
###                     ("_cargs" ("_position" v)
###                       ("_cargs" ("_position" ti) ("_position" ei))))
###                   ("\<^const>HOL.If"
###                     ("\<^const>HOL.eq" ("_position" v) ("_position" a))
###                     ("_position" ei) ("_position" e)))
###                 ("_case1" ("\<^const>Pure.dummy_pattern")
###                   ("_position" e)))))
###           ("_do_cons"
###             ("_do_bind" ("_pattern" ("_position" tb) ("_position" s))
###               ("_applC" ("_position" iteci_lu_code)
###                 ("_cargs" ("_position" ti)
###                   ("_cargs" ("_position" tt)
###                     ("_cargs" ("_position" te) ("_position" s))))))
###             ("_do_cons"
###               ("_do_bind" ("_pattern" ("_position" fb) ("_position" s))
###                 ("_applC" ("_position" iteci_lu_code)
###                   ("_cargs" ("_position" fi)
###                     ("_cargs" ("_position" ft)
###                       ("_cargs" ("_position" fe) ("_position" s))))))
###               ("_do_cons"
###                 ("_do_bind" ("_pattern" ("_position" r) ("_position" s))
###                   ("_applC" ("_position" ifci)
###                     ("_cargs" ("_position" a)
###                       ("_cargs" ("_position" tb)
###                         ("_cargs" ("_position" fb) ("_position" s))))))
###                 ("_do_cons"
###                   ("_do_bind" ("_position" cl)
###                     ("_applC" ("_position" hm_update)
###                       ("_cargs"
###                         ("_tuple" ("_position" i)
###                           ("_tuple_args" ("_position" t)
###                             ("_tuple_arg" ("_position" e))))
###                         ("_cargs" ("_position" r)
###                           ("_applC" ("_position" dcli) ("_position" s))))))
###                   ("_do_final"
###                     ("_applC" ("_position" return)
###                       ("_tuple" ("_position" r)
###                         ("_tuple_arg"
###                           ("_applC" ("_position" dcli_update)
###                             ("_cargs"
###                               ("_applC" ("_position" const)
###                                 ("_position" cl))
###                               ("_position" s)))))))))))))))))))))))))
###                     ("_case2"
###                       ("_case1"
###                         ("_applC" ("_position" Some) ("_position" b))
###                         ("_applC" ("_position" return)
###                           ("_tuple" ("_position" b)
###                             ("_tuple_arg" ("_position" s)))))
###                       ("_case1"
###                         ("_applC" ("_position" Some) ("_position" b))
###                         ("_applC" ("_position" return)
###                           ("_tuple" ("_position" b)
###                             ("_tuple_arg" ("_position" s))))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" iteci_lu_code)
###       ("_cargs" ("_position" i)
###         ("_cargs" ("_position" t)
###           ("_cargs" ("_position" e) ("_position" s)))))
###     ("_do_block"
###       ("_do_cons"
###         ("_do_bind" ("_position" lu)
###           ("_applC" ("_position" hm_lookup)
###             ("_cargs"
###               ("_tuple" ("_position" i)
###                 ("_tuple_args" ("_position" t)
###                   ("_tuple_arg" ("_position" e))))
###               ("_applC" ("_position" dcli) ("_position" s)))))
###         ("_do_final"
###           ("_case_syntax" ("_position" lu)
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_Let"
###                   ("_bind" ("_position" po)
###                     ("\<^const>HOL.If"
###                       ("\<^const>HOL.eq" ("_position" i)
###                         ("\<^const>Groups.one_class.one"))
###                       ("_applC" ("_position" Some) ("_position" t))
###                       ("\<^const>HOL.If"
###                         ("\<^const>HOL.eq" ("_position" i)
###                           ("\<^const>Groups.zero_class.zero"))
###                         ("_applC" ("_position" Some) ("_position" e))
###                         ("\<^const>HOL.If"
###                           ("\<^const>HOL.conj"
###                             ("\<^const>HOL.eq" ("_position" t)
###                               ("\<^const>Groups.one_class.one"))
###                             ("\<^const>HOL.eq" ("_position" e)
###                               ("\<^const>Groups.zero_class.zero")))
###                           ("_applC" ("_position" Some) ("_position" i))
###                           ("\<^const>HOL.If"
###                             ("\<^const>HOL.eq" ("_position" t)
###                               ("_position" e))
###                             ("_applC" ("_position" Some) ("_position" t))
###                             ("\<^const>HOL.If"
###                               ("\<^const>HOL.conj"
###                                 ("\<^const>HOL.eq" ("_position" e)
###                                   ("\<^const>Groups.one_class.one"))
###                                 ("\<^const>HOL.eq" ("_position" i)
###                                   ("_position" t)))
###                               ("_applC" ("_position" Some)
###                                 ("\<^const>Groups.one_class.one"))
###                               ("\<^const>HOL.If"
###                                 ("\<^const>HOL.conj"
###                                   ("\<^const>HOL.eq" ("_position" t)
###                                     ("\<^const>Groups.zero_class.zero"))
###                                   ("\<^const>HOL.eq" ("_position" i)
###                                     ("_position" e)))
###                                 ("_applC" ("_position" Some)
###                                   ("\<^const>Groups.zero_class.zero"))
###                                 ("_position" None))))))))
###                   ("_case_syntax" ("_position" po)
###                     ("_case1" ("_position" None)
###                       ("_do_block"
###                         ("_do_cons"
###                           ("_do_bind" ("_position" id)
###                             ("_applC" ("_position" destrci)
###                               ("_cargs" ("_position" i) ("_position" s))))
###                           ("_do_cons"
###                             ("_do_bind" ("_position" td)
###                               ("_applC" ("_position" destrci)
###                                 ("_cargs" ("_position" t) ("_position" s))))
###                             ("_do_cons"
###                               ("_do_bind" ("_position" ed)
###                                 ("_applC" ("_position" destrci)
###                                   ("_cargs" ("_position" e)
###                                     ("_position" s))))
###                               ("_do_cons"
###                                 ("_do_let" ("_position" a)
###                                   ("_case_syntax" ("_position" id)
###                                     ("_case1"
### ("_applC" ("_position" IFD)
###   ("_cargs" ("_position" v) ("_cargs" ("_position" t) ("_position" e))))
### ("_position" v))))
###                                 ("_do_cons"
###                                   ("_do_let" ("_position" a)
###                                     ("_case_syntax" ("_position" td)
### ("_case2"
###   ("_case1"
###     ("_applC" ("_position" IFD)
###       ("_cargs" ("_position" v) ("_cargs" ("_position" t) ("_position" e))))
###     ("_applC" ("_position" min) ("_cargs" ("_position" a) ("_position" v))))
###   ("_case1" ("\<^const>Pure.dummy_pattern") ("_position" a)))))
###                                   ("_do_cons"
###                                     ("_do_let" ("_position" a)
### ("_case_syntax" ("_position" ed)
###   ("_case2"
###     ("_case1"
###       ("_applC" ("_position" IFD)
###         ("_cargs" ("_position" v)
###           ("_cargs" ("_position" t) ("_position" e))))
###       ("_applC" ("_position" min)
###         ("_cargs" ("_position" a) ("_position" v))))
###     ("_case1" ("\<^const>Pure.dummy_pattern") ("_position" a)))))
###                                     ("_do_cons"
### ("_do_let" ("_position" ti)
###   ("_case_syntax" ("_position" id)
###     ("_case2"
###       ("_case1"
###         ("_applC" ("_position" IFD)
###           ("_cargs" ("_position" v)
###             ("_cargs" ("_position" ti) ("_position" ei))))
###         ("\<^const>HOL.If"
###           ("\<^const>HOL.eq" ("_position" v) ("_position" a))
###           ("_position" ti) ("_position" i)))
###       ("_case1" ("\<^const>Pure.dummy_pattern") ("_position" i)))))
### ("_do_cons"
###   ("_do_let" ("_position" tt)
###     ("_case_syntax" ("_position" td)
###       ("_case2"
###         ("_case1"
###           ("_applC" ("_position" IFD)
###             ("_cargs" ("_position" v)
###               ("_cargs" ("_position" ti) ("_position" ei))))
###           ("\<^const>HOL.If"
###             ("\<^const>HOL.eq" ("_position" v) ("_position" a))
###             ("_position" ti) ("_position" t)))
###         ("_case1" ("\<^const>Pure.dummy_pattern") ("_position" t)))))
###   ("_do_cons"
###     ("_do_let" ("_position" te)
###       ("_case_syntax" ("_position" ed)
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" IFD)
###               ("_cargs" ("_position" v)
###                 ("_cargs" ("_position" ti) ("_position" ei))))
###             ("\<^const>HOL.If"
###               ("\<^const>HOL.eq" ("_position" v) ("_position" a))
###               ("_position" ti) ("_position" e)))
###           ("_case1" ("\<^const>Pure.dummy_pattern") ("_position" e)))))
###     ("_do_cons"
###       ("_do_let" ("_position" fi)
###         ("_case_syntax" ("_position" id)
###           ("_case2"
###             ("_case1"
###               ("_applC" ("_position" IFD)
###                 ("_cargs" ("_position" v)
###                   ("_cargs" ("_position" ti) ("_position" ei))))
###               ("\<^const>HOL.If"
###                 ("\<^const>HOL.eq" ("_position" v) ("_position" a))
###                 ("_position" ei) ("_position" i)))
###             ("_case1" ("\<^const>Pure.dummy_pattern") ("_position" i)))))
###       ("_do_cons"
###         ("_do_let" ("_position" ft)
###           ("_case_syntax" ("_position" td)
###             ("_case2"
###               ("_case1"
###                 ("_applC" ("_position" IFD)
###                   ("_cargs" ("_position" v)
###                     ("_cargs" ("_position" ti) ("_position" ei))))
###                 ("\<^const>HOL.If"
###                   ("\<^const>HOL.eq" ("_position" v) ("_position" a))
###                   ("_position" ei) ("_position" t)))
###               ("_case1" ("\<^const>Pure.dummy_pattern") ("_position" t)))))
###         ("_do_cons"
###           ("_do_let" ("_position" fe)
###             ("_case_syntax" ("_position" ed)
###               ("_case2"
###                 ("_case1"
###                   ("_applC" ("_position" IFD)
###                     ("_cargs" ("_position" v)
###                       ("_cargs" ("_position" ti) ("_position" ei))))
###                   ("\<^const>HOL.If"
###                     ("\<^const>HOL.eq" ("_position" v) ("_position" a))
###                     ("_position" ei) ("_position" e)))
###                 ("_case1" ("\<^const>Pure.dummy_pattern")
###                   ("_position" e)))))
###           ("_do_cons"
###             ("_do_bind" ("_pattern" ("_position" tb) ("_position" s))
###               ("_applC" ("_position" iteci_lu_code)
###                 ("_cargs" ("_position" ti)
###                   ("_cargs" ("_position" tt)
###                     ("_cargs" ("_position" te) ("_position" s))))))
###             ("_do_cons"
###               ("_do_bind" ("_pattern" ("_position" fb) ("_position" s))
###                 ("_applC" ("_position" iteci_lu_code)
###                   ("_cargs" ("_position" fi)
###                     ("_cargs" ("_position" ft)
###                       ("_cargs" ("_position" fe) ("_position" s))))))
###               ("_do_cons"
###                 ("_do_bind" ("_pattern" ("_position" r) ("_position" s))
###                   ("_applC" ("_position" ifci)
###                     ("_cargs" ("_position" a)
###                       ("_cargs" ("_position" tb)
###                         ("_cargs" ("_position" fb) ("_position" s))))))
###                 ("_do_cons"
###                   ("_do_bind" ("_position" cl)
###                     ("_applC" ("_position" hm_update)
###                       ("_cargs"
###                         ("_tuple" ("_position" i)
###                           ("_tuple_args" ("_position" t)
###                             ("_tuple_arg" ("_position" e))))
###                         ("_cargs" ("_position" r)
###                           ("_applC" ("_position" dcli) ("_position" s))))))
###                   ("_do_final"
###                     ("_applC" ("_position" return)
###                       ("_tuple" ("_position" r)
###                         ("_tuple_arg"
###                           ("_applC" ("_position" dcli_update)
###                             ("_cargs"
###                               ("_applC" ("_position" const)
###                                 ("_position" cl))
###                               ("_position" s))))))))))))))))))))))))))))
###               ("_case2"
###                 ("_case1" ("_applC" ("_position" Some) ("_position" b))
###                   ("_applC" ("_position" return)
###                     ("_tuple" ("_position" b)
###                       ("_tuple_arg" ("_position" s)))))
###                 ("_case1" ("_applC" ("_position" Some) ("_position" b))
###                   ("_applC" ("_position" return)
###                     ("_tuple" ("_position" b)
###                       ("_tuple_arg" ("_position" s)))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" iteci_lu_code)
###       ("_cargs" ("_position" i)
###         ("_cargs" ("_position" t)
###           ("_cargs" ("_position" e) ("_position" s)))))
###     ("_do_block"
###       ("_do_cons"
###         ("_do_bind" ("_position" lu)
###           ("_applC" ("_position" hm_lookup)
###             ("_cargs"
###               ("_tuple" ("_position" i)
###                 ("_tuple_args" ("_position" t)
###                   ("_tuple_arg" ("_position" e))))
###               ("_applC" ("_position" dcli) ("_position" s)))))
###         ("_do_final"
###           ("_case_syntax" ("_position" lu)
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_Let"
###                   ("_bind" ("_position" po)
###                     ("\<^const>HOL.If"
###                       ("\<^const>HOL.eq" ("_position" i)
###                         ("\<^const>Groups.one_class.one"))
###                       ("_applC" ("_position" Some) ("_position" t))
###                       ("\<^const>HOL.If"
###                         ("\<^const>HOL.eq" ("_position" i)
###                           ("\<^const>Groups.zero_class.zero"))
###                         ("_applC" ("_position" Some) ("_position" e))
###                         ("\<^const>HOL.If"
###                           ("\<^const>HOL.conj"
###                             ("\<^const>HOL.eq" ("_position" t)
###                               ("\<^const>Groups.one_class.one"))
###                             ("\<^const>HOL.eq" ("_position" e)
###                               ("\<^const>Groups.zero_class.zero")))
###                           ("_applC" ("_position" Some) ("_position" i))
###                           ("\<^const>HOL.If"
###                             ("\<^const>HOL.eq" ("_position" t)
###                               ("_position" e))
###                             ("_applC" ("_position" Some) ("_position" t))
###                             ("\<^const>HOL.If"
###                               ("\<^const>HOL.conj"
###                                 ("\<^const>HOL.eq" ("_position" e)
###                                   ("\<^const>Groups.one_class.one"))
###                                 ("\<^const>HOL.eq" ("_position" i)
###                                   ("_position" t)))
###                               ("_applC" ("_position" Some)
###                                 ("\<^const>Groups.one_class.one"))
###                               ("\<^const>HOL.If"
###                                 ("\<^const>HOL.conj"
###                                   ("\<^const>HOL.eq" ("_position" t)
###                                     ("\<^const>Groups.zero_class.zero"))
###                                   ("\<^const>HOL.eq" ("_position" i)
###                                     ("_position" e)))
###                                 ("_applC" ("_position" Some)
###                                   ("\<^const>Groups.zero_class.zero"))
###                                 ("_position" None))))))))
###                   ("_case_syntax" ("_position" po)
###                     ("_case2"
###                       ("_case1" ("_position" None)
###                         ("_do_block"
###                           ("_do_cons"
###                             ("_do_bind" ("_position" id)
###                               ("_applC" ("_position" destrci)
###                                 ("_cargs" ("_position" i) ("_position" s))))
###                             ("_do_cons"
###                               ("_do_bind" ("_position" td)
###                                 ("_applC" ("_position" destrci)
###                                   ("_cargs" ("_position" t)
###                                     ("_position" s))))
###                               ("_do_cons"
###                                 ("_do_bind" ("_position" ed)
###                                   ("_applC" ("_position" destrci)
###                                     ("_cargs" ("_position" e)
### ("_position" s))))
###                                 ("_do_cons"
###                                   ("_do_let" ("_position" a)
###                                     ("_case_syntax" ("_position" id)
### ("_case1"
###   ("_applC" ("_position" IFD)
###     ("_cargs" ("_position" v) ("_cargs" ("_position" t) ("_position" e))))
###   ("_position" v))))
###                                   ("_do_cons"
###                                     ("_do_let" ("_position" a)
### ("_case_syntax" ("_position" td)
###   ("_case2"
###     ("_case1"
###       ("_applC" ("_position" IFD)
###         ("_cargs" ("_position" v)
###           ("_cargs" ("_position" t) ("_position" e))))
###       ("_applC" ("_position" min)
###         ("_cargs" ("_position" a) ("_position" v))))
###     ("_case1" ("\<^const>Pure.dummy_pattern") ("_position" a)))))
###                                     ("_do_cons"
### ("_do_let" ("_position" a)
###   ("_case_syntax" ("_position" ed)
###     ("_case2"
###       ("_case1"
###         ("_applC" ("_position" IFD)
###           ("_cargs" ("_position" v)
###             ("_cargs" ("_position" t) ("_position" e))))
###         ("_applC" ("_position" min)
###           ("_cargs" ("_position" a) ("_position" v))))
###       ("_case1" ("\<^const>Pure.dummy_pattern") ("_position" a)))))
### ("_do_cons"
###   ("_do_let" ("_position" ti)
###     ("_case_syntax" ("_position" id)
###       ("_case2"
###         ("_case1"
###           ("_applC" ("_position" IFD)
###             ("_cargs" ("_position" v)
###               ("_cargs" ("_position" ti) ("_position" ei))))
###           ("\<^const>HOL.If"
###             ("\<^const>HOL.eq" ("_position" v) ("_position" a))
###             ("_position" ti) ("_position" i)))
###         ("_case1" ("\<^const>Pure.dummy_pattern") ("_position" i)))))
###   ("_do_cons"
###     ("_do_let" ("_position" tt)
###       ("_case_syntax" ("_position" td)
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" IFD)
###               ("_cargs" ("_position" v)
###                 ("_cargs" ("_position" ti) ("_position" ei))))
###             ("\<^const>HOL.If"
###               ("\<^const>HOL.eq" ("_position" v) ("_position" a))
###               ("_position" ti) ("_position" t)))
###           ("_case1" ("\<^const>Pure.dummy_pattern") ("_position" t)))))
###     ("_do_cons"
###       ("_do_let" ("_position" te)
###         ("_case_syntax" ("_position" ed)
###           ("_case2"
###             ("_case1"
###               ("_applC" ("_position" IFD)
###                 ("_cargs" ("_position" v)
###                   ("_cargs" ("_position" ti) ("_position" ei))))
###               ("\<^const>HOL.If"
###                 ("\<^const>HOL.eq" ("_position" v) ("_position" a))
###                 ("_position" ti) ("_position" e)))
###             ("_case1" ("\<^const>Pure.dummy_pattern") ("_position" e)))))
###       ("_do_cons"
###         ("_do_let" ("_position" fi)
###           ("_case_syntax" ("_position" id)
###             ("_case2"
###               ("_case1"
###                 ("_applC" ("_position" IFD)
###                   ("_cargs" ("_position" v)
###                     ("_cargs" ("_position" ti) ("_position" ei))))
###                 ("\<^const>HOL.If"
###                   ("\<^const>HOL.eq" ("_position" v) ("_position" a))
###                   ("_position" ei) ("_position" i)))
###               ("_case1" ("\<^const>Pure.dummy_pattern") ("_position" i)))))
###         ("_do_cons"
###           ("_do_let" ("_position" ft)
###             ("_case_syntax" ("_position" td)
###               ("_case2"
###                 ("_case1"
###                   ("_applC" ("_position" IFD)
###                     ("_cargs" ("_position" v)
###                       ("_cargs" ("_position" ti) ("_position" ei))))
###                   ("\<^const>HOL.If"
###                     ("\<^const>HOL.eq" ("_position" v) ("_position" a))
###                     ("_position" ei) ("_position" t)))
###                 ("_case1" ("\<^const>Pure.dummy_pattern")
###                   ("_position" t)))))
###           ("_do_cons"
###             ("_do_let" ("_position" fe)
###               ("_case_syntax" ("_position" ed)
###                 ("_case2"
###                   ("_case1"
###                     ("_applC" ("_position" IFD)
###                       ("_cargs" ("_position" v)
###                         ("_cargs" ("_position" ti) ("_position" ei))))
###                     ("\<^const>HOL.If"
###                       ("\<^const>HOL.eq" ("_position" v) ("_position" a))
###                       ("_position" ei) ("_position" e)))
###                   ("_case1" ("\<^const>Pure.dummy_pattern")
###                     ("_position" e)))))
###             ("_do_cons"
###               ("_do_bind" ("_pattern" ("_position" tb) ("_position" s))
###                 ("_applC" ("_position" iteci_lu_code)
###                   ("_cargs" ("_position" ti)
###                     ("_cargs" ("_position" tt)
###                       ("_cargs" ("_position" te) ("_position" s))))))
###               ("_do_cons"
###                 ("_do_bind" ("_pattern" ("_position" fb) ("_position" s))
###                   ("_applC" ("_position" iteci_lu_code)
###                     ("_cargs" ("_position" fi)
###                       ("_cargs" ("_position" ft)
###                         ("_cargs" ("_position" fe) ("_position" s))))))
###                 ("_do_cons"
###                   ("_do_bind" ("_pattern" ("_position" r) ("_position" s))
###                     ("_applC" ("_position" ifci)
###                       ("_cargs" ("_position" a)
###                         ("_cargs" ("_position" tb)
###                           ("_cargs" ("_position" fb) ("_position" s))))))
###                   ("_do_cons"
###                     ("_do_bind" ("_position" cl)
###                       ("_applC" ("_position" hm_update)
###                         ("_cargs"
###                           ("_tuple" ("_position" i)
###                             ("_tuple_args" ("_position" t)
###                               ("_tuple_arg" ("_position" e))))
###                           ("_cargs" ("_position" r)
###                             ("_applC" ("_position" dcli)
###                               ("_position" s))))))
###                     ("_do_final"
###                       ("_applC" ("_position" return)
###                         ("_tuple" ("_position" r)
###                           ("_tuple_arg"
###                             ("_applC" ("_position" dcli_update)
###                               ("_cargs"
###                                 ("_applC" ("_position" const)
###                                   ("_position" cl))
###                                 ("_position" s)))))))))))))))))))))))))
###                       ("_case1"
###                         ("_applC" ("_position" Some) ("_position" b))
###                         ("_applC" ("_position" return)
###                           ("_tuple" ("_position" b)
###                             ("_tuple_arg" ("_position" s)))))))))
###               ("_case1" ("_applC" ("_position" Some) ("_position" b))
###                 ("_applC" ("_position" return)
###                   ("_tuple" ("_position" b)
###                     ("_tuple_arg" ("_position" s))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
iteci_lu ?i ?t ?e ?s =
hm_lookup (?i, ?t, ?e) (dcli ?s) >>=
(%lu. case lu of
      None =>
        tci ?s >>=
        (%(tr, bdd).
            fci bdd >>=
            (%(fl, bdd).
                destrci ?i bdd >>=
                (%id. destrci ?t bdd >>=
                      (%td. destrci ?e bdd >>=
                            (%ed. return
                                   (if id = TD then Some ?t
                                    else if id = FD then Some ?e
   else if td = TD & ed = FD then Some ?i
        else if ?t = ?e then Some ?t
             else if ed = TD & ?i = ?t then Some tr
                  else if td = FD & ?i = ?e then Some fl else None,
                                    bdd)))))) >>=
        (%(po, s).
            case po of
            None =>
              destrci ?i s >>=
              (%dest.
                  case dest of
                  IFD v ti ei =>
                    destrci ?t s >>=
                    case_IFEXD
                     (destrci ?e s >>=
                      case_IFEXD (return None) (return None)
                       (%v ti ei.
                           return None >>=
                           case_option (return (Some v))
                            (%u. return (Some (min u v)))))
                     (destrci ?e s >>=
                      case_IFEXD (return None) (return None)
                       (%v ti ei.
                           return None >>=
                           case_option (return (Some v))
                            (%u. return (Some (min u v)))))
                     (%v ti ei.
                         destrci ?e s >>=
                         case_IFEXD (return None) (return None)
                          (%v ti ei.
                              return None >>=
                              case_option (return (Some v))
                               (%u. return (Some (min u v)))) >>=
                         case_option (return (Some v))
                          (%u. return (Some (min u v)))) >>=
                    case_option (return (Some v))
                     (%u. return (Some (min u v)))
                  | _ => destrci ?t s >>=
                         case_IFEXD
                          (destrci ?e s >>=
                           case_IFEXD (return None) (return None)
                            (%v ti ei.
                                return None >>=
                                case_option (return (Some v))
                                 (%u. return (Some (min u v)))))
                          (destrci ?e s >>=
                           case_IFEXD (return None) (return None)
                            (%v ti ei.
                                return None >>=
                                case_option (return (Some v))
                                 (%u. return (Some (min u v)))))
                          (%v ti ei.
                              destrci ?e s >>=
                              case_IFEXD (return None) (return None)
                               (%v ti ei.
                                   return None >>=
                                   case_option (return (Some v))
                                    (%u. return (Some (min u v)))) >>=
                              case_option (return (Some v))
                               (%u. return (Some (min u v))))) >>=
              (%lt. case lt of None => raise STR ''Cannot happen''
                    | Some a =>
                        destrci ?i s >>=
                        (%dest.
                            case dest of
                            IFD v ti ei =>
                              return
                               (if v = a then if True then ti else ei
                                else ?i)
                            | _ => return ?i) >>=
                        (%ti. destrci ?t s >>=
                              (%dest.
                                  case dest of
                                  IFD v ti ei =>
                                    return
                                     (if v = a then if True then ti else ei
else ?t)
                                  | _ => return ?t) >>=
                              (%tt. destrci ?e s >>=
                                    (%dest.
  case dest of
  IFD v ti ei => return (if v = a then if True then ti else ei else ?e)
  | _ => return ?e) >>=
                                    (%te.
  destrci ?i s >>=
  (%dest.
      case dest of
      IFD v ti ei => return (if v = a then if False then ti else ei else ?i)
      | _ => return ?i) >>=
  (%fi. destrci ?t s >>=
        (%dest.
            case dest of
            IFD v ti ei =>
              return (if v = a then if False then ti else ei else ?t)
            | _ => return ?t) >>=
        (%ft. destrci ?e s >>=
              (%dest.
                  case dest of
                  IFD v ti ei =>
                    return (if v = a then if False then ti else ei else ?e)
                  | _ => return ?e) >>=
              (%fe. iteci_lu ti tt te s >>=
                    (%(tb, s).
                        iteci_lu fi ft fe s >>=
                        (%(fb, s).
                            ifci a tb fb s >>=
                            (%(r, s).
                                hm_update (?i, ?t, ?e) r (dcli s) >>=
                                (%cl. return
 (r, dcli_update (const cl) s))))))))))))
            | Some b => return (b, s))
      | Some b => return (b, ?s))
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
"liftM (map f)"
  :: "'a list Heap => 'b list Heap"
Found termination order: "size <*mlex*> {}"
### theory "Draft.Conc_Impl"
### 1.352s elapsed time, 1.601s cpu time, 0.126s GC time
Loading theory "Draft.Level_Collapse" (required by "Draft.BDD_ExamplesTemplates" via "Draft.BDD_Examples")
bdd_relator ?p ?s ==
\<exists>\<^sub>Acs.
   is_bdd_impl cs ?s *
   \<up>
    (?p <= {uu_.
            EX a b c.
               uu_ = (a, c) & (a, b) : bf_ifex_rel & (c, b) : Rmi cs} &
     bdd_sane cs) *
   true
val TRY' = fn: ('a -> tactic) -> 'a -> tactic
mi.ite_impl ?i1 ?t1 ?e1 ?bdd1 = Some (?p1, ?bdd'1) ==>
<is_bdd_impl ?bdd1
  ?bddi1> iteci ?i1 ?t1 ?e1
           ?bddi1 <%r. case r of
                       (pi, bddi') =>
                         is_bdd_impl ?bdd'1 bddi' *
                         \<up> (pi = ?p1)>\<^sub>t
[| bdd_sane ?s; in_rel (Rmi ?s) ?ii ?i; in_rel (Rmi ?s) ?ti ?t;
   in_rel (Rmi ?s) ?ei ?e |]
==> ospec (mi.ite_impl ?ii ?ti ?ei ?s)
     (%(r, s').
         (r, ifex_ite ?i ?t ?e) : Rmi s' & bdd_sane s' & mi.les ?s s')
[| (?fi, ?i) : bf_ifex_rel; (?ft, ?t) : bf_ifex_rel;
   (?fe, ?e) : bf_ifex_rel |]
==> (bf_ite ?fi ?ft ?fe, ifex_ite ?i ?t ?e) : bf_ifex_rel
### theory "Draft.Level_Collapse"
### 0.133s elapsed time, 0.169s cpu time, 0.046s GC time
Loading theory "Draft.BDD_Examples" (required by "Draft.BDD_ExamplesTemplates")
### theory "Draft.BDD_Examples"
### 0.031s elapsed time, 0.031s cpu time, 0.000s GC time
Loading theory "Draft.BDD_ExamplesTemplates"
val templateLemmas = []: (string * thm * template) list
### theory "Draft.BDD_ExamplesTemplates"
### 0.777s elapsed time, 0.991s cpu time, 0.082s GC time
val it = (): unit
