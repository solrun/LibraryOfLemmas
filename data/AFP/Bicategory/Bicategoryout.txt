Loading theory "HOL-Cardinals.Fun_More" (required by "Draft.BicategoryMoreTemplates" via "Draft.Bicategory" via "Draft.Prebicategory" via "Category3.EquivalenceOfCategories" via "Category3.Adjunction" via "Category3.Yoneda" via "Category3.SetCat" via "Category3.SetCategory" via "HOL-Cardinals.Cardinals" via "HOL-Cardinals.Ordinal_Arithmetic" via "HOL-Cardinals.Wellorder_Constructions" via "HOL-Cardinals.Wellorder_Embedding")
Loading theory "HOL-Library.FuncSet" (required by "Draft.BicategoryMoreTemplates" via "Draft.Bicategory" via "Draft.Prebicategory" via "Category3.EquivalenceOfCategories" via "Category3.Adjunction" via "Category3.Yoneda" via "Category3.DualCategory" via "Category3.Category")
Loading theory "HOL-Cardinals.Order_Relation_More" (required by "Draft.BicategoryMoreTemplates" via "Draft.Bicategory" via "Draft.Prebicategory" via "Category3.EquivalenceOfCategories" via "Category3.Adjunction" via "Category3.Yoneda" via "Category3.SetCat" via "Category3.SetCategory" via "HOL-Cardinals.Cardinals" via "HOL-Cardinals.Ordinal_Arithmetic" via "HOL-Cardinals.Wellorder_Constructions" via "HOL-Cardinals.Wellorder_Embedding" via "HOL-Cardinals.Wellorder_Relation" via "HOL-Cardinals.Wellfounded_More")
Loading theory "HOL-Cardinals.Order_Union" (required by "Draft.BicategoryMoreTemplates" via "Draft.Bicategory" via "Draft.Prebicategory" via "Category3.EquivalenceOfCategories" via "Category3.Adjunction" via "Category3.Yoneda" via "Category3.SetCat" via "Category3.SetCategory" via "HOL-Cardinals.Cardinals" via "HOL-Cardinals.Ordinal_Arithmetic" via "HOL-Cardinals.Wellorder_Constructions")
### theory "HOL-Cardinals.Fun_More"
### 0.074s elapsed time, 0.329s cpu time, 0.000s GC time
Loading theory "HOL-Library.Function_Algebras" (required by "Draft.BicategoryMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
instantiation
  fun :: (type, plus) plus
  plus_fun == plus :: ('a => 'b) => ('a => 'b) => 'a => 'b
### theory "HOL-Cardinals.Order_Union"
### 0.124s elapsed time, 0.509s cpu time, 0.068s GC time
Loading theory "HOL-Cardinals.Wellorder_Extension" (required by "Draft.BicategoryMoreTemplates" via "Draft.Bicategory" via "Draft.Prebicategory" via "Category3.EquivalenceOfCategories" via "Category3.Adjunction" via "Category3.Yoneda" via "Category3.SetCat" via "Category3.SetCategory" via "HOL-Cardinals.Cardinals")
instantiation
  fun :: (type, zero) zero
  zero_fun == zero_class.zero :: 'a => 'b
instantiation
  fun :: (type, times) times
  times_fun == times :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  fun :: (type, one) one
  one_fun == one_class.one :: 'a => 'b
### theory "HOL-Cardinals.Order_Relation_More"
### 0.167s elapsed time, 0.681s cpu time, 0.068s GC time
Loading theory "HOL-Cardinals.Wellfounded_More" (required by "Draft.BicategoryMoreTemplates" via "Draft.Bicategory" via "Draft.Prebicategory" via "Category3.EquivalenceOfCategories" via "Category3.Adjunction" via "Category3.Yoneda" via "Category3.SetCat" via "Category3.SetCategory" via "HOL-Cardinals.Cardinals" via "HOL-Cardinals.Ordinal_Arithmetic" via "HOL-Cardinals.Wellorder_Constructions" via "HOL-Cardinals.Wellorder_Embedding" via "HOL-Cardinals.Wellorder_Relation")
### theory "HOL-Cardinals.Wellorder_Extension"
### 0.061s elapsed time, 0.243s cpu time, 0.000s GC time
Loading theory "HOL-Library.Nat_Bijection" (required by "Draft.BicategoryMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.Stream")
### theory "HOL-Library.Function_Algebras"
### 0.117s elapsed time, 0.453s cpu time, 0.068s GC time
Loading theory "HOL-Library.Set_Algebras" (required by "Draft.BicategoryMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
### theory "HOL-Cardinals.Wellfounded_More"
### 0.030s elapsed time, 0.119s cpu time, 0.000s GC time
Loading theory "HOL-Cardinals.Wellorder_Relation" (required by "Draft.BicategoryMoreTemplates" via "Draft.Bicategory" via "Draft.Prebicategory" via "Category3.EquivalenceOfCategories" via "Category3.Adjunction" via "Category3.Yoneda" via "Category3.SetCat" via "Category3.SetCategory" via "HOL-Cardinals.Cardinals" via "HOL-Cardinals.Ordinal_Arithmetic" via "HOL-Cardinals.Wellorder_Constructions" via "HOL-Cardinals.Wellorder_Embedding")
instantiation
  set :: (plus) plus
  plus_set == plus :: 'a set => 'a set => 'a set
instantiation
  set :: (times) times
  times_set == times :: 'a set => 'a set => 'a set
locale wo_rel
  fixes r :: "('a * 'a) set"
  assumes "wo_rel r"
instantiation
  set :: (zero) zero
  zero_set == zero_class.zero :: 'a set
instantiation
  set :: (one) one
  one_set == one_class.one :: 'a set
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
### theory "HOL-Cardinals.Wellorder_Relation"
### 0.269s elapsed time, 0.935s cpu time, 0.410s GC time
Loading theory "HOL-Cardinals.Wellorder_Embedding" (required by "Draft.BicategoryMoreTemplates" via "Draft.Bicategory" via "Draft.Prebicategory" via "Category3.EquivalenceOfCategories" via "Category3.Adjunction" via "Category3.Yoneda" via "Category3.SetCat" via "Category3.SetCategory" via "HOL-Cardinals.Cardinals" via "HOL-Cardinals.Ordinal_Arithmetic" via "HOL-Cardinals.Wellorder_Constructions")
### theory "HOL-Library.FuncSet"
### 0.486s elapsed time, 1.807s cpu time, 0.477s GC time
Loading theory "Category3.Category" (required by "Draft.BicategoryMoreTemplates" via "Draft.Bicategory" via "Draft.Prebicategory" via "Category3.EquivalenceOfCategories" via "Category3.Adjunction" via "Category3.Yoneda" via "Category3.DualCategory")
Found termination order: "size_list size <*mlex*> {}"
### theory "HOL-Library.Set_Algebras"
### 0.322s elapsed time, 1.151s cpu time, 0.410s GC time
Loading theory "HOL-Library.Tree" (required by "Draft.BicategoryMoreTemplates" via "Draft.ExtrEqs" via "Draft.Templates")
locale partial_magma
  fixes C :: "'a => 'a => 'a"  (infixr \<open>\<cdot>\<close> 55)
  assumes "partial_magma (\<cdot>)"
### theory "HOL-Library.Nat_Bijection"
### 0.444s elapsed time, 1.623s cpu time, 0.496s GC time
Loading theory "HOL-Library.Stream" (required by "Draft.BicategoryMoreTemplates" via "Draft.ExtrEqs")
### theory "HOL-Cardinals.Wellorder_Embedding"
### 0.178s elapsed time, 0.703s cpu time, 0.086s GC time
Loading theory "HOL-Cardinals.Wellorder_Constructions" (required by "Draft.BicategoryMoreTemplates" via "Draft.Bicategory" via "Draft.Prebicategory" via "Category3.EquivalenceOfCategories" via "Category3.Adjunction" via "Category3.Yoneda" via "Category3.SetCat" via "Category3.SetCategory" via "HOL-Cardinals.Cardinals" via "HOL-Cardinals.Ordinal_Arithmetic")
locale category
  fixes C :: "'a => 'a => 'a"  (infixr \<open>\<cdot>\<close> 55)
  assumes "category (\<cdot>)"
### theory "Category3.Category"
### 0.263s elapsed time, 1.033s cpu time, 0.086s GC time
Loading theory "Category3.ConcreteCategory" (required by "Draft.BicategoryMoreTemplates" via "Draft.Bicategory" via "Draft.Prebicategory" via "Category3.EquivalenceOfCategories" via "Category3.Adjunction" via "Category3.Yoneda" via "Category3.SetCat" via "Category3.SetCategory" via "Category3.Functor")
locale concrete_category
  fixes Obj :: "'o set"
    and Hom :: "'o => 'o => 'a set"
    and Id :: "'o => 'a"
    and Comp :: "'o => 'o => 'o => 'a => 'a => 'a"
  assumes "concrete_category Obj Hom Id Comp"
locale wo_rel
  fixes r :: "('a * 'a) set"
  assumes "wo_rel r"
consts
  shift :: "'a list => 'a stream => 'a stream"
Proofs for coinductive predicate(s) "streamsp"
  Proving monotonicity ...
consts
  left :: "'a tree => 'a tree"
consts
  right :: "'a tree => 'a tree"
Found termination order: "size <*mlex*> {}"
consts
  snth :: "'a stream => nat => 'a"
consts
  stake :: "nat => 'a stream => 'a list"
consts
  sdrop :: "nat => 'a stream => 'a stream"
Found termination order: "size <*mlex*> {}"
### theory "HOL-Cardinals.Wellorder_Constructions"
### 0.523s elapsed time, 2.063s cpu time, 0.272s GC time
Loading theory "HOL-Cardinals.Cardinal_Order_Relation" (required by "Draft.BicategoryMoreTemplates" via "Draft.Bicategory" via "Draft.Prebicategory" via "Category3.EquivalenceOfCategories" via "Category3.Adjunction" via "Category3.Yoneda" via "Category3.SetCat" via "Category3.SetCategory" via "HOL-Cardinals.Cardinals" via "HOL-Cardinals.Cardinal_Arithmetic")
consts
  sfilter :: "('a => bool) => 'a stream => 'a stream"
Found termination order: "size <*mlex*> {}"
consts
  cycle :: "'a list => 'a stream"
class height = type +
  fixes height :: "'a => nat"
instantiation
  tree :: (type) height
  height_tree == height :: 'a tree => nat
consts
  siterate :: "('a => 'a) => 'a => 'a stream"
Found termination order: "size <*mlex*> {}"
consts
  flat :: "'a list stream => 'a stream"
consts
  sinterleave :: "'a stream => 'a stream => 'a stream"
Found termination order: "size <*mlex*> {}"
consts
  szip :: "'a stream => 'b stream => ('a * 'b) stream"
consts
  smap2 :: "('a => 'b => 'c) => 'a stream => 'b stream => 'c stream"
Found termination order: "size <*mlex*> {}"
### theory "HOL-Library.Stream"
### 1.107s elapsed time, 4.152s cpu time, 1.218s GC time
Loading theory "HOL-Cardinals.Ordinal_Arithmetic" (required by "Draft.BicategoryMoreTemplates" via "Draft.Bicategory" via "Draft.Prebicategory" via "Category3.EquivalenceOfCategories" via "Category3.Adjunction" via "Category3.Yoneda" via "Category3.SetCat" via "Category3.SetCategory" via "HOL-Cardinals.Cardinals")
Found termination order: "size <*mlex*> {}"
Found termination order: "{}"
Found termination order: "size <*mlex*> {}"
Found termination order: "{}"
Found termination order: "size <*mlex*> {}"
Found termination order: "{}"
Found termination order: "size <*mlex*> {}"
locale wo_rel
  fixes r :: "('a * 'a) set"
  assumes "wo_rel r"
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
locale wo_rel2
  fixes r :: "('a * 'a) set"
    and s :: "('b * 'b) set"
  assumes "wo_rel2 r s"
Found termination order: "size <*mlex*> {}"
### theory "HOL-Cardinals.Cardinal_Order_Relation"
### 1.039s elapsed time, 3.894s cpu time, 1.159s GC time
Loading theory "HOL-Cardinals.Cardinal_Arithmetic" (required by "Draft.BicategoryMoreTemplates" via "Draft.Bicategory" via "Draft.Prebicategory" via "Category3.EquivalenceOfCategories" via "Category3.Adjunction" via "Category3.Yoneda" via "Category3.SetCat" via "Category3.SetCategory" via "HOL-Cardinals.Cardinals")
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
### theory "Category3.ConcreteCategory"
### 1.622s elapsed time, 6.178s cpu time, 1.649s GC time
Loading theory "Category3.DiscreteCategory" (required by "Draft.BicategoryMoreTemplates" via "Draft.Bicategory")
locale discrete_category
  fixes Obj :: "'a set"
    and Null :: "'a"
  assumes "discrete_category Obj Null"
locale discrete_category
  fixes Obj :: "'a set"
    and Null :: "'a"
  assumes "discrete_category Obj Null"
### theory "HOL-Cardinals.Cardinal_Arithmetic"
### 0.213s elapsed time, 0.849s cpu time, 0.105s GC time
Loading theory "Category3.DualCategory" (required by "Draft.BicategoryMoreTemplates" via "Draft.Bicategory" via "Draft.Prebicategory" via "Category3.EquivalenceOfCategories" via "Category3.Adjunction" via "Category3.Yoneda")
### theory "Category3.DiscreteCategory"
### 0.434s elapsed time, 1.551s cpu time, 1.090s GC time
Loading theory "Category3.EpiMonoIso" (required by "Draft.BicategoryMoreTemplates" via "Draft.Bicategory" via "Draft.Prebicategory" via "Category3.EquivalenceOfCategories" via "Category3.Adjunction" via "Category3.Yoneda" via "Category3.SetCat" via "Category3.SetCategory" via "Category3.Functor" via "Category3.InitialTerminal")
locale category
  fixes C :: "'a => 'a => 'a"  (infixr \<open>\<cdot>\<close> 55)
  assumes "category (\<cdot>)"
locale dual_category
  fixes C :: "'a => 'a => 'a"  (infixr \<open>\<cdot>\<close> 55)
  assumes "dual_category (\<cdot>)"
Found termination order: "size <*mlex*> {}"
locale dual_category
  fixes C :: "'a => 'a => 'a"  (infixr \<open>\<cdot>\<close> 55)
  assumes "dual_category (\<cdot>)"
### theory "Category3.DualCategory"
### 0.502s elapsed time, 1.811s cpu time, 1.131s GC time
Loading theory "HOL-Library.BigO" (required by "Draft.BicategoryMoreTemplates" via "Draft.ExtrEqs")
### theory "HOL-Cardinals.Ordinal_Arithmetic"
### 1.221s elapsed time, 4.652s cpu time, 1.562s GC time
Loading theory "HOL-Cardinals.Cardinals" (required by "Draft.BicategoryMoreTemplates" via "Draft.Bicategory" via "Draft.Prebicategory" via "Category3.EquivalenceOfCategories" via "Category3.Adjunction" via "Category3.Yoneda" via "Category3.SetCat" via "Category3.SetCategory")
### theory "Category3.EpiMonoIso"
### 0.288s elapsed time, 1.135s cpu time, 0.109s GC time
Loading theory "Category3.InitialTerminal" (required by "Draft.BicategoryMoreTemplates" via "Draft.Bicategory" via "Draft.Prebicategory" via "Category3.EquivalenceOfCategories" via "Category3.Adjunction" via "Category3.Yoneda" via "Category3.SetCat" via "Category3.SetCategory" via "Category3.Functor")
### theory "HOL-Library.Tree"
### 2.601s elapsed time, 9.871s cpu time, 2.934s GC time
Loading theory "Category3.ProductCategory" (required by "Draft.BicategoryMoreTemplates" via "Draft.Bicategory" via "Draft.Prebicategory" via "Category3.EquivalenceOfCategories" via "Category3.Adjunction" via "Category3.Yoneda" via "Category3.FunctorCategory" via "Category3.BinaryFunctor")
locale category
  fixes C :: "'a => 'a => 'a"  (infixr \<open>\<cdot>\<close> 55)
  assumes "category (\<cdot>)"
### theory "Category3.InitialTerminal"
### 0.092s elapsed time, 0.367s cpu time, 0.000s GC time
Loading theory "Category3.Functor" (required by "Draft.BicategoryMoreTemplates" via "Draft.Bicategory" via "Draft.Prebicategory" via "Category3.EquivalenceOfCategories" via "Category3.Adjunction" via "Category3.Yoneda" via "Category3.SetCat" via "Category3.SetCategory")
locale product_category
  fixes
    C1 :: "'a1 => 'a1 => 'a1"  (infixr \<open>\<cdot>\<^sub>1\<close> 55)
    and
    C2 :: "'a2 => 'a2 => 'a2"  (infixr \<open>\<cdot>\<^sub>2\<close> 55)
  assumes "product_category (\<cdot>\<^sub>1) (\<cdot>\<^sub>2)"
### theory "HOL-Cardinals.Cardinals"
### 0.254s elapsed time, 1.002s cpu time, 0.068s GC time
Loading theory "Draft.Templates" (required by "Draft.BicategoryMoreTemplates" via "Draft.ExtrEqs")
datatype template_term
=
     t_empty
   | template_app of template_term * template_term
   | template_hole of int
   | template_var of int
datatype sign
= equals | greater_equals | greater_than | less_equals | less_than
datatype template
=
     template_bimplication of template * template
   | template_dunno
   | template_equation of template_term * template_term
   | template_implication of template list * template
   | template_inequation of sign * template_term * template_term
   | template_negation of template
   | template_predicate of template_term
constructor t_empty: template_term
constructor template_app: template_term * template_term -> template_term
constructor template_hole: int -> template_term
constructor template_var: int -> template_term
constructor equals: sign
constructor greater_equals: sign
constructor greater_than: sign
constructor less_equals: sign
constructor less_than: sign
constructor template_bimplication: template * template -> template
constructor template_dunno: template
constructor template_equation: template_term * template_term -> template
constructor template_implication: template list * template -> template
constructor template_inequation:
   sign * template_term * template_term -> template
constructor template_negation: template -> template
constructor template_predicate: template_term -> template
val vfs = fn: term -> (indexname * typ) list * (string * typ) list
val indexOf = fn: ''a list -> ''a -> int -> int
val has_eq = fn: term -> bool
val term2template = fn:
   (indexname * typ) list -> (string * typ) list -> term -> template_term
val lemma2predicate = fn: term -> term -> template
val makeTemplatewithContext = fn: term -> term -> template
val lemma2template = fn: term -> template
val thm2template = fn: thm -> template
val tterm2string = fn: template_term -> string
val template2string = fn: template -> string
val t = "height ?t <= size ?t": thm
val th =
   Const ("HOL.Trueprop", "bool => prop") $
     (Const ("Orderings.ord_class.less_eq", "nat => nat => bool") $
       (Const ("Tree.height_class.height", "?'a tree => nat") $
         Var (("t", 0), "?'a tree")) $
       (Const ("Nat.size_class.size", "?'a tree => nat") $
         Var (("t", 0), "?'a tree"))):
   term
### theory "Draft.Templates"
### 0.088s elapsed time, 0.346s cpu time, 0.079s GC time
### theory "Category3.ProductCategory"
### 0.316s elapsed time, 1.166s cpu time, 0.079s GC time
locale functor
  fixes A :: "'a => 'a => 'a"  (infixr \<open>\<cdot>\<^sub>A\<close> 55)
    and B :: "'b => 'b => 'b"  (infixr \<open>\<cdot>\<^sub>B\<close> 55)
    and F :: "'a => 'b"
  assumes "functor (\<cdot>\<^sub>A) (\<cdot>\<^sub>B) F"
locale endofunctor
  fixes A :: "'a => 'a => 'a"  (infixr \<open>\<cdot>\<close> 55)
    and F :: "'a => 'a"
  assumes "endofunctor (\<cdot>) F"
locale faithful_functor
  fixes A :: "'a => 'a => 'a"
    and B :: "'b => 'b => 'b"
    and F :: "'a => 'b"
  assumes "faithful_functor A B F"
### theory "HOL-Library.BigO"
### 0.761s elapsed time, 2.316s cpu time, 0.209s GC time
Loading theory "Draft.ExtrEqs" (required by "Draft.BicategoryMoreTemplates")
locale full_functor
  fixes A :: "'a => 'a => 'a"
    and B :: "'b => 'b => 'b"
    and F :: "'a => 'b"
  assumes "full_functor A B F"
locale fully_faithful_functor
  fixes A :: "'a => 'a => 'a"
    and B :: "'b => 'b => 'b"
    and F :: "'a => 'b"
  assumes "fully_faithful_functor A B F"
locale embedding_functor
  fixes A :: "'a => 'a => 'a"
    and B :: "'b => 'b => 'b"
    and F :: "'a => 'b"
  assumes "embedding_functor A B F"
locale embedding_functor
  fixes A :: "'a => 'a => 'a"
    and B :: "'b => 'b => 'b"
    and F :: "'a => 'b"
  assumes "embedding_functor A B F"
locale full_embedding_functor
  fixes A :: "'a => 'a => 'a"
    and B :: "'b => 'b => 'b"
    and F :: "'a => 'b"
  assumes "full_embedding_functor A B F"
locale essentially_surjective_functor
  fixes A :: "'a => 'a => 'a"  (infixr \<open>\<cdot>\<^sub>A\<close> 55)
    and B :: "'b => 'b => 'b"  (infixr \<open>\<cdot>\<^sub>B\<close> 55)
    and F :: "'a => 'b"
  assumes
    "essentially_surjective_functor (\<cdot>\<^sub>A) (\<cdot>\<^sub>B) F"
val eqpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Var (("_dummy_", 2), "?'a"))
       ):
   term Find_Theorems.criterion
val badeqpattern = Pattern (Const ("Pure.eq", "?'a => ?'a => prop")):
   term Find_Theorems.criterion
val undefpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Const ("HOL.undefined", "?'a"))
       ):
   term Find_Theorems.criterion
val thmpattern =
   Pattern
    (Const ("HOL.Trueprop", "bool => prop") $ Var (("_dummy_", 1), "bool")):
   term Find_Theorems.criterion
val badnames =
   ["*nitpick*", "*Nitpick*", "*full_exhaustive*", "*_def*", "Enum.finite*",
    "*Quickcheck*", "ATP*", "*Nunchaku*", "*Code*", "*BNF*", "*SMT*",
    "*.*.*"]:
   string list
val unwanted_names =
   [(false, Name "*nitpick*"), (false, Name "*Nitpick*"),
    (false, Name "*full_exhaustive*"), (false, Name "*_def*"),
    (false, Name "Enum.finite*"), (false, Name "*Quickcheck*"),
    (false, Name "ATP*"), (false, Name "*Nunchaku*"),
    (false, Name "*Code*"), (false, Name "*BNF*"), (false, Name "*SMT*"),
    (false, Name "*.*.*")]:
   (bool * term Find_Theorems.criterion) list
val has_vars = fn: term -> bool
val get_all_eqs = fn: string -> Proof.context -> (string * thm) list
val get_all_thms = fn: string -> Proof.context -> (string * thm) list
val get_noneq_thms = fn: string -> Proof.context -> (string * thm) list
val template_eqs = fn:
   string -> Proof.context -> (string * thm * template) list
val template_thms = fn:
   string -> Proof.context -> (string * thm * template) list
### theory "Draft.ExtrEqs"
### 0.573s elapsed time, 1.216s cpu time, 0.155s GC time
locale constant_functor
  fixes A :: "'a => 'a => 'a"
    and B :: "'b => 'b => 'b"
    and b :: "'b"
  assumes "constant_functor A B b"
locale identity_functor
  fixes C :: "'a => 'a => 'a"
  assumes "identity_functor C"
locale composite_functor
  fixes A :: "'a => 'a => 'a"
    and B :: "'b => 'b => 'b"
    and C :: "'c => 'c => 'c"
    and F :: "'a => 'b"
    and G :: "'b => 'c"
  assumes "composite_functor A B C F G"
locale inverse_functors
  fixes A :: "'a => 'a => 'a"  (infixr \<open>\<cdot>\<^sub>A\<close> 55)
    and B :: "'b => 'b => 'b"  (infixr \<open>\<cdot>\<^sub>B\<close> 55)
    and F :: "'b => 'a"
    and G :: "'a => 'b"
  assumes "inverse_functors (\<cdot>\<^sub>A) (\<cdot>\<^sub>B) F G"
locale isomorphic_categories
  fixes A :: "'a => 'a => 'a"  (infixr \<open>\<cdot>\<^sub>A\<close> 55)
    and B :: "'b => 'b => 'b"  (infixr \<open>\<cdot>\<^sub>B\<close> 55)
  assumes "isomorphic_categories (\<cdot>\<^sub>A) (\<cdot>\<^sub>B)"
locale invertible_functor
  fixes A :: "'a => 'a => 'a"  (infixr \<open>\<cdot>\<^sub>A\<close> 55)
    and B :: "'b => 'b => 'b"  (infixr \<open>\<cdot>\<^sub>B\<close> 55)
    and G :: "'a => 'b"
  assumes "invertible_functor (\<cdot>\<^sub>A) (\<cdot>\<^sub>B) G"
locale dual_functor
  fixes A :: "'a => 'a => 'a"  (infixr \<open>\<cdot>\<^sub>A\<close> 55)
    and B :: "'b => 'b => 'b"  (infixr \<open>\<cdot>\<^sub>B\<close> 55)
    and F :: "'a => 'b"
  assumes "dual_functor (\<cdot>\<^sub>A) (\<cdot>\<^sub>B) F"
locale category
  fixes C :: "'a => 'a => 'a"  (infixr \<open>\<cdot>\<close> 55)
  assumes "category (\<cdot>)"
locale category
  fixes C :: "'a => 'a => 'a"  (infixr \<open>\<cdot>\<close> 55)
  assumes "category (\<cdot>)"
### theory "Category3.Functor"
### 2.531s elapsed time, 4.238s cpu time, 0.474s GC time
Loading theory "Category3.NaturalTransformation" (required by "Draft.BicategoryMoreTemplates" via "Draft.Bicategory" via "Draft.Prebicategory" via "Category3.EquivalenceOfCategories" via "Category3.Adjunction" via "Category3.Yoneda" via "Category3.FunctorCategory" via "Category3.BinaryFunctor")
Loading theory "Category3.Subcategory" (required by "Draft.BicategoryMoreTemplates" via "Draft.Bicategory" via "Draft.Prebicategory")
Loading theory "Category3.SetCategory" (required by "Draft.BicategoryMoreTemplates" via "Draft.Bicategory" via "Draft.Prebicategory" via "Category3.EquivalenceOfCategories" via "Category3.Adjunction" via "Category3.Yoneda" via "Category3.SetCat")
locale subcategory
  fixes C :: "'a => 'a => 'a"  (infixr \<open>\<cdot>\<^sub>C\<close> 55)
    and Arr :: "'a => bool"
  assumes "subcategory (\<cdot>\<^sub>C) Arr"
locale natural_transformation
  fixes A :: "'a => 'a => 'a"  (infixr \<open>\<cdot>\<^sub>A\<close> 55)
    and B :: "'b => 'b => 'b"  (infixr \<open>\<cdot>\<^sub>B\<close> 55)
    and F :: "'a => 'b"
    and G :: "'a => 'b"
    and \<tau> :: "'a => 'b"
  assumes
    "natural_transformation (\<cdot>\<^sub>A) (\<cdot>\<^sub>B) F G \<tau>"
locale set_category_data
  fixes S :: "'s => 's => 's"  (infixr \<open>\<cdot>\<close> 55)
    and img :: "'s => 's"
  assumes "set_category_data (\<cdot>)"
locale transformation_by_components
  fixes A :: "'a => 'a => 'a"  (infixr \<open>\<cdot>\<^sub>A\<close> 55)
    and B :: "'b => 'b => 'b"  (infixr \<open>\<cdot>\<^sub>B\<close> 55)
    and F :: "'a => 'b"
    and G :: "'a => 'b"
    and t :: "'a => 'b"
  assumes
    "transformation_by_components (\<cdot>\<^sub>A) (\<cdot>\<^sub>B) F G t"
locale set_category_given_img
  fixes S :: "'s => 's => 's"  (infixr \<open>\<cdot>\<close> 55)
    and img :: "'s => 's"
    and \<AA> :: "('t * 't) set"
  assumes "set_category_given_img (\<cdot>) img \<AA>"
locale set_category
  fixes S :: "'s => 's => 's"  (infixr \<open>\<cdot>\<close> 55)
    and \<AA> :: "('t * 't) set"
  assumes "set_category (\<cdot>) \<AA>"
locale constant_transformation
  fixes A :: "'a => 'a => 'a"  (infixr \<open>\<cdot>\<^sub>A\<close> 55)
    and B :: "'b => 'b => 'b"  (infixr \<open>\<cdot>\<^sub>B\<close> 55)
    and g :: "'b"
  assumes "constant_transformation (\<cdot>\<^sub>A) (\<cdot>\<^sub>B) g"
locale replete_set_category
  fixes S :: "'s => 's => 's"  (infixr \<open>\<cdot>\<close> 55)
  assumes "replete_set_category (\<cdot>)"
locale constant_transformation
  fixes A :: "'a => 'a => 'a"  (infixr \<open>\<cdot>\<^sub>A\<close> 55)
    and B :: "'b => 'b => 'b"  (infixr \<open>\<cdot>\<^sub>B\<close> 55)
    and g :: "'b"
  assumes "constant_transformation (\<cdot>\<^sub>A) (\<cdot>\<^sub>B) g"
locale set_category
  fixes S :: "'s => 's => 's"  (infixr \<open>\<cdot>\<close> 55)
    and \<AA> :: "('t * 't) set"
  assumes "set_category (\<cdot>) \<AA>"
locale full_subcategory
  fixes C :: "'a => 'a => 'a"
    and Ide :: "'a => bool"
  assumes "full_subcategory C Ide"
locale vertical_composite
  fixes A :: "'a => 'a => 'a"  (infixr \<open>\<cdot>\<^sub>A\<close> 55)
    and B :: "'b => 'b => 'b"  (infixr \<open>\<cdot>\<^sub>B\<close> 55)
    and F :: "'a => 'b"
    and G :: "'a => 'b"
    and H :: "'a => 'b"
    and \<sigma> :: "'a => 'b"
    and \<tau> :: "'a => 'b"
  assumes
    "vertical_composite (\<cdot>\<^sub>A) (\<cdot>\<^sub>B) F G H \<sigma>
      \<tau>"
locale two_set_categories_bij_betw_Univ
  fixes S :: "'s => 's => 's"  (infixr \<open>\<cdot>\<close> 55)
    and S' :: "'t => 't => 't"  (infixr \<open>\<cdot>\<acute>\<close> 55)
    and \<AA> :: "('u * 'u) set"
    and \<phi> :: "'s => 't"
  assumes
    "two_set_categories_bij_betw_Univ (\<cdot>) (\<cdot>\<acute>) \<AA>
      \<phi>"
locale natural_isomorphism
  fixes A :: "'a => 'a => 'a"  (infixr \<open>\<cdot>\<^sub>A\<close> 55)
    and B :: "'b => 'b => 'b"  (infixr \<open>\<cdot>\<^sub>B\<close> 55)
    and F :: "'a => 'b"
    and G :: "'a => 'b"
    and \<tau> :: "'a => 'b"
  assumes
    "natural_isomorphism (\<cdot>\<^sub>A) (\<cdot>\<^sub>B) F G \<tau>"
locale set_category
  fixes S :: "'s => 's => 's"  (infixr \<open>\<cdot>\<close> 55)
    and \<AA> :: "('t * 't) set"
  assumes "set_category (\<cdot>) \<AA>"
locale inverse_transformation
  fixes A :: "'a => 'a => 'a"  (infixr \<open>\<cdot>\<^sub>A\<close> 55)
    and B :: "'b => 'b => 'b"  (infixr \<open>\<cdot>\<^sub>B\<close> 55)
    and F :: "'a => 'b"
    and G :: "'a => 'b"
    and \<tau> :: "'a => 'b"
  assumes
    "inverse_transformation (\<cdot>\<^sub>A) (\<cdot>\<^sub>B) F G \<tau>"
locale concrete_set_category
  fixes S :: "'s => 's => 's"  (infixr \<open>\<cdot>\<^sub>S\<close> 55)
    and \<AA> :: "('t * 't) set"
    and U :: "'a set"
    and \<iota> :: "'a => 's"
  assumes "concrete_set_category (\<cdot>\<^sub>S) \<AA> U \<iota>"
locale full_subcategory
  fixes C :: "'a => 'a => 'a"
    and Ide :: "'a => bool"
  assumes "full_subcategory C Ide"
locale replete_concrete_set_category
  fixes S :: "'s => 's => 's"  (infixr \<open>\<cdot>\<^sub>S\<close> 55)
    and U :: "'a set"
    and \<iota> :: "'a => 's"
  assumes "replete_concrete_set_category (\<cdot>\<^sub>S) U \<iota>"
### theory "Category3.SetCategory"
### 1.938s elapsed time, 5.922s cpu time, 0.701s GC time
Loading theory "Category3.SetCat" (required by "Draft.BicategoryMoreTemplates" via "Draft.Bicategory" via "Draft.Prebicategory" via "Category3.EquivalenceOfCategories" via "Category3.Adjunction" via "Category3.Yoneda")
locale inverse_transformations
  fixes A :: "'a => 'a => 'a"  (infixr \<open>\<cdot>\<^sub>A\<close> 55)
    and B :: "'b => 'b => 'b"  (infixr \<open>\<cdot>\<^sub>B\<close> 55)
    and F :: "'a => 'b"
    and G :: "'a => 'b"
    and \<tau> :: "'a => 'b"
    and \<tau>' :: "'a => 'b"
  assumes
    "inverse_transformations (\<cdot>\<^sub>A) (\<cdot>\<^sub>B) F G \<tau>
      \<tau>'"
locale setcat
  fixes dummy :: "'e"
    and \<AA> :: "('a * 'a) set"
  assumes "setcat \<AA>"
### theory "Category3.NaturalTransformation"
### 2.175s elapsed time, 6.644s cpu time, 0.776s GC time
Loading theory "Draft.IsomorphismClass" (required by "Draft.BicategoryMoreTemplates" via "Draft.Bicategory" via "Draft.Prebicategory")
Loading theory "Category3.BinaryFunctor" (required by "Draft.BicategoryMoreTemplates" via "Draft.Bicategory" via "Draft.Prebicategory" via "Category3.EquivalenceOfCategories" via "Category3.Adjunction" via "Category3.Yoneda" via "Category3.FunctorCategory")
locale category
  fixes C :: "'a => 'a => 'a"  (infixr \<open>\<cdot>\<close> 55)
  assumes "category (\<cdot>)"
### theory "Draft.IsomorphismClass"
### 0.094s elapsed time, 0.370s cpu time, 0.000s GC time
locale inclusion_functor
  fixes C :: "'a => 'a => 'a"
    and Arr :: "'a => bool"
  assumes "inclusion_functor C Arr"
locale binary_functor
  fixes
    A1 :: "'a1 => 'a1 => 'a1"
      (infixr \<open>\<cdot>\<^sub>A\<^sub>1\<close> 55)
    and
    A2 :: "'a2 => 'a2 => 'a2"
      (infixr \<open>\<cdot>\<^sub>A\<^sub>2\<close> 55)
    and B :: "'b => 'b => 'b"  (infixr \<open>\<cdot>\<^sub>B\<close> 55)
    and F :: "'a1 * 'a2 => 'b"
  assumes
    "binary_functor (\<cdot>\<^sub>A\<^sub>1) (\<cdot>\<^sub>A\<^sub>2)
      (\<cdot>\<^sub>B) F"
locale product_functor
  fixes
    A1 :: "'a1 => 'a1 => 'a1"
      (infixr \<open>\<cdot>\<^sub>A\<^sub>1\<close> 55)
    and
    A2 :: "'a2 => 'a2 => 'a2"
      (infixr \<open>\<cdot>\<^sub>A\<^sub>2\<close> 55)
    and
    B1 :: "'b1 => 'b1 => 'b1"
      (infixr \<open>\<cdot>\<^sub>B\<^sub>1\<close> 55)
    and
    B2 :: "'b2 => 'b2 => 'b2"
      (infixr \<open>\<cdot>\<^sub>B\<^sub>2\<close> 55)
    and F1 :: "'a1 => 'b1"
    and F2 :: "'a2 => 'b2"
  assumes
    "product_functor (\<cdot>\<^sub>A\<^sub>1) (\<cdot>\<^sub>A\<^sub>2)
      (\<cdot>\<^sub>B\<^sub>1) (\<cdot>\<^sub>B\<^sub>2) F1 F2"
locale replete_setcat
  fixes dummy :: "'e"
locale full_inclusion_functor
  fixes C :: "'a => 'a => 'a"
    and Ide :: "'a => bool"
  assumes "full_inclusion_functor C Ide"
locale full_inclusion_functor
  fixes C :: "'a => 'a => 'a"
    and Ide :: "'a => bool"
  assumes "full_inclusion_functor C Ide"
### theory "Category3.Subcategory"
### 4.004s elapsed time, 12.327s cpu time, 1.272s GC time
locale symmetry_functor
  fixes
    A1 :: "'a1 => 'a1 => 'a1"
      (infixr \<open>\<cdot>\<^sub>A\<^sub>1\<close> 55)
    and
    A2 :: "'a2 => 'a2 => 'a2"
      (infixr \<open>\<cdot>\<^sub>A\<^sub>2\<close> 55)
  assumes
    "symmetry_functor (\<cdot>\<^sub>A\<^sub>1) (\<cdot>\<^sub>A\<^sub>2)"
### theory "Category3.SetCat"
### 2.403s elapsed time, 7.093s cpu time, 0.682s GC time
locale binary_functor
  fixes
    A1 :: "'a1 => 'a1 => 'a1"
      (infixr \<open>\<cdot>\<^sub>A\<^sub>1\<close> 55)
    and
    A2 :: "'a2 => 'a2 => 'a2"
      (infixr \<open>\<cdot>\<^sub>A\<^sub>2\<close> 55)
    and B :: "'b => 'b => 'b"  (infixr \<open>\<cdot>\<^sub>B\<close> 55)
    and F :: "'a1 * 'a2 => 'b"
  assumes
    "binary_functor (\<cdot>\<^sub>A\<^sub>1) (\<cdot>\<^sub>A\<^sub>2)
      (\<cdot>\<^sub>B) F"
locale binary_functor_transformation
  fixes
    A1 :: "'a1 => 'a1 => 'a1"
      (infixr \<open>\<cdot>\<^sub>A\<^sub>1\<close> 55)
    and
    A2 :: "'a2 => 'a2 => 'a2"
      (infixr \<open>\<cdot>\<^sub>A\<^sub>2\<close> 55)
    and B :: "'b => 'b => 'b"  (infixr \<open>\<cdot>\<^sub>B\<close> 55)
    and F :: "'a1 * 'a2 => 'b"
    and G :: "'a1 * 'a2 => 'b"
    and \<tau> :: "'a1 * 'a2 => 'b"
  assumes
    "binary_functor_transformation (\<cdot>\<^sub>A\<^sub>1)
      (\<cdot>\<^sub>A\<^sub>2) (\<cdot>\<^sub>B) F G \<tau>"
### theory "Category3.BinaryFunctor"
### 2.680s elapsed time, 6.988s cpu time, 0.706s GC time
Loading theory "Category3.FunctorCategory" (required by "Draft.BicategoryMoreTemplates" via "Draft.Bicategory" via "Draft.Prebicategory" via "Category3.EquivalenceOfCategories" via "Category3.Adjunction" via "Category3.Yoneda")
locale functor_category
  fixes A :: "'a => 'a => 'a"  (infixr \<open>\<cdot>\<^sub>A\<close> 55)
    and B :: "'b => 'b => 'b"  (infixr \<open>\<cdot>\<^sub>B\<close> 55)
  assumes "functor_category (\<cdot>\<^sub>A) (\<cdot>\<^sub>B)"
locale functor_category
  fixes A :: "'a => 'a => 'a"  (infixr \<open>\<cdot>\<^sub>A\<close> 55)
    and B :: "'b => 'b => 'b"  (infixr \<open>\<cdot>\<^sub>B\<close> 55)
  assumes "functor_category (\<cdot>\<^sub>A) (\<cdot>\<^sub>B)"
locale evaluation_functor
  fixes A :: "'a => 'a => 'a"  (infixr \<open>\<cdot>\<^sub>A\<close> 55)
    and B :: "'b => 'b => 'b"  (infixr \<open>\<cdot>\<^sub>B\<close> 55)
  assumes "evaluation_functor (\<cdot>\<^sub>A) (\<cdot>\<^sub>B)"
locale currying
  fixes
    A1 :: "'a1 => 'a1 => 'a1"
      (infixr \<open>\<cdot>\<^sub>A\<^sub>1\<close> 55)
    and
    A2 :: "'a2 => 'a2 => 'a2"
      (infixr \<open>\<cdot>\<^sub>A\<^sub>2\<close> 55)
    and B :: "'b => 'b => 'b"  (infixr \<open>\<cdot>\<^sub>B\<close> 55)
  assumes
    "currying (\<cdot>\<^sub>A\<^sub>1) (\<cdot>\<^sub>A\<^sub>2)
      (\<cdot>\<^sub>B)"
locale curried_functor
  fixes
    A1 :: "'a1 => 'a1 => 'a1"
      (infixr \<open>\<cdot>\<^sub>A\<^sub>1\<close> 55)
    and
    A2 :: "'a2 => 'a2 => 'a2"
      (infixr \<open>\<cdot>\<^sub>A\<^sub>2\<close> 55)
    and B :: "'b => 'b => 'b"  (infixr \<open>\<cdot>\<^sub>B\<close> 55)
    and F :: "'a1 * 'a2 => 'b"
  assumes
    "curried_functor (\<cdot>\<^sub>A\<^sub>1) (\<cdot>\<^sub>A\<^sub>2)
      (\<cdot>\<^sub>B) F"
locale curried_functor'
  fixes
    A1 :: "'a1 => 'a1 => 'a1"
      (infixr \<open>\<cdot>\<^sub>A\<^sub>1\<close> 55)
    and
    A2 :: "'a2 => 'a2 => 'a2"
      (infixr \<open>\<cdot>\<^sub>A\<^sub>2\<close> 55)
    and B :: "'b => 'b => 'b"  (infixr \<open>\<cdot>\<^sub>B\<close> 55)
    and F :: "'a1 * 'a2 => 'b"
  assumes
    "curried_functor' (\<cdot>\<^sub>A\<^sub>1) (\<cdot>\<^sub>A\<^sub>2)
      (\<cdot>\<^sub>B) F"
### theory "Category3.FunctorCategory"
### 5.464s elapsed time, 5.928s cpu time, 0.628s GC time
Loading theory "Category3.Yoneda" (required by "Draft.BicategoryMoreTemplates" via "Draft.Bicategory" via "Draft.Prebicategory" via "Category3.EquivalenceOfCategories" via "Category3.Adjunction")
locale hom_functor
  fixes C :: "'c => 'c => 'c"  (infixr \<open>\<cdot>\<close> 55)
    and S :: "'s => 's => 's"  (infixr \<open>\<cdot>\<^sub>S\<close> 55)
    and \<phi> :: "'c * 'c => 'c => 's"
  assumes "hom_functor (\<cdot>) (\<cdot>\<^sub>S) \<phi>"
locale hom_functor
  fixes C :: "'c => 'c => 'c"  (infixr \<open>\<cdot>\<close> 55)
    and S :: "'s => 's => 's"  (infixr \<open>\<cdot>\<^sub>S\<close> 55)
    and \<phi> :: "'c * 'c => 'c => 's"
  assumes "hom_functor (\<cdot>) (\<cdot>\<^sub>S) \<phi>"
locale category
  fixes C :: "'a => 'a => 'a"  (infixr \<open>\<cdot>\<close> 55)
  assumes "category (\<cdot>)"
locale set_valued_functor
  fixes C :: "'c => 'c => 'c"
    and S :: "'s => 's => 's"
    and F :: "'c => 's"
  assumes "set_valued_functor C S F"
locale set_valued_transformation
  fixes C :: "'c => 'c => 'c"
    and S :: "'s => 's => 's"
    and F :: "'c => 's"
    and G :: "'c => 's"
    and \<tau> :: "'c => 's"
  assumes "set_valued_transformation C S F G \<tau>"
locale yoneda_functor
  fixes C :: "'c => 'c => 'c"  (infixr \<open>\<cdot>\<close> 55)
    and S :: "'s => 's => 's"  (infixr \<open>\<cdot>\<^sub>S\<close> 55)
    and \<phi> :: "'c * 'c => 'c => 's"
  assumes "yoneda_functor (\<cdot>) (\<cdot>\<^sub>S) \<phi>"
locale yoneda_functor_fixed_object
  fixes C :: "'c => 'c => 'c"  (infixr \<open>\<cdot>\<close> 55)
    and S :: "'s => 's => 's"  (infixr \<open>\<cdot>\<^sub>S\<close> 55)
    and \<phi> :: "'c * 'c => 'c => 's"
    and a :: "'c"
  assumes "yoneda_functor_fixed_object (\<cdot>) (\<cdot>\<^sub>S) \<phi> a"
locale yoneda_lemma
  fixes C :: "'c => 'c => 'c"  (infixr \<open>\<cdot>\<close> 55)
    and S :: "'s => 's => 's"  (infixr \<open>\<cdot>\<^sub>S\<close> 55)
    and \<phi> :: "'c * 'c => 'c => 's"
    and F :: "'c => 's"
    and a :: "'c"
  assumes "yoneda_lemma (\<cdot>) (\<cdot>\<^sub>S) \<phi> F a"
locale yoneda_lemma_fixed_e
  fixes C :: "'c => 'c => 'c"  (infixr \<open>\<cdot>\<close> 55)
    and S :: "'s => 's => 's"  (infixr \<open>\<cdot>\<^sub>S\<close> 55)
    and \<phi> :: "'c * 'c => 'c => 's"
    and F :: "'c => 's"
    and a :: "'c"
    and e :: "'s"
  assumes "yoneda_lemma_fixed_e (\<cdot>) (\<cdot>\<^sub>S) \<phi> F a e"
locale yoneda_lemma_fixed_\<tau>
  fixes C :: "'c => 'c => 'c"  (infixr \<open>\<cdot>\<close> 55)
    and S :: "'s => 's => 's"  (infixr \<open>\<cdot>\<^sub>S\<close> 55)
    and \<phi> :: "'c * 'c => 'c => 's"
    and F :: "'c => 's"
    and a :: "'c"
    and \<tau> :: "'c => 's"
  assumes
    "yoneda_lemma_fixed_\<tau> (\<cdot>) (\<cdot>\<^sub>S) \<phi> F a
      \<tau>"
locale yoneda_lemma
  fixes C :: "'c => 'c => 'c"  (infixr \<open>\<cdot>\<close> 55)
    and S :: "'s => 's => 's"  (infixr \<open>\<cdot>\<^sub>S\<close> 55)
    and \<phi> :: "'c * 'c => 'c => 's"
    and F :: "'c => 's"
    and a :: "'c"
  assumes "yoneda_lemma (\<cdot>) (\<cdot>\<^sub>S) \<phi> F a"
locale yoneda_lemma_for_hom
  fixes C :: "'c => 'c => 'c"  (infixr \<open>\<cdot>\<close> 55)
    and S :: "'s => 's => 's"  (infixr \<open>\<cdot>\<^sub>S\<close> 55)
    and \<phi> :: "'c * 'c => 'c => 's"
    and F :: "'c => 's"
    and a :: "'c"
    and a' :: "'c"
  assumes "yoneda_lemma_for_hom (\<cdot>) (\<cdot>\<^sub>S) \<phi> a a'"
locale yoneda_functor
  fixes C :: "'c => 'c => 'c"  (infixr \<open>\<cdot>\<close> 55)
    and S :: "'s => 's => 's"  (infixr \<open>\<cdot>\<^sub>S\<close> 55)
    and \<phi> :: "'c * 'c => 'c => 's"
  assumes "yoneda_functor (\<cdot>) (\<cdot>\<^sub>S) \<phi>"
### theory "Category3.Yoneda"
### 10.228s elapsed time, 11.432s cpu time, 1.626s GC time
Loading theory "Category3.Adjunction" (required by "Draft.BicategoryMoreTemplates" via "Draft.Bicategory" via "Draft.Prebicategory" via "Category3.EquivalenceOfCategories")
locale arrow_from_functor
  fixes D :: "'d => 'd => 'd"  (infixr \<open>\<cdot>\<^sub>D\<close> 55)
    and C :: "'c => 'c => 'c"  (infixr \<open>\<cdot>\<^sub>C\<close> 55)
    and F :: "'d => 'c"
    and x :: "'d"
    and y :: "'c"
    and e :: "'c"
  assumes "arrow_from_functor (\<cdot>\<^sub>D) (\<cdot>\<^sub>C) F x y e"
locale terminal_arrow_from_functor
  fixes D :: "'d => 'd => 'd"  (infixr \<open>\<cdot>\<^sub>D\<close> 55)
    and C :: "'c => 'c => 'c"  (infixr \<open>\<cdot>\<^sub>C\<close> 55)
    and F :: "'d => 'c"
    and x :: "'d"
    and y :: "'c"
    and e :: "'c"
  assumes
    "terminal_arrow_from_functor (\<cdot>\<^sub>D) (\<cdot>\<^sub>C) F x y
      e"
locale left_adjoint_functor
  fixes D :: "'d => 'd => 'd"  (infixr \<open>\<cdot>\<^sub>D\<close> 55)
    and C :: "'c => 'c => 'c"  (infixr \<open>\<cdot>\<^sub>C\<close> 55)
    and F :: "'d => 'c"
  assumes "left_adjoint_functor (\<cdot>\<^sub>D) (\<cdot>\<^sub>C) F"
locale arrow_to_functor
  fixes C :: "'c => 'c => 'c"  (infixr \<open>\<cdot>\<^sub>C\<close> 55)
    and D :: "'d => 'd => 'd"  (infixr \<open>\<cdot>\<^sub>D\<close> 55)
    and G :: "'c => 'd"
    and x :: "'d"
    and y :: "'c"
    and e :: "'d"
  assumes "arrow_to_functor (\<cdot>\<^sub>C) (\<cdot>\<^sub>D) G x y e"
locale initial_arrow_to_functor
  fixes C :: "'c => 'c => 'c"  (infixr \<open>\<cdot>\<^sub>C\<close> 55)
    and D :: "'d => 'd => 'd"  (infixr \<open>\<cdot>\<^sub>D\<close> 55)
    and G :: "'c => 'd"
    and x :: "'d"
    and y :: "'c"
    and e :: "'d"
  assumes
    "initial_arrow_to_functor (\<cdot>\<^sub>C) (\<cdot>\<^sub>D) G x y e"
locale right_adjoint_functor
  fixes C :: "'c => 'c => 'c"  (infixr \<open>\<cdot>\<^sub>C\<close> 55)
    and D :: "'d => 'd => 'd"  (infixr \<open>\<cdot>\<^sub>D\<close> 55)
    and G :: "'c => 'd"
  assumes "right_adjoint_functor (\<cdot>\<^sub>C) (\<cdot>\<^sub>D) G"
locale meta_adjunction
  fixes C :: "'c => 'c => 'c"  (infixr \<open>\<cdot>\<^sub>C\<close> 55)
    and D :: "'d => 'd => 'd"  (infixr \<open>\<cdot>\<^sub>D\<close> 55)
    and F :: "'d => 'c"
    and G :: "'c => 'd"
    and \<phi> :: "'d => 'c => 'd"
    and \<psi> :: "'c => 'd => 'c"
  assumes
    "meta_adjunction (\<cdot>\<^sub>C) (\<cdot>\<^sub>D) F G \<phi> \<psi>"
locale hom_adjunction
  fixes C :: "'c => 'c => 'c"  (infixr \<open>\<cdot>\<^sub>C\<close> 55)
    and D :: "'d => 'd => 'd"  (infixr \<open>\<cdot>\<^sub>D\<close> 55)
    and S :: "'s => 's => 's"  (infixr \<open>\<cdot>\<^sub>S\<close> 55)
    and \<phi>C :: "'c * 'c => 'c => 's"
    and \<phi>D :: "'d * 'd => 'd => 's"
    and F :: "'d => 'c"
    and G :: "'c => 'd"
    and \<Phi> :: "'d * 'c => 's"
    and \<Psi> :: "'d * 'c => 's"
  assumes
    "hom_adjunction (\<cdot>\<^sub>C) (\<cdot>\<^sub>D) (\<cdot>\<^sub>S)
      \<phi>C \<phi>D F G \<Phi> \<Psi>"
locale unit_counit_adjunction
  fixes C :: "'c => 'c => 'c"  (infixr \<open>\<cdot>\<^sub>C\<close> 55)
    and D :: "'d => 'd => 'd"  (infixr \<open>\<cdot>\<^sub>D\<close> 55)
    and F :: "'d => 'c"
    and G :: "'c => 'd"
    and \<eta> :: "'d => 'd"
    and \<epsilon> :: "'c => 'c"
  assumes
    "unit_counit_adjunction (\<cdot>\<^sub>C) (\<cdot>\<^sub>D) F G \<eta>
      \<epsilon>"
locale adjunction
  fixes C :: "'c => 'c => 'c"  (infixr \<open>\<cdot>\<^sub>C\<close> 55)
    and D :: "'d => 'd => 'd"  (infixr \<open>\<cdot>\<^sub>D\<close> 55)
    and S :: "'s => 's => 's"  (infixr \<open>\<cdot>\<^sub>S\<close> 55)
    and \<phi>C :: "'c * 'c => 'c => 's"
    and \<phi>D :: "'d * 'd => 'd => 's"
    and F :: "'d => 'c"
    and G :: "'c => 'd"
    and \<phi> :: "'d => 'c => 'd"
    and \<psi> :: "'c => 'd => 'c"
    and \<eta> :: "'d => 'd"
    and \<epsilon> :: "'c => 'c"
    and \<Phi> :: "'d * 'c => 's"
    and \<Psi> :: "'d * 'c => 's"
  assumes
    "adjunction (\<cdot>\<^sub>C) (\<cdot>\<^sub>D) (\<cdot>\<^sub>S)
      \<phi>C \<phi>D F G \<phi> \<psi> \<eta> \<epsilon> \<Phi> \<Psi>"
locale meta_adjunction
  fixes C :: "'c => 'c => 'c"  (infixr \<open>\<cdot>\<^sub>C\<close> 55)
    and D :: "'d => 'd => 'd"  (infixr \<open>\<cdot>\<^sub>D\<close> 55)
    and F :: "'d => 'c"
    and G :: "'c => 'd"
    and \<phi> :: "'d => 'c => 'd"
    and \<psi> :: "'c => 'd => 'c"
  assumes
    "meta_adjunction (\<cdot>\<^sub>C) (\<cdot>\<^sub>D) F G \<phi> \<psi>"
locale meta_adjunction
  fixes C :: "'c => 'c => 'c"  (infixr \<open>\<cdot>\<^sub>C\<close> 55)
    and D :: "'d => 'd => 'd"  (infixr \<open>\<cdot>\<^sub>D\<close> 55)
    and F :: "'d => 'c"
    and G :: "'c => 'd"
    and \<phi> :: "'d => 'c => 'd"
    and \<psi> :: "'c => 'd => 'c"
  assumes
    "meta_adjunction (\<cdot>\<^sub>C) (\<cdot>\<^sub>D) F G \<phi> \<psi>"
locale unit_counit_adjunction
  fixes C :: "'c => 'c => 'c"  (infixr \<open>\<cdot>\<^sub>C\<close> 55)
    and D :: "'d => 'd => 'd"  (infixr \<open>\<cdot>\<^sub>D\<close> 55)
    and F :: "'d => 'c"
    and G :: "'c => 'd"
    and \<eta> :: "'d => 'd"
    and \<epsilon> :: "'c => 'c"
  assumes
    "unit_counit_adjunction (\<cdot>\<^sub>C) (\<cdot>\<^sub>D) F G \<eta>
      \<epsilon>"
locale left_adjoint_functor
  fixes D :: "'d => 'd => 'd"  (infixr \<open>\<cdot>\<^sub>D\<close> 55)
    and C :: "'c => 'c => 'c"  (infixr \<open>\<cdot>\<^sub>C\<close> 55)
    and F :: "'d => 'c"
  assumes "left_adjoint_functor (\<cdot>\<^sub>D) (\<cdot>\<^sub>C) F"
locale right_adjoint_functor
  fixes C :: "'c => 'c => 'c"  (infixr \<open>\<cdot>\<^sub>C\<close> 55)
    and D :: "'d => 'd => 'd"  (infixr \<open>\<cdot>\<^sub>D\<close> 55)
    and G :: "'c => 'd"
  assumes "right_adjoint_functor (\<cdot>\<^sub>C) (\<cdot>\<^sub>D) G"
locale meta_adjunction
  fixes C :: "'c => 'c => 'c"  (infixr \<open>\<cdot>\<^sub>C\<close> 55)
    and D :: "'d => 'd => 'd"  (infixr \<open>\<cdot>\<^sub>D\<close> 55)
    and F :: "'d => 'c"
    and G :: "'c => 'd"
    and \<phi> :: "'d => 'c => 'd"
    and \<psi> :: "'c => 'd => 'c"
  assumes
    "meta_adjunction (\<cdot>\<^sub>C) (\<cdot>\<^sub>D) F G \<phi> \<psi>"
locale hom_adjunction
  fixes C :: "'c => 'c => 'c"  (infixr \<open>\<cdot>\<^sub>C\<close> 55)
    and D :: "'d => 'd => 'd"  (infixr \<open>\<cdot>\<^sub>D\<close> 55)
    and S :: "'s => 's => 's"  (infixr \<open>\<cdot>\<^sub>S\<close> 55)
    and \<phi>C :: "'c * 'c => 'c => 's"
    and \<phi>D :: "'d * 'd => 'd => 's"
    and F :: "'d => 'c"
    and G :: "'c => 'd"
    and \<Phi> :: "'d * 'c => 's"
    and \<Psi> :: "'d * 'c => 's"
  assumes
    "hom_adjunction (\<cdot>\<^sub>C) (\<cdot>\<^sub>D) (\<cdot>\<^sub>S)
      \<phi>C \<phi>D F G \<Phi> \<Psi>"
locale meta_adjunction
  fixes C :: "'c => 'c => 'c"  (infixr \<open>\<cdot>\<^sub>C\<close> 55)
    and D :: "'d => 'd => 'd"  (infixr \<open>\<cdot>\<^sub>D\<close> 55)
    and F :: "'d => 'c"
    and G :: "'c => 'd"
    and \<phi> :: "'d => 'c => 'd"
    and \<psi> :: "'c => 'd => 'c"
  assumes
    "meta_adjunction (\<cdot>\<^sub>C) (\<cdot>\<^sub>D) F G \<phi> \<psi>"
locale unit_counit_adjunction
  fixes C :: "'c => 'c => 'c"  (infixr \<open>\<cdot>\<^sub>C\<close> 55)
    and D :: "'d => 'd => 'd"  (infixr \<open>\<cdot>\<^sub>D\<close> 55)
    and F :: "'d => 'c"
    and G :: "'c => 'd"
    and \<eta> :: "'d => 'd"
    and \<epsilon> :: "'c => 'c"
  assumes
    "unit_counit_adjunction (\<cdot>\<^sub>C) (\<cdot>\<^sub>D) F G \<eta>
      \<epsilon>"
locale hom_adjunction
  fixes C :: "'c => 'c => 'c"  (infixr \<open>\<cdot>\<^sub>C\<close> 55)
    and D :: "'d => 'd => 'd"  (infixr \<open>\<cdot>\<^sub>D\<close> 55)
    and S :: "'s => 's => 's"  (infixr \<open>\<cdot>\<^sub>S\<close> 55)
    and \<phi>C :: "'c * 'c => 'c => 's"
    and \<phi>D :: "'d * 'd => 'd => 's"
    and F :: "'d => 'c"
    and G :: "'c => 'd"
    and \<Phi> :: "'d * 'c => 's"
    and \<Psi> :: "'d * 'c => 's"
  assumes
    "hom_adjunction (\<cdot>\<^sub>C) (\<cdot>\<^sub>D) (\<cdot>\<^sub>S)
      \<phi>C \<phi>D F G \<Phi> \<Psi>"
locale left_adjoint_functor
  fixes D :: "'d => 'd => 'd"  (infixr \<open>\<cdot>\<^sub>D\<close> 55)
    and C :: "'c => 'c => 'c"  (infixr \<open>\<cdot>\<^sub>C\<close> 55)
    and F :: "'d => 'c"
  assumes "left_adjoint_functor (\<cdot>\<^sub>D) (\<cdot>\<^sub>C) F"
locale right_adjoint_functor
  fixes C :: "'c => 'c => 'c"  (infixr \<open>\<cdot>\<^sub>C\<close> 55)
    and D :: "'d => 'd => 'd"  (infixr \<open>\<cdot>\<^sub>D\<close> 55)
    and G :: "'c => 'd"
  assumes "right_adjoint_functor (\<cdot>\<^sub>C) (\<cdot>\<^sub>D) G"
locale inverse_functors
  fixes A :: "'a => 'a => 'a"  (infixr \<open>\<cdot>\<^sub>A\<close> 55)
    and B :: "'b => 'b => 'b"  (infixr \<open>\<cdot>\<^sub>B\<close> 55)
    and F :: "'b => 'a"
    and G :: "'a => 'b"
  assumes "inverse_functors (\<cdot>\<^sub>A) (\<cdot>\<^sub>B) F G"
locale composite_adjunction
  fixes A :: "'a => 'a => 'a"  (infixr \<open>\<cdot>\<^sub>A\<close> 55)
    and B :: "'b => 'b => 'b"  (infixr \<open>\<cdot>\<^sub>B\<close> 55)
    and C :: "'c => 'c => 'c"  (infixr \<open>\<cdot>\<^sub>C\<close> 55)
    and F :: "'b => 'a"
    and G :: "'a => 'b"
    and F' :: "'c => 'b"
    and G' :: "'b => 'c"
    and \<phi> :: "'b => 'a => 'b"
    and \<psi> :: "'a => 'b => 'a"
    and \<phi>' :: "'c => 'b => 'c"
    and \<psi>' :: "'b => 'c => 'b"
  assumes
    "composite_adjunction (\<cdot>\<^sub>A) (\<cdot>\<^sub>B)
      (\<cdot>\<^sub>C) F G F' G' \<phi> \<psi> \<phi>' \<psi>'"
### theory "Category3.Adjunction"
### 22.855s elapsed time, 28.296s cpu time, 7.496s GC time
Loading theory "Category3.EquivalenceOfCategories" (required by "Draft.BicategoryMoreTemplates" via "Draft.Bicategory" via "Draft.Prebicategory")
locale equivalence_of_categories
  fixes C :: "'c => 'c => 'c"  (infixr \<open>\<cdot>\<^sub>C\<close> 55)
    and D :: "'d => 'd => 'd"  (infixr \<open>\<cdot>\<^sub>D\<close> 55)
    and F :: "'d => 'c"
    and G :: "'c => 'd"
    and \<eta> :: "'d => 'd"
    and \<epsilon> :: "'c => 'c"
  assumes
    "equivalence_of_categories (\<cdot>\<^sub>C) (\<cdot>\<^sub>D) F G
      \<eta> \<epsilon>"
locale equivalence_of_categories
  fixes C :: "'c => 'c => 'c"  (infixr \<open>\<cdot>\<^sub>C\<close> 55)
    and D :: "'d => 'd => 'd"  (infixr \<open>\<cdot>\<^sub>D\<close> 55)
    and F :: "'d => 'c"
    and G :: "'c => 'd"
    and \<eta> :: "'d => 'd"
    and \<epsilon> :: "'c => 'c"
  assumes
    "equivalence_of_categories (\<cdot>\<^sub>C) (\<cdot>\<^sub>D) F G
      \<eta> \<epsilon>"
locale equivalence_functor
  fixes C :: "'c => 'c => 'c"  (infixr \<open>\<cdot>\<^sub>C\<close> 55)
    and D :: "'d => 'd => 'd"  (infixr \<open>\<cdot>\<^sub>D\<close> 55)
    and G :: "'c => 'd"
  assumes "equivalence_functor (\<cdot>\<^sub>C) (\<cdot>\<^sub>D) G"
locale endofunctor
  fixes A :: "'a => 'a => 'a"  (infixr \<open>\<cdot>\<close> 55)
    and F :: "'a => 'a"
  assumes "endofunctor (\<cdot>) F"
locale adjoint_equivalence
  fixes C :: "'c => 'c => 'c"  (infixr \<open>\<cdot>\<^sub>C\<close> 55)
    and D :: "'d => 'd => 'd"  (infixr \<open>\<cdot>\<^sub>D\<close> 55)
    and F :: "'d => 'c"
    and G :: "'c => 'd"
    and \<eta> :: "'d => 'd"
    and \<epsilon> :: "'c => 'c"
  assumes
    "adjoint_equivalence (\<cdot>\<^sub>C) (\<cdot>\<^sub>D) F G \<eta>
      \<epsilon>"
locale adjoint_equivalence
  fixes C :: "'c => 'c => 'c"  (infixr \<open>\<cdot>\<^sub>C\<close> 55)
    and D :: "'d => 'd => 'd"  (infixr \<open>\<cdot>\<^sub>D\<close> 55)
    and F :: "'d => 'c"
    and G :: "'c => 'd"
    and \<eta> :: "'d => 'd"
    and \<epsilon> :: "'c => 'c"
  assumes
    "adjoint_equivalence (\<cdot>\<^sub>C) (\<cdot>\<^sub>D) F G \<eta>
      \<epsilon>"
locale fully_faithful_and_essentially_surjective_functor
  fixes C :: "'c => 'c => 'c"  (infixr \<open>\<cdot>\<^sub>C\<close> 55)
    and D :: "'d => 'd => 'd"  (infixr \<open>\<cdot>\<^sub>D\<close> 55)
    and F :: "'c => 'd"
  assumes
    "fully_faithful_and_essentially_surjective_functor (\<cdot>\<^sub>C)
      (\<cdot>\<^sub>D) F"
locale equivalence_of_categories
  fixes C :: "'c => 'c => 'c"  (infixr \<open>\<cdot>\<^sub>C\<close> 55)
    and D :: "'d => 'd => 'd"  (infixr \<open>\<cdot>\<^sub>D\<close> 55)
    and F :: "'d => 'c"
    and G :: "'c => 'd"
    and \<eta> :: "'d => 'd"
    and \<epsilon> :: "'c => 'c"
  assumes
    "equivalence_of_categories (\<cdot>\<^sub>C) (\<cdot>\<^sub>D) F G
      \<eta> \<epsilon>"
### theory "Category3.EquivalenceOfCategories"
### 1.557s elapsed time, 1.701s cpu time, 0.200s GC time
Loading theory "Draft.Prebicategory" (required by "Draft.BicategoryMoreTemplates" via "Draft.Bicategory")
Loading theory "MonoidalCategory.MonoidalCategory" (required by "Draft.BicategoryMoreTemplates" via "Draft.Bicategory")
locale binary_endofunctor
  fixes C :: "'a => 'a => 'a"  (infixr \<open>\<cdot>\<close> 55)
    and T :: "'a * 'a => 'a"
  assumes "binary_endofunctor (\<cdot>) T"
locale weak_composition
  fixes V :: "'a => 'a => 'a"  (infixr \<open>\<cdot>\<close> 55)
    and H :: "'a => 'a => 'a"  (infixr \<open>\<star>\<close> 53)
  assumes "weak_composition (\<cdot>) (\<star>)"
locale monoidal_category
  fixes C :: "'a => 'a => 'a"  (infixr \<open>\<cdot>\<close> 55)
    and T :: "'a * 'a => 'a"
    and \<alpha> :: "'a * 'a * 'a => 'a"
    and \<iota> :: "'a"
  assumes "monoidal_category (\<cdot>) T \<alpha> \<iota>"
locale extended_monoidal_category
  fixes C :: "'a => 'a => 'a"  (infixr \<open>\<cdot>\<close> 55)
    and T :: "'a * 'a => 'a"
    and \<alpha> :: "'a * 'a * 'a => 'a"
    and \<iota> :: "'a"
  assumes "extended_monoidal_category (\<cdot>) T \<alpha> \<iota>"
locale monoidal_category
  fixes C :: "'a => 'a => 'a"  (infixr \<open>\<cdot>\<close> 55)
    and T :: "'a * 'a => 'a"
    and \<alpha> :: "'a * 'a * 'a => 'a"
    and \<iota> :: "'a"
  assumes "monoidal_category (\<cdot>) T \<alpha> \<iota>"
locale left_hom
  fixes V :: "'a => 'a => 'a"  (infixr \<open>\<cdot>\<close> 55)
    and H :: "'a => 'a => 'a"  (infixr \<open>\<star>\<close> 53)
    and \<omega> :: "'a"
  assumes "left_hom (\<cdot>) (\<star>) \<omega>"
locale monoidal_category
  fixes C :: "'a => 'a => 'a"  (infixr \<open>\<cdot>\<close> 55)
    and T :: "'a * 'a => 'a"
    and \<alpha> :: "'a * 'a * 'a => 'a"
    and \<iota> :: "'a"
  assumes "monoidal_category (\<cdot>) T \<alpha> \<iota>"
locale monoidal_category_with_alternate_unit
  fixes C :: "'a => 'a => 'a"  (infixr \<open>\<cdot>\<close> 55)
    and T :: "'a * 'a => 'a"
    and \<alpha> :: "'a * 'a * 'a => 'a"
    and \<iota> :: "'a"
    and \<iota>\<^sub>1 :: "'a"
  assumes
    "monoidal_category_with_alternate_unit (\<cdot>) T \<alpha> \<iota>
      \<iota>\<^sub>1"
locale right_hom
  fixes V :: "'a => 'a => 'a"  (infixr \<open>\<cdot>\<close> 55)
    and H :: "'a => 'a => 'a"  (infixr \<open>\<star>\<close> 53)
    and \<omega> :: "'a"
  assumes "right_hom (\<cdot>) (\<star>) \<omega>"
locale elementary_monoidal_category
  fixes C :: "'a => 'a => 'a"  (infixr \<open>\<cdot>\<close> 55)
    and tensor :: "'a => 'a => 'a"  (infixr \<open>\<otimes>\<close> 53)
    and unity :: "'a"  (\<open>\<I>\<close>)
    and lunit :: "'a => 'a"  (\<open>\<l>[_]\<close>)
    and runit :: "'a => 'a"  (\<open>\<r>[_]\<close>)
    and assoc :: "'a => 'a => 'a => 'a"  (\<open>\<a>[_, _, _]\<close>)
  assumes
    "elementary_monoidal_category (\<cdot>) (\<otimes>) \<I> lunit runit
      assoc"
locale monoidal_category
  fixes C :: "'a => 'a => 'a"  (infixr \<open>\<cdot>\<close> 55)
    and T :: "'a * 'a => 'a"
    and \<alpha> :: "'a * 'a * 'a => 'a"
    and \<iota> :: "'a"
  assumes "monoidal_category (\<cdot>) T \<alpha> \<iota>"
locale elementary_monoidal_category
  fixes C :: "'a => 'a => 'a"  (infixr \<open>\<cdot>\<close> 55)
    and tensor :: "'a => 'a => 'a"  (infixr \<open>\<otimes>\<close> 53)
    and unity :: "'a"  (\<open>\<I>\<close>)
    and lunit :: "'a => 'a"  (\<open>\<l>[_]\<close>)
    and runit :: "'a => 'a"  (\<open>\<r>[_]\<close>)
    and assoc :: "'a => 'a => 'a => 'a"  (\<open>\<a>[_, _, _]\<close>)
  assumes
    "elementary_monoidal_category (\<cdot>) (\<otimes>) \<I> lunit runit
      assoc"
locale weak_composition
  fixes V :: "'a => 'a => 'a"  (infixr \<open>\<cdot>\<close> 55)
    and H :: "'a => 'a => 'a"  (infixr \<open>\<star>\<close> 53)
  assumes "weak_composition (\<cdot>) (\<star>)"
locale strict_monoidal_category
  fixes C :: "'a => 'a => 'a"  (infixr \<open>\<cdot>\<close> 55)
    and T :: "'a * 'a => 'a"
    and \<alpha> :: "'a * 'a * 'a => 'a"
    and \<iota> :: "'a"
  assumes "strict_monoidal_category (\<cdot>) T \<alpha> \<iota>"
locale regular_weak_composition
  fixes V :: "'a => 'a => 'a"  (infixr \<open>\<cdot>\<close> 55)
    and H :: "'a => 'a => 'a"  (infixr \<open>\<star>\<close> 53)
  assumes "regular_weak_composition (\<cdot>) (\<star>)"
locale opposite_monoidal_category
  fixes C :: "'a => 'a => 'a"  (infixr \<open>\<cdot>\<close> 55)
    and T\<^sub>C :: "'a * 'a => 'a"
    and \<alpha>\<^sub>C :: "'a * 'a * 'a => 'a"
    and \<iota> :: "'a"
  assumes
    "opposite_monoidal_category (\<cdot>) T\<^sub>C \<alpha>\<^sub>C
      \<iota>"
locale associative_weak_composition
  fixes V :: "'a => 'a => 'a"  (infixr \<open>\<cdot>\<close> 55)
    and H :: "'a => 'a => 'a"  (infixr \<open>\<star>\<close> 53)
    and \<a> :: "'a => 'a => 'a => 'a"  (\<open>\<a>[_, _, _]\<close>)
  assumes "associative_weak_composition (\<cdot>) (\<star>) \<a>"
locale opposite_monoidal_category
  fixes C :: "'a => 'a => 'a"  (infixr \<open>\<cdot>\<close> 55)
    and T\<^sub>C :: "'a * 'a => 'a"
    and \<alpha>\<^sub>C :: "'a * 'a * 'a => 'a"
    and \<iota> :: "'a"
  assumes
    "opposite_monoidal_category (\<cdot>) T\<^sub>C \<alpha>\<^sub>C
      \<iota>"
locale monoidal_language
  fixes C :: "'a => 'a => 'a"  (infixr \<open>\<cdot>\<close> 55)
  assumes "monoidal_language (\<cdot>)"
consts
  Dom :: "'a local.term => 'a local.term"
consts
  Cod :: "'a local.term => 'a local.term"
consts
  Arr :: "'a local.term => bool"
consts
  Ide :: "'a local.term => bool"
consts
  Can :: "'a local.term => bool"
locale right_hom_with_unit
  fixes V :: "'a => 'a => 'a"  (infixr \<open>\<cdot>\<close> 55)
    and H :: "'a => 'a => 'a"  (infixr \<open>\<star>\<close> 53)
    and \<a> :: "'a => 'a => 'a => 'a"  (\<open>\<a>[_, _, _]\<close>)
    and \<iota> :: "'a"
    and a :: "'a"
  assumes "right_hom_with_unit (\<cdot>) (\<star>) \<a> \<iota> a"
consts
  Inv :: "'a local.term => 'a local.term"
Found termination order: "size <*mlex*> {}"
consts
  dim :: "'a local.term => nat"
locale left_hom_with_unit
  fixes V :: "'a => 'a => 'a"  (infixr \<open>\<cdot>\<close> 55)
    and H :: "'a => 'a => 'a"  (infixr \<open>\<star>\<close> 53)
    and \<a> :: "'a => 'a => 'a => 'a"  (\<open>\<a>[_, _, _]\<close>)
    and \<iota> :: "'a"
    and b :: "'a"
  assumes "left_hom_with_unit (\<cdot>) (\<star>) \<a> \<iota> b"
locale prebicategory
  fixes V :: "'a => 'a => 'a"  (infixr \<open>\<cdot>\<close> 55)
    and H :: "'a => 'a => 'a"  (infixr \<open>\<star>\<close> 53)
    and \<a> :: "'a => 'a => 'a => 'a"  (\<open>\<a>[_, _, _]\<close>)
  assumes "prebicategory (\<cdot>) (\<star>) \<a>"
locale prebicategory
  fixes V :: "'a => 'a => 'a"  (infixr \<open>\<cdot>\<close> 55)
    and H :: "'a => 'a => 'a"  (infixr \<open>\<star>\<close> 53)
    and \<a> :: "'a => 'a => 'a => 'a"  (\<open>\<a>[_, _, _]\<close>)
  assumes "prebicategory (\<cdot>) (\<star>) \<a>"
locale horizontal_homs
  fixes V :: "'a => 'a => 'a"  (infixr \<open>\<cdot>\<close> 55)
    and src :: "'a => 'a"
    and trg :: "'a => 'a"
  assumes "horizontal_homs (\<cdot>) src trg"
locale weak_composition_with_homs
  fixes V :: "'a => 'a => 'a"  (infixr \<open>\<cdot>\<close> 55)
    and H :: "'a => 'a => 'a"  (infixr \<open>\<star>\<close> 53)
    and src :: "'a => 'a"
    and trg :: "'a => 'a"
  assumes "weak_composition_with_homs (\<cdot>) (\<star>) src trg"
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
locale prebicategory_with_homs
  fixes V :: "'a => 'a => 'a"  (infixr \<open>\<cdot>\<close> 55)
    and H :: "'a => 'a => 'a"  (infixr \<open>\<star>\<close> 53)
    and \<a> :: "'a => 'a => 'a => 'a"  (\<open>\<a>[_, _, _]\<close>)
    and src :: "'a => 'a"
    and trg :: "'a => 'a"
  assumes "prebicategory_with_homs (\<cdot>) (\<star>) \<a> src trg"
locale prebicategory
  fixes V :: "'a => 'a => 'a"  (infixr \<open>\<cdot>\<close> 55)
    and H :: "'a => 'a => 'a"  (infixr \<open>\<star>\<close> 53)
    and \<a> :: "'a => 'a => 'a => 'a"  (\<open>\<a>[_, _, _]\<close>)
  assumes "prebicategory (\<cdot>) (\<star>) \<a>"
locale prebicategory_with_units
  fixes V :: "'a => 'a => 'a"  (infixr \<open>\<cdot>\<close> 55)
    and H :: "'a => 'a => 'a"  (infixr \<open>\<star>\<close> 53)
    and \<a> :: "'a => 'a => 'a => 'a"  (\<open>\<a>[_, _, _]\<close>)
    and \<i> :: "'a => 'a"  (\<open>\<i>[_]\<close>)
  assumes "prebicategory_with_units (\<cdot>) (\<star>) \<a> \<i>"
locale prebicategory
  fixes V :: "'a => 'a => 'a"  (infixr \<open>\<cdot>\<close> 55)
    and H :: "'a => 'a => 'a"  (infixr \<open>\<star>\<close> 53)
    and \<a> :: "'a => 'a => 'a => 'a"  (\<open>\<a>[_, _, _]\<close>)
  assumes "prebicategory (\<cdot>) (\<star>) \<a>"
locale horizontal_composition
  fixes V :: "'a => 'a => 'a"  (infixr \<open>\<cdot>\<close> 55)
    and H :: "'a => 'a => 'a"  (infixr \<open>\<star>\<close> 53)
    and src :: "'a => 'a"
    and trg :: "'a => 'a"
  assumes "horizontal_composition (\<cdot>) (\<star>) src trg"
### theory "Draft.Prebicategory"
### 54.814s elapsed time, 145.355s cpu time, 78.884s GC time
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
locale evaluation_map
  fixes C :: "'c => 'c => 'c"  (infixr \<open>\<cdot>\<^sub>C\<close> 55)
    and D :: "'d => 'd => 'd"  (infixr \<open>\<cdot>\<close> 55)
    and T :: "'d * 'd => 'd"
    and \<alpha> :: "'d * 'd * 'd => 'd"
    and \<iota> :: "'d"
    and V :: "'c => 'd"
  assumes "evaluation_map (\<cdot>\<^sub>C) (\<cdot>) T \<alpha> \<iota> V"
consts
  eval :: "'c local.term => 'd"
### theory "MonoidalCategory.MonoidalCategory"
### 60.915s elapsed time, 155.701s cpu time, 84.063s GC time
Loading theory "Draft.Bicategory" (required by "Draft.BicategoryMoreTemplates")
locale bicategory
  fixes V :: "'a => 'a => 'a"  (infixr \<open>\<cdot>\<close> 55)
    and H :: "'a => 'a => 'a"  (infixr \<open>\<star>\<close> 53)
    and \<a> :: "'a => 'a => 'a => 'a"  (\<open>\<a>[_, _, _]\<close>)
    and \<i> :: "'a => 'a"  (\<open>\<i>[_]\<close>)
    and src :: "'a => 'a"
    and trg :: "'a => 'a"
  assumes "bicategory (\<cdot>) (\<star>) \<a> \<i> src trg"
locale category_as_bicategory
  fixes C :: "'a => 'a => 'a"  (infixr \<open>\<cdot>\<close> 55)
  assumes "category_as_bicategory (\<cdot>)"
locale monoidal_category
  fixes C :: "'a => 'a => 'a"  (infixr \<open>\<cdot>\<close> 55)
    and T :: "'a * 'a => 'a"
    and \<alpha> :: "'a * 'a * 'a => 'a"
    and \<iota> :: "'a"
  assumes "monoidal_category (\<cdot>) T \<alpha> \<iota>"
locale prebicategory_with_homs
  fixes V :: "'a => 'a => 'a"  (infixr \<open>\<cdot>\<close> 55)
    and H :: "'a => 'a => 'a"  (infixr \<open>\<star>\<close> 53)
    and \<a> :: "'a => 'a => 'a => 'a"  (\<open>\<a>[_, _, _]\<close>)
    and src :: "'a => 'a"
    and trg :: "'a => 'a"
  assumes "prebicategory_with_homs (\<cdot>) (\<star>) \<a> src trg"
locale prebicategory_with_homs_and_units
  fixes V :: "'a => 'a => 'a"  (infixr \<open>\<cdot>\<close> 55)
    and H :: "'a => 'a => 'a"  (infixr \<open>\<star>\<close> 53)
    and \<a> :: "'a => 'a => 'a => 'a"  (\<open>\<a>[_, _, _]\<close>)
    and \<i> :: "'a => 'a"  (\<open>\<i>[_]\<close>)
    and src :: "'a => 'a"
    and trg :: "'a => 'a"
  assumes
    "prebicategory_with_homs_and_units (\<cdot>) (\<star>) \<a> \<i> src
      trg"
locale prebicategory
  fixes V :: "'a => 'a => 'a"  (infixr \<open>\<cdot>\<close> 55)
    and H :: "'a => 'a => 'a"  (infixr \<open>\<star>\<close> 53)
    and \<a> :: "'a => 'a => 'a => 'a"  (\<open>\<a>[_, _, _]\<close>)
  assumes "prebicategory (\<cdot>) (\<star>) \<a>"
locale bicategory
  fixes V :: "'a => 'a => 'a"  (infixr \<open>\<cdot>\<close> 55)
    and H :: "'a => 'a => 'a"  (infixr \<open>\<star>\<close> 53)
    and \<a> :: "'a => 'a => 'a => 'a"  (\<open>\<a>[_, _, _]\<close>)
    and \<i> :: "'a => 'a"  (\<open>\<i>[_]\<close>)
    and src :: "'a => 'a"
    and trg :: "'a => 'a"
  assumes "bicategory (\<cdot>) (\<star>) \<a> \<i> src trg"
locale vertically_discrete_bicategory
  fixes V :: "'a => 'a => 'a"  (infixr \<open>\<cdot>\<close> 55)
    and H :: "'a => 'a => 'a"  (infixr \<open>\<star>\<close> 53)
    and \<a> :: "'a => 'a => 'a => 'a"  (\<open>\<a>[_, _, _]\<close>)
    and \<i> :: "'a => 'a"  (\<open>\<i>[_]\<close>)
    and src :: "'a => 'a"
    and trg :: "'a => 'a"
  assumes
    "vertically_discrete_bicategory (\<cdot>) (\<star>) \<a> \<i> src trg"
locale bicategory
  fixes V :: "'a => 'a => 'a"  (infixr \<open>\<cdot>\<close> 55)
    and H :: "'a => 'a => 'a"  (infixr \<open>\<star>\<close> 53)
    and \<a> :: "'a => 'a => 'a => 'a"  (\<open>\<a>[_, _, _]\<close>)
    and \<i> :: "'a => 'a"  (\<open>\<i>[_]\<close>)
    and src :: "'a => 'a"
    and trg :: "'a => 'a"
  assumes "bicategory (\<cdot>) (\<star>) \<a> \<i> src trg"
locale bicategory
  fixes V :: "'a => 'a => 'a"  (infixr \<open>\<cdot>\<close> 55)
    and H :: "'a => 'a => 'a"  (infixr \<open>\<star>\<close> 53)
    and \<a> :: "'a => 'a => 'a => 'a"  (\<open>\<a>[_, _, _]\<close>)
    and \<i> :: "'a => 'a"  (\<open>\<i>[_]\<close>)
    and src :: "'a => 'a"
    and trg :: "'a => 'a"
  assumes "bicategory (\<cdot>) (\<star>) \<a> \<i> src trg"
locale extended_bicategory
  fixes V :: "'a => 'a => 'a"  (infixr \<open>\<cdot>\<close> 55)
    and H :: "'a => 'a => 'a"  (infixr \<open>\<star>\<close> 53)
    and \<a> :: "'a => 'a => 'a => 'a"  (\<open>\<a>[_, _, _]\<close>)
    and \<i> :: "'a => 'a"  (\<open>\<i>[_]\<close>)
    and src :: "'a => 'a"
    and trg :: "'a => 'a"
  assumes "extended_bicategory (\<cdot>) (\<star>) \<a> \<i> src trg"
### theory "Draft.Bicategory"
### 33.274s elapsed time, 36.064s cpu time, 3.881s GC time
Loading theory "Draft.BicategoryMoreTemplates"
val templateLemmas = []: (string * thm * template) list
### theory "Draft.BicategoryMoreTemplates"
### 0.377s elapsed time, 0.573s cpu time, 0.060s GC time
val it = (): unit
