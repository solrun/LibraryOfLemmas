Loading theory "HOL-Eisbach.Eisbach" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates" via "Draft.PDDL_STRIPS_Checker" via "Draft.PDDL_STRIPS_Semantics" via "Automatic_Refinement.Misc")
Loading theory "Automatic_Refinement.Refine_Util_Bootstrap1" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates" via "Draft.PDDL_STRIPS_Checker" via "Draft.PDDL_STRIPS_Semantics" via "Automatic_Refinement.Refine_Util")
Loading theory "Containers.Equal" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates" via "Draft.PDDL_STRIPS_Checker" via "Containers.Containers")
Loading theory "Containers.Extend_Partial_Order" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates" via "Draft.PDDL_STRIPS_Checker" via "Containers.Containers" via "Containers.Set_Linorder")
signature PARSE_TOOLS =
  sig
    val is_real_val: ('a, 'b) parse_val -> bool
    val name_term: (term, string) parse_val parser
    val parse_term_val: 'a parser -> (term, 'a) parse_val parser
    val parse_thm_val: 'a parser -> (thm, 'a) parse_val parser
    datatype ('a, 'b) parse_val
    = Parse_Val of 'b * ('a -> unit) | Real_Val of 'a
    val parse_val_cases:
       ('a -> 'b) -> ('b, 'a) parse_val -> 'b * ('b -> unit)
    val the_parse_fun: ('a, 'b) parse_val -> 'a -> unit
    val the_parse_val: ('a, 'b) parse_val -> 'b
    val the_real_val: ('a, 'b) parse_val -> 'a
  end
structure Parse_Tools: PARSE_TOOLS
locale equal_base
  fixes equal :: "'a => 'a => bool"
locale Equal.equal
  fixes equal :: "'a => 'a => bool"
  assumes "equal equal"
infix 1 ##
signature BASIC_REFINE_UTIL =
  sig
    val ## : ('a -> 'b) * ('c -> 'd) -> 'a * 'c -> 'b * 'd
    val map_fold: ('a -> 'b -> 'c * 'b) -> 'a list -> 'b -> 'c list * 'b
    val map_option: ('a -> 'b) -> 'a option -> 'b option
    val seq_is_empty: 'a Seq.seq -> bool * 'a Seq.seq
    val split: ('a -> bool) -> 'a list -> 'a list * 'a list
    val split_matching:
       ('a -> 'b -> bool) ->
         'a list -> 'b list -> ('b list * 'b list) option
    val yield_singleton2:
       ('a list -> 'b -> ('c * 'd list) * 'e) -> 'a -> 'b -> ('c * 'd) * 'e
  end
structure Basic_Refine_Util: BASIC_REFINE_UTIL
val map_option = fn: ('a -> 'b) -> 'a option -> 'b option
val split = fn: ('a -> bool) -> 'a list -> 'a list * 'a list
val map_fold = fn: ('a -> 'b -> 'c * 'b) -> 'a list -> 'b -> 'c list * 'b
val split_matching = fn:
   ('a -> 'b -> bool) -> 'a list -> 'b list -> ('b list * 'b list) option
val seq_is_empty = fn: 'a Seq.seq -> bool * 'a Seq.seq
val ## = fn: ('a -> 'b) * ('c -> 'd) -> 'a * 'c -> 'b * 'd
val yield_singleton2 = fn:
   ('a list -> 'b -> ('c * 'd list) * 'e) -> 'a -> 'b -> ('c * 'd) * 'e
### theory "Containers.Equal"
### 0.039s elapsed time, 0.150s cpu time, 0.000s GC time
Loading theory "Containers.Closure_Set" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates" via "Draft.PDDL_STRIPS_Checker" via "Containers.Containers" via "Containers.Mapping_Impl" via "Containers.Set_Impl")
### theory "Automatic_Refinement.Refine_Util_Bootstrap1"
### 0.040s elapsed time, 0.154s cpu time, 0.000s GC time
Loading theory "Automatic_Refinement.Mk_Term_Antiquot" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates" via "Draft.PDDL_STRIPS_Checker" via "Draft.PDDL_STRIPS_Semantics" via "Automatic_Refinement.Refine_Util")
locale equal_base
  fixes equal :: "'a => 'a => bool"
### theory "Containers.Closure_Set"
### 0.038s elapsed time, 0.151s cpu time, 0.000s GC time
Loading theory "Automatic_Refinement.Mpat_Antiquot" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates" via "Draft.PDDL_STRIPS_Checker" via "Draft.PDDL_STRIPS_Semantics" via "Automatic_Refinement.Refine_Util")
signature METHOD_CLOSURE =
  sig
    val apply_method:
       Proof.context ->
         string ->
           term list ->
             thm list list ->
               (Proof.context -> Method.method) list ->
                 Proof.context -> thm list -> context_tactic
    val method:
       binding ->
         (binding * typ option * mixfix) list ->
           binding list ->
             binding list ->
               binding list ->
                 Token.src -> local_theory -> string * local_theory
    val method_cmd:
       binding ->
         (binding * string option * mixfix) list ->
           binding list ->
             binding list ->
               binding list ->
                 Token.src -> local_theory -> string * local_theory
  end
structure Method_Closure: METHOD_CLOSURE
### theory "Containers.Extend_Partial_Order"
### 0.136s elapsed time, 0.523s cpu time, 0.023s GC time
Loading theory "Containers.List_Fusion" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates" via "Draft.PDDL_STRIPS_Checker" via "Containers.Containers" via "Containers.Set_Linorder" via "Containers.Lexicographic_Order")
val mk_term_antiquot = fn:
   Context.generic * Token.T list ->
     string * (Context.generic * Token.T list)
### theory "Automatic_Refinement.Mk_Term_Antiquot"
### 0.114s elapsed time, 0.444s cpu time, 0.023s GC time
Loading theory "Deriving.Comparator" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates" via "Draft.PDDL_STRIPS_Checker" via "Containers.Containers" via "Containers.Collection_Order" via "Deriving.Compare_Instances" via "Deriving.Compare_Generator" via "Deriving.Comparator_Generator")
val mpat_antiquot = fn:
   Context.generic * Token.T list ->
     string * (Context.generic * Token.T list)
### theory "Automatic_Refinement.Mpat_Antiquot"
### 0.113s elapsed time, 0.439s cpu time, 0.023s GC time
Loading theory "Automatic_Refinement.Refine_Util" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates" via "Draft.PDDL_STRIPS_Checker" via "Draft.PDDL_STRIPS_Semantics")
Proofs for inductive predicate(s) "terminates_onp"
  Proving monotonicity ...
structure Eisbach_Rule_Insts: sig end
locale list
  fixes g :: "('a, 's) generator"
### ML warning (line 170 of "~~/src/HOL/Eisbach/match_method.ML"):
### Pattern is not exhaustive.
### ML warning (line 187 of "~~/src/HOL/Eisbach/match_method.ML"):
### Pattern is not exhaustive.
### ML warning (line 309 of "~~/src/HOL/Eisbach/match_method.ML"):
### Pattern is not exhaustive.
signature MATCH_METHOD =
  sig
    val focus_params: Proof.context -> term list
    val focus_schematics: Proof.context -> Envir.tenv
  end
structure Match_Method: MATCH_METHOD
val method_evaluate = fn: Method.text -> Proof.context -> thm list -> tactic
### theory "HOL-Eisbach.Eisbach"
### 0.516s elapsed time, 2.014s cpu time, 0.175s GC time
Loading theory "Deriving.Derive_Manager" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates" via "Draft.PDDL_STRIPS_Checker" via "Draft.Error_Monad_Add" via "Show.Show_Instances" via "Show.Show")
consts
  list_has_next :: "'a list => bool"
### No equation for constructor "[]"
consts
  list_next :: "'a list => 'a * 'a list"
signature DERIVE_MANAGER =
  sig
    val derive: string -> string -> string -> theory -> theory
    val derive_cmd: string -> string -> string -> theory -> theory
    val print_info: theory -> unit
    val register_derive:
       string ->
         string ->
           (string -> string -> theory -> theory) -> theory -> theory
  end
structure Derive_Manager: DERIVE_MANAGER
### theory "Deriving.Derive_Manager"
### 0.057s elapsed time, 0.268s cpu time, 0.000s GC time
Loading theory "Deriving.Generator_Aux" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates" via "Draft.PDDL_STRIPS_Checker" via "Draft.Error_Monad_Add" via "Show.Show_Instances" via "Show.Show")
### ML warning (line 563 of "$AFP/Automatic_Refinement/Lib/Refine_Util.thy"):
### Handler catches all exceptions.
infix 0 THEN_ELSE'
infix 0 THEN_ELSE_COMB'
infix 1 THEN_ALL_NEW_FWD
infix 1 THEN_INTERVAL
infix 2 ORELSE_INTERVAL
infix 3 ->>
type itactic = int -> int -> tactic
type tactic' = int -> tactic
signature BASIC_REFINE_UTIL =
  sig
    val ## : ('a -> 'b) * ('c -> 'd) -> 'a * 'c -> 'b * 'd
    val ->> :
       'a context_parser * ('a * Context.generic -> 'b * Context.generic) ->
         'b context_parser
    val ALL_GOALS_FWD: tactic' -> tactic
    val ALL_GOALS_FWD': tactic' -> tactic'
    val APPEND_LIST': tactic' list -> tactic'
    val CAN': tactic' -> tactic'
    val CASES': (tactic' * tactic) list -> tactic'
    val CONCL_COND': (term -> bool) -> tactic'
    val COND': (term -> bool) -> tactic'
    val IF_EXGOAL: (int -> tactic) -> tactic'
    val INTERVAL_FWD: tactic' -> int -> int -> tactic
    val NTIMES': tactic' -> int -> tactic'
    val ORELSE_INTERVAL: itactic * itactic -> itactic
    val REPEAT': tactic' -> tactic'
    val REPEAT_ALL_NEW_FWD: tactic' -> tactic'
    val REPEAT_DETERM': tactic' -> tactic'
    val RSm: Proof.context -> thm -> thm -> thm
    val SINGLE_INTERVAL: itactic -> tactic'
    val THEN_ALL_NEW_FWD: tactic' * tactic' -> tactic'
    val THEN_ELSE': tactic' * (tactic' * tactic') -> tactic'
    val THEN_ELSE_COMB':
       tactic' * ((tactic' * tactic' -> tactic') * tactic' * tactic') ->
         tactic'
    val THEN_INTERVAL: itactic * itactic -> itactic
    val TRADE: (Proof.context -> tactic') -> Proof.context -> tactic'
    val TRY_SOLVED': tactic' -> tactic'
    val WITH_concl: (term -> tactic') -> tactic'
    val WITH_subgoal: (term -> tactic') -> tactic'
    val elim_all_tac: Proof.context -> thm list -> tactic
    val eqsubst_inst_meth: (Proof.context -> Proof.method) context_parser
    val eqsubst_inst_tac:
       Proof.context ->
         bool ->
           int list ->
             ((indexname * Position.T) * string) list ->
               thm -> int -> tactic
    val fo_resolve_tac: thm list -> Proof.context -> tactic'
    val fo_rtac: thm -> Proof.context -> tactic'
    val has_Var: term -> bool
    val insert_subgoal_tac: cterm -> tactic'
    val insert_subgoals_tac: cterm list -> tactic'
    val is_Abs: term -> bool
    val is_Comb: term -> bool
    val is_TFree: typ -> bool
    val is_def_thm: thm -> bool
    type itactic = int -> int -> tactic
    val map_fold: ('a -> 'b -> 'c * 'b) -> 'a list -> 'b -> 'c list * 'b
    val map_option: ('a -> 'b) -> 'a option -> 'b option
    val prefer_tac: int -> tactic
    val rprem_tac: int -> Proof.context -> tactic'
    val rprems_tac: Proof.context -> tactic'
    val seq_is_empty: 'a Seq.seq -> bool * 'a Seq.seq
    val split: ('a -> bool) -> 'a list -> 'a list * 'a list
    val split_matching:
       ('a -> 'b -> bool) ->
         'a list -> 'b list -> ('b list * 'b list) option
    type tactic' = int -> tactic
    val yield_singleton2:
       ('a list -> 'b -> ('c * 'd list) * 'e) -> 'a -> 'b -> ('c * 'd) * 'e
  end
signature REFINE_UTIL =
  sig
    val ## : ('a -> 'b) * ('c -> 'd) -> 'a * 'c -> 'b * 'd
    val ->> :
       'a context_parser * ('a * Context.generic -> 'b * Context.generic) ->
         'b context_parser
    val ALL_GOALS_FWD: tactic' -> tactic
    val ALL_GOALS_FWD': tactic' -> tactic'
    val APPEND_LIST': tactic' list -> tactic'
    val CAN': tactic' -> tactic'
    val CASES': (tactic' * tactic) list -> tactic'
    val CONCL_COND': (term -> bool) -> tactic'
    val COND': (term -> bool) -> tactic'
    val HOL_concl_conv: (Proof.context -> conv) -> Proof.context -> conv
    val IF_EXGOAL: (int -> tactic) -> tactic'
    val INTERVAL_FWD: tactic' -> int -> int -> tactic
    val NTIMES': tactic' -> int -> tactic'
    val OF_fst: thm list -> thm list -> thm
    val ORELSE_INTERVAL: itactic * itactic -> itactic
    val REPEAT': tactic' -> tactic'
    val REPEAT_ALL_NEW_FWD: tactic' -> tactic'
    val REPEAT_DETERM': tactic' -> tactic'
    val RS_fst: thm -> thm list -> thm
    val RSm: Proof.context -> thm -> thm -> thm
    val SINGLE_INTERVAL: itactic -> tactic'
    val THEN_ALL_NEW_FWD: tactic' * tactic' -> tactic'
    val THEN_ELSE': tactic' * (tactic' * tactic') -> tactic'
    val THEN_ELSE_COMB':
       tactic' * ((tactic' * tactic' -> tactic') * tactic' * tactic') ->
         tactic'
    val THEN_INTERVAL: itactic * itactic -> itactic
    val TRADE: (Proof.context -> tactic') -> Proof.context -> tactic'
    val TRY_SOLVED': tactic' -> tactic'
    val WITH_concl: (term -> tactic') -> tactic'
    val WITH_subgoal: (term -> tactic') -> tactic'
    val abs_def: Proof.context -> thm -> thm
    val anorm_term: term -> term
    val anorm_typ: typ -> typ
    val apply_configs:
       ('a Config.T * 'a) list -> Proof.context -> Proof.context
    val build_res_net: thm list -> (int * thm) Net.net
    val cfg_trace_f_tac_conv: bool Config.T
    val changed_rule: (thm -> thm) -> thm -> thm
    val dest_itselfT: typ -> typ
    val dummify_tvars: term -> term
    val elim_all_tac: Proof.context -> thm list -> tactic
    val eqsubst_inst_meth: (Proof.context -> Proof.method) context_parser
    val eqsubst_inst_tac:
       Proof.context ->
         bool ->
           int list ->
             ((indexname * Position.T) * string) list ->
               thm -> int -> tactic
    val f_tac_conv:
       Proof.context -> (term -> term) -> (Proof.context -> tactic) -> conv
    val fcomb_conv: conv -> conv
    val fix_conv: Proof.context -> conv -> conv
    val fix_left_tuple_from_Ts:
       string -> typ list -> Proof.context -> term * Proof.context
    val fixup_vars: cterm -> thm -> thm
    val fixup_vars_conv: conv -> conv
    val fixup_vars_conv': (Proof.context -> conv) -> Proof.context -> conv
    val fo_matches: theory -> cterm -> term -> bool
    val fo_matchp: theory -> cterm -> term -> term list option
    val fo_resolve_tac: thm list -> Proof.context -> tactic'
    val fo_rtac: thm -> Proof.context -> tactic'
    val fold_binop_left:
       ('a -> 'b * 'a) ->
         ('c -> 'a -> 'b * 'a) ->
           ('b * 'b -> 'b) -> 'c list -> 'a -> 'b * 'a
    val fsub_conv: (Proof.context -> conv) -> Proof.context -> conv
    val ftop_conv: (Proof.context -> conv) -> Proof.context -> conv
    val has_Var: term -> bool
    val import_conv: (Proof.context -> conv) -> Proof.context -> conv
    val import_cterms:
       bool -> cterm list -> Proof.context -> cterm list * Proof.context
    val insert_subgoal_tac: cterm -> tactic'
    val insert_subgoals_tac: cterm list -> tactic'
    val instantiate_tuples:
       Proof.context -> (indexname * typ) list -> thm -> thm
    val instantiate_tuples_from_term_tac: Proof.context -> term -> tactic
    val instantiate_tuples_subgoal_tac: Proof.context -> tactic'
    val is_Abs: term -> bool
    val is_Comb: term -> bool
    val is_TFree: typ -> bool
    val is_def_thm: thm -> bool
    type itactic = int -> int -> tactic
    val ite_conv: conv -> conv -> conv -> conv
    val lambda_tuple: term list -> term -> term
    val list_binop_left: 'a -> ('a * 'a -> 'a) -> 'a list -> 'a
    val list_prodT_left: typ list -> typ
    val map_fold: ('a -> 'b -> 'c * 'b) -> 'a list -> 'b -> 'c list * 'b
    val map_option: ('a -> 'b) -> 'a option -> 'b option
    val mk_compN: int -> term -> term -> term
    val mk_compN1: typ list -> int -> term -> term -> term
    val mk_ltuple: term list -> term
    val monitor_conv: string -> conv -> conv
    val monitor_conv':
       string -> (Proof.context -> conv) -> Proof.context -> conv
    val order_by: ('a * 'a -> order) -> ('b -> 'a) -> 'b list -> 'b list
    val parse_bool_config: string -> bool Config.T -> bool context_parser
    val parse_bool_config':
       string ->
         bool Config.T ->
           Token.T list -> (bool Config.T * bool) * Token.T list
    val parse_paren_list: 'a context_parser -> 'a list context_parser
    val parse_paren_list':
       'a parser -> Token.T list -> 'a list * Token.T list
    val parse_paren_lists: 'a context_parser -> 'a list list context_parser
    val pat_conv: cterm -> (Proof.context -> conv) -> Proof.context -> conv
    val pat_conv':
       cterm -> (string -> Proof.context -> conv) -> Proof.context -> conv
    val prefer_tac: int -> tactic
    val repeat_rule: (thm -> thm) -> thm -> thm
    val rprem_tac: int -> Proof.context -> tactic'
    val rprems_tac: Proof.context -> tactic'
    val seq_is_empty: 'a Seq.seq -> bool * 'a Seq.seq
    val shift_lambda_left: thm -> thm
    val shift_lambda_leftN: int -> thm -> thm
    val split: ('a -> bool) -> 'a list -> 'a list * 'a list
    val split_matching:
       ('a -> 'b -> bool) ->
         'a list -> 'b list -> ('b list * 'b list) option
    val strip_prodT_left: typ -> typ list
    val subsume_sort: ('a -> term) -> theory -> 'a list -> 'a list
    val subsume_sort_gen:
       ('a -> term) -> Context.generic -> 'a list -> 'a list
    type tactic' = int -> tactic
    val trace_conv: conv
    val trade_rule:
       (Proof.context -> thm -> thm) -> Proof.context -> thm -> thm
    val try_rule: (thm -> thm) -> thm -> thm
    val yield_singleton2:
       ('a list -> 'b -> ('c * 'd list) * 'e) -> 'a -> 'b -> ('c * 'd) * 'e
  end
structure Refine_Util: REFINE_UTIL
structure Basic_Refine_Util: BASIC_REFINE_UTIL
val map_option = fn: ('a -> 'b) -> 'a option -> 'b option
val split = fn: ('a -> bool) -> 'a list -> 'a list * 'a list
val REPEAT_DETERM' = fn: tactic' -> tactic'
val RSm = fn: Proof.context -> thm -> thm -> thm
val NTIMES' = fn: tactic' -> int -> tactic'
val fo_resolve_tac = fn: thm list -> Proof.context -> tactic'
val SINGLE_INTERVAL = fn: itactic -> tactic'
val insert_subgoals_tac = fn: cterm list -> tactic'
val insert_subgoal_tac = fn: cterm -> tactic'
val THEN_ALL_NEW_FWD = fn: tactic' * tactic' -> tactic'
val TRY_SOLVED' = fn: tactic' -> tactic'
val INTERVAL_FWD = fn: tactic' -> int -> int -> tactic
val IF_EXGOAL = fn: (int -> tactic) -> tactic'
val eqsubst_inst_tac = fn:
   Proof.context ->
     bool ->
       int list ->
         ((indexname * Position.T) * string) list -> thm -> int -> tactic
val fo_rtac = fn: thm -> Proof.context -> tactic'
val TRADE = fn: (Proof.context -> tactic') -> Proof.context -> tactic'
val is_TFree = fn: typ -> bool
val ALL_GOALS_FWD = fn: tactic' -> tactic
val yield_singleton2 = fn:
   ('a list -> 'b -> ('c * 'd list) * 'e) -> 'a -> 'b -> ('c * 'd) * 'e
val ## = fn: ('a -> 'b) * ('c -> 'd) -> 'a * 'c -> 'b * 'd
val CAN' = fn: tactic' -> tactic'
val WITH_concl = fn: (term -> tactic') -> tactic'
val is_Abs = fn: term -> bool
val COND' = fn: (term -> bool) -> tactic'
val split_matching = fn:
   ('a -> 'b -> bool) -> 'a list -> 'b list -> ('b list * 'b list) option
val REPEAT_ALL_NEW_FWD = fn: tactic' -> tactic'
val CASES' = fn: (tactic' * tactic) list -> tactic'
val APPEND_LIST' = fn: tactic' list -> tactic'
val map_fold = fn: ('a -> 'b -> 'c * 'b) -> 'a list -> 'b -> 'c list * 'b
val is_def_thm = fn: thm -> bool
val THEN_INTERVAL = fn: itactic * itactic -> itactic
val rprems_tac = fn: Proof.context -> tactic'
val WITH_subgoal = fn: (term -> tactic') -> tactic'
val is_Comb = fn: term -> bool
val THEN_ELSE_COMB' = fn:
   tactic' * ((tactic' * tactic' -> tactic') * tactic' * tactic') -> tactic'
val eqsubst_inst_meth = fn: (Proof.context -> Proof.method) context_parser
val elim_all_tac = fn: Proof.context -> thm list -> tactic
val ->> = fn:
   'a context_parser * ('a * Context.generic -> 'b * Context.generic) ->
     'b context_parser
val ALL_GOALS_FWD' = fn: tactic' -> tactic'
val prefer_tac = fn: int -> tactic
val rprem_tac = fn: int -> Proof.context -> tactic'
val has_Var = fn: term -> bool
val REPEAT' = fn: tactic' -> tactic'
val THEN_ELSE' = fn: tactic' * (tactic' * tactic') -> tactic'
val CONCL_COND' = fn: (term -> bool) -> tactic'
val ORELSE_INTERVAL = fn: itactic * itactic -> itactic
val seq_is_empty = fn: 'a Seq.seq -> bool * 'a Seq.seq
### theory "Automatic_Refinement.Refine_Util"
### 0.399s elapsed time, 1.597s cpu time, 0.188s GC time
Loading theory "HOL-Library.AList" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates" via "Draft.PDDL_STRIPS_Checker" via "Containers.Containers" via "Containers.Mapping_Impl" via "Containers.AssocList" via "HOL-Library.DAList")
Found termination order: "{}"
locale comparator
  fixes comp :: "'a => 'a => order"
  assumes "comparator comp"
consts
  update :: "'key => 'val => ('key * 'val) list => ('key * 'val) list"
signature BNF_ACCESS =
  sig
    val bnf_types: Proof.context -> string list -> typ list
    val case_consts: Proof.context -> string list -> term list
    val case_simps: Proof.context -> string list -> thm list list
    val case_thms: Proof.context -> string list -> thm list
    val constr_argument_types:
       Proof.context -> string list -> typ list list list
    val constr_terms: Proof.context -> string -> term list
    val distinct_thms: Proof.context -> string list -> thm list list
    val induct_thms: Proof.context -> string list -> thm list
    val inject_thms: Proof.context -> string list -> thm list list
    val map_comps: Proof.context -> string list -> thm list
    val map_simps: Proof.context -> string list -> thm list list
    val map_terms: Proof.context -> string list -> term list
    val set_simps: Proof.context -> string list -> thm list list
    val set_terms: Proof.context -> string list -> term list list
  end
structure Bnf_Access: BNF_ACCESS
Found termination order: "{}"
signature GENERATOR_AUX =
  sig
    val OF_option: thm -> thm option list -> thm
    val add_used_tycos:
       Proof.context -> string -> string list -> string list
    val alist_to_string: (string * 'a) list -> string
    val conjI_tac:
       thm list ->
         Proof.context ->
           'a list -> (Proof.context -> int -> tactic) -> tactic
    val create_map:
       (typ -> term) ->
         (string * typ -> 'a -> term) ->
           'a ->
             (typ -> bool) ->
               (local_theory -> string -> bool list) ->
                 (local_theory -> string -> term) ->
                   (local_theory -> string -> 'a -> term) ->
                     string list ->
                       (local_theory -> string -> 'a) ->
                         typ -> local_theory -> term
    val create_partial:
       'a ->
         (typ -> bool) ->
           (local_theory -> string -> bool list) ->
             (local_theory -> string -> term) ->
               (local_theory -> string -> 'a -> term) ->
                 string list ->
                   (local_theory -> string -> 'a) ->
                     typ -> local_theory -> term
    val define_overloaded:
       string * term -> local_theory -> thm * local_theory
    val define_overloaded_generic:
       Attrib.binding * term -> local_theory -> thm * local_theory
    val drop_last: 'a list -> 'a list
    val freeify_tvars: typ -> typ
    val ind_case_to_idxs: 'a list list -> int -> int * int
    val infer_type: Proof.context -> term -> term
    val ints_to_subscript: int list -> string
    val is_class_instance: theory -> string -> sort -> bool
    val lambdas: term list -> term -> term
    val mk_case_tac:
       Proof.context ->
         term option list list ->
           thm ->
             (int ->
                Proof.context * thm list * (string * cterm) list -> tactic)
               -> tactic
    val mk_def: typ -> string -> term -> term
    val mk_id: typ -> term
    val mk_infer_const: string -> Proof.context -> term -> term
    val mutual_recursive_types:
       string -> Proof.context -> string list * typ list
    val prove_multi_future:
       Proof.context ->
         string list ->
           term list ->
             term list ->
               ({context: Proof.context, prems: thm list} -> tactic) ->
                 thm list
    val recursor:
       (string -> 'a) * ('a -> bool list) * string list ->
         bool ->
           (typ -> 'b) ->
             (typ -> 'b) ->
               (typ -> 'b) ->
                 ((typ * 'b option) list * 'a -> 'b) -> typ -> 'b
    val rename_types: (typ * typ) list -> term -> term
    val split_IHs:
       (string -> 'a) * ('a -> bool list) * string list ->
         typ list -> thm list -> thm list list
    val std_recursor_tac:
       (string -> 'a) * ('a -> bool list) * string list ->
         typ list ->
           ('a -> thm) ->
             thm list -> typ -> thm list -> Proof.context -> tactic
    val sub: string -> string
    val subT: string -> typ -> string
    val typ_and_vs_of_typname:
       theory -> string -> sort -> typ * (string * sort) list
    val typ_and_vs_of_used_typname:
       string ->
         bool list -> string list -> typ * (string * string list) list
    val type_parameters:
       typ -> Proof.context -> (string * sort) list * typ list
  end
structure Generator_Aux: GENERATOR_AUX
### theory "Deriving.Generator_Aux"
### 0.190s elapsed time, 0.733s cpu time, 0.080s GC time
Loading theory "Deriving.Equality_Generator" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates" via "Draft.PDDL_STRIPS_Checker" via "Containers.Containers" via "Containers.Collection_Eq" via "Deriving.Equality_Instances")
consts
  update_with_aux ::
    "'val
     => 'key => ('val => 'val) => ('key * 'val) list => ('key * 'val) list"
Found termination order: "case_sum (%x. Suc 0) (%x. 0) <*mlex*> {}"
Found termination order: "(%p. size_list size (snd p)) <*mlex*> {}"
### theory "Deriving.Comparator"
### 0.778s elapsed time, 3.096s cpu time, 0.296s GC time
Loading theory "Deriving.Compare" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates" via "Draft.PDDL_STRIPS_Checker" via "Containers.Containers" via "Containers.Collection_Order" via "Deriving.Compare_Instances" via "Deriving.Compare_Generator")
class compare = type +
  fixes compare :: "'a => 'a => order"
  assumes "comparator_compare": "comparator compare"
Proofs for inductive predicate(s) "filter_has_next"
  Proving monotonicity ...
signature EQUALITY_GENERATOR =
  sig
    val ensure_info: equality_type -> string -> local_theory -> local_theory
    datatype equality_type = BNF | EQ
    val generate_equality:
       equality_type -> string -> local_theory -> local_theory
    val generate_equalitys_from_bnf_fp:
       string ->
         local_theory ->
           ((term * thm list) list * (term * thm) list) * local_theory
    val get_info: Proof.context -> string -> info option
    type info =
       {equality: term,
        equality_def: thm option,
        equality_thm: thm,
        map: term,
        map_comp: thm option,
        partial_equality_thm: thm,
        pequality: term, used_positions: bool list}
    val register_equality_of: string -> local_theory -> local_theory
    val register_foreign_equality:
       typ -> term -> thm -> local_theory -> local_theory
    val register_foreign_partial_and_full_equality:
       string ->
         term ->
           term ->
             term ->
               thm option ->
                 thm option ->
                   thm -> thm -> bool list -> local_theory -> local_theory
  end
structure Equality_Generator: EQUALITY_GENERATOR
### theory "Deriving.Equality_Generator"
### 0.485s elapsed time, 1.760s cpu time, 0.587s GC time
Loading theory "Deriving.Comparator_Generator" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates" via "Draft.PDDL_STRIPS_Checker" via "Containers.Containers" via "Containers.Collection_Order" via "Deriving.Compare_Instances" via "Deriving.Compare_Generator")
class compare_order = compare + ord +
  assumes "ord_defs": "le_of_comp compare = (<=)" "lt_of_comp compare = (<)"
### theory "Containers.List_Fusion"
### 1.264s elapsed time, 4.862s cpu time, 0.844s GC time
Loading theory "Deriving.Equality_Instances" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates" via "Draft.PDDL_STRIPS_Checker" via "Containers.Containers" via "Containers.Collection_Eq")
generating equality for type "Sum_Type.sum"
generating equality for type "List.list"
generating equality for type "Product_Type.prod"
generating equality for type "Option.option"
### theory "Deriving.Equality_Instances"
### 0.104s elapsed time, 0.423s cpu time, 0.000s GC time
Loading theory "HOL-Library.Adhoc_Overloading" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates" via "Draft.PDDL_STRIPS_Checker" via "Draft.Error_Monad_Add" via "Certification_Monads.Check_Monad" via "Certification_Monads.Error_Monad" via "HOL-Library.Monad_Syntax")
Found termination order: "size_list size <*mlex*> {}"
signature ADHOC_OVERLOADING =
  sig
    val generic_add_overloaded: string -> Context.generic -> Context.generic
    val generic_add_variant:
       string -> term -> Context.generic -> Context.generic
    val generic_remove_overloaded:
       string -> Context.generic -> Context.generic
    val generic_remove_variant:
       string -> term -> Context.generic -> Context.generic
    val is_overloaded: Proof.context -> string -> bool
    val show_variants: bool Config.T
  end
structure Adhoc_Overloading: ADHOC_OVERLOADING
### theory "HOL-Library.Adhoc_Overloading"
### 0.106s elapsed time, 0.413s cpu time, 0.070s GC time
Loading theory "Certification_Monads.Error_Syntax" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates" via "Draft.PDDL_STRIPS_Checker" via "Draft.Error_Monad_Add" via "Certification_Monads.Check_Monad" via "Certification_Monads.Error_Monad")
### theory "Certification_Monads.Error_Syntax"
### 0.029s elapsed time, 0.111s cpu time, 0.000s GC time
Loading theory "HOL-Library.Monad_Syntax" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates" via "Draft.PDDL_STRIPS_Checker" via "Draft.Error_Monad_Add" via "Certification_Monads.Check_Monad" via "Certification_Monads.Error_Monad")
Found termination order: "(%p. size_list size (snd (snd p))) <*mlex*> {}"
### theory "HOL-Library.Monad_Syntax"
### 0.038s elapsed time, 0.151s cpu time, 0.000s GC time
Loading theory "Certification_Monads.Error_Monad" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates" via "Draft.PDDL_STRIPS_Checker" via "Draft.Error_Monad_Add" via "Certification_Monads.Check_Monad")
class compare_order = compare + linorder +
  assumes "ord_defs": "le_of_comp compare = (<=)" "lt_of_comp compare = (<)"
signature COMPARE_CODE =
  sig
    val change_compare_code:
       term -> string list -> local_theory -> local_theory
  end
structure Compare_Code: COMPARE_CODE
### theory "Deriving.Compare"
### 0.871s elapsed time, 3.293s cpu time, 0.692s GC time
Loading theory "Containers.Containers_Auxiliary" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates" via "Draft.PDDL_STRIPS_Checker" via "Containers.Containers" via "Containers.Set_Linorder")
Found termination order:
  "(%p. size_list size (snd (snd (snd p)))) <*mlex*> {}"
### theory "HOL-Library.AList"
### 1.295s elapsed time, 4.948s cpu time, 0.869s GC time
Loading theory "HOL-Library.DAList" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates" via "Draft.PDDL_STRIPS_Checker" via "Containers.Containers" via "Containers.Mapping_Impl" via "Containers.AssocList")
signature COMPARATOR_GENERATOR =
  sig
    datatype comparator_type = BNF | Linorder
    val ensure_info:
       comparator_type -> string -> local_theory -> local_theory
    val generate_comparator:
       comparator_type -> string -> local_theory -> local_theory
    val generate_comparators_from_bnf_fp:
       string ->
         local_theory ->
           ((term * thm list) list * (term * thm) list) * local_theory
    val get_info: Proof.context -> string -> info option
    type info =
       {comp: term,
        comp_def: thm option,
        comp_thm: thm,
        map: term,
        map_comp: thm option,
        partial_comp_thms: thm list, pcomp: term, used_positions: bool list}
    val register_comparator_of: string -> local_theory -> local_theory
    val register_foreign_comparator:
       typ -> term -> thm -> local_theory -> local_theory
    val register_foreign_partial_and_full_comparator:
       string ->
         term ->
           term ->
             term ->
               thm option ->
                 thm option ->
                   thm ->
                     thm ->
                       thm ->
                         thm -> bool list -> local_theory -> local_theory
  end
structure Comparator_Generator: COMPARATOR_GENERATOR
### theory "Deriving.Comparator_Generator"
### 0.667s elapsed time, 2.623s cpu time, 0.237s GC time
Loading theory "Deriving.Compare_Generator" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates" via "Draft.PDDL_STRIPS_Checker" via "Containers.Containers" via "Containers.Collection_Order" via "Deriving.Compare_Instances")
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
### Dropping global mixfix syntax: "less_eq_prod" (infix \<open>\<sqsubseteq>\<close> 50)
### Dropping global mixfix syntax: "less_prod" (infix \<open>\<sqsubset>\<close> 50)
### Dropping global mixfix syntax: "less_eq_prod'" (infix \<open>\<sqsubseteq>\<close> 50)
Found termination order: "(%p. length (snd (snd p))) <*mlex*> {}"
### Dropping global mixfix syntax: "less_prod'" (infix \<open>\<sqsubset>\<close> 50)
### theory "Containers.Containers_Auxiliary"
### 0.214s elapsed time, 0.846s cpu time, 0.069s GC time
Loading theory "HOL-Library.Cancellation" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates" via "Draft.PDDL_STRIPS_Checker" via "Draft.PDDL_STRIPS_Semantics" via "Automatic_Refinement.Misc" via "HOL-Library.Multiset")
Found termination order: "(%p. length (snd (snd p))) <*mlex*> {}"
instantiation
  alist :: (equal, equal) equal
  equal_alist == equal_class.equal ::
    ('a, 'b) alist => ('a, 'b) alist => bool
instantiation
  alist :: (type, type) size
  size_alist == size :: ('a, 'b) alist => nat
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
signature COMPARE_GENERATOR =
  sig
    val compare_instance:
       Comparator_Generator.comparator_type -> string -> theory -> theory
    val compare_order_instance_via_comparator_of: string -> theory -> theory
    val compare_order_instance_via_compare: string -> theory -> theory
  end
structure Compare_Generator: COMPARE_GENERATOR
### theory "Deriving.Compare_Generator"
### 0.341s elapsed time, 1.351s cpu time, 0.063s GC time
Loading theory "HOL-Library.Char_ord" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates" via "Draft.PDDL_STRIPS_Checker" via "Containers.Containers" via "Containers.Set_Linorder" via "Containers.Lexicographic_Order")
### Additional type variable(s) in specification of "random_aux_alist_rel": 'a, 'b
### Additional type variable(s) in specification of "random_aux_alist_dom": 'a, 'b
instantiation
  char :: linorder
  less_eq_char == less_eq :: char => char => bool
  less_char == less :: char => char => bool
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
instantiation
  char :: distrib_lattice
  inf_char == inf :: char => char => char
  sup_char == sup :: char => char => char
Found termination order: "(%p. nat_of_natural (fst p)) <*mlex*> {}"
instantiation
  alist :: (random, random) random
  random_alist == random_class.random ::
    natural
    => natural * natural
       => (('a, 'b) alist * (unit => term)) * natural * natural
### theory "HOL-Library.Char_ord"
### 0.099s elapsed time, 0.390s cpu time, 0.061s GC time
Loading theory "Containers.Lexicographic_Order" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates" via "Draft.PDDL_STRIPS_Checker" via "Containers.Containers" via "Containers.Set_Linorder")
instantiation
  alist :: (exhaustive, exhaustive) exhaustive
  exhaustive_alist == exhaustive_class.exhaustive ::
    (('a, 'b) alist => (bool * term list) option)
    => natural => (bool * term list) option
signature CANCEL = sig val proc: Proof.context -> cterm -> thm option end
functor Cancel_Fun (Data: CANCEL_NUMERALS_DATA): CANCEL
Found termination order: "size_list size <*mlex*> {}"
signature CANCEL_DATA =
  sig
    val dest_coeff: term -> int * term
    val dest_sum: term -> term list
    val find_first_coeff: term -> term list -> int * term list
    val mk_coeff: int * term -> term
    val mk_sum: typ -> term list -> term
    val norm_ss1: simpset
    val norm_ss2: simpset
    val norm_tac: Proof.context -> tactic
    val numeral_simp_tac: Proof.context -> tactic
    val prove_conv:
       tactic list -> Proof.context -> thm list -> term * term -> thm option
    val simplify_meta_eq: Proof.context -> thm -> thm
    val trans_tac: Proof.context -> thm option -> tactic
  end
structure Cancel_Data: CANCEL_DATA
Found termination order: "(%p. nat_of_natural (snd p)) <*mlex*> {}"
instantiation
  alist :: (full_exhaustive, full_exhaustive) full_exhaustive
  full_exhaustive_alist == full_exhaustive_class.full_exhaustive ::
    (('a, 'b) alist * (unit => term) => (bool * term list) option)
    => natural => (bool * term list) option
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
signature CANCEL_SIMPROCS =
  sig
    val diff_cancel: Proof.context -> cterm -> thm option
    val eq_cancel: Proof.context -> cterm -> thm option
    val less_cancel: Proof.context -> cterm -> thm option
    val less_eq_cancel: Proof.context -> cterm -> thm option
  end
structure Cancel_Simprocs: CANCEL_SIMPROCS
### theory "HOL-Library.Cancellation"
### 0.512s elapsed time, 2.011s cpu time, 0.191s GC time
Loading theory "HOL-Library.Multiset" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates" via "Draft.PDDL_STRIPS_Checker" via "Draft.PDDL_STRIPS_Semantics" via "Automatic_Refinement.Misc")
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
Found termination order: "(%p. nat_of_natural (snd p)) <*mlex*> {}"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
Found termination order: "size_list size <*mlex*> {}"
### theory "Containers.Lexicographic_Order"
### 0.300s elapsed time, 1.183s cpu time, 0.066s GC time
Loading theory "Deriving.Compare_Instances" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates" via "Draft.PDDL_STRIPS_Checker" via "Containers.Containers" via "Containers.Collection_Order")
instantiation
  multiset :: (type) cancel_comm_monoid_add
  zero_multiset == zero_class.zero :: 'a multiset
  minus_multiset == minus :: 'a multiset => 'a multiset => 'a multiset
  plus_multiset == plus :: 'a multiset => 'a multiset => 'a multiset
### theory "HOL-Library.DAList"
### 0.822s elapsed time, 3.240s cpu time, 0.288s GC time
Loading theory "Containers.AssocList" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates" via "Draft.PDDL_STRIPS_Checker" via "Containers.Containers" via "Containers.Mapping_Impl")
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
### theory "Certification_Monads.Error_Monad"
### 1.067s elapsed time, 4.183s cpu time, 0.431s GC time
Loading theory "Certification_Monads.Check_Monad" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates" via "Draft.PDDL_STRIPS_Checker" via "Draft.Error_Monad_Add")
consts
  update_with_aux ::
    "'val
     => 'key => ('val => 'val) => ('key * 'val) list => ('key * 'val) list"
Found termination order: "(%p. size_list size (snd p)) <*mlex*> {}"
deriving "compare_order" instance for type "Int.int"
deriving "compare" instance for type "Int.int"
deriving "compare_order" instance for type "Code_Numeral.integer"
deriving "compare" instance for type "Code_Numeral.integer"
deriving "compare_order" instance for type "Nat.nat"
deriving "compare" instance for type "Nat.nat"
deriving "compare_order" instance for type "String.char"
deriving "compare" instance for type "String.char"
deriving "compare" instance for type "Sum_Type.sum"
generating comparator for type "Sum_Type.sum"
deriving "compare" instance for type "List.list"
generating comparator for type "List.list"
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
deriving "compare" instance for type "Product_Type.prod"
generating comparator for type "Product_Type.prod"
deriving "compare" instance for type "Option.option"
generating comparator for type "Option.option"
Found termination order: "{}"
### theory "Certification_Monads.Check_Monad"
### 0.570s elapsed time, 2.056s cpu time, 0.875s GC time
Loading theory "HOL-Library.Code_Abstract_Nat" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates" via "Draft.PDDL_STRIPS_Checker" via "HOL-Library.Code_Target_Nat")
### theory "Containers.AssocList"
### 0.607s elapsed time, 2.198s cpu time, 0.875s GC time
Loading theory "HOL-Library.Function_Algebras" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
Found termination order: "{}"
instantiation
  fun :: (type, plus) plus
  plus_fun == plus :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  fun :: (type, zero) zero
  zero_fun == zero_class.zero :: 'a => 'b
instantiation
  fun :: (type, times) times
  times_fun == times :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  fun :: (type, one) one
  one_fun == one_class.one :: 'a => 'b
Found termination order: "{}"
### theory "HOL-Library.Code_Abstract_Nat"
### 0.089s elapsed time, 0.341s cpu time, 0.085s GC time
Loading theory "HOL-Library.Code_Target_Nat" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates" via "Draft.PDDL_STRIPS_Checker")
deriving "compare" instance for type "HOL.bool"
deriving "compare" instance for type "Product_Type.unit"
deriving "compare_order" instance for type "HOL.bool"
deriving "compare_order" instance for type "Product_Type.unit"
### theory "Deriving.Compare_Instances"
### 0.807s elapsed time, 2.971s cpu time, 1.056s GC time
Loading theory "HOL-Library.Infinite_Set" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates" via "Draft.PDDL_STRIPS_Checker" via "Draft.PDDL_STRIPS_Semantics" via "Automatic_Refinement.Misc")
### theory "HOL-Library.Function_Algebras"
### 0.141s elapsed time, 0.550s cpu time, 0.085s GC time
Loading theory "HOL-Library.Mapping" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates" via "Draft.PDDL_STRIPS_Checker" via "Containers.Containers" via "Containers.Mapping_Impl")
### Code generator: dropping subsumed code equation
### divmod_nat ?m ?n ==
### if ?n = 0 | ?m < ?n then (0, ?m)
### else let (q, y) = divmod_nat (?m - ?n) ?n in (Suc q, y)
### Code generator: dropping subsumed code equation
### divmod (num.Bit1 ?m) (num.Bit1 ?n) ==
### if ?m < ?n then (0, numeral (num.Bit1 ?m))
### else divmod_step (num.Bit1 ?n)
###       (divmod (num.Bit1 ?m) (num.Bit0 (num.Bit1 ?n)))
### Code generator: dropping subsumed code equation
### divmod (num.Bit0 ?m) (num.Bit1 ?n) ==
### if ?m <= ?n then (0, numeral (num.Bit0 ?m))
### else divmod_step (num.Bit1 ?n)
###       (divmod (num.Bit0 ?m) (num.Bit0 (num.Bit1 ?n)))
### Code generator: dropping subsumed code equation
### divmod (num.Bit1 ?m) (num.Bit0 ?n) ==
### case divmod ?m ?n of (q, r) => (q, 2 * r + 1)
### Code generator: dropping subsumed code equation
### divmod (num.Bit0 ?m) (num.Bit0 ?n) ==
### case divmod ?m ?n of (q, r) => (q, 2 * r)
### Code generator: dropping subsumed code equation
### divmod num.One (num.Bit1 ?n) == (0, Numeral1)
### Code generator: dropping subsumed code equation
### divmod num.One (num.Bit0 ?n) == (0, Numeral1)
### Code generator: dropping subsumed code equation
### divmod ?m num.One == (numeral ?m, 0)
### Code generator: dropping subsumed code equation
### Suc ?m <= ?n == ?m < ?n
### Code generator: dropping subsumed code equation
### 0 <= ?n == True
### Code generator: dropping subsumed code equation
### ?m < Suc ?n == ?m <= ?n
### Code generator: dropping subsumed code equation
### ?n < 0 == False
### Code generator: dropping subsumed code equation
### of_nat ?n == semiring_1_class.of_nat_aux (%i. i + (1::?'a)) ?n (0::?'a)
### theory "HOL-Library.Code_Target_Nat"
### 0.163s elapsed time, 0.637s cpu time, 0.094s GC time
Loading theory "HOL-Library.Nat_Bijection" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.Stream")
### Partially applied constant "Multiset.inter_mset" on left hand side of equation, in theorem:
### semilattice_inf.Inf_fin (\<inter>#) (set (?x # ?xs)) ==
### fold (\<inter>#) ?xs ?x
### Partially applied constant "Multiset.union_mset" on left hand side of equation, in theorem:
### semilattice_sup.Sup_fin (\<union>#) (set (?x # ?xs)) ==
### fold (\<union>#) ?xs ?x
consts
  enumerate :: "'a set => nat => 'a"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
### theory "HOL-Library.Infinite_Set"
### 0.324s elapsed time, 1.273s cpu time, 0.178s GC time
Loading theory "HOL-Library.Old_Datatype" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates" via "Draft.PDDL_STRIPS_Checker" via "Draft.PDDL_STRIPS_Semantics" via "Propositional_Proof_Systems.Formulas" via "HOL-Library.Countable")
Found termination order: "size_list size <*mlex*> {}"
signature MULTISET_SIMPROCS =
  sig
    val subset_cancel_msets: Proof.context -> cterm -> thm option
    val subseteq_cancel_msets: Proof.context -> cterm -> thm option
  end
structure Multiset_Simprocs: MULTISET_SIMPROCS
### theory "HOL-Library.Nat_Bijection"
### 0.366s elapsed time, 1.445s cpu time, 0.176s GC time
Loading theory "HOL-Library.Stream" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates" via "Draft.ExtrEqs")
instantiation
  multiset :: (type) Inf
  Inf_multiset == Inf :: 'a multiset set => 'a multiset
instantiation
  multiset :: (type) Sup
  Sup_multiset == Sup :: 'a multiset set => 'a multiset
instantiation
  mapping :: (type, type) equal
  equal_mapping == equal_class.equal ::
    ('a, 'b) mapping => ('a, 'b) mapping => bool
instantiation
  multiset :: (type) size
  size_multiset == size :: 'a multiset => nat
locale comp_fun_commute
  fixes f :: "'a => 'b => 'b"
  assumes "comp_fun_commute f"
signature OLD_DATATYPE =
  sig
    val check_specs: spec list -> theory -> spec list * Proof.context
    type config = {quiet: bool, strict: bool}
    val default_config: config
    type descr =
       (int * (string * dtyp list * (string * dtyp list) list)) list
    val distinct_lemma: thm
    datatype dtyp
    = DtRec of int | DtTFree of string * sort | DtType of string * dtyp list
    type info =
       {case_cong: thm,
        case_cong_weak: thm,
        case_name: string,
        case_rewrites: thm list,
        descr: descr,
        distinct: thm list,
        exhaust: thm,
        index: int,
        induct: thm,
        inducts: thm list,
        inject: thm list,
        nchotomy: thm,
        rec_names: string list,
        rec_rewrites: thm list, split: thm, split_asm: thm}
    val read_specs: spec_cmd list -> theory -> spec list * Proof.context
    type spec =
       (binding * (string * sort) list * mixfix) *
       (binding * typ list * mixfix) list
    type spec_cmd =
       (binding * (string * string option) list * mixfix) *
       (binding * string list * mixfix) list
  end
structure Old_Datatype: OLD_DATATYPE
### theory "HOL-Library.Old_Datatype"
### 0.775s elapsed time, 2.898s cpu time, 1.305s GC time
Loading theory "HOL-Library.Option_ord" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates" via "Draft.PDDL_STRIPS_Checker" via "Draft.PDDL_STRIPS_Semantics" via "Automatic_Refinement.Misc")
instantiation
  option :: (preorder) preorder
  less_eq_option == less_eq :: 'a option => 'a option => bool
  less_option == less :: 'a option => 'a option => bool
instantiation
  option :: (order) order_bot
  bot_option == bot :: 'a option
consts
  mset :: "'a list => 'a multiset"
instantiation
  option :: (order_top) order_top
  top_option == top :: 'a option
locale combine_mapping_abel_semigroup
  fixes f :: "'a => 'a => 'a"  (infixl \<open>\<^bold>*\<close> 70)
  assumes "combine_mapping_abel_semigroup (\<^bold>*)"
instantiation
  option :: (inf) inf
  inf_option == inf :: 'a option => 'a option => 'a option
instantiation
  option :: (sup) sup
  sup_option == sup :: 'a option => 'a option => 'a option
instantiation
  option :: (complete_lattice) complete_lattice
  Inf_option == Inf :: 'a option set => 'a option
  Sup_option == Sup :: 'a option set => 'a option
consts
  shift :: "'a list => 'a stream => 'a stream"
Proofs for coinductive predicate(s) "streamsp"
  Proving monotonicity ...
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
consts
  snth :: "'a stream => nat => 'a"
consts
  stake :: "nat => 'a stream => 'a list"
consts
  sdrop :: "nat => 'a stream => 'a stream"
### theory "HOL-Library.Option_ord"
### 0.398s elapsed time, 1.572s cpu time, 0.322s GC time
Loading theory "HOL-Library.Phantom_Type" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates" via "Draft.PDDL_STRIPS_Checker" via "Containers.Containers" via "Containers.Set_Linorder" via "HOL-Library.Cardinality")
locale comm_monoid_mset
  fixes f :: "'a => 'a => 'a"  (infixl \<open>\<^bold>*\<close> 70)
    and z :: "'a"  (\<open>\<^bold>1\<close>)
  assumes "comm_monoid_mset (\<^bold>*) \<^bold>1"
### theory "HOL-Library.Mapping"
### 1.536s elapsed time, 5.896s cpu time, 1.805s GC time
Loading theory "HOL-Library.RBT_Impl" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates" via "Draft.PDDL_STRIPS_Checker" via "Containers.Containers" via "Containers.Mapping_Impl" via "Containers.RBT_Mapping2" via "Containers.RBT_ext")
consts
  sfilter :: "('a => bool) => 'a stream => 'a stream"
consts
  cycle :: "'a list => 'a stream"
consts
  siterate :: "('a => 'a) => 'a => 'a stream"
class comm_monoid_add = ab_semigroup_add + monoid_add +
  assumes "add_0": "!!a. (0::'a) + a = a"
consts
  flat :: "'a list stream => 'a stream"
class comm_monoid_add = ab_semigroup_add + monoid_add +
  assumes "add_0": "!!a. (0::'a) + a = a"
consts
  sinterleave :: "'a stream => 'a stream => 'a stream"
consts
  szip :: "'a stream => 'b stream => ('a * 'b) stream"
class canonically_ordered_monoid_add = ordered_comm_monoid_add +
  assumes "le_iff_add": "!!a b. (a <= b) = (EX c. b = a + c)"
consts
  smap2 :: "('a => 'b => 'c) => 'a stream => 'b stream => 'c stream"
### theory "HOL-Library.Stream"
### 1.394s elapsed time, 5.342s cpu time, 1.808s GC time
Loading theory "HOL-Library.Set_Algebras" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
instantiation
  set :: (plus) plus
  plus_set == plus :: 'a set => 'a set => 'a set
instantiation
  set :: (times) times
  times_set == times :: 'a set => 'a set => 'a set
instantiation
  set :: (zero) zero
  zero_set == zero_class.zero :: 'a set
instantiation
  set :: (one) one
  one_set == one_class.one :: 'a set
class comm_monoid_mult = ab_semigroup_mult + monoid_mult + dvd +
  assumes "mult_1": "!!a. (1::'a) * a = a"
### theory "HOL-Library.Set_Algebras"
### 0.231s elapsed time, 0.924s cpu time, 0.111s GC time
Loading theory "HOL-Library.Tree" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates" via "Draft.ExtrEqs" via "Draft.Templates")
### theory "HOL-Library.Phantom_Type"
### 0.619s elapsed time, 2.459s cpu time, 0.384s GC time
Loading theory "Containers.Containers_Generator" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates" via "Draft.PDDL_STRIPS_Checker" via "Containers.Containers" via "Containers.Collection_Order")
signature CONTAINERS_GENERATOR =
  sig
    val HOLogic_list_conj: term list -> term
    val all_tys: term -> typ list -> term -> term
    val derive_is_c_dots_lemma:
       typ -> string -> thm list -> string -> theory -> theory
    val derive_none:
       string -> sort -> (typ -> term) -> string -> theory -> theory
    val derive_set_map_impl:
       string ->
         sort ->
           (string * term) list -> string -> string -> theory -> theory
    val is_class_instance: theory -> string -> sort -> bool
    val mk_Some: term -> term
    val mk_is_c_dots: typ -> string -> term
    val register_is_c_dots_lemma:
       string -> string -> thm -> theory -> theory
  end
structure Containers_Generator: CONTAINERS_GENERATOR
### theory "Containers.Containers_Generator"
### 0.436s elapsed time, 1.733s cpu time, 0.216s GC time
Loading theory "Containers.Collection_Enum" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates" via "Draft.PDDL_STRIPS_Checker" via "Containers.Containers")
class cenum = type +
  fixes
    cEnum ::
      "('a list * (('a => bool) => bool) * (('a => bool) => bool)) option"
  assumes
    "UNIV_cenum":
      "!!enum enum_all enum_ex.
          cEnum = Some (enum, enum_all, enum_ex) ==> UNIV = set enum"
    and
    "cenum_all_UNIV":
      "!!enum enum_all enum_ex P.
          cEnum = Some (enum, enum_all, enum_ex) ==>
          enum_all P = Ball UNIV P"
    and
    "cenum_ex_UNIV":
      "!!enum enum_all enum_ex P.
          cEnum = Some (enum, enum_all, enum_ex) ==> enum_ex P = Bex UNIV P"
signature CENUM_GENERATOR =
  sig val derive_no_cenum: string -> theory -> theory end
structure Cenum_Generator: CENUM_GENERATOR
consts
  left :: "'a tree => 'a tree"
consts
  right :: "'a tree => 'a tree"
consts
  entries :: "('a, 'b) rbt => ('a * 'b) list"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
### Rewrite rule not in simpset:
### Wellfounded.accp all_n_lists_rel (?P1, ?n1) ==>
### all_n_lists ?P1 ?n1 ==
### if ?n1 = 0 then ?P1 []
### else cenum_all (%x. all_n_lists (%xs. ?P1 (x # xs)) (?n1 - 1))
Found termination order: "size <*mlex*> {}"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
consts
  rbt_sorted :: "('a, 'b) rbt => bool"
### Rewrite rule not in simpset:
### Wellfounded.accp ex_n_lists_rel (?P1, ?n1) ==>
### ex_n_lists ?P1 ?n1 ==
### if ?n1 = 0 then ?P1 []
### else cenum_ex (%x. ex_n_lists (%xs. ?P1 (x # xs)) (?n1 - 1))
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
instantiation
  fun :: (cenum, cenum) cenum
  cEnum_fun == cEnum ::
    (('a => 'b) list *
     ((('a => 'b) => bool) => bool) * ((('a => 'b) => bool) => bool)) option
### Ambiguous input (line 136 of "$AFP/Containers/Collection_Enum.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_CENUM" ("\<^type>fun" ("_position_sort" 'a) ("_position_sort" 'b)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CENUM" ("_position_sort" 'a)))
###       ("_case2" ("_case1" ("_position" None) ("_position" None))
###         ("_case1"
###           ("_applC" ("_position" Some)
###             ("_tuple" ("_position" enum_a)
###               ("_tuple_args" ("_position" enum_all_a)
###                 ("_tuple_arg" ("_position" enum_ex_a)))))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CENUM" ("_position_sort" 'b)))
###             ("_case2" ("_case1" ("_position" None) ("_position" None))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("_tuple" ("_position" enum_b)
###                     ("_tuple_args" ("_position" enum_all_b)
###                       ("_tuple_arg" ("_position" enum_ex_b)))))
###                 ("_applC" ("_position" Some)
###                   ("_tuple"
###                     ("_applC" ("_position" map)
###                       ("_cargs"
###                         ("_lambda" ("_position" ys)
###                           ("\<^const>Fun.comp" ("_position" the)
###                             ("_applC" ("_position" map_of)
###                               ("_applC" ("_position" zip)
###                                 ("_cargs" ("_position" enum_a)
###                                   ("_position" ys))))))
###                         ("_applC" ("_position" List.n_lists)
###                           ("_cargs"
###                             ("_applC" ("_position" length)
###                               ("_position" enum_a))
###                             ("_position" enum_b)))))
###                     ("_tuple_args"
###                       ("_lambda" ("_position" P)
###                         ("_applC" ("_position" all_n_lists)
###                           ("_cargs" ("_position" enum_all_b)
###                             ("_cargs"
###                               ("_lambda" ("_position" bs)
###                                 ("_applC" ("_position" P)
###                                   ("\<^const>Fun.comp" ("_position" the)
###                                     ("_applC" ("_position" map_of)
### ("_applC" ("_position" zip)
###   ("_cargs" ("_position" enum_a) ("_position" bs)))))))
###                               ("_applC" ("_position" length)
###                                 ("_position" enum_a))))))
###                       ("_tuple_arg"
###                         ("_lambda" ("_position" P)
###                           ("_applC" ("_position" ex_n_lists)
###                             ("_cargs" ("_position" enum_ex_b)
###                               ("_cargs"
###                                 ("_lambda" ("_position" bs)
###                                   ("_applC" ("_position" P)
###                                     ("\<^const>Fun.comp" ("_position" the)
### ("_applC" ("_position" map_of)
###   ("_applC" ("_position" zip)
###     ("_cargs" ("_position" enum_a) ("_position" bs)))))))
###                                 ("_applC" ("_position" length)
###                                   ("_position" enum_a))))))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_CENUM" ("\<^type>fun" ("_position_sort" 'a) ("_position_sort" 'b)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CENUM" ("_position_sort" 'a)))
###       ("_case2" ("_case1" ("_position" None) ("_position" None))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some)
###               ("_tuple" ("_position" enum_a)
###                 ("_tuple_args" ("_position" enum_all_a)
###                   ("_tuple_arg" ("_position" enum_ex_a)))))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CENUM" ("_position_sort" 'b)))
###               ("_case1" ("_position" None) ("_position" None))))
###           ("_case1"
###             ("_applC" ("_position" Some)
###               ("_tuple" ("_position" enum_b)
###                 ("_tuple_args" ("_position" enum_all_b)
###                   ("_tuple_arg" ("_position" enum_ex_b)))))
###             ("_applC" ("_position" Some)
###               ("_tuple"
###                 ("_applC" ("_position" map)
###                   ("_cargs"
###                     ("_lambda" ("_position" ys)
###                       ("\<^const>Fun.comp" ("_position" the)
###                         ("_applC" ("_position" map_of)
###                           ("_applC" ("_position" zip)
###                             ("_cargs" ("_position" enum_a)
###                               ("_position" ys))))))
###                     ("_applC" ("_position" List.n_lists)
###                       ("_cargs"
###                         ("_applC" ("_position" length) ("_position" enum_a))
###                         ("_position" enum_b)))))
###                 ("_tuple_args"
###                   ("_lambda" ("_position" P)
###                     ("_applC" ("_position" all_n_lists)
###                       ("_cargs" ("_position" enum_all_b)
###                         ("_cargs"
###                           ("_lambda" ("_position" bs)
###                             ("_applC" ("_position" P)
###                               ("\<^const>Fun.comp" ("_position" the)
###                                 ("_applC" ("_position" map_of)
###                                   ("_applC" ("_position" zip)
###                                     ("_cargs" ("_position" enum_a)
### ("_position" bs)))))))
###                           ("_applC" ("_position" length)
###                             ("_position" enum_a))))))
###                   ("_tuple_arg"
###                     ("_lambda" ("_position" P)
###                       ("_applC" ("_position" ex_n_lists)
###                         ("_cargs" ("_position" enum_ex_b)
###                           ("_cargs"
###                             ("_lambda" ("_position" bs)
###                               ("_applC" ("_position" P)
###                                 ("\<^const>Fun.comp" ("_position" the)
###                                   ("_applC" ("_position" map_of)
###                                     ("_applC" ("_position" zip)
### ("_cargs" ("_position" enum_a) ("_position" bs)))))))
###                             ("_applC" ("_position" length)
###                               ("_position" enum_a))))))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Found termination order: "size <*mlex*> {}"
instantiation
  set :: (cenum) cenum
  cEnum_set == cEnum ::
    ('a set list *
     (('a set => bool) => bool) * (('a set => bool) => bool)) option
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
instantiation
  unit :: cenum
  cEnum_unit == cEnum ::
    (unit list * ((unit => bool) => bool) * ((unit => bool) => bool)) option
class height = type +
  fixes height :: "'a => nat"
instantiation
  tree :: (type) height
  height_tree == height :: 'a tree => nat
instantiation
  bool :: cenum
  cEnum_bool == cEnum ::
    (bool list * ((bool => bool) => bool) * ((bool => bool) => bool)) option
instantiation
  prod :: (cenum, cenum) cenum
  cEnum_prod == cEnum ::
    (('a * 'b) list *
     (('a * 'b => bool) => bool) * (('a * 'b => bool) => bool)) option
consts
  rbt_lookup :: "('a, 'b) rbt => 'a => 'b option"
### Ambiguous input (line 225 of "$AFP/Containers/Collection_Enum.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_CENUM"
###       ("\<^type>Product_Type.prod" ("_position_sort" 'a)
###         ("_position_sort" 'b)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CENUM" ("_position_sort" 'a)))
###       ("_case2" ("_case1" ("_position" None) ("_position" None))
###         ("_case1"
###           ("_applC" ("_position" Some)
###             ("_tuple" ("_position" enum_a)
###               ("_tuple_args" ("_position" enum_all_a)
###                 ("_tuple_arg" ("_position" enum_ex_a)))))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CENUM" ("_position_sort" 'b)))
###             ("_case2" ("_case1" ("_position" None) ("_position" None))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("_tuple" ("_position" enum_b)
###                     ("_tuple_args" ("_position" enum_all_b)
###                       ("_tuple_arg" ("_position" enum_ex_b)))))
###                 ("_applC" ("_position" Some)
###                   ("_tuple"
###                     ("_applC" ("_position" List.product)
###                       ("_cargs" ("_position" enum_a) ("_position" enum_b)))
###                     ("_tuple_args"
###                       ("_lambda" ("_position" P)
###                         ("_applC" ("_position" enum_all_a)
###                           ("_lambda" ("_position" x)
###                             ("_applC" ("_position" enum_all_b)
###                               ("_lambda" ("_position" y)
###                                 ("_applC" ("_position" P)
###                                   ("_tuple" ("_position" x)
###                                     ("_tuple_arg" ("_position" y)))))))))
###                       ("_tuple_arg"
###                         ("_lambda" ("_position" P)
###                           ("_applC" ("_position" enum_ex_a)
###                             ("_lambda" ("_position" x)
###                               ("_applC" ("_position" enum_ex_b)
###                                 ("_lambda" ("_position" y)
###                                   ("_applC" ("_position" P)
###                                     ("_tuple" ("_position" x)
### ("_tuple_arg" ("_position" y)))))))))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_CENUM"
###       ("\<^type>Product_Type.prod" ("_position_sort" 'a)
###         ("_position_sort" 'b)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CENUM" ("_position_sort" 'a)))
###       ("_case2" ("_case1" ("_position" None) ("_position" None))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some)
###               ("_tuple" ("_position" enum_a)
###                 ("_tuple_args" ("_position" enum_all_a)
###                   ("_tuple_arg" ("_position" enum_ex_a)))))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CENUM" ("_position_sort" 'b)))
###               ("_case1" ("_position" None) ("_position" None))))
###           ("_case1"
###             ("_applC" ("_position" Some)
###               ("_tuple" ("_position" enum_b)
###                 ("_tuple_args" ("_position" enum_all_b)
###                   ("_tuple_arg" ("_position" enum_ex_b)))))
###             ("_applC" ("_position" Some)
###               ("_tuple"
###                 ("_applC" ("_position" List.product)
###                   ("_cargs" ("_position" enum_a) ("_position" enum_b)))
###                 ("_tuple_args"
###                   ("_lambda" ("_position" P)
###                     ("_applC" ("_position" enum_all_a)
###                       ("_lambda" ("_position" x)
###                         ("_applC" ("_position" enum_all_b)
###                           ("_lambda" ("_position" y)
###                             ("_applC" ("_position" P)
###                               ("_tuple" ("_position" x)
###                                 ("_tuple_arg" ("_position" y)))))))))
###                   ("_tuple_arg"
###                     ("_lambda" ("_position" P)
###                       ("_applC" ("_position" enum_ex_a)
###                         ("_lambda" ("_position" x)
###                           ("_applC" ("_position" enum_ex_b)
###                             ("_lambda" ("_position" y)
###                               ("_applC" ("_position" P)
###                                 ("_tuple" ("_position" x)
###                                   ("_tuple_arg"
###                                     ("_position" y)))))))))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
instantiation
  multiset :: (preorder) order
  less_eq_multiset == less_eq :: 'a multiset => 'a multiset => bool
  less_multiset == less :: 'a multiset => 'a multiset => bool
instantiation
  sum :: (cenum, cenum) cenum
  cEnum_sum == cEnum ::
    (('a + 'b) list *
     (('a + 'b => bool) => bool) * (('a + 'b => bool) => bool)) option
Found termination order: "size <*mlex*> {}"
### Ambiguous input (line 237 of "$AFP/Containers/Collection_Enum.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_CENUM"
###       ("\<^type>Sum_Type.sum" ("_position_sort" 'a) ("_position_sort" 'b)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CENUM" ("_position_sort" 'a)))
###       ("_case2" ("_case1" ("_position" None) ("_position" None))
###         ("_case1"
###           ("_applC" ("_position" Some)
###             ("_tuple" ("_position" enum_a)
###               ("_tuple_args" ("_position" enum_all_a)
###                 ("_tuple_arg" ("_position" enum_ex_a)))))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CENUM" ("_position_sort" 'b)))
###             ("_case2" ("_case1" ("_position" None) ("_position" None))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("_tuple" ("_position" enum_b)
###                     ("_tuple_args" ("_position" enum_all_b)
###                       ("_tuple_arg" ("_position" enum_ex_b)))))
###                 ("_applC" ("_position" Some)
###                   ("_tuple"
###                     ("\<^const>List.append"
###                       ("_applC" ("_position" map)
###                         ("_cargs" ("_position" Inl) ("_position" enum_a)))
###                       ("_applC" ("_position" map)
###                         ("_cargs" ("_position" Inr) ("_position" enum_b))))
###                     ("_tuple_args"
###                       ("_lambda" ("_position" P)
###                         ("\<^const>HOL.conj"
###                           ("_applC" ("_position" enum_all_a)
###                             ("_lambda" ("_position" x)
###                               ("_applC" ("_position" P)
###                                 ("_applC" ("_position" Inl)
###                                   ("_position" x)))))
###                           ("_applC" ("_position" enum_all_b)
###                             ("_lambda" ("_position" x)
###                               ("_applC" ("_position" P)
###                                 ("_applC" ("_position" Inr)
###                                   ("_position" x)))))))
###                       ("_tuple_arg"
###                         ("_lambda" ("_position" P)
###                           ("\<^const>HOL.disj"
###                             ("_applC" ("_position" enum_ex_a)
###                               ("_lambda" ("_position" x)
###                                 ("_applC" ("_position" P)
###                                   ("_applC" ("_position" Inl)
###                                     ("_position" x)))))
###                             ("_applC" ("_position" enum_ex_b)
###                               ("_lambda" ("_position" x)
###                                 ("_applC" ("_position" P)
###                                   ("_applC" ("_position" Inr)
###                                     ("_position" x)))))))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_CENUM"
###       ("\<^type>Sum_Type.sum" ("_position_sort" 'a) ("_position_sort" 'b)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CENUM" ("_position_sort" 'a)))
###       ("_case2" ("_case1" ("_position" None) ("_position" None))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some)
###               ("_tuple" ("_position" enum_a)
###                 ("_tuple_args" ("_position" enum_all_a)
###                   ("_tuple_arg" ("_position" enum_ex_a)))))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CENUM" ("_position_sort" 'b)))
###               ("_case1" ("_position" None) ("_position" None))))
###           ("_case1"
###             ("_applC" ("_position" Some)
###               ("_tuple" ("_position" enum_b)
###                 ("_tuple_args" ("_position" enum_all_b)
###                   ("_tuple_arg" ("_position" enum_ex_b)))))
###             ("_applC" ("_position" Some)
###               ("_tuple"
###                 ("\<^const>List.append"
###                   ("_applC" ("_position" map)
###                     ("_cargs" ("_position" Inl) ("_position" enum_a)))
###                   ("_applC" ("_position" map)
###                     ("_cargs" ("_position" Inr) ("_position" enum_b))))
###                 ("_tuple_args"
###                   ("_lambda" ("_position" P)
###                     ("\<^const>HOL.conj"
###                       ("_applC" ("_position" enum_all_a)
###                         ("_lambda" ("_position" x)
###                           ("_applC" ("_position" P)
###                             ("_applC" ("_position" Inl) ("_position" x)))))
###                       ("_applC" ("_position" enum_all_b)
###                         ("_lambda" ("_position" x)
###                           ("_applC" ("_position" P)
###                             ("_applC" ("_position" Inr)
###                               ("_position" x)))))))
###                   ("_tuple_arg"
###                     ("_lambda" ("_position" P)
###                       ("\<^const>HOL.disj"
###                         ("_applC" ("_position" enum_ex_a)
###                           ("_lambda" ("_position" x)
###                             ("_applC" ("_position" P)
###                               ("_applC" ("_position" Inl)
###                                 ("_position" x)))))
###                         ("_applC" ("_position" enum_ex_b)
###                           ("_lambda" ("_position" x)
###                             ("_applC" ("_position" P)
###                               ("_applC" ("_position" Inr)
###                                 ("_position" x)))))))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
instantiation
  multiset :: (preorder) ordered_ab_semigroup_add
instantiation
  option :: (cenum) cenum
  cEnum_option == cEnum ::
    ('a option list *
     (('a option => bool) => bool) * (('a option => bool) => bool)) option
Proofs for inductive predicate(s) "pw_leq"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
  Proving monotonicity ...
instantiation
  Enum.finite_1 :: cenum
  cEnum_finite_1 == cEnum ::
    (Enum.finite_1 list *
     ((Enum.finite_1 => bool) => bool) *
     ((Enum.finite_1 => bool) => bool)) option
instantiation
  Enum.finite_2 :: cenum
  cEnum_finite_2 == cEnum ::
    (Enum.finite_2 list *
     ((Enum.finite_2 => bool) => bool) *
     ((Enum.finite_2 => bool) => bool)) option
instantiation
  Enum.finite_3 :: cenum
  cEnum_finite_3 == cEnum ::
    (Enum.finite_3 list *
     ((Enum.finite_3 => bool) => bool) *
     ((Enum.finite_3 => bool) => bool)) option
Found termination order: "size <*mlex*> {}"
instantiation
  Enum.finite_4 :: cenum
  cEnum_finite_4 == cEnum ::
    (Enum.finite_4 list *
     ((Enum.finite_4 => bool) => bool) *
     ((Enum.finite_4 => bool) => bool)) option
instantiation
  Enum.finite_5 :: cenum
  cEnum_finite_5 == cEnum ::
    (Enum.finite_5 list *
     ((Enum.finite_5 => bool) => bool) *
     ((Enum.finite_5 => bool) => bool)) option
instantiation
  char :: cenum
  cEnum_char == cEnum ::
    (char list * ((char => bool) => bool) * ((char => bool) => bool)) option
use None as trivial implementation of cenum for type list
registered list in class cenum
use None as trivial implementation of cenum for type nat
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
registered nat in class cenum
use None as trivial implementation of cenum for type int
registered int in class cenum
use None as trivial implementation of cenum for type integer
Found termination order: "size <*mlex*> {}"
registered integer in class cenum
use None as trivial implementation of cenum for type natural
registered natural in class cenum
use None as trivial implementation of cenum for type literal
registered literal in class cenum
### theory "Containers.Collection_Enum"
### 0.700s elapsed time, 2.777s cpu time, 0.439s GC time
Loading theory "Containers.Collection_Eq" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates" via "Draft.PDDL_STRIPS_Checker" via "Containers.Containers")
consts
  color_of :: "('a, 'b) rbt => color"
consts
  bheight :: "('a, 'b) rbt => nat"
consts
  inv1 :: "('a, 'b) rbt => bool"
consts
  inv1l :: "('a, 'b) rbt => bool"
consts
  inv2 :: "('a, 'b) rbt => bool"
Found termination order: "size <*mlex*> {}"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
Found termination order: "size <*mlex*> {}"
Found termination order: "(%p. length (fst p)) <*mlex*> {}"
instantiation
  multiset :: (equal) equal
  equal_multiset == equal_class.equal :: 'a multiset => 'a multiset => bool
class ceq = type +
  fixes ceq :: "('a => 'a => bool) option"
  assumes "ceq": "!!eqa. ceq = Some eqa ==> eqa = (=)"
instantiation
  multiset :: (random) random
  random_multiset == random_class.random ::
    natural
    => natural * natural
       => ('a multiset * (unit => term)) * natural * natural
Found termination order: "size <*mlex*> {}"
instantiation
  multiset :: (full_exhaustive) full_exhaustive
  full_exhaustive_multiset == full_exhaustive_class.full_exhaustive ::
    ('a multiset * (unit => term) => (bool * term list) option)
    => natural => (bool * term list) option
Proofs for inductive predicate(s) "pred_mset"
  Proving monotonicity ...
signature CEQ_GENERATOR =
  sig
    val ceq_instance_via_eq: string -> theory -> theory
    val ceq_instance_via_equality: string -> theory -> theory
    val derive_no_ceq: string -> theory -> theory
  end
structure Ceq_Generator: CEQ_GENERATOR
deriving "ceq" instance for type "Product_Type.unit" via "="
derived is_ceq_unit-lemma
### Code generator: dropping subsumed code equation
### CEQ(unit) == Some (=)
deriving "ceq" instance for type "HOL.bool" via "="
Found termination order: "size <*mlex*> {}"
derived is_ceq_bool-lemma
deriving "ceq" instance for type "Nat.nat" via "="
derived is_ceq_nat-lemma
deriving "ceq" instance for type "Int.int" via "="
derived is_ceq_int-lemma
deriving "ceq" instance for type "Enum.finite_1" via "="
derived is_ceq_finite_1-lemma
deriving "ceq" instance for type "Enum.finite_2" via "="
derived is_ceq_finite_2-lemma
deriving "ceq" instance for type "Enum.finite_3" via "="
Proofs for inductive predicate(s) "rel_mset'"
  Proving monotonicity ...
derived is_ceq_finite_3-lemma
deriving "ceq" instance for type "Enum.finite_4" via "="
derived is_ceq_finite_4-lemma
deriving "ceq" instance for type "Enum.finite_5" via "="
derived is_ceq_finite_5-lemma
deriving "ceq" instance for type "Code_Numeral.integer" via "="
derived is_ceq_integer-lemma
deriving "ceq" instance for type "Code_Numeral.natural" via "="
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
derived is_ceq_natural-lemma
deriving "ceq" instance for type "String.char" via "="
derived is_ceq_char-lemma
deriving "ceq" instance for type "String.literal" via "="
derived is_ceq_literal-lemma
deriving "ceq" instance for type "Sum_Type.sum"
derived is_ceq_sum-lemma
deriving "ceq" instance for type "Product_Type.prod"
derived is_ceq_prod-lemma
deriving "ceq" instance for type "List.list"
Found termination order: "size <*mlex*> {}"
derived is_ceq_list-lemma
deriving "ceq" instance for type "Option.option"
### theory "HOL-Library.Multiset"
### 4.656s elapsed time, 18.071s cpu time, 4.151s GC time
Loading theory "HOL-ex.Quicksort" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates" via "Draft.PDDL_STRIPS_Checker" via "Draft.PDDL_STRIPS_Semantics" via "Automatic_Refinement.Misc")
derived is_ceq_option-lemma
use None as trivial implementation of ceq for type fun
registered fun in class ceq
instantiation
  set :: (ceq) ceq
  ceq_set == ceq :: ('a set => 'a set => bool) option
instantiation
  Predicate.pred :: (ceq) ceq
  ceq_pred == ceq :: ('a Predicate.pred => 'a Predicate.pred => bool) option
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
### theory "Containers.Collection_Eq"
### 0.579s elapsed time, 2.292s cpu time, 0.250s GC time
Loading theory "Containers.DList_Set" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates" via "Draft.PDDL_STRIPS_Checker" via "Containers.Containers" via "Containers.Mapping_Impl" via "Containers.Set_Impl")
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
locale equal_base
  fixes equal :: "'a => 'a => bool"
consts
  list_member :: "'a list => 'a => bool"
consts
  list_distinct :: "'a list => bool"
consts
  list_remove1 :: "'a => 'a list => 'a list"
consts
  list_remdups :: "'a list => 'a list"
locale Equal.equal
  fixes equal :: "'a => 'a => bool"
  assumes "equal equal"
Found termination order: "size <*mlex*> {}"
Found termination order: "length <*mlex*> {}"
### theory "HOL-ex.Quicksort"
### 0.471s elapsed time, 1.868s cpu time, 0.256s GC time
Loading theory "Automatic_Refinement.Misc" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates" via "Draft.PDDL_STRIPS_Checker" via "Draft.PDDL_STRIPS_Semantics")
### theory "HOL-Library.Tree"
### 2.198s elapsed time, 8.735s cpu time, 1.162s GC time
Loading theory "HOL-Library.Cardinality" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates" via "Draft.PDDL_STRIPS_Checker" via "Containers.Containers" via "Containers.Set_Linorder")
### Additional type variable(s) in locale specification "CARD_1": 'a
class CARD_1 = type +
  assumes "CARD_1": "CARD('a) = 1"
### theory "Containers.DList_Set"
### 0.703s elapsed time, 2.786s cpu time, 0.368s GC time
Loading theory "Draft.Templates" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates" via "Draft.ExtrEqs")
### Additional type variable(s) in locale specification "card2": 'a
datatype template_term
=
     t_empty
   | template_app of template_term * template_term
   | template_hole of int
   | template_var of int
datatype sign
= equals | greater_equals | greater_than | less_equals | less_than
datatype template
=
     template_bimplication of template * template
   | template_dunno
   | template_equation of template_term * template_term
   | template_implication of template list * template
   | template_inequation of sign * template_term * template_term
   | template_negation of template
   | template_predicate of template_term
constructor t_empty: template_term
constructor template_app: template_term * template_term -> template_term
constructor template_hole: int -> template_term
constructor template_var: int -> template_term
constructor equals: sign
constructor greater_equals: sign
constructor greater_than: sign
constructor less_equals: sign
constructor less_than: sign
constructor template_bimplication: template * template -> template
constructor template_dunno: template
constructor template_equation: template_term * template_term -> template
constructor template_implication: template list * template -> template
constructor template_inequation:
   sign * template_term * template_term -> template
constructor template_negation: template -> template
constructor template_predicate: template_term -> template
val vfs = fn: term -> (indexname * typ) list * (string * typ) list
val indexOf = fn: ''a list -> ''a -> int -> int
val has_eq = fn: term -> bool
val term2template = fn:
   (indexname * typ) list -> (string * typ) list -> term -> template_term
val lemma2predicate = fn: term -> term -> template
val makeTemplatewithContext = fn: term -> term -> template
val lemma2template = fn: term -> template
val thm2template = fn: thm -> template
val tterm2string = fn: template_term -> string
val template2string = fn: template -> string
val t = "height ?t <= size ?t": thm
val th =
   Const ("HOL.Trueprop", "bool => prop") $
     (Const ("Orderings.ord_class.less_eq", "nat => nat => bool") $
       (Const ("Tree.height_class.height", "?'a tree => nat") $
         Var (("t", 0), "?'a tree")) $
       (Const ("Nat.size_class.size", "?'a tree => nat") $
         Var (("t", 0), "?'a tree"))):
   term
### theory "Draft.Templates"
### 0.069s elapsed time, 0.273s cpu time, 0.000s GC time
Loading theory "HOL-Library.While_Combinator" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates" via "Draft.PDDL_STRIPS_Checker")
class card2 = finite +
  assumes "two_le_card": "2 <= CARD('a)"
class finite_UNIV = type +
  fixes finite_UNIV :: "('a, bool) phantom"
  assumes "finite_UNIV": "finite_UNIV = Phantom('a) (finite UNIV)"
class card_UNIV = finite_UNIV +
  fixes card_UNIV :: "('a, nat) phantom"
  assumes "card_UNIV": "card_UNIV_class.card_UNIV = Phantom('a) CARD('a)"
instantiation
  nat :: card_UNIV
  card_UNIV_nat == card_UNIV_class.card_UNIV :: (nat, nat) phantom
  finite_UNIV_nat == finite_UNIV :: (nat, bool) phantom
instantiation
  int :: card_UNIV
  card_UNIV_int == card_UNIV_class.card_UNIV :: (int, nat) phantom
  finite_UNIV_int == finite_UNIV :: (int, bool) phantom
instantiation
  natural :: card_UNIV
  card_UNIV_natural == card_UNIV_class.card_UNIV :: (natural, nat) phantom
  finite_UNIV_natural == finite_UNIV :: (natural, bool) phantom
instantiation
  integer :: card_UNIV
  card_UNIV_integer == card_UNIV_class.card_UNIV :: (integer, nat) phantom
  finite_UNIV_integer == finite_UNIV :: (integer, bool) phantom
instantiation
  list :: (type) card_UNIV
  card_UNIV_list == card_UNIV_class.card_UNIV :: ('a list, nat) phantom
  finite_UNIV_list == finite_UNIV :: ('a list, bool) phantom
instantiation
  unit :: card_UNIV
  card_UNIV_unit == card_UNIV_class.card_UNIV :: (unit, nat) phantom
  finite_UNIV_unit == finite_UNIV :: (unit, bool) phantom
instantiation
  bool :: card_UNIV
  card_UNIV_bool == card_UNIV_class.card_UNIV :: (bool, nat) phantom
  finite_UNIV_bool == finite_UNIV :: (bool, bool) phantom
Found termination order: "{}"
locale Assoc
  fixes f :: "'a => 'a => 'a"
  assumes "Assoc f"
instantiation
  char :: card_UNIV
  card_UNIV_char == card_UNIV_class.card_UNIV :: (char, nat) phantom
  finite_UNIV_char == finite_UNIV :: (char, bool) phantom
locale AC
  fixes f :: "'a => 'a => 'a"
  assumes "AC f"
instantiation
  prod :: (finite_UNIV, finite_UNIV) finite_UNIV
  finite_UNIV_prod == finite_UNIV :: ('a * 'b, bool) phantom
locale su_rel_fun
  fixes F :: "('a * 'b) set"
    and f :: "'a => 'b"
  assumes "su_rel_fun F f"
instantiation
  prod :: (card_UNIV, card_UNIV) card_UNIV
  card_UNIV_prod == card_UNIV_class.card_UNIV :: ('a * 'b, nat) phantom
instantiation
  sum :: (finite_UNIV, finite_UNIV) finite_UNIV
  finite_UNIV_sum == finite_UNIV :: ('a + 'b, bool) phantom
instantiation
  sum :: (card_UNIV, card_UNIV) card_UNIV
  card_UNIV_sum == card_UNIV_class.card_UNIV :: ('a + 'b, nat) phantom
instantiation
  fun :: (finite_UNIV, card_UNIV) finite_UNIV
  finite_UNIV_fun == finite_UNIV :: ('a => 'b, bool) phantom
instantiation
  fun :: (card_UNIV, card_UNIV) card_UNIV
  card_UNIV_fun == card_UNIV_class.card_UNIV :: ('a => 'b, nat) phantom
instantiation
  option :: (finite_UNIV) finite_UNIV
  finite_UNIV_option == finite_UNIV :: ('a option, bool) phantom
Found termination order: "{}"
instantiation
  option :: (card_UNIV) card_UNIV
  card_UNIV_option == card_UNIV_class.card_UNIV :: ('a option, nat) phantom
instantiation
  String.literal :: card_UNIV
  card_UNIV_literal == card_UNIV_class.card_UNIV ::
    (String.literal, nat) phantom
  finite_UNIV_literal == finite_UNIV :: (String.literal, bool) phantom
instantiation
  set :: (finite_UNIV) finite_UNIV
  finite_UNIV_set == finite_UNIV :: ('a set, bool) phantom
instantiation
  set :: (card_UNIV) card_UNIV
  card_UNIV_set == card_UNIV_class.card_UNIV :: ('a set, nat) phantom
instantiation
  Enum.finite_1 :: card_UNIV
  card_UNIV_finite_1 == card_UNIV_class.card_UNIV ::
    (Enum.finite_1, nat) phantom
  finite_UNIV_finite_1 == finite_UNIV :: (Enum.finite_1, bool) phantom
instantiation
  Enum.finite_2 :: card_UNIV
  card_UNIV_finite_2 == card_UNIV_class.card_UNIV ::
    (Enum.finite_2, nat) phantom
  finite_UNIV_finite_2 == finite_UNIV :: (Enum.finite_2, bool) phantom
instantiation
  Enum.finite_3 :: card_UNIV
  card_UNIV_finite_3 == card_UNIV_class.card_UNIV ::
    (Enum.finite_3, nat) phantom
  finite_UNIV_finite_3 == finite_UNIV :: (Enum.finite_3, bool) phantom
Found termination order: "{}"
instantiation
  Enum.finite_4 :: card_UNIV
  card_UNIV_finite_4 == card_UNIV_class.card_UNIV ::
    (Enum.finite_4, nat) phantom
  finite_UNIV_finite_4 == finite_UNIV :: (Enum.finite_4, bool) phantom
instantiation
  Enum.finite_5 :: card_UNIV
  card_UNIV_finite_5 == card_UNIV_class.card_UNIV ::
    (Enum.finite_5, nat) phantom
  finite_UNIV_finite_5 == finite_UNIV :: (Enum.finite_5, bool) phantom
### theory "HOL-Library.While_Combinator"
### 0.459s elapsed time, 1.827s cpu time, 0.180s GC time
Loading theory "HOL-Library.Countable" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates" via "Draft.PDDL_STRIPS_Checker" via "Draft.PDDL_STRIPS_Semantics" via "Propositional_Proof_Systems.Formulas")
### theory "HOL-Library.Cardinality"
### 0.748s elapsed time, 2.981s cpu time, 0.180s GC time
Loading theory "Containers.Set_Linorder" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates" via "Draft.PDDL_STRIPS_Checker" via "Containers.Containers")
Found termination order: "(%p. length (fst p)) <*mlex*> {}"
### Additional type variable(s) in locale specification "countable": 'a
locale comp_fun_commute
  fixes f :: "'a => 'b => 'b"
  assumes "comp_fun_commute f"
class countable = type +
  assumes "ex_inj": "EX to_nat. inj to_nat"
specification
  finite_complement_partition: finite ?A ==> ?A : infinite_complement_partition
  complement_partition: infinite UNIV ==>
(?A : infinite_complement_partition) =
(- ?A ~: infinite_complement_partition)
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
### Ignoring duplicate rewrite rule:
### dom (%x. Some (?f1 x)) == UNIV
consts
  filter_rev_aux :: "'a list => ('a => bool) => 'a list => 'a list"
### Missing patterns in function definition:
### !!a v va. zipf a (v # va) [] = undefined
### !!a v va. zipf a [] (v # va) = undefined
Proofs for inductive predicate(s) "finite_item"
class order = preorder +
  assumes "order_antisym": "!!x y. [| x <= y; y <= x |] ==> x = y"
  Proving monotonicity ...
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
Found termination order: "(%p. length (snd (snd p))) <*mlex*> {}"
val old_countable_datatype_tac = fn: Proof.context -> int -> tactic
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
### ML warning (line 93 of "~~/src/HOL/Tools/BNF/bnf_lfp_countable.ML"):
### Pattern is not exhaustive.
### ML warning (line 139 of "~~/src/HOL/Tools/BNF/bnf_lfp_countable.ML"):
### Pattern is not exhaustive.
### ML warning (line 143 of "~~/src/HOL/Tools/BNF/bnf_lfp_countable.ML"):
### Matches are not exhaustive.
### ML warning (line 145 of "~~/src/HOL/Tools/BNF/bnf_lfp_countable.ML"):
### Matches are not exhaustive.
### ML warning (line 156 of "~~/src/HOL/Tools/BNF/bnf_lfp_countable.ML"):
### Pattern is not exhaustive.
signature BNF_LFP_COUNTABLE =
  sig
    val countable_datatype_tac: Proof.context -> tactic
    val derive_encode_injectives_thms:
       Proof.context -> string list -> thm list
  end
structure BNF_LFP_Countable: BNF_LFP_COUNTABLE
val countable_datatype_tac = fn: Proof.context -> thm -> thm Seq.seq
val countable_tac = fn: Proof.context -> int -> tactic
Found termination order: "(%p. length (snd (snd p))) <*mlex*> {}"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
### theory "HOL-Library.Countable"
### 1.223s elapsed time, 4.861s cpu time, 0.563s GC time
Loading theory "HOL-Library.BigO" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates" via "Draft.ExtrEqs")
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
class proper_intrvl = ord +
  fixes proper_interval :: "'a option => 'a option => bool"
Found termination order: "(%p. length (snd (snd p))) <*mlex*> {}"
class proper_interval = proper_intrvl +
  assumes
    "proper_interval_simps": "proper_interval None None = True"
      "!!y. proper_interval None (Some y) = (EX z. z < y)"
      "!!x. proper_interval (Some x) None = (EX z. x < z)"
      "!!x y. proper_interval (Some x) (Some y) = (EX z>x. z < y)"
class proper_intrvl = ord +
  fixes proper_interval :: "'a option => 'a option => bool"
### Code generator: dropping subsumed code equation
### quicksort (?x # ?xs) ==
### quicksort (filter (%y. y < ?x) ?xs) @
### [?x] @ quicksort (filter ((<=) ?x) ?xs)
### Code generator: dropping subsumed code equation
### quicksort [] == []
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
Found termination order:
  "(%p. length (snd (snd p))) <*mlex*>
   (%p. length (fst (snd p))) <*mlex*> {}"
### theory "HOL-Library.BigO"
### 0.853s elapsed time, 3.388s cpu time, 0.304s GC time
Loading theory "Draft.ExtrEqs" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates")
Found termination order:
  "(%p. length (snd (snd p))) <*mlex*>
   (%p. length (fst (snd p))) <*mlex*> {}"
Found termination order:
  "(%p. length (snd p)) <*mlex*> (%p. length (fst p)) <*mlex*> {}"
Found termination order: "{}"
Found termination order:
  "(%p. length (snd (snd p))) <*mlex*>
   (%p. length (fst (snd p))) <*mlex*> {}"
val eqpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Var (("_dummy_", 2), "?'a"))
       ):
   term Find_Theorems.criterion
val badeqpattern = Pattern (Const ("Pure.eq", "?'a => ?'a => prop")):
   term Find_Theorems.criterion
val undefpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Const ("HOL.undefined", "?'a"))
       ):
   term Find_Theorems.criterion
val thmpattern =
   Pattern
    (Const ("HOL.Trueprop", "bool => prop") $ Var (("_dummy_", 1), "bool")):
   term Find_Theorems.criterion
val badnames =
   ["*nitpick*", "*Nitpick*", "*full_exhaustive*", "*_def*", "Enum.finite*",
    "*Quickcheck*", "ATP*", "*Nunchaku*", "*Code*", "*BNF*", "*SMT*",
    "*.*.*"]:
   string list
val unwanted_names =
   [(false, Name "*nitpick*"), (false, Name "*Nitpick*"),
    (false, Name "*full_exhaustive*"), (false, Name "*_def*"),
    (false, Name "Enum.finite*"), (false, Name "*Quickcheck*"),
    (false, Name "ATP*"), (false, Name "*Nunchaku*"),
    (false, Name "*Code*"), (false, Name "*BNF*"), (false, Name "*SMT*"),
    (false, Name "*.*.*")]:
   (bool * term Find_Theorems.criterion) list
val has_vars = fn: term -> bool
val get_all_eqs = fn: string -> Proof.context -> (string * thm) list
val get_all_thms = fn: string -> Proof.context -> (string * thm) list
val get_noneq_thms = fn: string -> Proof.context -> (string * thm) list
val template_eqs = fn:
   string -> Proof.context -> (string * thm * template) list
val template_thms = fn:
   string -> Proof.context -> (string * thm * template) list
### theory "Draft.ExtrEqs"
### 0.730s elapsed time, 2.901s cpu time, 0.305s GC time
Loading theory "Propositional_Proof_Systems.Formulas" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates" via "Draft.PDDL_STRIPS_Checker" via "Draft.PDDL_STRIPS_Semantics")
consts
  the_default :: "'a => 'a option => 'a"
class ccpo = Sup + order +
  assumes
    "ccpo_Sup_upper":
      "!!A x.
          [| Complete_Partial_Order.chain (<=) A; x : A |] ==> x <= Sup A"
  assumes
    "ccpo_Sup_least":
      "!!A z.
          [| Complete_Partial_Order.chain (<=) A; !!x. x : A ==> x <= z |]
          ==> Sup A <= z"
### theory "Automatic_Refinement.Misc"
### 4.199s elapsed time, 16.675s cpu time, 1.760s GC time
Loading theory "Show.Show" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates" via "Draft.PDDL_STRIPS_Checker" via "Draft.Error_Monad_Add" via "Show.Show_Instances")
class show = type +
  fixes shows_prec :: "nat => 'a => char list => char list"
    and shows_list :: "'a list => char list => char list"
  assumes
    "shows_prec_append":
      "!!p x r s. shows_prec p x (r @ s) = shows_prec p x r @ s"
    and
    "shows_list_append":
      "!!xs r s. shows_list xs (r @ s) = shows_list xs r @ s"
Found termination order: "(%p. length (snd (snd p))) <*mlex*> {}"
consts
  subformulae :: "'a formula => 'a formula list"
### Ambiguous input (line 62 of "$AFP/Propositional_Proof_Systems/Formulas.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("\<^fixed>BigAnd" ("_position" Nil))
###     ("_applC" ("\<^const>Formulas.formula.Not")
###       ("\<^const>Formulas.formula.Bot"))))
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>BigAnd"
###     ("\<^const>HOL.eq" ("_position" Nil)
###       ("_applC" ("\<^const>Formulas.formula.Not")
###         ("\<^const>Formulas.formula.Bot")))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 63 of "$AFP/Propositional_Proof_Systems/Formulas.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Formulas.formula.And"
###     ("\<^fixed>BigAnd"
###       ("\<^const>HOL.eq"
###         ("\<^const>List.list.Cons" ("_position" F) ("_position" Fs))
###         ("_position" F)))
###     ("\<^fixed>BigAnd" ("_position" Fs))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>BigAnd"
###       ("\<^const>List.list.Cons" ("_position" F) ("_position" Fs)))
###     ("\<^const>Formulas.formula.And" ("_position" F)
###       ("\<^fixed>BigAnd" ("_position" Fs)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>BigAnd"
###     ("\<^const>HOL.eq"
###       ("\<^const>List.list.Cons" ("_position" F) ("_position" Fs))
###       ("\<^const>Formulas.formula.And" ("_position" F)
###         ("\<^fixed>BigAnd" ("_position" Fs))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
consts
  BigAnd :: "'a formula list => 'a formula"
instantiation
  char :: show
  shows_prec_char == shows_prec :: nat => char => char list => char list
  shows_list_char == shows_list :: char list => char list => char list
### Ambiguous input (line 69 of "$AFP/Propositional_Proof_Systems/Formulas.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("\<^fixed>BigOr" ("_position" Nil))
###     ("\<^const>Formulas.formula.Bot")))
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>BigOr"
###     ("\<^const>HOL.eq" ("_position" Nil)
###       ("\<^const>Formulas.formula.Bot"))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 70 of "$AFP/Propositional_Proof_Systems/Formulas.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Formulas.formula.Or"
###     ("\<^fixed>BigOr"
###       ("\<^const>HOL.eq"
###         ("\<^const>List.list.Cons" ("_position" F) ("_position" Fs))
###         ("_position" F)))
###     ("\<^fixed>BigOr" ("_position" Fs))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>BigOr"
###       ("\<^const>List.list.Cons" ("_position" F) ("_position" Fs)))
###     ("\<^const>Formulas.formula.Or" ("_position" F)
###       ("\<^fixed>BigOr" ("_position" Fs)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>BigOr"
###     ("\<^const>HOL.eq"
###       ("\<^const>List.list.Cons" ("_position" F) ("_position" Fs))
###       ("\<^const>Formulas.formula.Or" ("_position" F)
###         ("\<^fixed>BigOr" ("_position" Fs))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
consts
  BigOr :: "'a formula list => 'a formula"
consts
  pn_atoms :: "'a formula => 'a set * 'a set"
class proper_intrvl = ord +
  fixes proper_interval :: "'a option => 'a option => bool"
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
signature SHOW_GENERATOR =
  sig
    val generate_showsp: string -> local_theory -> local_theory
    val register_foreign_partial_and_full_showsp:
       string ->
         int ->
           term ->
             term ->
               thm option ->
                 term ->
                   thm option ->
                     bool list -> thm -> local_theory -> local_theory
    val register_foreign_showsp:
       typ -> term -> thm -> local_theory -> local_theory
    val show_instance: string -> theory -> theory
  end
structure Show_Generator: SHOW_GENERATOR
instantiation
  list :: (show) show
  shows_prec_list == shows_prec :: nat => 'a list => char list => char list
  shows_list_list == shows_list :: 'a list list => char list => char list
instantiation
  String.literal :: show
  shows_prec_literal == shows_prec ::
    nat => String.literal => char list => char list
  shows_list_literal == shows_list ::
    String.literal list => char list => char list
Found termination order: "size <*mlex*> {}"
### theory "Show.Show"
### 0.989s elapsed time, 3.916s cpu time, 0.377s GC time
Loading theory "Show.Show_Instances" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates" via "Draft.PDDL_STRIPS_Checker" via "Draft.Error_Monad_Add")
Found termination order: "{}"
consts
  showsp_bool :: "nat => bool => char list => char list"
consts
  pshowsp_prod ::
    "nat
     => (char list => char list) * (char list => char list)
        => char list => char list"
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
Found termination order: "{}"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
deriving "show" instance for type "Option.option"
generating show function for type "Option.option"
### theory "Propositional_Proof_Systems.Formulas"
### 2.357s elapsed time, 9.338s cpu time, 0.985s GC time
Loading theory "Propositional_Proof_Systems.Sema" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates" via "Draft.PDDL_STRIPS_Checker" via "Draft.PDDL_STRIPS_Semantics")
deriving "show" instance for type "Sum_Type.sum"
generating show function for type "Sum_Type.sum"
consts
  formula_semantics :: "('a => bool) => 'a formula => bool"
consts
  formula_semantics_alt :: "('a => bool) => 'a formula => bool"
deriving "show" instance for type "Product_Type.prod"
deriving "show" instance for type "Product_Type.unit"
consts
  formula_semantics_tt :: "('a => bool) => 'a formula => bool"
deriving "show" instance for type "HOL.bool"
### Ambiguous input (line 72 of "$AFP/Propositional_Proof_Systems/Sema.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Sema.formula_semantics" ("_position" A)
###     ("\<^const>Formulas.BigAnd"
###       ("\<^const>HOL.iff" ("_position" F)
###         ("_Ball" ("_position" f)
###           ("_applC" ("_position" set) ("_position" F))
###           ("\<^const>Sema.formula_semantics" ("_position" A)
###             ("_position" f)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.iff"
###     ("\<^const>Sema.formula_semantics" ("_position" A)
###       ("\<^const>Formulas.BigAnd" ("_position" F)))
###     ("_Ball" ("_position" f) ("_applC" ("_position" set) ("_position" F))
###       ("\<^const>Sema.formula_semantics" ("_position" A) ("_position" f)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 73 of "$AFP/Propositional_Proof_Systems/Sema.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Sema.formula_semantics" ("_position" A)
###     ("\<^const>Formulas.BigOr"
###       ("\<^const>HOL.iff" ("_position" F)
###         ("_Bex" ("_position" f) ("_applC" ("_position" set) ("_position" F))
###           ("\<^const>Sema.formula_semantics" ("_position" A)
###             ("_position" f)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.iff"
###     ("\<^const>Sema.formula_semantics" ("_position" A)
###       ("\<^const>Formulas.BigOr" ("_position" F)))
###     ("_Bex" ("_position" f) ("_applC" ("_position" set) ("_position" F))
###       ("\<^const>Sema.formula_semantics" ("_position" A) ("_position" f)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
deriving "show" instance for type "Nat.nat"
deriving "show" instance for type "Int.int"
### theory "Propositional_Proof_Systems.Sema"
### 0.141s elapsed time, 0.559s cpu time, 0.000s GC time
Loading theory "Propositional_Proof_Systems.Consistency" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates" via "Draft.PDDL_STRIPS_Checker" via "Draft.PDDL_STRIPS_Semantics")
deriving "show" instance for type "Rat.rat"
Proofs for inductive predicate(s) "Con"
  Proving monotonicity ...
Proofs for inductive predicate(s) "Dis"
  Proving monotonicity ...
Found termination order:
  "(%p. length (snd (snd (snd p)))) <*mlex*>
   (%p. length (fst (snd (snd p)))) <*mlex*> {}"
### theory "Show.Show_Instances"
### 1.157s elapsed time, 4.580s cpu time, 0.387s GC time
Loading theory "Draft.Error_Monad_Add" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates" via "Draft.PDDL_STRIPS_Checker")
consts
  pcp_seq :: "'a set set => 'a set => nat => 'a set"
### theory "Propositional_Proof_Systems.Consistency"
### 0.280s elapsed time, 1.119s cpu time, 0.149s GC time
Loading theory "Draft.PDDL_STRIPS_Semantics" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates" via "Draft.PDDL_STRIPS_Checker")
### theory "Draft.Error_Monad_Add"
### 0.430s elapsed time, 1.699s cpu time, 0.146s GC time
val mk_2elem_list = fn: term -> term -> term
val mk_compr = fn: term -> term -> term
val test1 = "[1, 2]": cterm
val test2 = "{x: {1, 2, 3}. 2 < x}": cterm
val test3 =
   Const ("Groups.plus_class.plus", "nat => nat => nat") $ Bound 0 $
     Bound 0:
   term
val dest_pair_singleton = fn: term -> term
val dest_nat_pair_singleton = fn: term -> term * term
val dest_pair_singleton_T = fn: term -> (term * typ) * (term * typ)
val dest_pair_lambda = fn: term -> string * typ * string * typ * term * term
val foo = fn: term -> term * term * int * term * term
(if ?x <= ?y then if ?x = ?y then ?P else ?Q else ?R) =
(case compare ?x ?y of Eq => ?P | Lt => ?Q | Gt => ?R)
(if ?x <= ?y then if ?y = ?x then ?P else ?Q else ?R) =
(case compare ?x ?y of Eq => ?P | Lt => ?Q | Gt => ?R)
(if ?x <= ?y then if ?y <= ?x then ?P else ?Q else ?R) =
(case compare ?x ?y of Eq => ?P | Lt => ?Q | Gt => ?R)
(if ?x <= ?y then if ?x < ?y then ?Q else ?P else ?R) =
(case compare ?x ?y of Eq => ?P | Lt => ?Q | Gt => ?R)
(if ?x < ?y then ?Q else if ?x <= ?y then ?P else ?R) =
(case compare ?x ?y of Eq => ?P | Lt => ?Q | Gt => ?R)
(if ?x < ?y then ?Q else if ?y < ?x then ?R else ?P) =
(case compare ?x ?y of Eq => ?P | Lt => ?Q | Gt => ?R)
(if ?x < ?y then ?Q else if ?x = ?y then ?P else ?R) =
(case compare ?x ?y of Eq => ?P | Lt => ?Q | Gt => ?R)
(if ?x < ?y then ?Q else if ?y = ?x then ?P else ?R) =
(case compare ?x ?y of Eq => ?P | Lt => ?Q | Gt => ?R)
(if ?x = ?y then ?P else if ?y < ?x then ?R else ?Q) =
(case compare ?x ?y of Eq => ?P | Lt => ?Q | Gt => ?R)
(if ?x = ?y then ?P else if ?x < ?y then ?Q else ?R) =
(case compare ?x ?y of Eq => ?P | Lt => ?Q | Gt => ?R)
(if ?x = ?y then ?P else if ?y <= ?x then ?R else ?Q) =
(case compare ?x ?y of Eq => ?P | Lt => ?Q | Gt => ?R)
(if ?x = ?y then ?P else if ?x <= ?y then ?Q else ?R) =
(case compare ?x ?y of Eq => ?P | Lt => ?Q | Gt => ?R)
\<Sqinter> (Sup ` ?A) = \<Squnion> (Inf ` {f ` ?A |f. ALL Y:?A. f Y : Y})
(0 < length ?xs) = (?xs ~= [])
"merge"
  :: "'a"
"(3, 2)"
  :: "nat * nat"
Found termination order:
  "(%p. length (snd (snd p))) <*mlex*>
   (%p. length (fst (snd p))) <*mlex*> {}"
instantiation
  unit :: proper_interval
  proper_interval_unit == proper_interval ::
    unit option => unit option => bool
Found termination order: "{}"
instantiation
  bool :: proper_interval
  proper_interval_bool == proper_interval ::
    bool option => bool option => bool
Found termination order: "{}"
instantiation
  nat :: proper_interval
  proper_interval_nat == proper_interval :: nat option => nat option => bool
Found termination order: "{}"
instantiation
  int :: proper_interval
  proper_interval_int == proper_interval :: int option => int option => bool
Found termination order: "{}"
instantiation
  integer :: proper_interval
  proper_interval_integer == proper_interval ::
    integer option => integer option => bool
instantiation
  natural :: proper_interval
  proper_interval_natural == proper_interval ::
    natural option => natural option => bool
instantiation
  char :: proper_interval
  proper_interval_char == proper_interval ::
    char option => char option => bool
Found termination order: "{}"
### Ignoring duplicate rewrite rule:
### balance Empty ?s1 ?t1 Empty == Branch B Empty ?s1 ?t1 Empty
### Ignoring duplicate rewrite rule:
### balance (Branch B ?va1 ?vb1 ?vc1 ?vd1) ?s1 ?t1 Empty ==
### Branch B (Branch B ?va1 ?vb1 ?vc1 ?vd1) ?s1 ?t1 Empty
### Ignoring duplicate rewrite rule:
### balance Empty ?s1 ?t1 (Branch B ?va1 ?vb1 ?vc1 ?vd1) ==
### Branch B Empty ?s1 ?t1 (Branch B ?va1 ?vb1 ?vc1 ?vd1)
Found termination order: "{}"
instantiation
  Enum.finite_1 :: proper_interval
  proper_interval_finite_1 == proper_interval ::
    Enum.finite_1 option => Enum.finite_1 option => bool
instantiation
  Enum.finite_2 :: proper_interval
  proper_interval_finite_2 == proper_interval ::
    Enum.finite_2 option => Enum.finite_2 option => bool
Found termination order: "{}"
instantiation
  Enum.finite_3 :: proper_interval
  proper_interval_finite_3 == proper_interval ::
    Enum.finite_3 option => Enum.finite_3 option => bool
Found termination order: "{}"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
consts
  paint :: "color => ('a, 'b) rbt => ('a, 'b) rbt"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
class proper_intrvl = ord +
  fixes proper_interval :: "'a option => 'a option => bool"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
### theory "Containers.Set_Linorder"
### 7.935s elapsed time, 30.070s cpu time, 3.313s GC time
Loading theory "Containers.Collection_Order" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates" via "Draft.PDDL_STRIPS_Checker" via "Containers.Containers")
Found termination order: "(%p. size (snd (snd (snd p)))) <*mlex*> {}"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
class ccompare = type +
  fixes ccompare :: "('a => 'a => order) option"
  assumes "ccompare": "!!comp. ccompare = Some comp ==> comparator comp"
class ccompare = type +
  fixes ccompare :: "('a => 'a => order) option"
  assumes "ccompare": "!!comp. ccompare = Some comp ==> comparator comp"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
signature CCOMPARE_GENERATOR =
  sig
    val ccompare_instance_via_comparator: string -> theory -> theory
    val ccompare_instance_via_compare: string -> theory -> theory
    val derive_no_ccompare: string -> theory -> theory
  end
structure CCompare_Generator: CCOMPARE_GENERATOR
deriving "compare_order" instance for type "Enum.finite_1"
deriving "compare" instance for type "Enum.finite_1"
deriving "compare_order" instance for type "Enum.finite_2"
deriving "compare" instance for type "Enum.finite_2"
deriving "compare_order" instance for type "Enum.finite_3"
deriving "compare" instance for type "Enum.finite_3"
deriving "compare_order" instance for type "Code_Numeral.natural"
deriving "compare" instance for type "Code_Numeral.natural"
deriving "compare_order" instance for type "String.literal"
deriving "compare" instance for type "String.literal"
deriving "ccompare_order" instance for type "Product_Type.unit" via compare_order
derived is_ccompare_unit-lemma
deriving "ccompare_order" instance for type "HOL.bool" via compare_order
derived is_ccompare_bool-lemma
deriving "ccompare_order" instance for type "Nat.nat" via compare_order
derived is_ccompare_nat-lemma
deriving "ccompare_order" instance for type "Int.int" via compare_order
derived is_ccompare_int-lemma
deriving "ccompare_order" instance for type "Enum.finite_1" via compare_order
derived is_ccompare_finite_1-lemma
deriving "ccompare_order" instance for type "Enum.finite_2" via compare_order
derived is_ccompare_finite_2-lemma
deriving "ccompare_order" instance for type "Enum.finite_3" via compare_order
derived is_ccompare_finite_3-lemma
deriving "ccompare_order" instance for type "Code_Numeral.integer" via compare_order
derived is_ccompare_integer-lemma
deriving "ccompare_order" instance for type "Code_Numeral.natural" via compare_order
derived is_ccompare_natural-lemma
deriving "ccompare_order" instance for type "String.char" via compare_order
derived is_ccompare_char-lemma
deriving "ccompare_order" instance for type "String.literal" via compare_order
derived is_ccompare_literal-lemma
use None as trivial implementation of ccompare for type finite_4
registered finite_4 in class ccompare
use None as trivial implementation of ccompare for type finite_5
registered finite_5 in class ccompare
deriving "ccompare" instance for type "Sum_Type.sum"
derived is_ccompare_sum-lemma
deriving "ccompare" instance for type "List.list"
derived is_ccompare_list-lemma
deriving "ccompare" instance for type "Option.option"
derived is_ccompare_option-lemma
deriving "ccompare" instance for type "Product_Type.prod"
derived is_ccompare_prod-lemma
use None as trivial implementation of ccompare for type fun
registered fun in class ccompare
instantiation
  set :: (ccompare) ccompare
  ccompare_set == ccompare :: ('a set => 'a set => order) option
use None as trivial implementation of ccompare for type pred
registered pred in class ccompare
class cproper_interval = ccompare +
  fixes cproper_interval :: "'a option => 'a option => bool"
  assumes
    "cproper_interval":
      "[| ID ccompare ~= None; finite UNIV |]
       ==> class.proper_interval cless cproper_interval"
instantiation
  unit :: cproper_interval
  cproper_interval_unit == cproper_interval ::
    unit option => unit option => bool
instantiation
  bool :: cproper_interval
  cproper_interval_bool == cproper_interval ::
    bool option => bool option => bool
instantiation
  nat :: cproper_interval
  cproper_interval_nat == cproper_interval ::
    nat option => nat option => bool
instantiation
  int :: cproper_interval
  cproper_interval_int == cproper_interval ::
    int option => int option => bool
instantiation
  integer :: cproper_interval
  cproper_interval_integer == cproper_interval ::
    integer option => integer option => bool
instantiation
  natural :: cproper_interval
  cproper_interval_natural == cproper_interval ::
    natural option => natural option => bool
instantiation
  char :: cproper_interval
  cproper_interval_char == cproper_interval ::
    char option => char option => bool
instantiation
  Enum.finite_1 :: cproper_interval
  cproper_interval_finite_1 == cproper_interval ::
    Enum.finite_1 option => Enum.finite_1 option => bool
instantiation
  Enum.finite_2 :: cproper_interval
  cproper_interval_finite_2 == cproper_interval ::
    Enum.finite_2 option => Enum.finite_2 option => bool
instantiation
  Enum.finite_3 :: cproper_interval
  cproper_interval_finite_3 == cproper_interval ::
    Enum.finite_3 option => Enum.finite_3 option => bool
instantiation
  Enum.finite_4 :: cproper_interval
  cproper_interval_finite_4 == cproper_interval ::
    Enum.finite_4 option => Enum.finite_4 option => bool
instantiation
  Enum.finite_5 :: cproper_interval
  cproper_interval_finite_5 == cproper_interval ::
    Enum.finite_5 option => Enum.finite_5 option => bool
instantiation
  sum :: (cproper_interval, cproper_interval) cproper_interval
  cproper_interval_sum == cproper_interval ::
    ('a + 'b) option => ('a + 'b) option => bool
Found termination order: "{}"
Found termination order: "{}"
class order = preorder +
  assumes "order_antisym": "!!x y. [| x <= y; y <= x |] ==> x = y"
instantiation
  prod :: (cproper_interval, cproper_interval) cproper_interval
  cproper_interval_prod == cproper_interval ::
    ('a * 'b) option => ('a * 'b) option => bool
Found termination order: "{}"
instantiation
  list :: (ccompare) cproper_interval
  cproper_interval_list == cproper_interval ::
    'a list option => 'a list option => bool
instantiation
  String.literal :: cproper_interval
  cproper_interval_literal == cproper_interval ::
    String.literal option => String.literal option => bool
instantiation
  option :: (cproper_interval) cproper_interval
  cproper_interval_option == cproper_interval ::
    'a option option => 'a option option => bool
Found termination order: "{}"
instantiation
  set :: (cproper_interval) cproper_interval
  cproper_interval_set == cproper_interval ::
    'a set option => 'a set option => bool
### Not an equation, in theorem:
### cproper_interval_set_dom (None, None) ==> cproper_interval None None == True
### Not an equation, in theorem:
### cproper_interval_set_dom (None, Some ?B) ==>
### cproper_interval None (Some ?B) == ?B ~= {}
### Not an equation, in theorem:
### cproper_interval_set_dom (Some ?A, None) ==>
### cproper_interval (Some ?A) None == ?A ~= UNIV
### Not an equation, in theorem:
### cproper_interval_set_dom (Some ?A, Some ?B) ==>
### cproper_interval (Some ?A) (Some ?B) ==
### finite UNIV & (EX C. cless ?A C & cless C ?B)
Found termination order: "{}"
instantiation
  fun :: (type, type) cproper_interval
  cproper_interval_fun == cproper_interval ::
    ('a => 'b) option => ('a => 'b) option => bool
### theory "Containers.Collection_Order"
### 1.654s elapsed time, 5.374s cpu time, 0.692s GC time
Found termination order: "{}"
class order = preorder +
  assumes "order_antisym": "!!x y. [| x <= y; y <= x |] ==> x = y"
Found termination order:
  "(%p. size (snd p)) <*mlex*> (%p. size (fst p)) <*mlex*> {}"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
Found termination order: "{}"
Found termination order: "size <*mlex*> {}"
locale ast_domain
  fixes D :: "ast_domain"
Found termination order: "{}"
Found termination order: "(%p. size_list size (fst (snd p))) <*mlex*> {}"
Found termination order: "{}"
locale ast_domain
  fixes D :: "ast_domain"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "size <*mlex*> {}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order:
  "case_sum (%p. size (fst (snd p)))
    (case_sum (%p. size (snd (snd (snd (snd p)))))
      (%p. size (snd p))) <*mlex*>
   case_sum (%x. Suc 0) (%x. 0) <*mlex*>
   case_sum (%x. 0) (case_sum (%x. Suc 0) (%x. 0)) <*mlex*> {}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
locale ast_problem
  fixes P :: "ast_problem"
Found termination order: "{}"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
locale wf_ast_domain
  fixes D :: "ast_domain"
  assumes "wf_ast_domain D"
locale wf_ast_problem
  fixes P :: "ast_problem"
  assumes "wf_ast_problem P"
locale ast_domain
  fixes D :: "ast_domain"
Found termination order: "{}"
Found termination order: "{}"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
consts
  rbt_map_entry :: "'a => ('b => 'b) => ('a, 'b) rbt => ('a, 'b) rbt"
locale ast_problem
  fixes P :: "ast_problem"
Found termination order: "{}"
consts
  map :: "('a => 'b => 'c) => ('a, 'b) rbt => ('a, 'c) rbt"
Found termination order: "{}"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
locale ast_problem
  fixes P :: "ast_problem"
Found termination order: "{}"
Found termination order: "(%p. size (fst (snd (snd p)))) <*mlex*> {}"
locale ast_problem
  fixes P :: "ast_problem"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
locale wf_ast_problem
  fixes P :: "ast_problem"
  assumes "wf_ast_problem P"
### theory "Draft.PDDL_STRIPS_Semantics"
### 10.298s elapsed time, 28.350s cpu time, 6.777s GC time
Found termination order:
  "case_sum (%p. size (fst p)) (%p. size (fst p)) <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
Found termination order: "{}"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
### Ambiguous input (line 1808 of "~~/src/HOL/Library/RBT_Impl.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("_applC" ("_position" sorted)
###         ("_applC" ("_position" map)
###           ("_cargs" ("_position" fst) ("_position" xs)))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("_applC" ("_position" sorted)
###           ("_applC" ("_position" map)
###             ("_cargs" ("_position" fst) ("_position" ys)))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("_applC" ("_position" map_of)
###         ("_cargs"
###           ("_applC" ("_position" sunion_with)
###             ("_cargs" ("_position" f)
###               ("_cargs" ("_position" xs) ("_position" ys))))
###           ("_position" k)))
###       ("_case_syntax"
###         ("_applC" ("_position" map_of)
###           ("_cargs" ("_position" xs) ("_position" k)))
###         ("_case2"
###           ("_case1" ("_position" None)
###             ("_applC" ("_position" map_of)
###               ("_cargs" ("_position" ys) ("_position" k))))
###           ("_case1" ("_applC" ("_position" Some) ("_position" v))
###             ("_case_syntax"
###               ("_applC" ("_position" map_of)
###                 ("_cargs" ("_position" ys) ("_position" k)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Some) ("_position" v)))
###                 ("_case1" ("_applC" ("_position" Some) ("_position" w))
###                   ("_applC" ("_position" Some)
###                     ("_applC" ("_position" f)
###                       ("_cargs" ("_position" k)
###                         ("_cargs" ("_position" v)
###                           ("_position" w))))))))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("_applC" ("_position" sorted)
###         ("_applC" ("_position" map)
###           ("_cargs" ("_position" fst) ("_position" xs)))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("_applC" ("_position" sorted)
###           ("_applC" ("_position" map)
###             ("_cargs" ("_position" fst) ("_position" ys)))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("_applC" ("_position" map_of)
###         ("_cargs"
###           ("_applC" ("_position" sunion_with)
###             ("_cargs" ("_position" f)
###               ("_cargs" ("_position" xs) ("_position" ys))))
###           ("_position" k)))
###       ("_case_syntax"
###         ("_applC" ("_position" map_of)
###           ("_cargs" ("_position" xs) ("_position" k)))
###         ("_case2"
###           ("_case1" ("_position" None)
###             ("_applC" ("_position" map_of)
###               ("_cargs" ("_position" ys) ("_position" k))))
###           ("_case2"
###             ("_case1" ("_applC" ("_position" Some) ("_position" v))
###               ("_case_syntax"
###                 ("_applC" ("_position" map_of)
###                   ("_cargs" ("_position" ys) ("_position" k)))
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Some) ("_position" v)))))
###             ("_case1" ("_applC" ("_position" Some) ("_position" w))
###               ("_applC" ("_position" Some)
###                 ("_applC" ("_position" f)
###                   ("_cargs" ("_position" k)
###                     ("_cargs" ("_position" v) ("_position" w))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order:
  "(%p. size (snd p)) <*mlex*> (%p. size (fst p)) <*mlex*> {}"
Found termination order: "(%p. size (snd (snd (snd p)))) <*mlex*> {}"
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
Found termination order: "{}"
Found termination order: "size <*mlex*> {}"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
### Ambiguous input (line 2563 of "~~/src/HOL/Library/RBT_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" rbt_lookup)
###       ("_cargs"
###         ("_applC" ("_position" fold)
###           ("_cargs"
###             ("_applC" ("_position" rbt_insert_with_key) ("_position" f))
###             ("_cargs" ("_position" t1) ("_position" t2))))
###         ("_position" k)))
###     ("_case_syntax"
###       ("_applC" ("_position" rbt_lookup)
###         ("_cargs" ("_position" t1) ("_position" k)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" rbt_lookup)
###             ("_cargs" ("_position" t2) ("_position" k))))
###         ("_case1" ("_applC" ("_position" Some) ("_position" v))
###           ("_case_syntax"
###             ("_applC" ("_position" rbt_lookup)
###               ("_cargs" ("_position" t2) ("_position" k)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Some) ("_position" v)))
###               ("_case1" ("_applC" ("_position" Some) ("_position" w))
###                 ("_applC" ("_position" Some)
###                   ("_applC" ("_position" f)
###                     ("_cargs" ("_position" k)
###                       ("_cargs" ("_position" w) ("_position" v)))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" rbt_lookup)
###       ("_cargs"
###         ("_applC" ("_position" fold)
###           ("_cargs"
###             ("_applC" ("_position" rbt_insert_with_key) ("_position" f))
###             ("_cargs" ("_position" t1) ("_position" t2))))
###         ("_position" k)))
###     ("_case_syntax"
###       ("_applC" ("_position" rbt_lookup)
###         ("_cargs" ("_position" t1) ("_position" k)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" rbt_lookup)
###             ("_cargs" ("_position" t2) ("_position" k))))
###         ("_case2"
###           ("_case1" ("_applC" ("_position" Some) ("_position" v))
###             ("_case_syntax"
###               ("_applC" ("_position" rbt_lookup)
###                 ("_cargs" ("_position" t2) ("_position" k)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Some) ("_position" v)))))
###           ("_case1" ("_applC" ("_position" Some) ("_position" w))
###             ("_applC" ("_position" Some)
###               ("_applC" ("_position" f)
###                 ("_cargs" ("_position" k)
###                   ("_cargs" ("_position" w) ("_position" v)))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
### Ambiguous input (line 2939 of "~~/src/HOL/Library/RBT_Impl.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("_applC" ("_position" rbt_sorted) ("_position" t1)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("_applC" ("_position" rbt_sorted) ("_position" t2)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("_applC" ("_position" rbt_lookup)
###         ("_cargs"
###           ("_applC" ("_position" rbt_union_with_key)
###             ("_cargs" ("_position" f)
###               ("_cargs" ("_position" t1) ("_position" t2))))
###           ("_position" k)))
###       ("_case_syntax"
###         ("_applC" ("_position" rbt_lookup)
###           ("_cargs" ("_position" t1) ("_position" k)))
###         ("_case2"
###           ("_case1" ("_position" None)
###             ("_applC" ("_position" rbt_lookup)
###               ("_cargs" ("_position" t2) ("_position" k))))
###           ("_case1" ("_applC" ("_position" Some) ("_position" v))
###             ("_case_syntax"
###               ("_applC" ("_position" rbt_lookup)
###                 ("_cargs" ("_position" t2) ("_position" k)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Some) ("_position" v)))
###                 ("_case1" ("_applC" ("_position" Some) ("_position" w))
###                   ("_applC" ("_position" Some)
###                     ("_applC" ("_position" f)
###                       ("_cargs" ("_position" k)
###                         ("_cargs" ("_position" v)
###                           ("_position" w))))))))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("_applC" ("_position" rbt_sorted) ("_position" t1)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("_applC" ("_position" rbt_sorted) ("_position" t2)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("_applC" ("_position" rbt_lookup)
###         ("_cargs"
###           ("_applC" ("_position" rbt_union_with_key)
###             ("_cargs" ("_position" f)
###               ("_cargs" ("_position" t1) ("_position" t2))))
###           ("_position" k)))
###       ("_case_syntax"
###         ("_applC" ("_position" rbt_lookup)
###           ("_cargs" ("_position" t1) ("_position" k)))
###         ("_case2"
###           ("_case1" ("_position" None)
###             ("_applC" ("_position" rbt_lookup)
###               ("_cargs" ("_position" t2) ("_position" k))))
###           ("_case2"
###             ("_case1" ("_applC" ("_position" Some) ("_position" v))
###               ("_case_syntax"
###                 ("_applC" ("_position" rbt_lookup)
###                   ("_cargs" ("_position" t2) ("_position" k)))
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Some) ("_position" v)))))
###             ("_case1" ("_applC" ("_position" Some) ("_position" w))
###               ("_applC" ("_position" Some)
###                 ("_applC" ("_position" f)
###                   ("_cargs" ("_position" k)
###                     ("_cargs" ("_position" v) ("_position" w))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2972 of "~~/src/HOL/Library/RBT_Impl.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("_applC" ("_position" rbt_sorted) ("_position" t1)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("_applC" ("_position" rbt_sorted) ("_position" t2)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("_applC" ("_position" rbt_lookup)
###         ("_cargs"
###           ("_applC" ("_position" rbt_inter_with_key)
###             ("_cargs" ("_position" f)
###               ("_cargs" ("_position" t1) ("_position" t2))))
###           ("_position" k)))
###       ("_case_syntax"
###         ("_applC" ("_position" rbt_lookup)
###           ("_cargs" ("_position" t1) ("_position" k)))
###         ("_case2" ("_case1" ("_position" None) ("_position" None))
###           ("_case1" ("_applC" ("_position" Some) ("_position" v))
###             ("_case_syntax"
###               ("_applC" ("_position" rbt_lookup)
###                 ("_cargs" ("_position" t2) ("_position" k)))
###               ("_case2" ("_case1" ("_position" None) ("_position" None))
###                 ("_case1" ("_applC" ("_position" Some) ("_position" w))
###                   ("_applC" ("_position" Some)
###                     ("_applC" ("_position" f)
###                       ("_cargs" ("_position" k)
###                         ("_cargs" ("_position" v)
###                           ("_position" w))))))))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("_applC" ("_position" rbt_sorted) ("_position" t1)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("_applC" ("_position" rbt_sorted) ("_position" t2)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("_applC" ("_position" rbt_lookup)
###         ("_cargs"
###           ("_applC" ("_position" rbt_inter_with_key)
###             ("_cargs" ("_position" f)
###               ("_cargs" ("_position" t1) ("_position" t2))))
###           ("_position" k)))
###       ("_case_syntax"
###         ("_applC" ("_position" rbt_lookup)
###           ("_cargs" ("_position" t1) ("_position" k)))
###         ("_case2" ("_case1" ("_position" None) ("_position" None))
###           ("_case2"
###             ("_case1" ("_applC" ("_position" Some) ("_position" v))
###               ("_case_syntax"
###                 ("_applC" ("_position" rbt_lookup)
###                   ("_cargs" ("_position" t2) ("_position" k)))
###                 ("_case1" ("_position" None) ("_position" None))))
###             ("_case1" ("_applC" ("_position" Some) ("_position" w))
###               ("_applC" ("_position" Some)
###                 ("_applC" ("_position" f)
###                   ("_cargs" ("_position" k)
###                     ("_cargs" ("_position" v) ("_position" w))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Code generator: dropping subsumed code equation
### keys (Branch ?c ?l ?k ?v ?r) == keys ?l @ ?k # keys ?r
### Code generator: dropping subsumed code equation
### keys Empty == []
### theory "HOL-Library.RBT_Impl"
### 36.062s elapsed time, 88.246s cpu time, 20.156s GC time
Loading theory "Containers.RBT_ext" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates" via "Draft.PDDL_STRIPS_Checker" via "Containers.Containers" via "Containers.Mapping_Impl" via "Containers.RBT_Mapping2")
Loading theory "Deriving.RBT_Comparator_Impl" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates" via "Draft.PDDL_STRIPS_Checker" via "Containers.Containers" via "Containers.Mapping_Impl" via "Containers.RBT_Mapping2")
consts
  rbt_comp_lookup :: "('a, 'b) rbt => 'a => 'b option"
Found termination order: "(%p. size (snd (snd (snd p)))) <*mlex*> {}"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
### Dropping global mixfix syntax: "less_eq_prod'" (infix \<open>\<sqsubseteq>\<close> 50)
### Dropping global mixfix syntax: "less_prod'" (infix \<open>\<sqsubset>\<close> 50)
consts
  RBT_Impl_diag :: "('a, 'b) rbt => ('a * 'a, 'b) rbt"
Found termination order: "{}"
### Missing patterns in function definition:
### rbt_keys_next ([], rbt.Empty) = undefined
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
### Missing patterns in function definition:
### rbt_entries_next ([], rbt.Empty) = undefined
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
### theory "Containers.RBT_ext"
### 1.348s elapsed time, 3.656s cpu time, 0.479s GC time
Found termination order:
  "case_sum (%p. size (fst (snd p)))
    (case_sum (%p. size (snd (snd (snd (snd p)))))
      (%p. size (snd p))) <*mlex*>
   case_sum (%x. Suc 0) (%x. 0) <*mlex*>
   case_sum (%x. 0) (case_sum (%x. Suc 0) (%x. 0)) <*mlex*> {}"
consts
  rbt_comp_map_entry :: "'a => ('b => 'b) => ('a, 'b) rbt => ('a, 'b) rbt"
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
### theory "Deriving.RBT_Comparator_Impl"
### 3.927s elapsed time, 6.512s cpu time, 0.827s GC time
Loading theory "Containers.RBT_Mapping2" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates" via "Draft.PDDL_STRIPS_Checker" via "Containers.Containers" via "Containers.Mapping_Impl")
### Ambiguous input (line 247 of "$AFP/Containers/RBT_Mapping2.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" lookup)
###       ("_applC" ("_position" meet)
###         ("_cargs" ("_position" f)
###           ("_cargs"
###             ("_constrain" ("_position" t1)
###               ("_tappl" ("_position_sort" 'a) ("_position_sort" 'b)
###                 ("_type_name" mapping_rbt)))
###             ("_position" t2)))))
###     ("_lambda" ("_position" k)
###       ("_case_syntax"
###         ("_applC" ("_position" lookup)
###           ("_cargs" ("_position" t1) ("_position" k)))
###         ("_case2" ("_case1" ("_position" None) ("_position" None))
###           ("_case1" ("_applC" ("_position" Some) ("_position" v1))
###             ("_case_syntax"
###               ("_applC" ("_position" lookup)
###                 ("_cargs" ("_position" t2) ("_position" k)))
###               ("_case2" ("_case1" ("_position" None) ("_position" None))
###                 ("_case1" ("_applC" ("_position" Some) ("_position" v2))
###                   ("_applC" ("_position" Some)
###                     ("_applC" ("_position" f)
###                       ("_cargs" ("_position" k)
###                         ("_cargs" ("_position" v1)
###                           ("_position" v2))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" lookup)
###       ("_applC" ("_position" meet)
###         ("_cargs" ("_position" f)
###           ("_cargs"
###             ("_constrain" ("_position" t1)
###               ("_tappl" ("_position_sort" 'a) ("_position_sort" 'b)
###                 ("_type_name" mapping_rbt)))
###             ("_position" t2)))))
###     ("_lambda" ("_position" k)
###       ("_case_syntax"
###         ("_applC" ("_position" lookup)
###           ("_cargs" ("_position" t1) ("_position" k)))
###         ("_case2" ("_case1" ("_position" None) ("_position" None))
###           ("_case2"
###             ("_case1" ("_applC" ("_position" Some) ("_position" v1))
###               ("_case_syntax"
###                 ("_applC" ("_position" lookup)
###                   ("_cargs" ("_position" t2) ("_position" k)))
###                 ("_case1" ("_position" None) ("_position" None))))
###             ("_case1" ("_applC" ("_position" Some) ("_position" v2))
###               ("_applC" ("_position" Some)
###                 ("_applC" ("_position" f)
###                   ("_cargs" ("_position" k)
###                     ("_cargs" ("_position" v1) ("_position" v2))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "Containers.RBT_Mapping2"
### 0.757s elapsed time, 0.761s cpu time, 0.000s GC time
Loading theory "Containers.RBT_Set2" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates" via "Draft.PDDL_STRIPS_Checker" via "Containers.Containers" via "Containers.Mapping_Impl" via "Containers.Set_Impl")
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
### theory "Containers.RBT_Set2"
### 0.947s elapsed time, 1.128s cpu time, 0.239s GC time
Loading theory "Containers.Set_Impl" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates" via "Draft.PDDL_STRIPS_Checker" via "Containers.Containers" via "Containers.Mapping_Impl")
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
Found termination order: "length <*mlex*> {}"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
structure Set_Complement_Eqs: NAMED_THMS
### Code generator: dropping subsumed code equation
### Collect ?P == set (filter ?P enum_class.enum)
### Ambiguous input (line 739 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Set.union" ("_applC" ("_position" RBT_set) ("_position" rbt))
###       ("_applC" ("_position" DList_set) ("_position" dxs)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''union RBT_set DList_set: ccompare = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Set.union"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt))
###                   ("_applC" ("_position" DList_set) ("_position" dxs)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'b)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position" ''union RBT_set DList_set: ceq = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Set.union"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs)))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_applC" ("_position" RBT_set)
###                   ("_applC" ("_position" DList_Set.fold)
###                     ("_cargs" ("_position" RBT_Set2.insert)
###                       ("_cargs" ("_position" dxs)
###                         ("_position" rbt)))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Set.union" ("_applC" ("_position" RBT_set) ("_position" rbt))
###       ("_applC" ("_position" DList_set) ("_position" dxs)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''union RBT_set DList_set: ccompare = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Set.union"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt))
###                   ("_applC" ("_position" DList_set) ("_position" dxs)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'b)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position" ''union RBT_set DList_set: ceq = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Set.union"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs)))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_applC" ("_position" RBT_set)
###               ("_applC" ("_position" DList_Set.fold)
###                 ("_cargs" ("_position" RBT_Set2.insert)
###                   ("_cargs" ("_position" dxs) ("_position" rbt)))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 744 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Set.union"
###       ("_applC" ("_position" DList_set) ("_position" dxs))
###       ("_applC" ("_position" RBT_set) ("_position" rbt)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''union DList_set RBT_set: ccompare = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Set.union"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt))
###                   ("_applC" ("_position" DList_set) ("_position" dxs)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'b)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position" ''union DList_set RBT_set: ceq = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Set.union"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs)))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_applC" ("_position" RBT_set)
###                   ("_applC" ("_position" DList_Set.fold)
###                     ("_cargs" ("_position" RBT_Set2.insert)
###                       ("_cargs" ("_position" dxs)
###                         ("_position" rbt)))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Set.union"
###       ("_applC" ("_position" DList_set) ("_position" dxs))
###       ("_applC" ("_position" RBT_set) ("_position" rbt)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''union DList_set RBT_set: ccompare = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Set.union"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt))
###                   ("_applC" ("_position" DList_set) ("_position" dxs)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'b)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position" ''union DList_set RBT_set: ceq = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Set.union"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs)))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_applC" ("_position" RBT_set)
###               ("_applC" ("_position" DList_Set.fold)
###                 ("_cargs" ("_position" RBT_Set2.insert)
###                   ("_cargs" ("_position" dxs) ("_position" rbt)))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 823 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Set.inter"
###       ("_applC" ("_position" DList_set) ("_position" dxs))
###       ("_applC" ("_position" RBT_set) ("_position" rbt)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''inter DList_set RBT_set: ccompare = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Set.inter"
###                   ("_applC" ("_position" DList_set) ("_position" dxs))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'b)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position" ''inter DList_set RBT_set: ceq = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Set.inter"
###                         ("_applC" ("_position" DList_set) ("_position" dxs))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt)))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_applC" ("_position" RBT_set)
###                   ("_applC" ("_position" RBT_Set2.inter_list)
###                     ("_cargs" ("_position" rbt)
###                       ("_applC" ("_position" list_of_dlist)
###                         ("_position" dxs)))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Set.inter"
###       ("_applC" ("_position" DList_set) ("_position" dxs))
###       ("_applC" ("_position" RBT_set) ("_position" rbt)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''inter DList_set RBT_set: ccompare = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Set.inter"
###                   ("_applC" ("_position" DList_set) ("_position" dxs))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'b)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position" ''inter DList_set RBT_set: ceq = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Set.inter"
###                         ("_applC" ("_position" DList_set) ("_position" dxs))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt)))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_applC" ("_position" RBT_set)
###               ("_applC" ("_position" RBT_Set2.inter_list)
###                 ("_cargs" ("_position" rbt)
###                   ("_applC" ("_position" list_of_dlist)
###                     ("_position" dxs)))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 838 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Set.inter" ("_applC" ("_position" RBT_set) ("_position" rbt))
###       ("_applC" ("_position" DList_set) ("_position" dxs)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''inter RBT_set DList_set: ccompare = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Set.inter"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt))
###                   ("_applC" ("_position" DList_set) ("_position" dxs)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'b)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position" ''inter RBT_set DList_set: ceq = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Set.inter"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs)))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_applC" ("_position" RBT_set)
###                   ("_applC" ("_position" RBT_Set2.inter_list)
###                     ("_cargs" ("_position" rbt)
###                       ("_applC" ("_position" list_of_dlist)
###                         ("_position" dxs)))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Set.inter" ("_applC" ("_position" RBT_set) ("_position" rbt))
###       ("_applC" ("_position" DList_set) ("_position" dxs)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''inter RBT_set DList_set: ccompare = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Set.inter"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt))
###                   ("_applC" ("_position" DList_set) ("_position" dxs)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'b)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position" ''inter RBT_set DList_set: ceq = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Set.inter"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs)))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_applC" ("_position" RBT_set)
###               ("_applC" ("_position" RBT_Set2.inter_list)
###                 ("_cargs" ("_position" rbt)
###                   ("_applC" ("_position" list_of_dlist)
###                     ("_position" dxs)))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Code generator: dropping subsumed code equation
### Inf ?A ?x == INF f\<in>?A. f ?x
### Code generator: dropping subsumed code equation
### Sup ?A ?x == SUP f\<in>?A. f ?x
### Ambiguous input (line 951 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" csorted_list_of_set)
###       ("_applC" ("_position" DList_set) ("_position" dxs)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'b)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''csorted_list_of_set DList_set: ceq = None''))
###               ("_lambda" ("_idtdummy")
###                 ("_applC" ("_position" csorted_list_of_set)
###                   ("_applC" ("_position" DList_set) ("_position" dxs)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''csorted_list_of_set DList_set: ccompare = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("_applC" ("_position" csorted_list_of_set)
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs)))))))
###               ("_case1" ("_applC" ("_position" Some) ("_position" c))
###                 ("_applC" ("_position" ord.quicksort)
###                   ("_cargs"
###                     ("_applC" ("_position" lt_of_comp) ("_position" c))
###                     ("_applC" ("_position" list_of_dlist)
###                       ("_position" dxs))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" csorted_list_of_set)
###       ("_applC" ("_position" DList_set) ("_position" dxs)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'b)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''csorted_list_of_set DList_set: ceq = None''))
###               ("_lambda" ("_idtdummy")
###                 ("_applC" ("_position" csorted_list_of_set)
###                   ("_applC" ("_position" DList_set) ("_position" dxs)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'b)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''csorted_list_of_set DList_set: ccompare = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("_applC" ("_position" csorted_list_of_set)
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs)))))))))
###           ("_case1" ("_applC" ("_position" Some) ("_position" c))
###             ("_applC" ("_position" ord.quicksort)
###               ("_cargs" ("_applC" ("_position" lt_of_comp) ("_position" c))
###                 ("_applC" ("_position" list_of_dlist)
###                   ("_position" dxs))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
Found termination order: "(%p. length (snd (snd p))) <*mlex*> {}"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
### Code generator: dropping subsumed code equation
### set_eq ?A ?B == ?A <= ?B & ?B <= ?A
### Ambiguous input (line 1326 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" the_elem)
###       ("_applC" ("_position" DList_set) ("_position" dxs)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal" ("_position" ''the_elem DList_set: ceq = None''))
###               ("_lambda" ("_idtdummy")
###                 ("_applC" ("_position" the_elem)
###                   ("_applC" ("_position" DList_set) ("_position" dxs)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" list_of_dlist) ("_position" dxs))
###             ("_case2" ("_case1" ("_list" ("_position" x)) ("_position" x))
###               ("_case1" ("\<^const>Pure.dummy_pattern")
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position" ''the_elem DList_set: not unique''))
###                     ("_lambda" ("_idtdummy")
###                       ("_applC" ("_position" the_elem)
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" the_elem)
###       ("_applC" ("_position" DList_set) ("_position" dxs)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal" ("_position" ''the_elem DList_set: ceq = None''))
###               ("_lambda" ("_idtdummy")
###                 ("_applC" ("_position" the_elem)
###                   ("_applC" ("_position" DList_set) ("_position" dxs)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" list_of_dlist) ("_position" dxs))
###               ("_case1" ("_list" ("_position" x)) ("_position" x))))
###           ("_case1" ("\<^const>Pure.dummy_pattern")
###             ("_applC" ("_position" Code.abort)
###               ("_cargs"
###                 ("_Literal"
###                   ("_position" ''the_elem DList_set: not unique''))
###                 ("_lambda" ("_idtdummy")
###                   ("_applC" ("_position" the_elem)
###                     ("_applC" ("_position" DList_set)
###                       ("_position" dxs))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1331 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" the_elem)
###       ("_applC" ("_position" RBT_set) ("_position" rbt)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''the_elem RBT_set: ccompare = None''))
###               ("_lambda" ("_idtdummy")
###                 ("_applC" ("_position" the_elem)
###                   ("_applC" ("_position" RBT_set) ("_position" rbt)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" RBT_Mapping2.impl_of) ("_position" rbt))
###             ("_case2"
###               ("_case1"
###                 ("_applC" ("_position" RBT_Impl.Branch)
###                   ("_cargs" ("\<^const>Pure.dummy_pattern")
###                     ("_cargs" ("_position" RBT_Impl.Empty)
###                       ("_cargs" ("_position" x)
###                         ("_cargs" ("\<^const>Pure.dummy_pattern")
###                           ("_position" RBT_Impl.Empty))))))
###                 ("_position" x))
###               ("_case1" ("\<^const>Pure.dummy_pattern")
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position" ''the_elem RBT_set: not unique''))
###                     ("_lambda" ("_idtdummy")
###                       ("_applC" ("_position" the_elem)
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" the_elem)
###       ("_applC" ("_position" RBT_set) ("_position" rbt)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''the_elem RBT_set: ccompare = None''))
###               ("_lambda" ("_idtdummy")
###                 ("_applC" ("_position" the_elem)
###                   ("_applC" ("_position" RBT_set) ("_position" rbt)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" RBT_Mapping2.impl_of)
###                 ("_position" rbt))
###               ("_case1"
###                 ("_applC" ("_position" RBT_Impl.Branch)
###                   ("_cargs" ("\<^const>Pure.dummy_pattern")
###                     ("_cargs" ("_position" RBT_Impl.Empty)
###                       ("_cargs" ("_position" x)
###                         ("_cargs" ("\<^const>Pure.dummy_pattern")
###                           ("_position" RBT_Impl.Empty))))))
###                 ("_position" x))))
###           ("_case1" ("\<^const>Pure.dummy_pattern")
###             ("_applC" ("_position" Code.abort)
###               ("_cargs"
###                 ("_Literal" ("_position" ''the_elem RBT_set: not unique''))
###                 ("_lambda" ("_idtdummy")
###                   ("_applC" ("_position" the_elem)
###                     ("_applC" ("_position" RBT_set)
###                       ("_position" rbt))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1387 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" Product_Type.product)
###       ("_cargs" ("_applC" ("_position" DList_set) ("_position" dxs))
###         ("_applC" ("_position" DList_set) ("_position" dys))))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''product DList_set DList_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("_applC" ("_position" Product_Type.product)
###                   ("_cargs"
###                     ("_applC" ("_position" DList_set) ("_position" dxs))
###                     ("_applC" ("_position" DList_set)
###                       ("_position" dys))))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'b)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''product DList_set DList_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("_applC" ("_position" Product_Type.product)
###                         ("_cargs"
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs))
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dys))))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_applC" ("_position" DList_set)
###                   ("_applC" ("_position" DList_Set.product)
###                     ("_cargs" ("_position" dxs) ("_position" dys))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" Product_Type.product)
###       ("_cargs" ("_applC" ("_position" DList_set) ("_position" dxs))
###         ("_applC" ("_position" DList_set) ("_position" dys))))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''product DList_set DList_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("_applC" ("_position" Product_Type.product)
###                   ("_cargs"
###                     ("_applC" ("_position" DList_set) ("_position" dxs))
###                     ("_applC" ("_position" DList_set)
###                       ("_position" dys))))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'b)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''product DList_set DList_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("_applC" ("_position" Product_Type.product)
###                         ("_cargs"
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs))
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dys))))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_applC" ("_position" DList_set)
###               ("_applC" ("_position" DList_Set.product)
###                 ("_cargs" ("_position" dxs) ("_position" dys))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1403 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" Product_Type.product)
###       ("_cargs" ("_applC" ("_position" RBT_set) ("_position" rbt1))
###         ("_applC" ("_position" RBT_set) ("_position" rbt2))))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'c)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''product RBT_set RBT_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("_applC" ("_position" Product_Type.product)
###                   ("_cargs"
###                     ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                     ("_applC" ("_position" RBT_set)
###                       ("_position" rbt2))))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'd)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''product RBT_set RBT_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("_applC" ("_position" Product_Type.product)
###                         ("_cargs"
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt1))
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt2))))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_applC" ("_position" RBT_set)
###                   ("_applC" ("_position" RBT_Set2.product)
###                     ("_cargs" ("_position" rbt1)
###                       ("_position" rbt2))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" Product_Type.product)
###       ("_cargs" ("_applC" ("_position" RBT_set) ("_position" rbt1))
###         ("_applC" ("_position" RBT_set) ("_position" rbt2))))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'c)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''product RBT_set RBT_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("_applC" ("_position" Product_Type.product)
###                   ("_cargs"
###                     ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                     ("_applC" ("_position" RBT_set)
###                       ("_position" rbt2))))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'd)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''product RBT_set RBT_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("_applC" ("_position" Product_Type.product)
###                         ("_cargs"
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt1))
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt2))))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_applC" ("_position" RBT_set)
###               ("_applC" ("_position" RBT_Set2.product)
###                 ("_cargs" ("_position" rbt1) ("_position" rbt2))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1470 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.Image"
###       ("_applC" ("_position" DList_set) ("_position" dxs)) ("_position" B))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal" ("_position" ''Image DList_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.Image"
###                   ("_applC" ("_position" DList_set) ("_position" dxs))
###                   ("_position" B))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'b)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position" ''Image DList_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.Image"
###                         ("_applC" ("_position" DList_set) ("_position" dxs))
###                         ("_position" B))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_applC" ("_position" DList_Set.fold)
###                   ("_cargs"
###                     ("_lambda"
###                       ("_pttrns"
###                         ("_pattern" ("_position" x) ("_position" y))
###                         ("_position" acc))
###                       ("\<^const>HOL.If"
###                         ("\<^const>Set.member" ("_position" x)
###                           ("_position" B))
###                         ("_applC" ("_position" insert)
###                           ("_cargs" ("_position" y) ("_position" acc)))
###                         ("_position" acc)))
###                     ("_cargs" ("_position" dxs)
###                       ("\<^const>Set.empty"))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.Image"
###       ("_applC" ("_position" DList_set) ("_position" dxs)) ("_position" B))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal" ("_position" ''Image DList_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.Image"
###                   ("_applC" ("_position" DList_set) ("_position" dxs))
###                   ("_position" B))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'b)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position" ''Image DList_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.Image"
###                         ("_applC" ("_position" DList_set) ("_position" dxs))
###                         ("_position" B))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_applC" ("_position" DList_Set.fold)
###               ("_cargs"
###                 ("_lambda"
###                   ("_pttrns" ("_pattern" ("_position" x) ("_position" y))
###                     ("_position" acc))
###                   ("\<^const>HOL.If"
###                     ("\<^const>Set.member" ("_position" x) ("_position" B))
###                     ("_applC" ("_position" insert)
###                       ("_cargs" ("_position" y) ("_position" acc)))
###                     ("_position" acc)))
###                 ("_cargs" ("_position" dxs) ("\<^const>Set.empty"))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1477 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.Image"
###       ("_applC" ("_position" RBT_set) ("_position" rbt)) ("_position" C))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'c)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal" ("_position" ''Image RBT_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.Image"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt))
###                   ("_position" C))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'd)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position" ''Image RBT_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.Image"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt))
###                         ("_position" C))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_applC" ("_position" RBT_Set2.fold)
###                   ("_cargs"
###                     ("_lambda"
###                       ("_pttrns"
###                         ("_pattern" ("_position" x) ("_position" y))
###                         ("_position" acc))
###                       ("\<^const>HOL.If"
###                         ("\<^const>Set.member" ("_position" x)
###                           ("_position" C))
###                         ("_applC" ("_position" insert)
###                           ("_cargs" ("_position" y) ("_position" acc)))
###                         ("_position" acc)))
###                     ("_cargs" ("_position" rbt)
###                       ("\<^const>Set.empty"))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.Image"
###       ("_applC" ("_position" RBT_set) ("_position" rbt)) ("_position" C))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'c)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal" ("_position" ''Image RBT_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.Image"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt))
###                   ("_position" C))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'd)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position" ''Image RBT_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.Image"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt))
###                         ("_position" C))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_applC" ("_position" RBT_Set2.fold)
###               ("_cargs"
###                 ("_lambda"
###                   ("_pttrns" ("_pattern" ("_position" x) ("_position" y))
###                     ("_position" acc))
###                   ("\<^const>HOL.If"
###                     ("\<^const>Set.member" ("_position" x) ("_position" C))
###                     ("_applC" ("_position" insert)
###                       ("_cargs" ("_position" y) ("_position" acc)))
###                     ("_position" acc)))
###                 ("_cargs" ("_position" rbt) ("\<^const>Set.empty"))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1546 of "$AFP/Containers/Set_Impl.thy") produces 5 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt1))
###       ("_applC" ("_position" RBT_set) ("_position" rbt2)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp RBT_set RBT_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt2)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp RBT_set RBT_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt2)))))))
###               ("_case1" ("_applC" ("_position" Some) ("_position" c_b))
###                 ("_case_syntax"
###                   ("_applC" ("_position" ID)
###                     ("_CCOMPARE" ("_position_sort" 'c)))
###                   ("_case2"
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp RBT_set RBT_set: ccompare3 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt1))
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt2)))))))
###                     ("_case1"
###                       ("_applC" ("_position" Some)
###                         ("\<^const>Pure.dummy_pattern"))
###                       ("_applC" ("_position" RBT_Set2.fold)
###                         ("_cargs"
###                           ("_lambda"
###                             ("_pattern" ("_position" x) ("_position" y))
###                             ("_applC" ("_position" RBT_Set2.fold)
###                               ("_cargs"
###                                 ("_lambda"
###                                   ("_pttrns"
###                                     ("_pattern" ("_position" y')
### ("_position" z))
###                                     ("_position" A))
###                                   ("\<^const>HOL.If"
###                                     ("\<^const>HOL.not_equal"
### ("_applC" ("_position" c_b) ("_cargs" ("_position" y) ("_position" y')))
### ("_position" Eq))
###                                     ("_position" A)
###                                     ("_applC" ("_position" insert)
### ("_cargs" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z)))
###   ("_position" A)))))
###                                 ("_position" rbt2))))
###                           ("_cargs" ("_position" rbt1)
###                             ("\<^const>Set.empty")))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt1))
###       ("_applC" ("_position" RBT_set) ("_position" rbt2)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp RBT_set RBT_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt2)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'b)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp RBT_set RBT_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt2)))))))))
###           ("_case1" ("_applC" ("_position" Some) ("_position" c_b))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'c)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp RBT_set RBT_set: ccompare3 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt1))
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt2)))))))
###                 ("_case1"
###                   ("_applC" ("_position" Some)
###                     ("\<^const>Pure.dummy_pattern"))
###                   ("_applC" ("_position" RBT_Set2.fold)
###                     ("_cargs"
###                       ("_lambda"
###                         ("_pattern" ("_position" x) ("_position" y))
###                         ("_applC" ("_position" RBT_Set2.fold)
###                           ("_cargs"
###                             ("_lambda"
###                               ("_pttrns"
###                                 ("_pattern" ("_position" y')
###                                   ("_position" z))
###                                 ("_position" A))
###                               ("\<^const>HOL.If"
###                                 ("\<^const>HOL.not_equal"
###                                   ("_applC" ("_position" c_b)
###                                     ("_cargs" ("_position" y)
### ("_position" y')))
###                                   ("_position" Eq))
###                                 ("_position" A)
###                                 ("_applC" ("_position" insert)
###                                   ("_cargs"
###                                     ("_tuple" ("_position" x)
### ("_tuple_arg" ("_position" z)))
###                                     ("_position" A)))))
###                             ("_position" rbt2))))
###                       ("_cargs" ("_position" rbt1)
###                         ("\<^const>Set.empty")))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt1))
###       ("_applC" ("_position" RBT_set) ("_position" rbt2)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp RBT_set RBT_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt2)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp RBT_set RBT_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt2)))))))
###               ("_case2"
###                 ("_case1" ("_applC" ("_position" Some) ("_position" c_b))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CCOMPARE" ("_position_sort" 'c)))
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp RBT_set RBT_set: ccompare3 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt1))
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt2)))))))))
###                 ("_case1"
###                   ("_applC" ("_position" Some)
###                     ("\<^const>Pure.dummy_pattern"))
###                   ("_applC" ("_position" RBT_Set2.fold)
###                     ("_cargs"
###                       ("_lambda"
###                         ("_pattern" ("_position" x) ("_position" y))
###                         ("_applC" ("_position" RBT_Set2.fold)
###                           ("_cargs"
###                             ("_lambda"
###                               ("_pttrns"
###                                 ("_pattern" ("_position" y')
###                                   ("_position" z))
###                                 ("_position" A))
###                               ("\<^const>HOL.If"
###                                 ("\<^const>HOL.not_equal"
###                                   ("_applC" ("_position" c_b)
###                                     ("_cargs" ("_position" y)
### ("_position" y')))
###                                   ("_position" Eq))
###                                 ("_position" A)
###                                 ("_applC" ("_position" insert)
###                                   ("_cargs"
###                                     ("_tuple" ("_position" x)
### ("_tuple_arg" ("_position" z)))
###                                     ("_position" A)))))
###                             ("_position" rbt2))))
###                       ("_cargs" ("_position" rbt1)
###                         ("\<^const>Set.empty")))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt1))
###       ("_applC" ("_position" RBT_set) ("_position" rbt2)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp RBT_set RBT_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt2)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'b)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp RBT_set RBT_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt2)))))))))
###           ("_case2"
###             ("_case1" ("_applC" ("_position" Some) ("_position" c_b))
###               ("_case_syntax"
###                 ("_applC" ("_position" ID)
###                   ("_CCOMPARE" ("_position_sort" 'c)))
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp RBT_set RBT_set: ccompare3 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt1))
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt2)))))))))
###             ("_case1"
###               ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###               ("_applC" ("_position" RBT_Set2.fold)
###                 ("_cargs"
###                   ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                     ("_applC" ("_position" RBT_Set2.fold)
###                       ("_cargs"
###                         ("_lambda"
###                           ("_pttrns"
###                             ("_pattern" ("_position" y') ("_position" z))
###                             ("_position" A))
###                           ("\<^const>HOL.If"
###                             ("\<^const>HOL.not_equal"
###                               ("_applC" ("_position" c_b)
###                                 ("_cargs" ("_position" y) ("_position" y')))
###                               ("_position" Eq))
###                             ("_position" A)
###                             ("_applC" ("_position" insert)
###                               ("_cargs"
###                                 ("_tuple" ("_position" x)
###                                   ("_tuple_arg" ("_position" z)))
###                                 ("_position" A)))))
###                         ("_position" rbt2))))
###                   ("_cargs" ("_position" rbt1)
###                     ("\<^const>Set.empty")))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt1))
###       ("_applC" ("_position" RBT_set) ("_position" rbt2)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp RBT_set RBT_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt2)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'b)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp RBT_set RBT_set: ccompare2 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt1))
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt2)))))))
###                 ("_case1" ("_applC" ("_position" Some) ("_position" c_b))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CCOMPARE" ("_position_sort" 'c)))
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp RBT_set RBT_set: ccompare3 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt1))
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt2))))))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_applC" ("_position" RBT_Set2.fold)
###               ("_cargs"
###                 ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                   ("_applC" ("_position" RBT_Set2.fold)
###                     ("_cargs"
###                       ("_lambda"
###                         ("_pttrns"
###                           ("_pattern" ("_position" y') ("_position" z))
###                           ("_position" A))
###                         ("\<^const>HOL.If"
###                           ("\<^const>HOL.not_equal"
###                             ("_applC" ("_position" c_b)
###                               ("_cargs" ("_position" y) ("_position" y')))
###                             ("_position" Eq))
###                           ("_position" A)
###                           ("_applC" ("_position" insert)
###                             ("_cargs"
###                               ("_tuple" ("_position" x)
###                                 ("_tuple_arg" ("_position" z)))
###                               ("_position" A)))))
###                       ("_position" rbt2))))
###                 ("_cargs" ("_position" rbt1) ("\<^const>Set.empty"))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1555 of "$AFP/Containers/Set_Impl.thy") produces 14 parse trees (10 displayed):
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt3))
###       ("_applC" ("_position" DList_set) ("_position" dxs1)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position"
###                   ''relcomp RBT_set DList_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs1)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'd)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp RBT_set DList_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs1)))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_case_syntax"
###                   ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'd)))
###                   ("_case2"
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp RBT_set DList_set: ceq2 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt3))
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs1)))))))
###                     ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                       ("_case_syntax"
###                         ("_applC" ("_position" ID)
###                           ("_CEQ" ("_position_sort" 'e)))
###                         ("_case2"
###                           ("_case1" ("_position" None)
###                             ("_applC" ("_position" Code.abort)
###                               ("_cargs"
###                                 ("_Literal"
###                                   ("_position"
###                                     ''relcomp RBT_set DList_set: ceq3 = None''))
###                                 ("_lambda" ("_idtdummy")
###                                   ("\<^const>Relation.relcomp"
###                                     ("_applC" ("_position" RBT_set)
### ("_position" rbt3))
###                                     ("_applC" ("_position" DList_set)
### ("_position" dxs1)))))))
###                           ("_case1"
###                             ("_applC" ("_position" Some)
###                               ("\<^const>Pure.dummy_pattern"))
###                             ("_applC" ("_position" RBT_Set2.fold)
###                               ("_cargs"
###                                 ("_lambda"
###                                   ("_pattern" ("_position" x)
###                                     ("_position" y))
###                                   ("_applC" ("_position" DList_Set.fold)
###                                     ("_cargs"
### ("_lambda"
###   ("_pttrns" ("_pattern" ("_position" y') ("_position" z)) ("_position" A))
###   ("\<^const>HOL.If"
###     ("_applC" ("_position" eq) ("_cargs" ("_position" y) ("_position" y')))
###     ("_applC" ("_position" insert)
###       ("_cargs" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z)))
###         ("_position" A)))
###     ("_position" A)))
### ("_position" dxs1))))
###                                 ("_cargs" ("_position" rbt3)
###                                   ("\<^const>Set.empty"))))))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt3))
###       ("_applC" ("_position" DList_set) ("_position" dxs1)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position"
###                   ''relcomp RBT_set DList_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs1)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'd)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp RBT_set DList_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs1)))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'd)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp RBT_set DList_set: ceq2 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt3))
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs1)))))))
###                 ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CEQ" ("_position_sort" 'e)))
###                     ("_case2"
###                       ("_case1" ("_position" None)
###                         ("_applC" ("_position" Code.abort)
###                           ("_cargs"
###                             ("_Literal"
###                               ("_position"
###                                 ''relcomp RBT_set DList_set: ceq3 = None''))
###                             ("_lambda" ("_idtdummy")
###                               ("\<^const>Relation.relcomp"
###                                 ("_applC" ("_position" RBT_set)
###                                   ("_position" rbt3))
###                                 ("_applC" ("_position" DList_set)
###                                   ("_position" dxs1)))))))
###                       ("_case1"
###                         ("_applC" ("_position" Some)
###                           ("\<^const>Pure.dummy_pattern"))
###                         ("_applC" ("_position" RBT_Set2.fold)
###                           ("_cargs"
###                             ("_lambda"
###                               ("_pattern" ("_position" x) ("_position" y))
###                               ("_applC" ("_position" DList_Set.fold)
###                                 ("_cargs"
###                                   ("_lambda"
###                                     ("_pttrns"
### ("_pattern" ("_position" y') ("_position" z)) ("_position" A))
###                                     ("\<^const>HOL.If"
### ("_applC" ("_position" eq) ("_cargs" ("_position" y) ("_position" y')))
### ("_applC" ("_position" insert)
###   ("_cargs" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z)))
###     ("_position" A)))
### ("_position" A)))
###                                   ("_position" dxs1))))
###                             ("_cargs" ("_position" rbt3)
###                               ("\<^const>Set.empty"))))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt3))
###       ("_applC" ("_position" DList_set) ("_position" dxs1)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position"
###                   ''relcomp RBT_set DList_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs1)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'd)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp RBT_set DList_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs1)))))))
###               ("_case2"
###                 ("_case1"
###                   ("_applC" ("_position" Some)
###                     ("\<^const>Pure.dummy_pattern"))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CEQ" ("_position_sort" 'd)))
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp RBT_set DList_set: ceq2 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt3))
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs1)))))))))
###                 ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CEQ" ("_position_sort" 'e)))
###                     ("_case2"
###                       ("_case1" ("_position" None)
###                         ("_applC" ("_position" Code.abort)
###                           ("_cargs"
###                             ("_Literal"
###                               ("_position"
###                                 ''relcomp RBT_set DList_set: ceq3 = None''))
###                             ("_lambda" ("_idtdummy")
###                               ("\<^const>Relation.relcomp"
###                                 ("_applC" ("_position" RBT_set)
###                                   ("_position" rbt3))
###                                 ("_applC" ("_position" DList_set)
###                                   ("_position" dxs1)))))))
###                       ("_case1"
###                         ("_applC" ("_position" Some)
###                           ("\<^const>Pure.dummy_pattern"))
###                         ("_applC" ("_position" RBT_Set2.fold)
###                           ("_cargs"
###                             ("_lambda"
###                               ("_pattern" ("_position" x) ("_position" y))
###                               ("_applC" ("_position" DList_Set.fold)
###                                 ("_cargs"
###                                   ("_lambda"
###                                     ("_pttrns"
### ("_pattern" ("_position" y') ("_position" z)) ("_position" A))
###                                     ("\<^const>HOL.If"
### ("_applC" ("_position" eq) ("_cargs" ("_position" y) ("_position" y')))
### ("_applC" ("_position" insert)
###   ("_cargs" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z)))
###     ("_position" A)))
### ("_position" A)))
###                                   ("_position" dxs1))))
###                             ("_cargs" ("_position" rbt3)
###                               ("\<^const>Set.empty"))))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt3))
###       ("_applC" ("_position" DList_set) ("_position" dxs1)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position"
###                   ''relcomp RBT_set DList_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs1)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'd)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp RBT_set DList_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs1)))))))))
###           ("_case2"
###             ("_case1"
###               ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###               ("_case_syntax"
###                 ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'd)))
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp RBT_set DList_set: ceq2 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt3))
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs1)))))))))
###             ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###               ("_case_syntax"
###                 ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###                 ("_case2"
###                   ("_case1" ("_position" None)
###                     ("_applC" ("_position" Code.abort)
###                       ("_cargs"
###                         ("_Literal"
###                           ("_position"
###                             ''relcomp RBT_set DList_set: ceq3 = None''))
###                         ("_lambda" ("_idtdummy")
###                           ("\<^const>Relation.relcomp"
###                             ("_applC" ("_position" RBT_set)
###                               ("_position" rbt3))
###                             ("_applC" ("_position" DList_set)
###                               ("_position" dxs1)))))))
###                   ("_case1"
###                     ("_applC" ("_position" Some)
###                       ("\<^const>Pure.dummy_pattern"))
###                     ("_applC" ("_position" RBT_Set2.fold)
###                       ("_cargs"
###                         ("_lambda"
###                           ("_pattern" ("_position" x) ("_position" y))
###                           ("_applC" ("_position" DList_Set.fold)
###                             ("_cargs"
###                               ("_lambda"
###                                 ("_pttrns"
###                                   ("_pattern" ("_position" y')
###                                     ("_position" z))
###                                   ("_position" A))
###                                 ("\<^const>HOL.If"
###                                   ("_applC" ("_position" eq)
###                                     ("_cargs" ("_position" y)
### ("_position" y')))
###                                   ("_applC" ("_position" insert)
###                                     ("_cargs"
### ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z))) ("_position" A)))
###                                   ("_position" A)))
###                               ("_position" dxs1))))
###                         ("_cargs" ("_position" rbt3)
###                           ("\<^const>Set.empty"))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt3))
###       ("_applC" ("_position" DList_set) ("_position" dxs1)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position"
###                   ''relcomp RBT_set DList_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs1)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'd)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp RBT_set DList_set: ccompare2 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt3))
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs1)))))))
###                 ("_case1"
###                   ("_applC" ("_position" Some)
###                     ("\<^const>Pure.dummy_pattern"))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CEQ" ("_position_sort" 'd)))
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp RBT_set DList_set: ceq2 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt3))
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs1))))))))))))
###           ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp RBT_set DList_set: ceq3 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt3))
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs1)))))))
###                 ("_case1"
###                   ("_applC" ("_position" Some)
###                     ("\<^const>Pure.dummy_pattern"))
###                   ("_applC" ("_position" RBT_Set2.fold)
###                     ("_cargs"
###                       ("_lambda"
###                         ("_pattern" ("_position" x) ("_position" y))
###                         ("_applC" ("_position" DList_Set.fold)
###                           ("_cargs"
###                             ("_lambda"
###                               ("_pttrns"
###                                 ("_pattern" ("_position" y')
###                                   ("_position" z))
###                                 ("_position" A))
###                               ("\<^const>HOL.If"
###                                 ("_applC" ("_position" eq)
###                                   ("_cargs" ("_position" y)
###                                     ("_position" y')))
###                                 ("_applC" ("_position" insert)
###                                   ("_cargs"
###                                     ("_tuple" ("_position" x)
### ("_tuple_arg" ("_position" z)))
###                                     ("_position" A)))
###                                 ("_position" A)))
###                             ("_position" dxs1))))
###                       ("_cargs" ("_position" rbt3)
###                         ("\<^const>Set.empty")))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt3))
###       ("_applC" ("_position" DList_set) ("_position" dxs1)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position"
###                   ''relcomp RBT_set DList_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs1)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'd)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp RBT_set DList_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs1)))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_case_syntax"
###                   ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'd)))
###                   ("_case2"
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp RBT_set DList_set: ceq2 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt3))
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs1)))))))
###                     ("_case2"
###                       ("_case1"
###                         ("_applC" ("_position" Some) ("_position" eq))
###                         ("_case_syntax"
###                           ("_applC" ("_position" ID)
###                             ("_CEQ" ("_position_sort" 'e)))
###                           ("_case1" ("_position" None)
###                             ("_applC" ("_position" Code.abort)
###                               ("_cargs"
###                                 ("_Literal"
###                                   ("_position"
###                                     ''relcomp RBT_set DList_set: ceq3 = None''))
###                                 ("_lambda" ("_idtdummy")
###                                   ("\<^const>Relation.relcomp"
###                                     ("_applC" ("_position" RBT_set)
### ("_position" rbt3))
###                                     ("_applC" ("_position" DList_set)
### ("_position" dxs1)))))))))
###                       ("_case1"
###                         ("_applC" ("_position" Some)
###                           ("\<^const>Pure.dummy_pattern"))
###                         ("_applC" ("_position" RBT_Set2.fold)
###                           ("_cargs"
###                             ("_lambda"
###                               ("_pattern" ("_position" x) ("_position" y))
###                               ("_applC" ("_position" DList_Set.fold)
###                                 ("_cargs"
###                                   ("_lambda"
###                                     ("_pttrns"
### ("_pattern" ("_position" y') ("_position" z)) ("_position" A))
###                                     ("\<^const>HOL.If"
### ("_applC" ("_position" eq) ("_cargs" ("_position" y) ("_position" y')))
### ("_applC" ("_position" insert)
###   ("_cargs" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z)))
###     ("_position" A)))
### ("_position" A)))
###                                   ("_position" dxs1))))
###                             ("_cargs" ("_position" rbt3)
###                               ("\<^const>Set.empty"))))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt3))
###       ("_applC" ("_position" DList_set) ("_position" dxs1)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position"
###                   ''relcomp RBT_set DList_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs1)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'd)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp RBT_set DList_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs1)))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'd)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp RBT_set DList_set: ceq2 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt3))
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs1)))))))
###                 ("_case2"
###                   ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                     ("_case_syntax"
###                       ("_applC" ("_position" ID)
###                         ("_CEQ" ("_position_sort" 'e)))
###                       ("_case1" ("_position" None)
###                         ("_applC" ("_position" Code.abort)
###                           ("_cargs"
###                             ("_Literal"
###                               ("_position"
###                                 ''relcomp RBT_set DList_set: ceq3 = None''))
###                             ("_lambda" ("_idtdummy")
###                               ("\<^const>Relation.relcomp"
###                                 ("_applC" ("_position" RBT_set)
###                                   ("_position" rbt3))
###                                 ("_applC" ("_position" DList_set)
###                                   ("_position" dxs1)))))))))
###                   ("_case1"
###                     ("_applC" ("_position" Some)
###                       ("\<^const>Pure.dummy_pattern"))
###                     ("_applC" ("_position" RBT_Set2.fold)
###                       ("_cargs"
###                         ("_lambda"
###                           ("_pattern" ("_position" x) ("_position" y))
###                           ("_applC" ("_position" DList_Set.fold)
###                             ("_cargs"
###                               ("_lambda"
###                                 ("_pttrns"
###                                   ("_pattern" ("_position" y')
###                                     ("_position" z))
###                                   ("_position" A))
###                                 ("\<^const>HOL.If"
###                                   ("_applC" ("_position" eq)
###                                     ("_cargs" ("_position" y)
### ("_position" y')))
###                                   ("_applC" ("_position" insert)
###                                     ("_cargs"
### ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z))) ("_position" A)))
###                                   ("_position" A)))
###                               ("_position" dxs1))))
###                         ("_cargs" ("_position" rbt3)
###                           ("\<^const>Set.empty"))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt3))
###       ("_applC" ("_position" DList_set) ("_position" dxs1)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position"
###                   ''relcomp RBT_set DList_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs1)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'd)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp RBT_set DList_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs1)))))))
###               ("_case2"
###                 ("_case1"
###                   ("_applC" ("_position" Some)
###                     ("\<^const>Pure.dummy_pattern"))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CEQ" ("_position_sort" 'd)))
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp RBT_set DList_set: ceq2 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt3))
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs1)))))))))
###                 ("_case2"
###                   ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                     ("_case_syntax"
###                       ("_applC" ("_position" ID)
###                         ("_CEQ" ("_position_sort" 'e)))
###                       ("_case1" ("_position" None)
###                         ("_applC" ("_position" Code.abort)
###                           ("_cargs"
###                             ("_Literal"
###                               ("_position"
###                                 ''relcomp RBT_set DList_set: ceq3 = None''))
###                             ("_lambda" ("_idtdummy")
###                               ("\<^const>Relation.relcomp"
###                                 ("_applC" ("_position" RBT_set)
###                                   ("_position" rbt3))
###                                 ("_applC" ("_position" DList_set)
###                                   ("_position" dxs1)))))))))
###                   ("_case1"
###                     ("_applC" ("_position" Some)
###                       ("\<^const>Pure.dummy_pattern"))
###                     ("_applC" ("_position" RBT_Set2.fold)
###                       ("_cargs"
###                         ("_lambda"
###                           ("_pattern" ("_position" x) ("_position" y))
###                           ("_applC" ("_position" DList_Set.fold)
###                             ("_cargs"
###                               ("_lambda"
###                                 ("_pttrns"
###                                   ("_pattern" ("_position" y')
###                                     ("_position" z))
###                                   ("_position" A))
###                                 ("\<^const>HOL.If"
###                                   ("_applC" ("_position" eq)
###                                     ("_cargs" ("_position" y)
### ("_position" y')))
###                                   ("_applC" ("_position" insert)
###                                     ("_cargs"
### ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z))) ("_position" A)))
###                                   ("_position" A)))
###                               ("_position" dxs1))))
###                         ("_cargs" ("_position" rbt3)
###                           ("\<^const>Set.empty"))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt3))
###       ("_applC" ("_position" DList_set) ("_position" dxs1)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position"
###                   ''relcomp RBT_set DList_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs1)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'd)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp RBT_set DList_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs1)))))))))
###           ("_case2"
###             ("_case1"
###               ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###               ("_case_syntax"
###                 ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'd)))
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp RBT_set DList_set: ceq2 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt3))
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs1)))))))))
###             ("_case2"
###               ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                 ("_case_syntax"
###                   ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###                   ("_case1" ("_position" None)
###                     ("_applC" ("_position" Code.abort)
###                       ("_cargs"
###                         ("_Literal"
###                           ("_position"
###                             ''relcomp RBT_set DList_set: ceq3 = None''))
###                         ("_lambda" ("_idtdummy")
###                           ("\<^const>Relation.relcomp"
###                             ("_applC" ("_position" RBT_set)
###                               ("_position" rbt3))
###                             ("_applC" ("_position" DList_set)
###                               ("_position" dxs1)))))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_applC" ("_position" RBT_Set2.fold)
###                   ("_cargs"
###                     ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                       ("_applC" ("_position" DList_Set.fold)
###                         ("_cargs"
###                           ("_lambda"
###                             ("_pttrns"
###                               ("_pattern" ("_position" y') ("_position" z))
###                               ("_position" A))
###                             ("\<^const>HOL.If"
###                               ("_applC" ("_position" eq)
###                                 ("_cargs" ("_position" y) ("_position" y')))
###                               ("_applC" ("_position" insert)
###                                 ("_cargs"
###                                   ("_tuple" ("_position" x)
###                                     ("_tuple_arg" ("_position" z)))
###                                   ("_position" A)))
###                               ("_position" A)))
###                           ("_position" dxs1))))
###                     ("_cargs" ("_position" rbt3)
###                       ("\<^const>Set.empty"))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt3))
###       ("_applC" ("_position" DList_set) ("_position" dxs1)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position"
###                   ''relcomp RBT_set DList_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs1)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'd)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp RBT_set DList_set: ccompare2 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt3))
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs1)))))))
###                 ("_case1"
###                   ("_applC" ("_position" Some)
###                     ("\<^const>Pure.dummy_pattern"))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CEQ" ("_position_sort" 'd)))
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp RBT_set DList_set: ceq2 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt3))
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs1))))))))))))
###           ("_case2"
###             ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###               ("_case_syntax"
###                 ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp RBT_set DList_set: ceq3 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt3))
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs1)))))))))
###             ("_case1"
###               ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###               ("_applC" ("_position" RBT_Set2.fold)
###                 ("_cargs"
###                   ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                     ("_applC" ("_position" DList_Set.fold)
###                       ("_cargs"
###                         ("_lambda"
###                           ("_pttrns"
###                             ("_pattern" ("_position" y') ("_position" z))
###                             ("_position" A))
###                           ("\<^const>HOL.If"
###                             ("_applC" ("_position" eq)
###                               ("_cargs" ("_position" y) ("_position" y')))
###                             ("_applC" ("_position" insert)
###                               ("_cargs"
###                                 ("_tuple" ("_position" x)
###                                   ("_tuple_arg" ("_position" z)))
###                                 ("_position" A)))
###                             ("_position" A)))
###                         ("_position" dxs1))))
###                   ("_cargs" ("_position" rbt3)
###                     ("\<^const>Set.empty")))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1566 of "$AFP/Containers/Set_Impl.thy") produces 14 parse trees (10 displayed):
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs2))
###       ("_applC" ("_position" RBT_set) ("_position" rbt4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set RBT_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs2))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt4)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'd)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp DList_set RBT_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs2))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt4)))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_case_syntax"
###                   ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'd)))
###                   ("_case2"
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp DList_set RBT_set: ccompare2 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs2))
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt4)))))))
###                     ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                       ("_case_syntax"
###                         ("_applC" ("_position" ID)
###                           ("_CCOMPARE" ("_position_sort" 'a)))
###                         ("_case2"
###                           ("_case1" ("_position" None)
###                             ("_applC" ("_position" Code.abort)
###                               ("_cargs"
###                                 ("_Literal"
###                                   ("_position"
###                                     ''relcomp DList_set RBT_set: ccompare3 = None''))
###                                 ("_lambda" ("_idtdummy")
###                                   ("\<^const>Relation.relcomp"
###                                     ("_applC" ("_position" DList_set)
### ("_position" dxs2))
###                                     ("_applC" ("_position" RBT_set)
### ("_position" rbt4)))))))
###                           ("_case1"
###                             ("_applC" ("_position" Some)
###                               ("\<^const>Pure.dummy_pattern"))
###                             ("_applC" ("_position" DList_Set.fold)
###                               ("_cargs"
###                                 ("_lambda"
###                                   ("_pattern" ("_position" x)
###                                     ("_position" y))
###                                   ("_applC" ("_position" RBT_Set2.fold)
###                                     ("_cargs"
### ("_lambda"
###   ("_pttrns" ("_pattern" ("_position" y') ("_position" z)) ("_position" A))
###   ("\<^const>HOL.If"
###     ("_applC" ("_position" eq) ("_cargs" ("_position" y) ("_position" y')))
###     ("_applC" ("_position" insert)
###       ("_cargs" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z)))
###         ("_position" A)))
###     ("_position" A)))
### ("_position" rbt4))))
###                                 ("_cargs" ("_position" dxs2)
###                                   ("\<^const>Set.empty"))))))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs2))
###       ("_applC" ("_position" RBT_set) ("_position" rbt4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set RBT_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs2))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt4)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'd)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp DList_set RBT_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs2))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt4)))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'd)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp DList_set RBT_set: ccompare2 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs2))
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt4)))))))
###                 ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CCOMPARE" ("_position_sort" 'a)))
###                     ("_case2"
###                       ("_case1" ("_position" None)
###                         ("_applC" ("_position" Code.abort)
###                           ("_cargs"
###                             ("_Literal"
###                               ("_position"
###                                 ''relcomp DList_set RBT_set: ccompare3 = None''))
###                             ("_lambda" ("_idtdummy")
###                               ("\<^const>Relation.relcomp"
###                                 ("_applC" ("_position" DList_set)
###                                   ("_position" dxs2))
###                                 ("_applC" ("_position" RBT_set)
###                                   ("_position" rbt4)))))))
###                       ("_case1"
###                         ("_applC" ("_position" Some)
###                           ("\<^const>Pure.dummy_pattern"))
###                         ("_applC" ("_position" DList_Set.fold)
###                           ("_cargs"
###                             ("_lambda"
###                               ("_pattern" ("_position" x) ("_position" y))
###                               ("_applC" ("_position" RBT_Set2.fold)
###                                 ("_cargs"
###                                   ("_lambda"
###                                     ("_pttrns"
### ("_pattern" ("_position" y') ("_position" z)) ("_position" A))
###                                     ("\<^const>HOL.If"
### ("_applC" ("_position" eq) ("_cargs" ("_position" y) ("_position" y')))
### ("_applC" ("_position" insert)
###   ("_cargs" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z)))
###     ("_position" A)))
### ("_position" A)))
###                                   ("_position" rbt4))))
###                             ("_cargs" ("_position" dxs2)
###                               ("\<^const>Set.empty"))))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs2))
###       ("_applC" ("_position" RBT_set) ("_position" rbt4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set RBT_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs2))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt4)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'd)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp DList_set RBT_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs2))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt4)))))))
###               ("_case2"
###                 ("_case1"
###                   ("_applC" ("_position" Some)
###                     ("\<^const>Pure.dummy_pattern"))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CEQ" ("_position_sort" 'd)))
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp DList_set RBT_set: ccompare2 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs2))
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt4)))))))))
###                 ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CCOMPARE" ("_position_sort" 'a)))
###                     ("_case2"
###                       ("_case1" ("_position" None)
###                         ("_applC" ("_position" Code.abort)
###                           ("_cargs"
###                             ("_Literal"
###                               ("_position"
###                                 ''relcomp DList_set RBT_set: ccompare3 = None''))
###                             ("_lambda" ("_idtdummy")
###                               ("\<^const>Relation.relcomp"
###                                 ("_applC" ("_position" DList_set)
###                                   ("_position" dxs2))
###                                 ("_applC" ("_position" RBT_set)
###                                   ("_position" rbt4)))))))
###                       ("_case1"
###                         ("_applC" ("_position" Some)
###                           ("\<^const>Pure.dummy_pattern"))
###                         ("_applC" ("_position" DList_Set.fold)
###                           ("_cargs"
###                             ("_lambda"
###                               ("_pattern" ("_position" x) ("_position" y))
###                               ("_applC" ("_position" RBT_Set2.fold)
###                                 ("_cargs"
###                                   ("_lambda"
###                                     ("_pttrns"
### ("_pattern" ("_position" y') ("_position" z)) ("_position" A))
###                                     ("\<^const>HOL.If"
### ("_applC" ("_position" eq) ("_cargs" ("_position" y) ("_position" y')))
### ("_applC" ("_position" insert)
###   ("_cargs" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z)))
###     ("_position" A)))
### ("_position" A)))
###                                   ("_position" rbt4))))
###                             ("_cargs" ("_position" dxs2)
###                               ("\<^const>Set.empty"))))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs2))
###       ("_applC" ("_position" RBT_set) ("_position" rbt4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set RBT_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs2))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt4)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'd)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp DList_set RBT_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs2))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt4)))))))))
###           ("_case2"
###             ("_case1"
###               ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###               ("_case_syntax"
###                 ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'd)))
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp DList_set RBT_set: ccompare2 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs2))
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt4)))))))))
###             ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###               ("_case_syntax"
###                 ("_applC" ("_position" ID)
###                   ("_CCOMPARE" ("_position_sort" 'a)))
###                 ("_case2"
###                   ("_case1" ("_position" None)
###                     ("_applC" ("_position" Code.abort)
###                       ("_cargs"
###                         ("_Literal"
###                           ("_position"
###                             ''relcomp DList_set RBT_set: ccompare3 = None''))
###                         ("_lambda" ("_idtdummy")
###                           ("\<^const>Relation.relcomp"
###                             ("_applC" ("_position" DList_set)
###                               ("_position" dxs2))
###                             ("_applC" ("_position" RBT_set)
###                               ("_position" rbt4)))))))
###                   ("_case1"
###                     ("_applC" ("_position" Some)
###                       ("\<^const>Pure.dummy_pattern"))
###                     ("_applC" ("_position" DList_Set.fold)
###                       ("_cargs"
###                         ("_lambda"
###                           ("_pattern" ("_position" x) ("_position" y))
###                           ("_applC" ("_position" RBT_Set2.fold)
###                             ("_cargs"
###                               ("_lambda"
###                                 ("_pttrns"
###                                   ("_pattern" ("_position" y')
###                                     ("_position" z))
###                                   ("_position" A))
###                                 ("\<^const>HOL.If"
###                                   ("_applC" ("_position" eq)
###                                     ("_cargs" ("_position" y)
### ("_position" y')))
###                                   ("_applC" ("_position" insert)
###                                     ("_cargs"
### ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z))) ("_position" A)))
###                                   ("_position" A)))
###                               ("_position" rbt4))))
###                         ("_cargs" ("_position" dxs2)
###                           ("\<^const>Set.empty"))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs2))
###       ("_applC" ("_position" RBT_set) ("_position" rbt4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set RBT_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs2))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt4)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'd)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp DList_set RBT_set: ceq2 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs2))
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt4)))))))
###                 ("_case1"
###                   ("_applC" ("_position" Some)
###                     ("\<^const>Pure.dummy_pattern"))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CEQ" ("_position_sort" 'd)))
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp DList_set RBT_set: ccompare2 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs2))
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt4))))))))))))
###           ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'a)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp DList_set RBT_set: ccompare3 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs2))
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt4)))))))
###                 ("_case1"
###                   ("_applC" ("_position" Some)
###                     ("\<^const>Pure.dummy_pattern"))
###                   ("_applC" ("_position" DList_Set.fold)
###                     ("_cargs"
###                       ("_lambda"
###                         ("_pattern" ("_position" x) ("_position" y))
###                         ("_applC" ("_position" RBT_Set2.fold)
###                           ("_cargs"
###                             ("_lambda"
###                               ("_pttrns"
###                                 ("_pattern" ("_position" y')
###                                   ("_position" z))
###                                 ("_position" A))
###                               ("\<^const>HOL.If"
###                                 ("_applC" ("_position" eq)
###                                   ("_cargs" ("_position" y)
###                                     ("_position" y')))
###                                 ("_applC" ("_position" insert)
###                                   ("_cargs"
###                                     ("_tuple" ("_position" x)
### ("_tuple_arg" ("_position" z)))
###                                     ("_position" A)))
###                                 ("_position" A)))
###                             ("_position" rbt4))))
###                       ("_cargs" ("_position" dxs2)
###                         ("\<^const>Set.empty")))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs2))
###       ("_applC" ("_position" RBT_set) ("_position" rbt4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set RBT_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs2))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt4)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'd)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp DList_set RBT_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs2))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt4)))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_case_syntax"
###                   ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'd)))
###                   ("_case2"
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp DList_set RBT_set: ccompare2 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs2))
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt4)))))))
###                     ("_case2"
###                       ("_case1"
###                         ("_applC" ("_position" Some) ("_position" eq))
###                         ("_case_syntax"
###                           ("_applC" ("_position" ID)
###                             ("_CCOMPARE" ("_position_sort" 'a)))
###                           ("_case1" ("_position" None)
###                             ("_applC" ("_position" Code.abort)
###                               ("_cargs"
###                                 ("_Literal"
###                                   ("_position"
###                                     ''relcomp DList_set RBT_set: ccompare3 = None''))
###                                 ("_lambda" ("_idtdummy")
###                                   ("\<^const>Relation.relcomp"
###                                     ("_applC" ("_position" DList_set)
### ("_position" dxs2))
###                                     ("_applC" ("_position" RBT_set)
### ("_position" rbt4)))))))))
###                       ("_case1"
###                         ("_applC" ("_position" Some)
###                           ("\<^const>Pure.dummy_pattern"))
###                         ("_applC" ("_position" DList_Set.fold)
###                           ("_cargs"
###                             ("_lambda"
###                               ("_pattern" ("_position" x) ("_position" y))
###                               ("_applC" ("_position" RBT_Set2.fold)
###                                 ("_cargs"
###                                   ("_lambda"
###                                     ("_pttrns"
### ("_pattern" ("_position" y') ("_position" z)) ("_position" A))
###                                     ("\<^const>HOL.If"
### ("_applC" ("_position" eq) ("_cargs" ("_position" y) ("_position" y')))
### ("_applC" ("_position" insert)
###   ("_cargs" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z)))
###     ("_position" A)))
### ("_position" A)))
###                                   ("_position" rbt4))))
###                             ("_cargs" ("_position" dxs2)
###                               ("\<^const>Set.empty"))))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs2))
###       ("_applC" ("_position" RBT_set) ("_position" rbt4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set RBT_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs2))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt4)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'd)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp DList_set RBT_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs2))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt4)))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'd)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp DList_set RBT_set: ccompare2 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs2))
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt4)))))))
###                 ("_case2"
###                   ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                     ("_case_syntax"
###                       ("_applC" ("_position" ID)
###                         ("_CCOMPARE" ("_position_sort" 'a)))
###                       ("_case1" ("_position" None)
###                         ("_applC" ("_position" Code.abort)
###                           ("_cargs"
###                             ("_Literal"
###                               ("_position"
###                                 ''relcomp DList_set RBT_set: ccompare3 = None''))
###                             ("_lambda" ("_idtdummy")
###                               ("\<^const>Relation.relcomp"
###                                 ("_applC" ("_position" DList_set)
###                                   ("_position" dxs2))
###                                 ("_applC" ("_position" RBT_set)
###                                   ("_position" rbt4)))))))))
###                   ("_case1"
###                     ("_applC" ("_position" Some)
###                       ("\<^const>Pure.dummy_pattern"))
###                     ("_applC" ("_position" DList_Set.fold)
###                       ("_cargs"
###                         ("_lambda"
###                           ("_pattern" ("_position" x) ("_position" y))
###                           ("_applC" ("_position" RBT_Set2.fold)
###                             ("_cargs"
###                               ("_lambda"
###                                 ("_pttrns"
###                                   ("_pattern" ("_position" y')
###                                     ("_position" z))
###                                   ("_position" A))
###                                 ("\<^const>HOL.If"
###                                   ("_applC" ("_position" eq)
###                                     ("_cargs" ("_position" y)
### ("_position" y')))
###                                   ("_applC" ("_position" insert)
###                                     ("_cargs"
### ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z))) ("_position" A)))
###                                   ("_position" A)))
###                               ("_position" rbt4))))
###                         ("_cargs" ("_position" dxs2)
###                           ("\<^const>Set.empty"))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs2))
###       ("_applC" ("_position" RBT_set) ("_position" rbt4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set RBT_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs2))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt4)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'd)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp DList_set RBT_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs2))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt4)))))))
###               ("_case2"
###                 ("_case1"
###                   ("_applC" ("_position" Some)
###                     ("\<^const>Pure.dummy_pattern"))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CEQ" ("_position_sort" 'd)))
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp DList_set RBT_set: ccompare2 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs2))
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt4)))))))))
###                 ("_case2"
###                   ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                     ("_case_syntax"
###                       ("_applC" ("_position" ID)
###                         ("_CCOMPARE" ("_position_sort" 'a)))
###                       ("_case1" ("_position" None)
###                         ("_applC" ("_position" Code.abort)
###                           ("_cargs"
###                             ("_Literal"
###                               ("_position"
###                                 ''relcomp DList_set RBT_set: ccompare3 = None''))
###                             ("_lambda" ("_idtdummy")
###                               ("\<^const>Relation.relcomp"
###                                 ("_applC" ("_position" DList_set)
###                                   ("_position" dxs2))
###                                 ("_applC" ("_position" RBT_set)
###                                   ("_position" rbt4)))))))))
###                   ("_case1"
###                     ("_applC" ("_position" Some)
###                       ("\<^const>Pure.dummy_pattern"))
###                     ("_applC" ("_position" DList_Set.fold)
###                       ("_cargs"
###                         ("_lambda"
###                           ("_pattern" ("_position" x) ("_position" y))
###                           ("_applC" ("_position" RBT_Set2.fold)
###                             ("_cargs"
###                               ("_lambda"
###                                 ("_pttrns"
###                                   ("_pattern" ("_position" y')
###                                     ("_position" z))
###                                   ("_position" A))
###                                 ("\<^const>HOL.If"
###                                   ("_applC" ("_position" eq)
###                                     ("_cargs" ("_position" y)
### ("_position" y')))
###                                   ("_applC" ("_position" insert)
###                                     ("_cargs"
### ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z))) ("_position" A)))
###                                   ("_position" A)))
###                               ("_position" rbt4))))
###                         ("_cargs" ("_position" dxs2)
###                           ("\<^const>Set.empty"))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs2))
###       ("_applC" ("_position" RBT_set) ("_position" rbt4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set RBT_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs2))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt4)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'd)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp DList_set RBT_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs2))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt4)))))))))
###           ("_case2"
###             ("_case1"
###               ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###               ("_case_syntax"
###                 ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'd)))
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp DList_set RBT_set: ccompare2 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs2))
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt4)))))))))
###             ("_case2"
###               ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                 ("_case_syntax"
###                   ("_applC" ("_position" ID)
###                     ("_CCOMPARE" ("_position_sort" 'a)))
###                   ("_case1" ("_position" None)
###                     ("_applC" ("_position" Code.abort)
###                       ("_cargs"
###                         ("_Literal"
###                           ("_position"
###                             ''relcomp DList_set RBT_set: ccompare3 = None''))
###                         ("_lambda" ("_idtdummy")
###                           ("\<^const>Relation.relcomp"
###                             ("_applC" ("_position" DList_set)
###                               ("_position" dxs2))
###                             ("_applC" ("_position" RBT_set)
###                               ("_position" rbt4)))))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_applC" ("_position" DList_Set.fold)
###                   ("_cargs"
###                     ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                       ("_applC" ("_position" RBT_Set2.fold)
###                         ("_cargs"
###                           ("_lambda"
###                             ("_pttrns"
###                               ("_pattern" ("_position" y') ("_position" z))
###                               ("_position" A))
###                             ("\<^const>HOL.If"
###                               ("_applC" ("_position" eq)
###                                 ("_cargs" ("_position" y) ("_position" y')))
###                               ("_applC" ("_position" insert)
###                                 ("_cargs"
###                                   ("_tuple" ("_position" x)
###                                     ("_tuple_arg" ("_position" z)))
###                                   ("_position" A)))
###                               ("_position" A)))
###                           ("_position" rbt4))))
###                     ("_cargs" ("_position" dxs2)
###                       ("\<^const>Set.empty"))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs2))
###       ("_applC" ("_position" RBT_set) ("_position" rbt4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set RBT_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs2))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt4)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'd)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp DList_set RBT_set: ceq2 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs2))
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt4)))))))
###                 ("_case1"
###                   ("_applC" ("_position" Some)
###                     ("\<^const>Pure.dummy_pattern"))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CEQ" ("_position_sort" 'd)))
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp DList_set RBT_set: ccompare2 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs2))
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt4))))))))))))
###           ("_case2"
###             ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###               ("_case_syntax"
###                 ("_applC" ("_position" ID)
###                   ("_CCOMPARE" ("_position_sort" 'a)))
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp DList_set RBT_set: ccompare3 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs2))
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt4)))))))))
###             ("_case1"
###               ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###               ("_applC" ("_position" DList_Set.fold)
###                 ("_cargs"
###                   ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                     ("_applC" ("_position" RBT_Set2.fold)
###                       ("_cargs"
###                         ("_lambda"
###                           ("_pttrns"
###                             ("_pattern" ("_position" y') ("_position" z))
###                             ("_position" A))
###                           ("\<^const>HOL.If"
###                             ("_applC" ("_position" eq)
###                               ("_cargs" ("_position" y) ("_position" y')))
###                             ("_applC" ("_position" insert)
###                               ("_cargs"
###                                 ("_tuple" ("_position" x)
###                                   ("_tuple_arg" ("_position" z)))
###                                 ("_position" A)))
###                             ("_position" A)))
###                         ("_position" rbt4))))
###                   ("_cargs" ("_position" dxs2)
###                     ("\<^const>Set.empty")))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1577 of "$AFP/Containers/Set_Impl.thy") produces 5 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs3))
###       ("_applC" ("_position" DList_set) ("_position" dxs4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set DList_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs4)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'f)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp DList_set DList_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs3))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs4)))))))
###               ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                 ("_case_syntax"
###                   ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'g)))
###                   ("_case2"
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp DList_set DList_set: ceq3 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs3))
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs4)))))))
###                     ("_case1"
###                       ("_applC" ("_position" Some)
###                         ("\<^const>Pure.dummy_pattern"))
###                       ("_applC" ("_position" DList_Set.fold)
###                         ("_cargs"
###                           ("_lambda"
###                             ("_pattern" ("_position" x) ("_position" y))
###                             ("_applC" ("_position" DList_Set.fold)
###                               ("_cargs"
###                                 ("_lambda"
###                                   ("_pttrns"
###                                     ("_pattern" ("_position" y')
### ("_position" z))
###                                     ("_position" A))
###                                   ("\<^const>HOL.If"
###                                     ("_applC" ("_position" eq)
### ("_cargs" ("_position" y) ("_position" y')))
###                                     ("_applC" ("_position" insert)
### ("_cargs" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z)))
###   ("_position" A)))
###                                     ("_position" A)))
###                                 ("_position" dxs4))))
###                           ("_cargs" ("_position" dxs3)
###                             ("\<^const>Set.empty")))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs3))
###       ("_applC" ("_position" DList_set) ("_position" dxs4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set DList_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs4)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'f)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp DList_set DList_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs3))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs4)))))))))
###           ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'g)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp DList_set DList_set: ceq3 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs3))
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs4)))))))
###                 ("_case1"
###                   ("_applC" ("_position" Some)
###                     ("\<^const>Pure.dummy_pattern"))
###                   ("_applC" ("_position" DList_Set.fold)
###                     ("_cargs"
###                       ("_lambda"
###                         ("_pattern" ("_position" x) ("_position" y))
###                         ("_applC" ("_position" DList_Set.fold)
###                           ("_cargs"
###                             ("_lambda"
###                               ("_pttrns"
###                                 ("_pattern" ("_position" y')
###                                   ("_position" z))
###                                 ("_position" A))
###                               ("\<^const>HOL.If"
###                                 ("_applC" ("_position" eq)
###                                   ("_cargs" ("_position" y)
###                                     ("_position" y')))
###                                 ("_applC" ("_position" insert)
###                                   ("_cargs"
###                                     ("_tuple" ("_position" x)
### ("_tuple_arg" ("_position" z)))
###                                     ("_position" A)))
###                                 ("_position" A)))
###                             ("_position" dxs4))))
###                       ("_cargs" ("_position" dxs3)
###                         ("\<^const>Set.empty")))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs3))
###       ("_applC" ("_position" DList_set) ("_position" dxs4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set DList_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs4)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'f)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp DList_set DList_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs3))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs4)))))))
###               ("_case2"
###                 ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CEQ" ("_position_sort" 'g)))
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp DList_set DList_set: ceq3 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs3))
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs4)))))))))
###                 ("_case1"
###                   ("_applC" ("_position" Some)
###                     ("\<^const>Pure.dummy_pattern"))
###                   ("_applC" ("_position" DList_Set.fold)
###                     ("_cargs"
###                       ("_lambda"
###                         ("_pattern" ("_position" x) ("_position" y))
###                         ("_applC" ("_position" DList_Set.fold)
###                           ("_cargs"
###                             ("_lambda"
###                               ("_pttrns"
###                                 ("_pattern" ("_position" y')
###                                   ("_position" z))
###                                 ("_position" A))
###                               ("\<^const>HOL.If"
###                                 ("_applC" ("_position" eq)
###                                   ("_cargs" ("_position" y)
###                                     ("_position" y')))
###                                 ("_applC" ("_position" insert)
###                                   ("_cargs"
###                                     ("_tuple" ("_position" x)
### ("_tuple_arg" ("_position" z)))
###                                     ("_position" A)))
###                                 ("_position" A)))
###                             ("_position" dxs4))))
###                       ("_cargs" ("_position" dxs3)
###                         ("\<^const>Set.empty")))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs3))
###       ("_applC" ("_position" DList_set) ("_position" dxs4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set DList_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs4)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'f)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp DList_set DList_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs3))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs4)))))))))
###           ("_case2"
###             ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###               ("_case_syntax"
###                 ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'g)))
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp DList_set DList_set: ceq3 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs3))
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs4)))))))))
###             ("_case1"
###               ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###               ("_applC" ("_position" DList_Set.fold)
###                 ("_cargs"
###                   ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                     ("_applC" ("_position" DList_Set.fold)
###                       ("_cargs"
###                         ("_lambda"
###                           ("_pttrns"
###                             ("_pattern" ("_position" y') ("_position" z))
###                             ("_position" A))
###                           ("\<^const>HOL.If"
###                             ("_applC" ("_position" eq)
###                               ("_cargs" ("_position" y) ("_position" y')))
###                             ("_applC" ("_position" insert)
###                               ("_cargs"
###                                 ("_tuple" ("_position" x)
###                                   ("_tuple_arg" ("_position" z)))
###                                 ("_position" A)))
###                             ("_position" A)))
###                         ("_position" dxs4))))
###                   ("_cargs" ("_position" dxs3)
###                     ("\<^const>Set.empty")))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs3))
###       ("_applC" ("_position" DList_set) ("_position" dxs4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set DList_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs4)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'f)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp DList_set DList_set: ceq2 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs3))
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs4)))))))
###                 ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CEQ" ("_position_sort" 'g)))
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp DList_set DList_set: ceq3 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs3))
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs4))))))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_applC" ("_position" DList_Set.fold)
###               ("_cargs"
###                 ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                   ("_applC" ("_position" DList_Set.fold)
###                     ("_cargs"
###                       ("_lambda"
###                         ("_pttrns"
###                           ("_pattern" ("_position" y') ("_position" z))
###                           ("_position" A))
###                         ("\<^const>HOL.If"
###                           ("_applC" ("_position" eq)
###                             ("_cargs" ("_position" y) ("_position" y')))
###                           ("_applC" ("_position" insert)
###                             ("_cargs"
###                               ("_tuple" ("_position" x)
###                                 ("_tuple_arg" ("_position" z)))
###                               ("_position" A)))
###                           ("_position" A)))
###                       ("_position" dxs4))))
###                 ("_cargs" ("_position" dxs3) ("\<^const>Set.empty"))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1591 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt1))
###       ("_applC" ("_position" Set_Monad) ("_position" xs3)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position"
###                   ''relcomp RBT_set Set_Monad: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                   ("_applC" ("_position" Set_Monad) ("_position" xs3)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp RBT_set Set_Monad: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                         ("_applC" ("_position" Set_Monad)
###                           ("_position" xs3)))))))
###               ("_case1" ("_applC" ("_position" Some) ("_position" c_b))
###                 ("_applC" ("_position" RBT_Set2.fold)
###                   ("_cargs"
###                     ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                       ("_applC" ("_position" fold)
###                         ("_cargs"
###                           ("_lambda"
###                             ("_pttrns"
###                               ("_pattern" ("_position" y') ("_position" z))
###                               ("_position" A))
###                             ("\<^const>HOL.If"
###                               ("\<^const>HOL.not_equal"
###                                 ("_applC" ("_position" c_b)
###                                   ("_cargs" ("_position" y)
###                                     ("_position" y')))
###                                 ("_position" Eq))
###                               ("_position" A)
###                               ("_applC" ("_position" insert)
###                                 ("_cargs"
###                                   ("_tuple" ("_position" x)
###                                     ("_tuple_arg" ("_position" z)))
###                                   ("_position" A)))))
###                           ("_position" xs3))))
###                     ("_cargs" ("_position" rbt1)
###                       ("\<^const>Set.empty"))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt1))
###       ("_applC" ("_position" Set_Monad) ("_position" xs3)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position"
###                   ''relcomp RBT_set Set_Monad: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                   ("_applC" ("_position" Set_Monad) ("_position" xs3)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'b)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp RBT_set Set_Monad: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                         ("_applC" ("_position" Set_Monad)
###                           ("_position" xs3)))))))))
###           ("_case1" ("_applC" ("_position" Some) ("_position" c_b))
###             ("_applC" ("_position" RBT_Set2.fold)
###               ("_cargs"
###                 ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                   ("_applC" ("_position" fold)
###                     ("_cargs"
###                       ("_lambda"
###                         ("_pttrns"
###                           ("_pattern" ("_position" y') ("_position" z))
###                           ("_position" A))
###                         ("\<^const>HOL.If"
###                           ("\<^const>HOL.not_equal"
###                             ("_applC" ("_position" c_b)
###                               ("_cargs" ("_position" y) ("_position" y')))
###                             ("_position" Eq))
###                           ("_position" A)
###                           ("_applC" ("_position" insert)
###                             ("_cargs"
###                               ("_tuple" ("_position" x)
###                                 ("_tuple_arg" ("_position" z)))
###                               ("_position" A)))))
###                       ("_position" xs3))))
###                 ("_cargs" ("_position" rbt1) ("\<^const>Set.empty"))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1598 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" Set_Monad) ("_position" xs4))
###       ("_applC" ("_position" RBT_set) ("_position" rbt5)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position"
###                   ''relcomp Set_Monad RBT_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" Set_Monad) ("_position" xs4))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt5)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp Set_Monad RBT_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" Set_Monad) ("_position" xs4))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt5)))))))
###               ("_case1" ("_applC" ("_position" Some) ("_position" c_b))
###                 ("_applC" ("_position" fold)
###                   ("_cargs"
###                     ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                       ("_applC" ("_position" RBT_Set2.fold)
###                         ("_cargs"
###                           ("_lambda"
###                             ("_pttrns"
###                               ("_pattern" ("_position" y') ("_position" z))
###                               ("_position" A))
###                             ("\<^const>HOL.If"
###                               ("\<^const>HOL.not_equal"
###                                 ("_applC" ("_position" c_b)
###                                   ("_cargs" ("_position" y)
###                                     ("_position" y')))
###                                 ("_position" Eq))
###                               ("_position" A)
###                               ("_applC" ("_position" insert)
###                                 ("_cargs"
###                                   ("_tuple" ("_position" x)
###                                     ("_tuple_arg" ("_position" z)))
###                                   ("_position" A)))))
###                           ("_position" rbt5))))
###                     ("_cargs" ("_position" xs4)
###                       ("\<^const>Set.empty"))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" Set_Monad) ("_position" xs4))
###       ("_applC" ("_position" RBT_set) ("_position" rbt5)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position"
###                   ''relcomp Set_Monad RBT_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" Set_Monad) ("_position" xs4))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt5)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'b)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp Set_Monad RBT_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" Set_Monad) ("_position" xs4))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt5)))))))))
###           ("_case1" ("_applC" ("_position" Some) ("_position" c_b))
###             ("_applC" ("_position" fold)
###               ("_cargs"
###                 ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                   ("_applC" ("_position" RBT_Set2.fold)
###                     ("_cargs"
###                       ("_lambda"
###                         ("_pttrns"
###                           ("_pattern" ("_position" y') ("_position" z))
###                           ("_position" A))
###                         ("\<^const>HOL.If"
###                           ("\<^const>HOL.not_equal"
###                             ("_applC" ("_position" c_b)
###                               ("_cargs" ("_position" y) ("_position" y')))
###                             ("_position" Eq))
###                           ("_position" A)
###                           ("_applC" ("_position" insert)
###                             ("_cargs"
###                               ("_tuple" ("_position" x)
###                                 ("_tuple_arg" ("_position" z)))
###                               ("_position" A)))))
###                       ("_position" rbt5))))
###                 ("_cargs" ("_position" xs4) ("\<^const>Set.empty"))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1605 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs3))
###       ("_applC" ("_position" Set_Monad) ("_position" xs5)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set Set_Monad: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs3))
###                   ("_applC" ("_position" Set_Monad) ("_position" xs5)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'f)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp DList_set Set_Monad: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs3))
###                         ("_applC" ("_position" Set_Monad)
###                           ("_position" xs5)))))))
###               ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                 ("_applC" ("_position" DList_Set.fold)
###                   ("_cargs"
###                     ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                       ("_applC" ("_position" fold)
###                         ("_cargs"
###                           ("_lambda"
###                             ("_pttrns"
###                               ("_pattern" ("_position" y') ("_position" z))
###                               ("_position" A))
###                             ("\<^const>HOL.If"
###                               ("_applC" ("_position" eq)
###                                 ("_cargs" ("_position" y) ("_position" y')))
###                               ("_applC" ("_position" insert)
###                                 ("_cargs"
###                                   ("_tuple" ("_position" x)
###                                     ("_tuple_arg" ("_position" z)))
###                                   ("_position" A)))
###                               ("_position" A)))
###                           ("_position" xs5))))
###                     ("_cargs" ("_position" dxs3)
###                       ("\<^const>Set.empty"))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs3))
###       ("_applC" ("_position" Set_Monad) ("_position" xs5)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set Set_Monad: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs3))
###                   ("_applC" ("_position" Set_Monad) ("_position" xs5)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'f)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp DList_set Set_Monad: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs3))
###                         ("_applC" ("_position" Set_Monad)
###                           ("_position" xs5)))))))))
###           ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###             ("_applC" ("_position" DList_Set.fold)
###               ("_cargs"
###                 ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                   ("_applC" ("_position" fold)
###                     ("_cargs"
###                       ("_lambda"
###                         ("_pttrns"
###                           ("_pattern" ("_position" y') ("_position" z))
###                           ("_position" A))
###                         ("\<^const>HOL.If"
###                           ("_applC" ("_position" eq)
###                             ("_cargs" ("_position" y) ("_position" y')))
###                           ("_applC" ("_position" insert)
###                             ("_cargs"
###                               ("_tuple" ("_position" x)
###                                 ("_tuple_arg" ("_position" z)))
###                               ("_position" A)))
###                           ("_position" A)))
###                       ("_position" xs5))))
###                 ("_cargs" ("_position" dxs3) ("\<^const>Set.empty"))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1612 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" Set_Monad) ("_position" xs6))
###       ("_applC" ("_position" DList_set) ("_position" dxs4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'f)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp Set_Monad DList_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" Set_Monad) ("_position" xs6))
###                   ("_applC" ("_position" DList_set) ("_position" dxs4)))))))
###         ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'g)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp Set_Monad DList_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" Set_Monad) ("_position" xs6))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs4)))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_applC" ("_position" fold)
###                   ("_cargs"
###                     ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                       ("_applC" ("_position" DList_Set.fold)
###                         ("_cargs"
###                           ("_lambda"
###                             ("_pttrns"
###                               ("_pattern" ("_position" y') ("_position" z))
###                               ("_position" A))
###                             ("\<^const>HOL.If"
###                               ("_applC" ("_position" eq)
###                                 ("_cargs" ("_position" y) ("_position" y')))
###                               ("_applC" ("_position" insert)
###                                 ("_cargs"
###                                   ("_tuple" ("_position" x)
###                                     ("_tuple_arg" ("_position" z)))
###                                   ("_position" A)))
###                               ("_position" A)))
###                           ("_position" dxs4))))
###                     ("_cargs" ("_position" xs6)
###                       ("\<^const>Set.empty"))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" Set_Monad) ("_position" xs6))
###       ("_applC" ("_position" DList_set) ("_position" dxs4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'f)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp Set_Monad DList_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" Set_Monad) ("_position" xs6))
###                   ("_applC" ("_position" DList_set) ("_position" dxs4)))))))
###         ("_case2"
###           ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'g)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp Set_Monad DList_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" Set_Monad) ("_position" xs6))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs4)))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_applC" ("_position" fold)
###               ("_cargs"
###                 ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                   ("_applC" ("_position" DList_Set.fold)
###                     ("_cargs"
###                       ("_lambda"
###                         ("_pttrns"
###                           ("_pattern" ("_position" y') ("_position" z))
###                           ("_position" A))
###                         ("\<^const>HOL.If"
###                           ("_applC" ("_position" eq)
###                             ("_cargs" ("_position" y) ("_position" y')))
###                           ("_applC" ("_position" insert)
###                             ("_cargs"
###                               ("_tuple" ("_position" x)
###                                 ("_tuple_arg" ("_position" z)))
###                               ("_position" A)))
###                           ("_position" A)))
###                       ("_position" dxs4))))
###                 ("_cargs" ("_position" xs6) ("\<^const>Set.empty"))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1629 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.iff" ("_applC" ("_position" irrefl) ("_position" r))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###           ("_Ball" ("_pattern" ("_position" x) ("_position" y))
###             ("_position" r)
###             ("\<^const>HOL.Not"
###               ("_applC" ("_position" eq)
###                 ("_cargs" ("_position" x) ("_position" y))))))
###         ("_case1" ("_position" None)
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''irrefl: ceq = None & ccompare = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("_applC" ("_position" irrefl) ("_position" r))))))
###               ("_case1" ("_applC" ("_position" Some) ("_position" c))
###                 ("_Ball" ("_pattern" ("_position" x) ("_position" y))
###                   ("_position" r)
###                   ("\<^const>HOL.not_equal"
###                     ("_applC" ("_position" c)
###                       ("_cargs" ("_position" x) ("_position" y)))
###                     ("_position" Eq)))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.iff" ("_applC" ("_position" irrefl) ("_position" r))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###           ("_Ball" ("_pattern" ("_position" x) ("_position" y))
###             ("_position" r)
###             ("\<^const>HOL.Not"
###               ("_applC" ("_position" eq)
###                 ("_cargs" ("_position" x) ("_position" y))))))
###         ("_case2"
###           ("_case1" ("_position" None)
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'a)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''irrefl: ceq = None & ccompare = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("_applC" ("_position" irrefl) ("_position" r))))))))
###           ("_case1" ("_applC" ("_position" Some) ("_position" c))
###             ("_Ball" ("_pattern" ("_position" x) ("_position" y))
###               ("_position" r)
###               ("\<^const>HOL.not_equal"
###                 ("_applC" ("_position" c)
###                   ("_cargs" ("_position" x) ("_position" y)))
###                 ("_position" Eq)))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1722 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" can_select)
###       ("_cargs" ("_position" P)
###         ("_applC" ("_position" Set_Monad) ("_position" xs))))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''can_select Set_Monad: ceq = None''))
###               ("_lambda" ("_idtdummy")
###                 ("_applC" ("_position" can_select)
###                   ("_cargs" ("_position" P)
###                     ("_applC" ("_position" Set_Monad)
###                       ("_position" xs))))))))
###         ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###           ("_case_syntax"
###             ("_applC" ("_position" filter)
###               ("_cargs" ("_position" P) ("_position" xs)))
###             ("_case2" ("_case1" ("_position" Nil) ("_position" False))
###               ("_case1"
###                 ("\<^const>List.list.Cons" ("_position" x) ("_position" xs))
###                 ("_applC" ("_position" list_all)
###                   ("_cargs" ("_applC" ("_position" eq) ("_position" x))
###                     ("_position" xs)))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" can_select)
###       ("_cargs" ("_position" P)
###         ("_applC" ("_position" Set_Monad) ("_position" xs))))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''can_select Set_Monad: ceq = None''))
###               ("_lambda" ("_idtdummy")
###                 ("_applC" ("_position" can_select)
###                   ("_cargs" ("_position" P)
###                     ("_applC" ("_position" Set_Monad)
###                       ("_position" xs))))))))
###         ("_case2"
###           ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###             ("_case_syntax"
###               ("_applC" ("_position" filter)
###                 ("_cargs" ("_position" P) ("_position" xs)))
###               ("_case1" ("_position" Nil) ("_position" False))))
###           ("_case1"
###             ("\<^const>List.list.Cons" ("_position" x) ("_position" xs))
###             ("_applC" ("_position" list_all)
###               ("_cargs" ("_applC" ("_position" eq) ("_position" x))
###                 ("_position" xs)))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1833 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_constrain" ("_position" set_empty_choose)
###       ("_tapp"
###         ("_ofsort" ("_position_sort" 'a)
###           ("_sort"
###             ("_classes" ("_class_name" ceq) ("_class_name" ccompare))))
###         ("_type_name" set)))
###     ("_case_syntax" ("_CCOMPARE" ("_position_sort" 'a))
###       ("_case2"
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_applC" ("_position" RBT_set) ("_position" RBT_Set2.empty)))
###         ("_case1" ("_position" None)
###           ("_case_syntax" ("_CEQ" ("_position_sort" 'a))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Set_Monad)
###                   ("\<^const>List.list.Nil")))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_applC" ("_position" DList_set)
###                   ("_position" DList_Set.empty))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_constrain" ("_position" set_empty_choose)
###       ("_tapp"
###         ("_ofsort" ("_position_sort" 'a)
###           ("_sort"
###             ("_classes" ("_class_name" ceq) ("_class_name" ccompare))))
###         ("_type_name" set)))
###     ("_case_syntax" ("_CCOMPARE" ("_position_sort" 'a))
###       ("_case2"
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_applC" ("_position" RBT_set) ("_position" RBT_Set2.empty)))
###         ("_case2"
###           ("_case1" ("_position" None)
###             ("_case_syntax" ("_CEQ" ("_position_sort" 'a))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Set_Monad)
###                   ("\<^const>List.list.Nil")))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_applC" ("_position" DList_set)
###               ("_position" DList_Set.empty))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
class set_impl = type +
  fixes set_impl :: "('a, set_impl) phantom"
signature SET_IMPL_GENERATOR =
  sig val derive_set_impl: string -> string -> theory -> theory end
structure Set_Impl_Generator: SET_IMPL_GENERATOR
use dlist as set_impl for type unit
registered unit in class set_impl
use dlist as set_impl for type bool
registered bool in class set_impl
use rbt as set_impl for type nat
registered nat in class set_impl
use set_RBT as set_impl for type int
registered int in class set_impl
use dlist as set_impl for type finite_1
registered finite_1 in class set_impl
use dlist as set_impl for type finite_2
registered finite_2 in class set_impl
use dlist as set_impl for type finite_3
registered finite_3 in class set_impl
use rbt as set_impl for type integer
registered integer in class set_impl
use rbt as set_impl for type natural
registered natural in class set_impl
use rbt as set_impl for type char
registered char in class set_impl
instantiation
  sum :: (set_impl, set_impl) set_impl
  set_impl_sum == set_impl :: ('a + 'b, set_impl) phantom
instantiation
  prod :: (set_impl, set_impl) set_impl
  set_impl_prod == set_impl :: ('a * 'b, set_impl) phantom
use choose as set_impl for type list
registered list in class set_impl
use rbt as set_impl for type literal
registered literal in class set_impl
instantiation
  option :: (set_impl) set_impl
  set_impl_option == set_impl :: ('a option, set_impl) phantom
use monad as set_impl for type fun
registered fun in class set_impl
use choose as set_impl for type set
registered set in class set_impl
instantiation
  phantom :: (type, set_impl) set_impl
  set_impl_phantom == set_impl :: (('a, 'b) phantom, set_impl) phantom
### Ambiguous input (line 1952 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" set_aux) ("_position" set_Choose))
###     ("_case_syntax"
###       ("_CCOMPARE"
###         ("_ofsort" ("_position_sort" 'a)
###           ("_sort"
###             ("_classes" ("_class_name" ccompare) ("_class_name" ceq)))))
###       ("_case2"
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_applC" ("_position" conv)
###             ("_applC" ("_position" RBT_set) ("_position" RBT_Set2.empty))))
###         ("_case1" ("_position" None)
###           ("_case_syntax" ("_CEQ" ("_position_sort" 'a))
###             ("_case2" ("_case1" ("_position" None) ("_position" Set_Monad))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_applC" ("_position" conv)
###                   ("_applC" ("_position" DList_set)
###                     ("_position" DList_Set.empty)))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" set_aux) ("_position" set_Choose))
###     ("_case_syntax"
###       ("_CCOMPARE"
###         ("_ofsort" ("_position_sort" 'a)
###           ("_sort"
###             ("_classes" ("_class_name" ccompare) ("_class_name" ceq)))))
###       ("_case2"
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_applC" ("_position" conv)
###             ("_applC" ("_position" RBT_set) ("_position" RBT_Set2.empty))))
###         ("_case2"
###           ("_case1" ("_position" None)
###             ("_case_syntax" ("_CEQ" ("_position_sort" 'a))
###               ("_case1" ("_position" None) ("_position" Set_Monad))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_applC" ("_position" conv)
###               ("_applC" ("_position" DList_set)
###                 ("_position" DList_Set.empty)))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "Containers.Set_Impl"
### 9.396s elapsed time, 10.408s cpu time, 1.038s GC time
Loading theory "Containers.Mapping_Impl" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates" via "Draft.PDDL_STRIPS_Checker" via "Containers.Containers")
class mapping_impl = type +
  fixes mapping_impl :: "('a, mapping_impl) phantom"
signature MAPPING_IMPL_GENERATOR =
  sig val derive_mapping_impl: string -> string -> theory -> theory end
structure Mapping_Impl_Generator: MAPPING_IMPL_GENERATOR
use assoclist as mapping_impl for type unit
registered unit in class mapping_impl
use assoclist as mapping_impl for type bool
registered bool in class mapping_impl
use rbt as mapping_impl for type nat
registered nat in class mapping_impl
use mapping_RBT as mapping_impl for type int
registered int in class mapping_impl
use assoclist as mapping_impl for type finite_1
registered finite_1 in class mapping_impl
use assoclist as mapping_impl for type finite_2
registered finite_2 in class mapping_impl
use assoclist as mapping_impl for type finite_3
registered finite_3 in class mapping_impl
use rbt as mapping_impl for type integer
registered integer in class mapping_impl
use rbt as mapping_impl for type natural
registered natural in class mapping_impl
use rbt as mapping_impl for type char
registered char in class mapping_impl
instantiation
  sum :: (mapping_impl, mapping_impl) mapping_impl
  mapping_impl_sum == mapping_impl :: ('a + 'b, mapping_impl) phantom
instantiation
  prod :: (mapping_impl, mapping_impl) mapping_impl
  mapping_impl_prod == mapping_impl :: ('a * 'b, mapping_impl) phantom
use choose as mapping_impl for type list
registered list in class mapping_impl
use rbt as mapping_impl for type literal
registered literal in class mapping_impl
instantiation
  option :: (mapping_impl) mapping_impl
  mapping_impl_option == mapping_impl :: ('a option, mapping_impl) phantom
use choose as mapping_impl for type set
registered set in class mapping_impl
instantiation
  phantom :: (type, mapping_impl) mapping_impl
  mapping_impl_phantom == mapping_impl ::
    (('a, 'b) phantom, mapping_impl) phantom
### theory "Containers.Mapping_Impl"
### 1.117s elapsed time, 1.284s cpu time, 0.000s GC time
Loading theory "Containers.Map_To_Mapping" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates" via "Draft.PDDL_STRIPS_Checker" via "Containers.Containers")
structure Containers_Pre: NAMED_THMS
structure Containers_Post: NAMED_THMS
val map_apply_simproc =
   Simproc
    {lhss = [Var (("f", 0), "?'b => ?'a option") $ Var (("x", 0), "?'b")],
     name = "map_apply", proc = fn, stamp = Stamp 8856484}:
   simproc
signature CONTAINERS =
  sig
    val identify: Context.generic -> thm -> thm
    val identify_attribute: attribute
  end
structure Containers: CONTAINERS
### theory "Containers.Map_To_Mapping"
### 0.132s elapsed time, 0.134s cpu time, 0.000s GC time
Loading theory "Containers.Containers" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates" via "Draft.PDDL_STRIPS_Checker")
### theory "Containers.Containers"
### 0.029s elapsed time, 0.029s cpu time, 0.000s GC time
Loading theory "Draft.PDDL_STRIPS_Checker" (required by "Draft.PDDL_STRIPS_CheckerMoreTemplates")
Found termination order: "{}"
locale ast_domain
  fixes D :: "ast_domain"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
locale ast_domain
  fixes D :: "ast_domain"
Found termination order: "{}"
locale ast_problem
  fixes P :: "ast_problem"
locale wf_ast_domain
  fixes D :: "ast_domain"
  assumes "wf_ast_domain D"
locale ast_domain
  fixes D :: "ast_domain"
### theory "Draft.PDDL_STRIPS_Checker"
### 2.835s elapsed time, 3.365s cpu time, 0.625s GC time
Loading theory "Draft.PDDL_STRIPS_CheckerMoreTemplates"
val templateLemmas =
   [("PDDL_STRIPS_Checker.tab_succ_correct",
     "E_of_succ (tab_succ ?l) = set ?l",
     template_equation
      (template_app
        (template_hole 2, template_app (template_hole 1, template_var 0)),
       template_app (template_hole 0, template_var 0))),
    ("PDDL_STRIPS_Checker.ty_term'_correct",
     "ty_term' ?varT ?objT = ty_term ?varT (Mapping.lookup ?objT)",
     template_equation
      (template_app
        (template_app (template_hole 2, template_var 1), template_var 0),
       template_app
        (template_app (template_hole 1, template_var 1),
         template_app (template_hole 0, template_var 0)))),
    ("PDDL_STRIPS_Checker.succ_as_E",
     "set (?succ ?x) = E_of_succ ?succ `` {?x}",
     template_equation
      (template_app
        (template_hole 4, template_app (template_var 1, template_var 0)),
       template_app
        (template_app
          (template_hole 3, template_app (template_hole 2, template_var 1)),
         template_app
          (template_app (template_hole 1, template_var 0),
           template_hole 0)))),
    ("PDDL_STRIPS_Checker.ty_term'_correct_aux",
     "ty_term' ?varT ?objT ?t = ty_term ?varT (Mapping.lookup ?objT) ?t",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 2, template_var 2), template_var 1),
         template_var 0),
       template_app
        (template_app
          (template_app (template_hole 1, template_var 2),
           template_app (template_hole 0, template_var 1)),
         template_var 0))),
    ("PDDL_STRIPS_Checker.finite_imp_finite_dfs_reachable",
     "[| finite ?E; finite ?S |] ==> finite (?E^* `` ?S)",
     template_implication
      ([template_predicate (template_app (template_hole 3, template_var 1)),
        template_predicate
         (template_app (template_hole 2, template_var 0))],
       template_predicate
        (
           template_app
            (template_hole 2,
             template_app
              (template_app
                (template_hole 1,
                 template_app (template_hole 0, template_var 1)),
               template_var 0))
           ))),
    ("PDDL_STRIPS_Checker.dfs_reachable_tab_succ_correct",
     "dfs_reachable (tab_succ ?l) ?D ?vs\<^sub>0 =
      (Collect ?D Int (set ?l)^* `` set ?vs\<^sub>0 ~= {})",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_hole 10,
                  template_app (template_hole 9, template_var 2)),
                template_var 1),
              template_var 0)
            )],
       template_negation
        (
           template_equation
            (template_app
              (template_app
                (template_hole 6,
                 template_app (template_hole 5, template_var 1)),
               template_app
                (template_app
                  (template_hole 4,
                   template_app
                    (template_hole 3,
                     template_app (template_hole 2, template_var 2))),
                 template_app (template_hole 1, template_var 0))),
             template_hole 0)
           ))),
    ("PDDL_STRIPS_Checker.Some_eq_map_option",
     "(Some ?y = map_option ?f ?xo) = (EX z. ?xo = Some z & ?f z = ?y)",
     template_equation
      (template_app
        (template_app
          (template_hole 7, template_app (template_hole 6, template_var 2)),
         template_app
          (template_app (template_hole 5, template_var 1), template_var 0)),
       template_app (template_hole 4, t_empty))),
    ("PDDL_STRIPS_Checker.all_neq_Cons_is_Nil",
     "finite ((E_of_succ ?succ)^* `` set ?w\<^sub>0) ==>
      (ALL y ys. ?x2.0 ~= y # ys) = (?x2.0 = [])",
     template_implication
      ([template_predicate
         (
            template_app
             (template_hole 11,
              template_app
               (template_app
                 (template_hole 10,
                  template_app
                   (template_hole 9,
                    template_app (template_hole 8, template_var 2))),
                template_app (template_hole 7, template_var 1)))
            )],
       template_implication
        ([template_predicate (template_app (template_hole 5, t_empty))],
         template_equation (template_var 0, template_hole 0)))),
    ("PDDL_STRIPS_Checker.dfs_reachable_correct",
     "finite ((E_of_succ ?succ)^* `` set ?w\<^sub>0) ==>
      dfs_reachable ?succ ?D ?w\<^sub>0 =
      (Collect ?D Int (E_of_succ ?succ)^* `` set ?w\<^sub>0 ~= {})",
     template_implication
      ([template_predicate
         (
            template_app
             (template_hole 11,
              template_app
               (template_app
                 (template_hole 10,
                  template_app
                   (template_hole 9,
                    template_app (template_hole 8, template_var 2))),
                template_app (template_hole 7, template_var 1)))
            )],
       template_implication
        ([template_predicate
           (
              template_app
               (template_app
                 (template_app (template_hole 5, template_var 2),
                  template_var 0),
                template_var 1)
              )],
         template_negation
          (
             template_equation
              (template_app
                (template_app
                  (template_hole 2,
                   template_app (template_hole 1, template_var 0)),
                 template_app
                  (template_app
                    (template_hole 10,
                     template_app
                      (template_hole 9,
                       template_app (template_hole 8, template_var 2))),
                   template_app (template_hole 7, template_var 1))),
               template_hole 0)
             )))),
    ("PDDL_STRIPS_Checker.card_decreases",
     "[| finite ((E_of_succ ?succ)^* `` set ?w\<^sub>0); finite ?V;
         ?y ~: ?V;
         dfs_reachable_invar ?succ ?w\<^sub>0 ?D ?V (insert ?y ?W) ?brk |]
      ==> card ((E_of_succ ?succ)^* `` set ?w\<^sub>0 - insert ?y ?V)
          < card ((E_of_succ ?succ)^* `` set ?w\<^sub>0 - ?V)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_hole 11,
              template_app
               (template_app
                 (template_hole 10,
                  template_app
                   (template_hole 9,
                    template_app (template_hole 8, template_var 6))),
                template_app (template_hole 7, template_var 5)))
            ),
        template_predicate
         (template_app (template_hole 11, template_var 4)),
        template_negation
         (
            template_predicate
             (
                template_app
                 (template_app (template_hole 5, template_var 3),
                  template_var 4)
                )
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app
                   (template_app
                     (template_app (template_hole 4, template_var 6),
                      template_var 5),
                    template_var 2),
                  template_var 4),
                template_app
                 (template_app (template_hole 3, template_var 3),
                  template_var 1)),
              template_var 0)
            )],
       template_inequation
        (less_than,
         template_app
          (template_hole 1,
           template_app
            (template_app
              (template_hole 0,
               template_app
                (template_app
                  (template_hole 10,
                   template_app
                    (template_hole 9,
                     template_app (template_hole 8, template_var 6))),
                 template_app (template_hole 7, template_var 5))),
             template_app
              (template_app (template_hole 3, template_var 3),
               template_var 4))),
         template_app
          (template_hole 1,
           template_app
            (template_app
              (template_hole 0,
               template_app
                (template_app
                  (template_hole 10,
                   template_app
                    (template_hole 9,
                     template_app (template_hole 8, template_var 6))),
                 template_app (template_hole 7, template_var 5))),
             template_var 4)))))]:
   (string * thm * template) list
### theory "Draft.PDDL_STRIPS_CheckerMoreTemplates"
### 0.864s elapsed time, 1.043s cpu time, 0.000s GC time
val it = (): unit
