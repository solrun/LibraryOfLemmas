Loading theory "Pure-ex.Guess" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "Sturm_Sequences.Sturm" via "Sturm_Sequences.Sturm_Method" via "Sturm_Sequences.Sturm_Theorem" via "Sturm_Sequences.Sturm_Library" via "Sturm_Sequences.Misc_Polynomial")
Loading theory "HOL-Computational_Algebra.Fraction_Field" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "Sturm_Sequences.Sturm" via "Sturm_Sequences.Sturm_Method" via "Sturm_Sequences.Sturm_Theorem" via "Sturm_Sequences.Sturm_Library" via "Sturm_Sequences.Misc_Polynomial" via "HOL-Computational_Algebra.Polynomial_Factorial" via "HOL-Computational_Algebra.Normalized_Fraction")
Loading theory "HOL-Combinatorics.Transposition" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "HOL-Analysis.Multivariate_Analysis" via "HOL-Analysis.Ordered_Euclidean_Space" via "HOL-Analysis.Convex_Euclidean_Space" via "HOL-Analysis.Topology_Euclidean_Space" via "HOL-Analysis.Elementary_Normed_Spaces" via "HOL-Analysis.Cartesian_Space")
Loading theory "HOL-Decision_Procs.Dense_Linear_Order" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "HOL-Decision_Procs.Approximation" via "HOL-Decision_Procs.Approximation_Bounds")
### ML warning (line 99 of "~~/src/Pure/ex/Guess.thy"):
### Pattern is not exhaustive.
### ML warning (line 150 of "~~/src/Pure/ex/Guess.thy"):
### Matches are not exhaustive.
### ML warning (line 157 of "~~/src/Pure/ex/Guess.thy"):
### Pattern is not exhaustive.
signature GUESS =
  sig
    val guess:
       (binding * typ option * mixfix) list ->
         bool -> Proof.state -> Proof.state
    val guess_cmd:
       (binding * string option * mixfix) list ->
         bool -> Proof.state -> Proof.state
  end
structure Guess: GUESS
### theory "Pure-ex.Guess"
### 0.077s elapsed time, 0.284s cpu time, 0.032s GC time
Loading theory "HOL-Library.Cancellation" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "HOL-Analysis.Multivariate_Analysis" via "HOL-Analysis.Determinants" via "HOL-Combinatorics.Permutations" via "HOL-Library.Multiset")
### ML warning (line 98 of "~~/src/HOL/Decision_Procs/langford_data.ML"):
### Pattern is not exhaustive.
### ML warning (line 99 of "~~/src/HOL/Decision_Procs/langford_data.ML"):
### Pattern is not exhaustive.
signature LANGFORD_DATA =
  sig
    val add: entry -> attribute
    val del: attribute
    type entry
    val get: Proof.context -> simpset * (thm * entry) list
    val match: Proof.context -> cterm -> entry option
  end
structure Langford_Data: LANGFORD_DATA
### theory "HOL-Combinatorics.Transposition"
### 0.139s elapsed time, 0.568s cpu time, 0.032s GC time
Loading theory "HOL-Library.Code_Abstract_Nat" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "HOL-Decision_Procs.Approximation" via "HOL-Library.Code_Target_Numeral_Float" via "HOL-Library.Code_Target_Numeral" via "HOL-Library.Code_Target_Nat")
signature FERRANTE_RACKOF_DATA =
  sig
    val add: entry -> attribute
    val del: attribute
    type entry
    val funs:
       thm ->
         {isolate_conv:
          morphism -> Proof.context -> cterm list -> cterm -> thm,
          simpset: morphism -> Proof.context -> simpset,
          whatis: morphism -> cterm -> cterm -> ord}
           -> declaration
    val get: Proof.context -> (thm * entry) list
    val match: Proof.context -> cterm -> entry option
    datatype ord = Eq | Ge | Gt | Le | Lt | NEq | Nox
  end
structure Ferrante_Rackoff_Data: FERRANTE_RACKOF_DATA
### theory "HOL-Library.Code_Abstract_Nat"
### 0.061s elapsed time, 0.248s cpu time, 0.000s GC time
Loading theory "HOL-Library.Code_Target_Nat" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "HOL-Decision_Procs.Approximation" via "HOL-Library.Code_Target_Numeral_Float" via "HOL-Library.Code_Target_Numeral")
### Code generator: dropping subsumed code equation
### divmod_nat ?m ?n ==
### if ?n = 0 | ?m < ?n then (0, ?m)
### else let (q, y) = divmod_nat (?m - ?n) ?n in (Suc q, y)
### Code generator: dropping subsumed code equation
### divmod (num.Bit1 ?m) (num.Bit1 ?n) ==
### if ?m < ?n then (0, numeral (num.Bit1 ?m))
### else divmod_step (num.Bit1 ?n)
###       (divmod (num.Bit1 ?m) (num.Bit0 (num.Bit1 ?n)))
### Code generator: dropping subsumed code equation
### divmod (num.Bit0 ?m) (num.Bit1 ?n) ==
### if ?m <= ?n then (0, numeral (num.Bit0 ?m))
### else divmod_step (num.Bit1 ?n)
###       (divmod (num.Bit0 ?m) (num.Bit0 (num.Bit1 ?n)))
### Code generator: dropping subsumed code equation
### divmod (num.Bit1 ?m) (num.Bit0 ?n) ==
### case divmod ?m ?n of (q, r) => (q, 2 * r + 1)
### Code generator: dropping subsumed code equation
### divmod (num.Bit0 ?m) (num.Bit0 ?n) ==
### case divmod ?m ?n of (q, r) => (q, 2 * r)
### Code generator: dropping subsumed code equation
### divmod num.One (num.Bit1 ?n) == (0, Numeral1)
### Code generator: dropping subsumed code equation
### divmod num.One (num.Bit0 ?n) == (0, Numeral1)
### Code generator: dropping subsumed code equation
### divmod ?m num.One == (numeral ?m, 0)
### Code generator: dropping subsumed code equation
### Suc ?m <= ?n == ?m < ?n
### Code generator: dropping subsumed code equation
### 0 <= ?n == True
### Code generator: dropping subsumed code equation
### ?m < Suc ?n == ?m <= ?n
### Code generator: dropping subsumed code equation
### ?n < 0 == False
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
### Code generator: dropping subsumed code equation
### of_nat ?n == semiring_1_class.of_nat_aux (%i. i + (1::?'a)) ?n (0::?'a)
### theory "HOL-Library.Code_Target_Nat"
### 0.127s elapsed time, 0.499s cpu time, 0.029s GC time
Loading theory "HOL-Library.Code_Target_Int" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "HOL-Decision_Procs.Approximation" via "HOL-Library.Code_Target_Numeral_Float" via "HOL-Library.Code_Target_Numeral")
### Code generator: dropping subsumed code equation
### 1 == Int.Pos num.One
### Code generator: dropping subsumed code equation
### Int.Neg ?m + Int.Neg ?n == Int.Neg (?m + ?n)
### Code generator: dropping subsumed code equation
### Int.Neg ?m + Int.Pos ?n == Int.sub ?n ?m
### Code generator: dropping subsumed code equation
### Int.Pos ?m + Int.Neg ?n == Int.sub ?m ?n
### Code generator: dropping subsumed code equation
### Int.Pos ?m + Int.Pos ?n == Int.Pos (?m + ?n)
### Code generator: dropping subsumed code equation
### 0 + ?l == ?l
### Code generator: dropping subsumed code equation
### ?k + 0 == ?k
### Code generator: dropping subsumed code equation
### - Int.Neg ?m == Int.Pos ?m
### Code generator: dropping subsumed code equation
### - Int.Pos ?m == Int.Neg ?m
### Code generator: dropping subsumed code equation
### - 0 == 0
### Code generator: dropping subsumed code equation
### Int.Neg ?m - Int.Neg ?n == Int.sub ?n ?m
### Code generator: dropping subsumed code equation
### Int.Neg ?m - Int.Pos ?n == Int.Neg (?m + ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m - Int.Neg ?n == Int.Pos (?m + ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m - Int.Pos ?n == Int.sub ?m ?n
### Code generator: dropping subsumed code equation
### 0 - ?l == - ?l
### Code generator: dropping subsumed code equation
### ?k - 0 == ?k
### Code generator: dropping subsumed code equation
### Int.dup (Int.Neg ?n) == Int.Neg (num.Bit0 ?n)
### Code generator: dropping subsumed code equation
### Int.dup (Int.Pos ?n) == Int.Pos (num.Bit0 ?n)
### Code generator: dropping subsumed code equation
### Int.dup 0 == 0
### Code generator: dropping subsumed code equation
### Int.Neg ?m * Int.Neg ?n == Int.Pos (?m * ?n)
### Code generator: dropping subsumed code equation
### Int.Neg ?m * Int.Pos ?n == Int.Neg (?m * ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m * Int.Neg ?n == Int.Neg (?m * ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m * Int.Pos ?n == Int.Pos (?m * ?n)
### Code generator: dropping subsumed code equation
### 0 * ?l == 0
### Code generator: dropping subsumed code equation
### ?k * 0 == 0
### Code generator: dropping subsumed code equation
### Int.Neg ?m div Int.Neg ?n == fst (divmod ?m ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m div Int.Neg ?n == - Divides.adjust_div (divmod ?m ?n)
### Code generator: dropping subsumed code equation
### Int.Neg ?m div Int.Pos ?n == - Divides.adjust_div (divmod ?m ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m div Int.Pos ?n == fst (divmod ?m ?n)
### Code generator: dropping subsumed code equation
### ?k div Int.Neg num.One == - ?k
### Code generator: dropping subsumed code equation
### ?k div Int.Pos num.One == ?k
### Code generator: dropping subsumed code equation
### 0 div ?k == 0
### Code generator: dropping subsumed code equation
### ?k div 0 == 0
### Code generator: dropping subsumed code equation
### Int.Neg ?m mod Int.Neg ?n == - snd (divmod ?m ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m mod Int.Neg ?n ==
### - Divides.adjust_mod (Int.Pos ?n) (snd (divmod ?m ?n))
### Code generator: dropping subsumed code equation
### Int.Neg ?m mod Int.Pos ?n ==
### Divides.adjust_mod (Int.Pos ?n) (snd (divmod ?m ?n))
### Code generator: dropping subsumed code equation
### Int.Pos ?m mod Int.Pos ?n == snd (divmod ?m ?n)
### Code generator: dropping subsumed code equation
### ?k mod Int.Neg num.One == 0
### Code generator: dropping subsumed code equation
### ?k mod Int.Pos num.One == 0
### Code generator: dropping subsumed code equation
### 0 mod ?k == 0
### Code generator: dropping subsumed code equation
### ?k mod 0 == ?k
### Code generator: dropping subsumed code equation
### divmod (num.Bit1 ?m) (num.Bit1 ?n) ==
### if ?m < ?n then (0, numeral (num.Bit1 ?m))
### else divmod_step (num.Bit1 ?n)
###       (divmod (num.Bit1 ?m) (num.Bit0 (num.Bit1 ?n)))
### Code generator: dropping subsumed code equation
### divmod (num.Bit0 ?m) (num.Bit1 ?n) ==
### if ?m <= ?n then (0, numeral (num.Bit0 ?m))
### else divmod_step (num.Bit1 ?n)
###       (divmod (num.Bit0 ?m) (num.Bit0 (num.Bit1 ?n)))
### Code generator: dropping subsumed code equation
### divmod (num.Bit1 ?m) (num.Bit0 ?n) ==
### case divmod ?m ?n of (q, r) => (q, 2 * r + 1)
### Code generator: dropping subsumed code equation
### divmod (num.Bit0 ?m) (num.Bit0 ?n) ==
### case divmod ?m ?n of (q, r) => (q, 2 * r)
### Code generator: dropping subsumed code equation
### divmod num.One (num.Bit1 ?n) == (0, Numeral1)
signature CANCEL = sig val proc: Proof.context -> cterm -> thm option end
functor Cancel_Fun (Data: CANCEL_NUMERALS_DATA): CANCEL
### Code generator: dropping subsumed code equation
### divmod num.One (num.Bit0 ?n) == (0, Numeral1)
### Code generator: dropping subsumed code equation
### divmod ?m num.One == (numeral ?m, 0)
### Code generator: dropping subsumed code equation
### equal_class.equal ?k ?k == True
### Code generator: dropping subsumed code equation
### equal_class.equal (Int.Neg ?k) (Int.Neg ?l) == equal_class.equal ?k ?l
### Code generator: dropping subsumed code equation
### equal_class.equal (Int.Neg ?k) (Int.Pos ?l) == False
### Code generator: dropping subsumed code equation
### equal_class.equal (Int.Neg ?k) 0 == False
### Code generator: dropping subsumed code equation
### equal_class.equal (Int.Pos ?k) (Int.Neg ?l) == False
### Code generator: dropping subsumed code equation
### equal_class.equal (Int.Pos ?k) (Int.Pos ?l) == equal_class.equal ?k ?l
### Code generator: dropping subsumed code equation
### equal_class.equal (Int.Pos ?k) 0 == False
### Code generator: dropping subsumed code equation
### equal_class.equal 0 (Int.Neg ?l) == False
### Code generator: dropping subsumed code equation
### equal_class.equal 0 (Int.Pos ?l) == False
### Code generator: dropping subsumed code equation
### equal_class.equal 0 0 == True
### Code generator: dropping subsumed code equation
### Int.Neg ?k <= Int.Neg ?l == ?l <= ?k
### Code generator: dropping subsumed code equation
### Int.Neg ?k <= Int.Pos ?l == True
### Code generator: dropping subsumed code equation
### Int.Neg ?k <= 0 == True
### Code generator: dropping subsumed code equation
### Int.Pos ?k <= Int.Neg ?l == False
### Code generator: dropping subsumed code equation
### Int.Pos ?k <= Int.Pos ?l == ?k <= ?l
### Code generator: dropping subsumed code equation
### Int.Pos ?k <= 0 == False
### Code generator: dropping subsumed code equation
### 0 <= Int.Neg ?l == False
### Code generator: dropping subsumed code equation
### 0 <= Int.Pos ?l == True
### Code generator: dropping subsumed code equation
### 0 <= 0 == True
### Code generator: dropping subsumed code equation
### Int.Neg ?k < Int.Neg ?l == ?l < ?k
### Code generator: dropping subsumed code equation
### Int.Neg ?k < Int.Pos ?l == True
### Code generator: dropping subsumed code equation
### Int.Neg ?k < 0 == True
### Code generator: dropping subsumed code equation
### Int.Pos ?k < Int.Neg ?l == False
### Code generator: dropping subsumed code equation
### Int.Pos ?k < Int.Pos ?l == ?k < ?l
### Code generator: dropping subsumed code equation
### Int.Pos ?k < 0 == False
### Code generator: dropping subsumed code equation
### 0 < Int.Neg ?l == False
### Code generator: dropping subsumed code equation
### 0 < Int.Pos ?l == True
### Code generator: dropping subsumed code equation
### 0 < 0 == False
signature CANCEL_DATA =
  sig
    val dest_coeff: term -> int * term
    val dest_sum: term -> term list
    val find_first_coeff: term -> term list -> int * term list
    val mk_coeff: int * term -> term
    val mk_sum: typ -> term list -> term
    val norm_ss1: simpset
    val norm_ss2: simpset
    val norm_tac: Proof.context -> tactic
    val numeral_simp_tac: Proof.context -> tactic
    val prove_conv:
       tactic list -> Proof.context -> thm list -> term * term -> thm option
    val simplify_meta_eq: Proof.context -> thm -> thm
    val trans_tac: Proof.context -> thm option -> tactic
  end
structure Cancel_Data: CANCEL_DATA
instantiation
  fract :: (idom) comm_ring_1
  uminus_fract == uminus :: 'a fract => 'a fract
  one_fract == one_class.one :: 'a fract
  times_fract == times :: 'a fract => 'a fract => 'a fract
  zero_fract == zero_class.zero :: 'a fract
  minus_fract == minus :: 'a fract => 'a fract => 'a fract
  plus_fract == plus :: 'a fract => 'a fract => 'a fract
### Code generator: dropping subsumed code equation
### of_int (Int.Pos ?k) == numeral ?k
### Code generator: dropping subsumed code equation
### of_int 0 == 0::?'a
### Code generator: dropping subsumed code equation
### of_int (Int.Neg ?k) == - numeral ?k
### Code generator: dropping subsumed code equation
### nat (Int.Pos ?k) == nat_of_num ?k
### Code generator: dropping subsumed code equation
### nat 0 == 0
### Code generator: dropping subsumed code equation
### nat (Int.Neg ?k) == 0
### theory "HOL-Library.Code_Target_Int"
### 0.126s elapsed time, 0.494s cpu time, 0.028s GC time
Loading theory "HOL-Library.Code_Target_Numeral" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "HOL-Decision_Procs.Approximation" via "HOL-Library.Code_Target_Numeral_Float")
signature CANCEL_SIMPROCS =
  sig
    val diff_cancel: Proof.context -> cterm -> thm option
    val eq_cancel: Proof.context -> cterm -> thm option
    val less_cancel: Proof.context -> cterm -> thm option
    val less_eq_cancel: Proof.context -> cterm -> thm option
  end
structure Cancel_Simprocs: CANCEL_SIMPROCS
### theory "HOL-Library.Cancellation"
### 0.412s elapsed time, 1.665s cpu time, 0.058s GC time
Loading theory "HOL-Library.Multiset" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "HOL-Analysis.Multivariate_Analysis" via "HOL-Analysis.Determinants" via "HOL-Combinatorics.Permutations")
### theory "HOL-Library.Code_Target_Numeral"
### 0.099s elapsed time, 0.395s cpu time, 0.000s GC time
Loading theory "HOL-Library.FuncSet" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "HOL-Analysis.Multivariate_Analysis" via "HOL-Analysis.Ordered_Euclidean_Space" via "HOL-Analysis.Convex_Euclidean_Space" via "HOL-Analysis.Topology_Euclidean_Space" via "HOL-Analysis.Elementary_Normed_Spaces")
instantiation
  multiset :: (type) cancel_comm_monoid_add
  zero_multiset == zero_class.zero :: 'a multiset
  minus_multiset == minus :: 'a multiset => 'a multiset => 'a multiset
  plus_multiset == plus :: 'a multiset => 'a multiset => 'a multiset
instantiation
  fract :: (idom) field
  inverse_fract == inverse :: 'a fract => 'a fract
  divide_fract == divide :: 'a fract => 'a fract => 'a fract
instantiation
  fract :: (linordered_idom) linorder
  less_eq_fract == less_eq :: 'a fract => 'a fract => bool
  less_fract == less :: 'a fract => 'a fract => bool
instantiation
  fract :: (linordered_idom) linordered_field
  sgn_fract == sgn :: 'a fract => 'a fract
  abs_fract == abs :: 'a fract => 'a fract
instantiation
  fract :: (linordered_idom) distrib_lattice
  inf_fract == inf :: 'a fract => 'a fract => 'a fract
  sup_fract == sup :: 'a fract => 'a fract => 'a fract
### ML warning (file "~~/src/HOL/Decision_Procs/langford.ML"):
### Matches are not exhaustive.
### ML warning (line 24 of "~~/src/HOL/Decision_Procs/langford.ML"):
### Pattern is not exhaustive.
### ML warning (line 90 of "~~/src/HOL/Decision_Procs/langford.ML"):
### Value identifier (q) has not been referenced.
### ML warning (line 90 of "~~/src/HOL/Decision_Procs/langford.ML"):
### Value identifier (p) has not been referenced.
### ML warning (file "~~/src/HOL/Decision_Procs/langford.ML"):
### Matches are not exhaustive.
### ML warning (line 100 of "~~/src/HOL/Decision_Procs/langford.ML"):
### Matches are not exhaustive.
### ML warning (line 136 of "~~/src/HOL/Decision_Procs/langford.ML"):
### Pattern is not exhaustive.
signature LANGFORD =
  sig
    val dlo_conv: Proof.context -> cterm -> thm
    val dlo_tac: Proof.context -> int -> tactic
  end
structure Langford: LANGFORD
### theory "HOL-Computational_Algebra.Fraction_Field"
### 1.021s elapsed time, 3.952s cpu time, 0.533s GC time
Loading theory "HOL-Library.Function_Algebras" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
### theory "HOL-Library.FuncSet"
### 0.461s elapsed time, 1.732s cpu time, 0.390s GC time
Loading theory "HOL-Library.Disjoint_Sets" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "HOL-Analysis.Multivariate_Analysis" via "HOL-Analysis.Ordered_Euclidean_Space" via "HOL-Analysis.Convex_Euclidean_Space" via "HOL-Analysis.Topology_Euclidean_Space" via "HOL-Analysis.Elementary_Normed_Spaces" via "HOL-Analysis.Elementary_Metric_Spaces" via "HOL-Analysis.Abstract_Topology_2" via "HOL-Analysis.Elementary_Topology")
instantiation
  fun :: (type, plus) plus
  plus_fun == plus :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  fun :: (type, zero) zero
  zero_fun == zero_class.zero :: 'a => 'b
instantiation
  fun :: (type, times) times
  times_fun == times :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  fun :: (type, one) one
  one_fun == one_class.one :: 'a => 'b
### theory "HOL-Library.Function_Algebras"
### 0.126s elapsed time, 0.495s cpu time, 0.075s GC time
Loading theory "HOL-Library.Infinite_Set" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "HOL-Analysis.Multivariate_Analysis" via "HOL-Analysis.Ordered_Euclidean_Space" via "HOL-Analysis.Convex_Euclidean_Space" via "HOL-Analysis.Convex" via "HOL-Analysis.Affine" via "HOL-Analysis.Linear_Algebra")
locale linorder_stupid_syntax
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
  assumes "linorder_stupid_syntax less_eq less"
locale comm_monoid_set
  fixes f :: "'a => 'a => 'a"  (infixl \<open>\<^bold>*\<close> 70)
    and z :: "'a"  (\<open>\<^bold>1\<close>)
  assumes "comm_monoid_set (\<^bold>*) \<^bold>1"
### Partially applied constant "Multiset.inter_mset" on left hand side of equation, in theorem:
### semilattice_inf.Inf_fin (\<inter>#) (set (?x # ?xs)) ==
### fold (\<inter>#) ?xs ?x
locale linorder_no_ub
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
  assumes "linorder_no_ub (\<sqsubseteq>) (\<sqsubset>)"
### Partially applied constant "Multiset.union_mset" on left hand side of equation, in theorem:
### semilattice_sup.Sup_fin (\<union>#) (set (?x # ?xs)) ==
### fold (\<union>#) ?xs ?x
consts
  enumerate :: "'a set => nat => 'a"
### theory "HOL-Library.Disjoint_Sets"
### 0.275s elapsed time, 1.077s cpu time, 0.141s GC time
Loading theory "HOL-Library.More_List" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "Sturm_Sequences.Sturm" via "Sturm_Sequences.Sturm_Method" via "Sturm_Sequences.Sturm_Theorem" via "HOL-Computational_Algebra.Polynomial")
### theory "HOL-Library.Infinite_Set"
### 0.277s elapsed time, 1.094s cpu time, 0.127s GC time
Loading theory "HOL-Library.Nat_Bijection" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.Stream")
locale linorder_no_lb
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
  assumes "linorder_no_lb (\<sqsubseteq>) (\<sqsubset>)"
### theory "HOL-Library.More_List"
### 0.169s elapsed time, 0.664s cpu time, 0.061s GC time
Loading theory "HOL-Library.Old_Datatype" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "HOL-Analysis.Multivariate_Analysis" via "HOL-Analysis.Ordered_Euclidean_Space" via "HOL-Analysis.Convex_Euclidean_Space" via "HOL-Analysis.Topology_Euclidean_Space" via "HOL-Analysis.Elementary_Normed_Spaces" via "HOL-Analysis.Elementary_Metric_Spaces" via "HOL-Analysis.Abstract_Topology_2" via "HOL-Analysis.Elementary_Topology" via "HOL-Library.Set_Idioms" via "HOL-Library.Countable_Set" via "HOL-Library.Countable")
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
signature MULTISET_SIMPROCS =
  sig
    val subset_cancel_msets: Proof.context -> cterm -> thm option
    val subseteq_cancel_msets: Proof.context -> cterm -> thm option
  end
structure Multiset_Simprocs: MULTISET_SIMPROCS
instantiation
  multiset :: (type) Inf
  Inf_multiset == Inf :: 'a multiset set => 'a multiset
instantiation
  multiset :: (type) Sup
  Sup_multiset == Sup :: 'a multiset set => 'a multiset
locale constr_dense_linorder
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
    and between :: "'a => 'a => 'a"
  assumes "constr_dense_linorder (\<sqsubseteq>) (\<sqsubset>) between"
Found termination order: "size_list size <*mlex*> {}"
instantiation
  multiset :: (type) size
  size_multiset == size :: 'a multiset => nat
### theory "HOL-Library.Nat_Bijection"
### 0.552s elapsed time, 1.996s cpu time, 0.752s GC time
Loading theory "HOL-Library.Stream" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.ExtrEqs")
### ML warning (line 33 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Value identifier (simpset) has not been referenced.
### ML warning (line 32 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Value identifier (atoms) has not been referenced.
### ML warning (line 31 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Value identifier (entr) has not been referenced.
### ML warning (line 35 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Value identifier (vs) has not been referenced.
### ML warning (line 35 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Matches are not exhaustive.
### ML warning (line 63 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Matches are not exhaustive.
### ML warning (line 90 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Pattern is not exhaustive.
### ML warning (file "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Matches are not exhaustive.
### ML warning (line 113 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Pattern is not exhaustive.
### ML warning (line 115 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Pattern is not exhaustive.
### ML warning (line 117 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Pattern is not exhaustive.
### ML warning (line 119 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Pattern is not exhaustive.
### ML warning (line 121 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Pattern is not exhaustive.
### ML warning (line 149 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Matches are not exhaustive.
### ML warning (line 147 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Pattern is not exhaustive.
### ML warning (line 143 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Pattern is not exhaustive.
### ML warning (line 149 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Matches are not exhaustive.
### ML warning (line 147 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Pattern is not exhaustive.
### ML warning (line 143 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Pattern is not exhaustive.
signature FERRANTE_RACKOFF =
  sig
    val dlo_conv: Proof.context -> conv
    val dlo_tac: Proof.context -> int -> tactic
  end
structure FerranteRackoff: FERRANTE_RACKOFF
locale comp_fun_commute
  fixes f :: "'a => 'b => 'b"
  assumes "comp_fun_commute f"
### Partially applied constant "Orderings.ord_class.less_eq" on left hand side of equation, in theorem:
### linorder.Min (<=) (set (?x # ?xs)) == fold (ord.min (<=)) ?xs ?x
### Partially applied constant "Orderings.ord_class.less_eq" on left hand side of equation, in theorem:
### linorder.Max (<=) (set (?x # ?xs)) == fold (ord.max (<=)) ?xs ?x
signature OLD_DATATYPE =
  sig
    val check_specs: spec list -> theory -> spec list * Proof.context
    type config = {quiet: bool, strict: bool}
    val default_config: config
    type descr =
       (int * (string * dtyp list * (string * dtyp list) list)) list
    val distinct_lemma: thm
    datatype dtyp
    = DtRec of int | DtTFree of string * sort | DtType of string * dtyp list
    type info =
       {case_cong: thm,
        case_cong_weak: thm,
        case_name: string,
        case_rewrites: thm list,
        descr: descr,
        distinct: thm list,
        exhaust: thm,
        index: int,
        induct: thm,
        inducts: thm list,
        inject: thm list,
        nchotomy: thm,
        rec_names: string list,
        rec_rewrites: thm list, split: thm, split_asm: thm}
    val read_specs: spec_cmd list -> theory -> spec list * Proof.context
    type spec =
       (binding * (string * sort) list * mixfix) *
       (binding * typ list * mixfix) list
    type spec_cmd =
       (binding * (string * string option) list * mixfix) *
       (binding * string list * mixfix) list
  end
structure Old_Datatype: OLD_DATATYPE
### theory "HOL-Library.Old_Datatype"
### 0.684s elapsed time, 2.507s cpu time, 0.824s GC time
Loading theory "HOL-Library.Phantom_Type" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "HOL-Analysis.Multivariate_Analysis" via "HOL-Analysis.Ordered_Euclidean_Space" via "HOL-Analysis.Convex_Euclidean_Space" via "HOL-Analysis.Topology_Euclidean_Space" via "HOL-Analysis.Elementary_Normed_Spaces" via "HOL-Analysis.Cartesian_Space" via "HOL-Analysis.Finite_Cartesian_Product" via "HOL-Library.Numeral_Type" via "HOL-Library.Cardinality")
consts
  mset :: "'a list => 'a multiset"
### theory "HOL-Decision_Procs.Dense_Linear_Order"
### 2.345s elapsed time, 8.979s cpu time, 1.628s GC time
Loading theory "HOL-Library.Product_Plus" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "HOL-Analysis.Multivariate_Analysis" via "HOL-Analysis.Ordered_Euclidean_Space" via "HOL-Analysis.Convex_Euclidean_Space" via "HOL-Analysis.Convex" via "HOL-Analysis.Affine" via "HOL-Analysis.Linear_Algebra" via "HOL-Analysis.Euclidean_Space" via "HOL-Analysis.Product_Vector")
instantiation
  prod :: (zero, zero) zero
  zero_prod == zero_class.zero :: 'a * 'b
instantiation
  prod :: (plus, plus) plus
  plus_prod == plus :: 'a * 'b => 'a * 'b => 'a * 'b
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
instantiation
  prod :: (minus, minus) minus
  minus_prod == minus :: 'a * 'b => 'a * 'b => 'a * 'b
instantiation
  prod :: (uminus, uminus) uminus
  uminus_prod == uminus :: 'a * 'b => 'a * 'b
consts
  shift :: "'a list => 'a stream => 'a stream"
### theory "HOL-Library.Product_Plus"
### 0.115s elapsed time, 0.452s cpu time, 0.064s GC time
Loading theory "HOL-Library.Product_Order" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "HOL-Analysis.Multivariate_Analysis" via "HOL-Analysis.Ordered_Euclidean_Space")
Proofs for coinductive predicate(s) "streamsp"
  Proving monotonicity ...
instantiation
  prod :: (ord, ord) ord
  less_eq_prod == less_eq :: 'a * 'b => 'a * 'b => bool
  less_prod == less :: 'a * 'b => 'a * 'b => bool
locale comm_monoid_mset
  fixes f :: "'a => 'a => 'a"  (infixl \<open>\<^bold>*\<close> 70)
    and z :: "'a"  (\<open>\<^bold>1\<close>)
  assumes "comm_monoid_mset (\<^bold>*) \<^bold>1"
instantiation
  prod :: (inf, inf) inf
  inf_prod == inf :: 'a * 'b => 'a * 'b => 'a * 'b
instantiation
  prod :: (sup, sup) sup
  sup_prod == sup :: 'a * 'b => 'a * 'b => 'a * 'b
consts
  snth :: "'a stream => nat => 'a"
instantiation
  prod :: (top, top) top
  top_prod == top :: 'a * 'b
instantiation
  prod :: (bot, bot) bot
  bot_prod == bot :: 'a * 'b
consts
  stake :: "nat => 'a stream => 'a list"
instantiation
  prod :: (Inf, Inf) Inf
  Inf_prod == Inf :: ('a * 'b) set => 'a * 'b
class comm_monoid_add = ab_semigroup_add + monoid_add +
  assumes "add_0": "!!a. (0::'a) + a = a"
consts
  sdrop :: "nat => 'a stream => 'a stream"
instantiation
  prod :: (Sup, Sup) Sup
  Sup_prod == Sup :: ('a * 'b) set => 'a * 'b
class comm_monoid_add = ab_semigroup_add + monoid_add +
  assumes "add_0": "!!a. (0::'a) + a = a"
consts
  sfilter :: "('a => bool) => 'a stream => 'a stream"
### theory "HOL-Library.Product_Order"
### 0.214s elapsed time, 0.840s cpu time, 0.086s GC time
Loading theory "HOL-Library.Set_Algebras" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
consts
  cycle :: "'a list => 'a stream"
instantiation
  set :: (plus) plus
  plus_set == plus :: 'a set => 'a set => 'a set
instantiation
  set :: (times) times
  times_set == times :: 'a set => 'a set => 'a set
class canonically_ordered_monoid_add = ordered_comm_monoid_add +
  assumes "le_iff_add": "!!a b. (a <= b) = (EX c. b = a + c)"
instantiation
  set :: (zero) zero
  zero_set == zero_class.zero :: 'a set
instantiation
  set :: (one) one
  one_set == one_class.one :: 'a set
consts
  siterate :: "('a => 'a) => 'a => 'a stream"
### theory "HOL-Library.Phantom_Type"
### 0.912s elapsed time, 3.388s cpu time, 1.192s GC time
Loading theory "HOL-Library.Cardinality" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "HOL-Analysis.Multivariate_Analysis" via "HOL-Analysis.Ordered_Euclidean_Space" via "HOL-Analysis.Convex_Euclidean_Space" via "HOL-Analysis.Topology_Euclidean_Space" via "HOL-Analysis.Elementary_Normed_Spaces" via "HOL-Analysis.Cartesian_Space" via "HOL-Analysis.Finite_Cartesian_Product" via "HOL-Library.Numeral_Type")
consts
  flat :: "'a list stream => 'a stream"
### Additional type variable(s) in locale specification "CARD_1": 'a
consts
  sinterleave :: "'a stream => 'a stream => 'a stream"
consts
  szip :: "'a stream => 'b stream => ('a * 'b) stream"
class CARD_1 = type +
  assumes "CARD_1": "CARD('a) = 1"
### theory "HOL-Library.Set_Algebras"
### 0.531s elapsed time, 1.880s cpu time, 1.019s GC time
Loading theory "HOL-Library.Tree" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.ExtrEqs" via "Draft.Templates")
consts
  smap2 :: "('a => 'b => 'c) => 'a stream => 'b stream => 'c stream"
### theory "HOL-Library.Stream"
### 1.269s elapsed time, 4.786s cpu time, 1.308s GC time
Loading theory "HOL-Library.Countable" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "HOL-Analysis.Multivariate_Analysis" via "HOL-Analysis.Ordered_Euclidean_Space" via "HOL-Analysis.Convex_Euclidean_Space" via "HOL-Analysis.Topology_Euclidean_Space" via "HOL-Analysis.Elementary_Normed_Spaces" via "HOL-Analysis.Elementary_Metric_Spaces" via "HOL-Analysis.Abstract_Topology_2" via "HOL-Analysis.Elementary_Topology" via "HOL-Library.Set_Idioms" via "HOL-Library.Countable_Set")
class comm_monoid_mult = ab_semigroup_mult + monoid_mult + dvd +
  assumes "mult_1": "!!a. (1::'a) * a = a"
### Additional type variable(s) in locale specification "card2": 'a
class card2 = finite +
  assumes "two_le_card": "2 <= CARD('a)"
class finite_UNIV = type +
  fixes finite_UNIV :: "('a, bool) phantom"
  assumes "finite_UNIV": "finite_UNIV = Phantom('a) (finite UNIV)"
class card_UNIV = finite_UNIV +
  fixes card_UNIV :: "('a, nat) phantom"
  assumes "card_UNIV": "card_UNIV_class.card_UNIV = Phantom('a) CARD('a)"
instantiation
  nat :: card_UNIV
  card_UNIV_nat == card_UNIV_class.card_UNIV :: (nat, nat) phantom
  finite_UNIV_nat == finite_UNIV :: (nat, bool) phantom
instantiation
  int :: card_UNIV
  card_UNIV_int == card_UNIV_class.card_UNIV :: (int, nat) phantom
  finite_UNIV_int == finite_UNIV :: (int, bool) phantom
instantiation
  natural :: card_UNIV
  card_UNIV_natural == card_UNIV_class.card_UNIV :: (natural, nat) phantom
  finite_UNIV_natural == finite_UNIV :: (natural, bool) phantom
instantiation
  integer :: card_UNIV
  card_UNIV_integer == card_UNIV_class.card_UNIV :: (integer, nat) phantom
  finite_UNIV_integer == finite_UNIV :: (integer, bool) phantom
instantiation
  list :: (type) card_UNIV
  card_UNIV_list == card_UNIV_class.card_UNIV :: ('a list, nat) phantom
  finite_UNIV_list == finite_UNIV :: ('a list, bool) phantom
instantiation
  unit :: card_UNIV
  card_UNIV_unit == card_UNIV_class.card_UNIV :: (unit, nat) phantom
  finite_UNIV_unit == finite_UNIV :: (unit, bool) phantom
instantiation
  bool :: card_UNIV
  card_UNIV_bool == card_UNIV_class.card_UNIV :: (bool, nat) phantom
  finite_UNIV_bool == finite_UNIV :: (bool, bool) phantom
instantiation
  char :: card_UNIV
  card_UNIV_char == card_UNIV_class.card_UNIV :: (char, nat) phantom
  finite_UNIV_char == finite_UNIV :: (char, bool) phantom
instantiation
  prod :: (finite_UNIV, finite_UNIV) finite_UNIV
  finite_UNIV_prod == finite_UNIV :: ('a * 'b, bool) phantom
instantiation
  prod :: (card_UNIV, card_UNIV) card_UNIV
  card_UNIV_prod == card_UNIV_class.card_UNIV :: ('a * 'b, nat) phantom
instantiation
  sum :: (finite_UNIV, finite_UNIV) finite_UNIV
  finite_UNIV_sum == finite_UNIV :: ('a + 'b, bool) phantom
instantiation
  sum :: (card_UNIV, card_UNIV) card_UNIV
  card_UNIV_sum == card_UNIV_class.card_UNIV :: ('a + 'b, nat) phantom
instantiation
  fun :: (finite_UNIV, card_UNIV) finite_UNIV
  finite_UNIV_fun == finite_UNIV :: ('a => 'b, bool) phantom
### Additional type variable(s) in locale specification "countable": 'a
instantiation
  fun :: (card_UNIV, card_UNIV) card_UNIV
  card_UNIV_fun == card_UNIV_class.card_UNIV :: ('a => 'b, nat) phantom
instantiation
  option :: (finite_UNIV) finite_UNIV
  finite_UNIV_option == finite_UNIV :: ('a option, bool) phantom
instantiation
  option :: (card_UNIV) card_UNIV
  card_UNIV_option == card_UNIV_class.card_UNIV :: ('a option, nat) phantom
instantiation
  String.literal :: card_UNIV
  card_UNIV_literal == card_UNIV_class.card_UNIV ::
    (String.literal, nat) phantom
  finite_UNIV_literal == finite_UNIV :: (String.literal, bool) phantom
class countable = type +
  assumes "ex_inj": "EX to_nat. inj to_nat"
instantiation
  set :: (finite_UNIV) finite_UNIV
  finite_UNIV_set == finite_UNIV :: ('a set, bool) phantom
instantiation
  set :: (card_UNIV) card_UNIV
  card_UNIV_set == card_UNIV_class.card_UNIV :: ('a set, nat) phantom
instantiation
  Enum.finite_1 :: card_UNIV
  card_UNIV_finite_1 == card_UNIV_class.card_UNIV ::
    (Enum.finite_1, nat) phantom
  finite_UNIV_finite_1 == finite_UNIV :: (Enum.finite_1, bool) phantom
instantiation
  Enum.finite_2 :: card_UNIV
  card_UNIV_finite_2 == card_UNIV_class.card_UNIV ::
    (Enum.finite_2, nat) phantom
  finite_UNIV_finite_2 == finite_UNIV :: (Enum.finite_2, bool) phantom
consts
  left :: "'a tree => 'a tree"
instantiation
  Enum.finite_3 :: card_UNIV
  card_UNIV_finite_3 == card_UNIV_class.card_UNIV ::
    (Enum.finite_3, nat) phantom
  finite_UNIV_finite_3 == finite_UNIV :: (Enum.finite_3, bool) phantom
consts
  right :: "'a tree => 'a tree"
instantiation
  Enum.finite_4 :: card_UNIV
  card_UNIV_finite_4 == card_UNIV_class.card_UNIV ::
    (Enum.finite_4, nat) phantom
  finite_UNIV_finite_4 == finite_UNIV :: (Enum.finite_4, bool) phantom
instantiation
  Enum.finite_5 :: card_UNIV
  card_UNIV_finite_5 == card_UNIV_class.card_UNIV ::
    (Enum.finite_5, nat) phantom
  finite_UNIV_finite_5 == finite_UNIV :: (Enum.finite_5, bool) phantom
### theory "HOL-Library.Cardinality"
### 0.784s elapsed time, 3.094s cpu time, 0.245s GC time
Loading theory "HOL-Library.Numeral_Type" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "HOL-Analysis.Multivariate_Analysis" via "HOL-Analysis.Ordered_Euclidean_Space" via "HOL-Analysis.Convex_Euclidean_Space" via "HOL-Analysis.Topology_Euclidean_Space" via "HOL-Analysis.Elementary_Normed_Spaces" via "HOL-Analysis.Cartesian_Space" via "HOL-Analysis.Finite_Cartesian_Product")
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Proofs for inductive predicate(s) "finite_item"
  Proving monotonicity ...
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
Found termination order: "size <*mlex*> {}"
instantiation
  num1 :: CARD_1
instantiation
  num1 :: {comm_monoid_mult,numeral,comm_ring}
  uminus_num1 == uminus :: num1 => num1
  zero_num1 == zero_class.zero :: num1
  minus_num1 == minus :: num1 => num1 => num1
  plus_num1 == plus :: num1 => num1 => num1
  one_num1 == one_class.one :: num1
  times_num1 == times :: num1 => num1 => num1
instantiation
  num1 :: linorder
  less_eq_num1 == less_eq :: num1 => num1 => bool
  less_num1 == less :: num1 => num1 => bool
class height = type +
  fixes height :: "'a => nat"
instantiation
  tree :: (type) height
  height_tree == height :: 'a tree => nat
locale mod_type
  fixes n :: "int"
    and Rep :: "'a => int"
    and Abs :: "int => 'a"
  assumes "mod_type n Rep Abs"
locale mod_ring
  fixes n :: "int"
    and Rep :: "'a => int"
    and Abs :: "int => 'a"
  assumes "mod_ring n Rep Abs"
instantiation
  bit0 :: (finite) {minus,one,plus,times,uminus,zero}
  bit1 :: (finite) {minus,one,plus,times,uminus,zero}
  zero_bit0 == zero_class.zero :: 'a bit0
  uminus_bit0 == uminus :: 'a bit0 => 'a bit0
  times_bit0 == times :: 'a bit0 => 'a bit0 => 'a bit0
  plus_bit0 == plus :: 'a bit0 => 'a bit0 => 'a bit0
  one_bit0 == one_class.one :: 'a bit0
  minus_bit0 == minus :: 'a bit0 => 'a bit0 => 'a bit0
  zero_bit1 == zero_class.zero :: 'a bit1
  uminus_bit1 == uminus :: 'a bit1 => 'a bit1
  times_bit1 == times :: 'a bit1 => 'a bit1 => 'a bit1
  plus_bit1 == plus :: 'a bit1 => 'a bit1 => 'a bit1
  one_bit1 == one_class.one :: 'a bit1
  minus_bit1 == minus :: 'a bit1 => 'a bit1 => 'a bit1
val old_countable_datatype_tac = fn: Proof.context -> int -> tactic
Found termination order: "size <*mlex*> {}"
### ML warning (line 93 of "~~/src/HOL/Tools/BNF/bnf_lfp_countable.ML"):
### Pattern is not exhaustive.
### ML warning (line 139 of "~~/src/HOL/Tools/BNF/bnf_lfp_countable.ML"):
### Pattern is not exhaustive.
### ML warning (line 143 of "~~/src/HOL/Tools/BNF/bnf_lfp_countable.ML"):
### Matches are not exhaustive.
### ML warning (line 145 of "~~/src/HOL/Tools/BNF/bnf_lfp_countable.ML"):
### Matches are not exhaustive.
### ML warning (line 156 of "~~/src/HOL/Tools/BNF/bnf_lfp_countable.ML"):
### Pattern is not exhaustive.
signature BNF_LFP_COUNTABLE =
  sig
    val countable_datatype_tac: Proof.context -> tactic
    val derive_encode_injectives_thms:
       Proof.context -> string list -> thm list
  end
structure BNF_LFP_Countable: BNF_LFP_COUNTABLE
Found termination order: "size <*mlex*> {}"
val countable_datatype_tac = fn: Proof.context -> thm -> thm Seq.seq
val countable_tac = fn: Proof.context -> int -> tactic
instantiation
  multiset :: (preorder) order
  less_eq_multiset == less_eq :: 'a multiset => 'a multiset => bool
  less_multiset == less :: 'a multiset => 'a multiset => bool
Found termination order: "size <*mlex*> {}"
instantiation
  bit0 :: (finite) linorder
  bit1 :: (finite) linorder
  less_eq_bit0 == less_eq :: 'a bit0 => 'a bit0 => bool
  less_bit0 == less :: 'a bit0 => 'a bit0 => bool
  less_eq_bit1 == less_eq :: 'a bit1 => 'a bit1 => bool
  less_bit1 == less :: 'a bit1 => 'a bit1 => bool
instantiation
  multiset :: (preorder) ordered_ab_semigroup_add
Proofs for inductive predicate(s) "pw_leq"
  Proving monotonicity ...
instantiation
  num0 :: equal
  equal_num0 == equal_class.equal :: num0 => num0 => bool
Found termination order: "size <*mlex*> {}"
instantiation
  num1 :: equal
  equal_num1 == equal_class.equal :: num1 => num1 => bool
instantiation
  num1 :: enum
  enum_num1 == enum_class.enum :: num1 list
  enum_all_num1 == enum_class.enum_all :: (num1 => bool) => bool
  enum_ex_num1 == enum_class.enum_ex :: (num1 => bool) => bool
instantiation
  num0 :: card_UNIV
  num1 :: card_UNIV
  card_UNIV_num0 == card_UNIV_class.card_UNIV :: (num0, nat) phantom
  finite_UNIV_num0 == finite_UNIV :: (num0, bool) phantom
  card_UNIV_num1 == card_UNIV_class.card_UNIV :: (num1, nat) phantom
  finite_UNIV_num1 == finite_UNIV :: (num1, bool) phantom
Found termination order: "size <*mlex*> {}"
### theory "HOL-Library.Countable"
### 1.256s elapsed time, 4.956s cpu time, 0.491s GC time
Loading theory "HOL-Library.Countable_Set" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "HOL-Analysis.Multivariate_Analysis" via "HOL-Analysis.Ordered_Euclidean_Space" via "HOL-Analysis.Convex_Euclidean_Space" via "HOL-Analysis.Topology_Euclidean_Space" via "HOL-Analysis.Elementary_Normed_Spaces" via "HOL-Analysis.Elementary_Metric_Spaces" via "HOL-Analysis.Abstract_Topology_2" via "HOL-Analysis.Elementary_Topology" via "HOL-Library.Set_Idioms")
instantiation
  bit0 :: (finite) equal
  bit1 :: (finite) equal
  equal_bit0 == equal_class.equal :: 'a bit0 => 'a bit0 => bool
  equal_bit1 == equal_class.equal :: 'a bit1 => 'a bit1 => bool
Found termination order: "size <*mlex*> {}"
instantiation
  bit0 :: (finite) enum
  enum_bit0 == enum_class.enum :: 'a bit0 list
  enum_all_bit0 == enum_class.enum_all :: ('a bit0 => bool) => bool
  enum_ex_bit0 == enum_class.enum_ex :: ('a bit0 => bool) => bool
instantiation
  bit1 :: (finite) enum
  enum_bit1 == enum_class.enum :: 'a bit1 list
  enum_all_bit1 == enum_class.enum_all :: ('a bit1 => bool) => bool
  enum_ex_bit1 == enum_class.enum_ex :: ('a bit1 => bool) => bool
Found termination order: "size <*mlex*> {}"
instantiation
  bit0 :: (finite) finite_UNIV
  bit1 :: (finite) finite_UNIV
  finite_UNIV_bit0 == finite_UNIV :: ('a bit0, bool) phantom
  finite_UNIV_bit1 == finite_UNIV :: ('a bit1, bool) phantom
Found termination order: "(%p. length (fst p)) <*mlex*> {}"
instantiation
  bit0 :: ({card_UNIV,finite}) card_UNIV
  bit1 :: ({card_UNIV,finite}) card_UNIV
  card_UNIV_bit0 == card_UNIV_class.card_UNIV :: ('a bit0, nat) phantom
  card_UNIV_bit1 == card_UNIV_class.card_UNIV :: ('a bit1, nat) phantom
instantiation
  multiset :: (equal) equal
  equal_multiset == equal_class.equal :: 'a multiset => 'a multiset => bool
### theory "HOL-Library.Numeral_Type"
### 0.795s elapsed time, 3.138s cpu time, 0.380s GC time
Loading theory "HOL-Analysis.Metric_Arith" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "HOL-Analysis.Multivariate_Analysis" via "HOL-Analysis.Ordered_Euclidean_Space" via "HOL-Analysis.Convex_Euclidean_Space" via "HOL-Analysis.Topology_Euclidean_Space" via "HOL-Analysis.Elementary_Normed_Spaces" via "HOL-Analysis.Elementary_Metric_Spaces")
instantiation
  multiset :: (random) random
  random_multiset == random_class.random ::
    natural
    => natural * natural
       => ('a multiset * (unit => term)) * natural * natural
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
instantiation
  multiset :: (full_exhaustive) full_exhaustive
  full_exhaustive_multiset == full_exhaustive_class.full_exhaustive ::
    ('a multiset * (unit => term) => (bool * term list) option)
    => natural => (bool * term list) option
Proofs for inductive predicate(s) "pred_mset"
  Proving monotonicity ...
Found termination order: "size <*mlex*> {}"
Proofs for inductive predicate(s) "rel_mset'"
  Proving monotonicity ...
locale comm_monoid_set
  fixes f :: "'a => 'a => 'a"  (infixl \<open>\<^bold>*\<close> 70)
    and z :: "'a"  (\<open>\<^bold>1\<close>)
  assumes "comm_monoid_set (\<^bold>*) \<^bold>1"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
### theory "HOL-Library.Multiset"
### 4.422s elapsed time, 16.945s cpu time, 3.393s GC time
Loading theory "HOL-Computational_Algebra.Factorial_Ring" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "Sturm_Sequences.Sturm" via "Sturm_Sequences.Sturm_Method" via "Sturm_Sequences.Sturm_Theorem" via "HOL-Computational_Algebra.Polynomial")
### theory "HOL-Library.Countable_Set"
### 0.491s elapsed time, 1.940s cpu time, 0.196s GC time
Loading theory "HOL-Combinatorics.Permutations" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "HOL-Analysis.Multivariate_Analysis" via "HOL-Analysis.Determinants")
Found termination order: "size <*mlex*> {}"
### theory "HOL-Library.Tree"
### 2.127s elapsed time, 8.405s cpu time, 0.847s GC time
signature METRIC_ARITH =
  sig
    val argo_timeout: real Config.T
    val metric_arith_tac: Proof.context -> int -> tactic
    val trace: bool Config.T
  end
structure Metric_Arith: METRIC_ARITH
Loading theory "Draft.Templates" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.ExtrEqs")
### theory "HOL-Analysis.Metric_Arith"
### 0.674s elapsed time, 2.669s cpu time, 0.266s GC time
Loading theory "HOL-Library.Countable_Complete_Lattices" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "HOL-Analysis.Multivariate_Analysis" via "HOL-Analysis.Cross3" via "HOL-Analysis.Cartesian_Euclidean_Space" via "HOL-Analysis.Derivative" via "HOL-Analysis.Bounded_Linear_Function" via "HOL-Analysis.Uniform_Limit" via "HOL-Analysis.Summation_Tests" via "HOL-Library.Extended_Real" via "HOL-Library.Extended_Nat" via "HOL-Library.Order_Continuity")
datatype template_term
=
     t_empty
   | template_app of template_term * template_term
   | template_hole of int
   | template_var of int
datatype sign
= equals | greater_equals | greater_than | less_equals | less_than
datatype template
=
     template_bimplication of template * template
   | template_dunno
   | template_equation of template_term * template_term
   | template_implication of template list * template
   | template_inequation of sign * template_term * template_term
   | template_negation of template
   | template_predicate of template_term
constructor t_empty: template_term
constructor template_app: template_term * template_term -> template_term
constructor template_hole: int -> template_term
constructor template_var: int -> template_term
constructor equals: sign
constructor greater_equals: sign
constructor greater_than: sign
constructor less_equals: sign
constructor less_than: sign
constructor template_bimplication: template * template -> template
constructor template_dunno: template
constructor template_equation: template_term * template_term -> template
constructor template_implication: template list * template -> template
constructor template_inequation:
   sign * template_term * template_term -> template
constructor template_negation: template -> template
constructor template_predicate: template_term -> template
val vfs = fn: term -> (indexname * typ) list * (string * typ) list
val indexOf = fn: ''a list -> ''a -> int -> int
val has_eq = fn: term -> bool
val term2template = fn:
   (indexname * typ) list -> (string * typ) list -> term -> template_term
val lemma2predicate = fn: term -> term -> template
val makeTemplatewithContext = fn: term -> term -> template
val lemma2template = fn: term -> template
val thm2template = fn: thm -> template
val tterm2string = fn: template_term -> string
val template2string = fn: template -> string
val t = "height ?t <= size ?t": thm
val th =
   Const ("HOL.Trueprop", "bool => prop") $
     (Const ("Orderings.ord_class.less_eq", "nat => nat => bool") $
       (Const ("Tree.height_class.height", "?'a tree => nat") $
         Var (("t", 0), "?'a tree")) $
       (Const ("Nat.size_class.size", "?'a tree => nat") $
         Var (("t", 0), "?'a tree"))):
   term
### theory "Draft.Templates"
### 0.067s elapsed time, 0.271s cpu time, 0.000s GC time
Loading theory "HOL-Library.Set_Idioms" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "HOL-Analysis.Multivariate_Analysis" via "HOL-Analysis.Ordered_Euclidean_Space" via "HOL-Analysis.Convex_Euclidean_Space" via "HOL-Analysis.Topology_Euclidean_Space" via "HOL-Analysis.Elementary_Normed_Spaces" via "HOL-Analysis.Elementary_Metric_Spaces" via "HOL-Analysis.Abstract_Topology_2" via "HOL-Analysis.Elementary_Topology")
Proofs for inductive predicate(s) "swapidseq"
  Proving monotonicity ...
### theory "HOL-Library.Set_Idioms"
### 0.226s elapsed time, 0.899s cpu time, 0.073s GC time
Loading theory "HOL-Analysis.Abstract_Topology" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "HOL-Analysis.Multivariate_Analysis" via "HOL-Analysis.Ordered_Euclidean_Space" via "HOL-Analysis.Convex_Euclidean_Space" via "HOL-Analysis.Topology_Euclidean_Space" via "HOL-Analysis.Elementary_Normed_Spaces" via "HOL-Analysis.Elementary_Metric_Spaces" via "HOL-Analysis.Abstract_Topology_2")
locale comm_monoid_set
  fixes f :: "'a => 'a => 'a"  (infixl \<open>\<^bold>*\<close> 70)
    and z :: "'a"  (\<open>\<^bold>1\<close>)
  assumes "comm_monoid_set (\<^bold>*) \<^bold>1"
class countable_complete_lattice = Inf + Sup + lattice + bot + top +
  assumes "ccInf_lower": "!!A x. [| countable A; x : A |] ==> Inf A <= x"
  assumes
    "ccInf_greatest":
      "!!A z. [| countable A; !!x. x : A ==> z <= x |] ==> z <= Inf A"
  assumes "ccSup_upper": "!!A x. [| countable A; x : A |] ==> x <= Sup A"
  assumes
    "ccSup_least":
      "!!A z. [| countable A; !!x. x : A ==> x <= z |] ==> Sup A <= z"
  assumes "ccInf_empty": "Inf {} = top"
  assumes "ccSup_empty": "Sup {} = bot"
Found termination order: "(%p. size_list size (fst p)) <*mlex*> {}"
class normalization_semidom = algebraic_semidom +
  semidom_divide_unit_factor +
  fixes normalize :: "'a => 'a"
  assumes
    "unit_factor_mult_normalize": "!!a. unit_factor a * normalize a = a"
    and "normalize_0": "normalize (0::'a) = (0::'a)"
### theory "HOL-Combinatorics.Permutations"
### 1.488s elapsed time, 5.605s cpu time, 1.997s GC time
Loading theory "HOL-Analysis.Inner_Product" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "HOL-Analysis.Multivariate_Analysis" via "HOL-Analysis.Ordered_Euclidean_Space" via "HOL-Analysis.Convex_Euclidean_Space" via "HOL-Analysis.Convex" via "HOL-Analysis.Affine" via "HOL-Analysis.Linear_Algebra" via "HOL-Analysis.Euclidean_Space")
class semiring_gcd = gcd + normalization_semidom +
  assumes "gcd_dvd1": "!!a b. gcd a b dvd a"
    and "gcd_dvd2": "!!a b. gcd a b dvd b"
    and "gcd_greatest": "!!c a b. [| c dvd a; c dvd b |] ==> c dvd gcd a b"
    and "normalize_gcd": "!!a b. normalize (gcd a b) = gcd a b"
    and "lcm_gcd": "!!a b. lcm a b = normalize (a * b div gcd a b)"
class real_inner = dist_norm + real_vector + sgn_div_norm +
  uniformity_dist + open_uniformity +
  fixes inner :: "'a => 'a => real"
  assumes "inner_commute": "!!x y. inner x y = inner y x"
    and "inner_add_left": "!!x y z. inner (x + y) z = inner x z + inner y z"
    and
    "inner_scaleR_left": "!!r x y. inner (r *\<^sub>R x) y = r * inner x y"
    and "inner_ge_zero": "!!x. 0 <= inner x x"
    and "inner_eq_zero_iff": "!!x. (inner x x = 0) = (x = (0::'a))"
    and "norm_eq_sqrt_inner": "!!x. norm x = sqrt (inner x x)"
class countable_complete_distrib_lattice = countable_complete_lattice +
  assumes
    "sup_ccInf": "!!B a. countable B ==> sup a (Inf B) = Inf (sup a ` B)"
  assumes
    "inf_ccSup": "!!B a. countable B ==> inf a (Sup B) = Sup (inf a ` B)"
instantiation
  real :: real_inner
  inner_real == inner :: real => real => real
class factorial_semiring = normalization_semidom +
  assumes
    "prime_factorization_exists":
      "!!x. x ~= (0::'a) ==>
            EX A. (ALL x. x :# A --> prime_elem x) &
                  normalize (\<Prod>\<^sub># A) = normalize x"
instantiation
  complex :: real_inner
  inner_complex == inner :: complex => complex => real
bundle inner_syntax
bundle no_inner_syntax
### theory "HOL-Analysis.Inner_Product"
### 1.060s elapsed time, 4.191s cpu time, 0.247s GC time
Loading theory "HOL-Analysis.L2_Norm" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "HOL-Analysis.Multivariate_Analysis" via "HOL-Analysis.Ordered_Euclidean_Space" via "HOL-Analysis.Convex_Euclidean_Space" via "HOL-Analysis.Convex" via "HOL-Analysis.Affine" via "HOL-Analysis.Linear_Algebra" via "HOL-Analysis.Euclidean_Space")
### theory "HOL-Analysis.L2_Norm"
### 0.115s elapsed time, 0.452s cpu time, 0.079s GC time
Loading theory "HOL-Analysis.Operator_Norm" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "HOL-Analysis.Multivariate_Analysis" via "HOL-Analysis.Cross3" via "HOL-Analysis.Cartesian_Euclidean_Space" via "HOL-Analysis.Derivative" via "HOL-Analysis.Bounded_Linear_Function")
class factorial_semiring = normalization_semidom +
  assumes
    "prime_factorization_exists":
      "!!x. x ~= (0::'a) ==>
            EX A. (ALL x. x :# A --> prime_elem x) &
                  normalize (\<Prod>\<^sub># A) = normalize x"
### theory "HOL-Analysis.Operator_Norm"
### 0.098s elapsed time, 0.400s cpu time, 0.000s GC time
Loading theory "HOL-Analysis.Product_Vector" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "HOL-Analysis.Multivariate_Analysis" via "HOL-Analysis.Ordered_Euclidean_Space" via "HOL-Analysis.Convex_Euclidean_Space" via "HOL-Analysis.Convex" via "HOL-Analysis.Affine" via "HOL-Analysis.Linear_Algebra" via "HOL-Analysis.Euclidean_Space")
### theory "HOL-Library.Countable_Complete_Lattices"
### 2.692s elapsed time, 10.371s cpu time, 2.258s GC time
Loading theory "HOL-Library.BigO" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.ExtrEqs")
locale module_prod
  fixes s1 :: "'a => 'b => 'b"
    and s2 :: "'a => 'c => 'c"
  assumes "module_prod s1 s2"
locale vector_space_prod
  fixes s1 :: "'a => 'b => 'b"  (infixr \<open>*a\<close> 75)
    and s2 :: "'a => 'c => 'c"  (infixr \<open>*b\<close> 75)
  assumes "vector_space_prod (*a) (*b)"
### Cannot skip proof of schematic goal statement
instantiation
  prod :: (real_vector, real_vector) real_vector
  scaleR_prod == scaleR :: real => 'a * 'b => 'a * 'b
### Cannot skip proof of schematic goal statement
instantiation
  prod :: (metric_space, metric_space) dist
  dist_prod == dist :: 'a * 'b => 'a * 'b => real
instantiation
  prod :: (uniformity, uniformity) uniformity
  uniformity_prod == uniformity :: (('a * 'b) * 'a * 'b) filter
instantiation
  prod :: (uniform_space, uniform_space) uniform_space
instantiation
  prod :: (metric_space, metric_space) uniformity_dist
instantiation
  prod :: (metric_space, metric_space) metric_space
instantiation
  prod :: (real_normed_vector, real_normed_vector) real_normed_vector
  sgn_prod == sgn :: 'a * 'b => 'a * 'b
  norm_prod == norm :: 'a * 'b => real
Proofs for inductive predicate(s) "generate_topology_on"
  Proving monotonicity ...
locale finite_dimensional_vector_space_prod
  fixes s1 :: "'a => 'b => 'b"  (infixr \<open>*a\<close> 75)
    and s2 :: "'a => 'c => 'c"  (infixr \<open>*b\<close> 75)
    and B1 :: "'b set"
    and B2 :: "'c set"
  assumes "finite_dimensional_vector_space_prod (*a) (*b) B1 B2"
### theory "HOL-Analysis.Product_Vector"
### 0.968s elapsed time, 3.832s cpu time, 0.398s GC time
Loading theory "HOL-Analysis.Elementary_Topology" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "HOL-Analysis.Multivariate_Analysis" via "HOL-Analysis.Ordered_Euclidean_Space" via "HOL-Analysis.Convex_Euclidean_Space" via "HOL-Analysis.Topology_Euclidean_Space" via "HOL-Analysis.Elementary_Normed_Spaces" via "HOL-Analysis.Elementary_Metric_Spaces" via "HOL-Analysis.Abstract_Topology_2")
### theory "HOL-Analysis.Abstract_Topology"
### 3.079s elapsed time, 11.910s cpu time, 2.340s GC time
Loading theory "HOL-Analysis.Abstract_Limits" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "HOL-Analysis.Multivariate_Analysis" via "HOL-Analysis.Cross3" via "HOL-Analysis.Cartesian_Euclidean_Space" via "HOL-Analysis.Derivative" via "HOL-Analysis.Bounded_Linear_Function" via "HOL-Analysis.Function_Topology")
### theory "HOL-Library.BigO"
### 0.849s elapsed time, 3.362s cpu time, 0.303s GC time
Loading theory "HOL-Analysis.Euclidean_Space" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "HOL-Analysis.Multivariate_Analysis" via "HOL-Analysis.Ordered_Euclidean_Space" via "HOL-Analysis.Convex_Euclidean_Space" via "HOL-Analysis.Convex" via "HOL-Analysis.Affine" via "HOL-Analysis.Linear_Algebra")
### theory "HOL-Analysis.Abstract_Limits"
### 0.865s elapsed time, 3.148s cpu time, 2.233s GC time
Loading theory "Draft.ExtrEqs" (required by "Draft.Safe_DistanceMoreTemplates")
class topological_space = open +
  assumes "open_UNIV": "open UNIV"
  assumes "open_Int": "!!S T. [| open S; open T |] ==> open (S Int T)"
  assumes "open_Union": "!!K. Ball K open ==> open (\<Union> K)"
locale countable_basis
  fixes p :: "'a set => bool"
    and B :: "'a set set"
  assumes "countable_basis p B"
class factorial_semiring_gcd = factorial_semiring + Gcd +
  assumes "gcd_eq_gcd_factorial": "!!a b. gcd a b = gcd_factorial a b"
    and "lcm_eq_lcm_factorial": "!!a b. lcm a b = lcm_factorial a b"
    and "Gcd_eq_Gcd_factorial": "!!A. Gcd A = Gcd_factorial A"
    and "Lcm_eq_Lcm_factorial": "!!A. Lcm A = Lcm_factorial A"
class euclidean_space = real_inner +
  fixes Basis :: "'a set"
  assumes "nonempty_Basis": "Basis ~= {}"
  assumes "finite_Basis": "finite Basis"
  assumes
    "inner_Basis":
      "!!u v.
          [| u : Basis; v : Basis |]
          ==> inner u v = (if u = v then 1 else 0)"
  assumes
    "euclidean_all_zero_iff":
      "!!x. (ALL u:Basis. inner x u = 0) = (x = (0::'a))"
class second_countable_topology = topological_space +
  assumes
    "ex_countable_subbasis":
      "EX B. countable B & open = generate_topology B"
val eqpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Var (("_dummy_", 2), "?'a"))
       ):
   term Find_Theorems.criterion
val badeqpattern = Pattern (Const ("Pure.eq", "?'a => ?'a => prop")):
   term Find_Theorems.criterion
val undefpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Const ("HOL.undefined", "?'a"))
       ):
   term Find_Theorems.criterion
val thmpattern =
   Pattern
    (Const ("HOL.Trueprop", "bool => prop") $ Var (("_dummy_", 1), "bool")):
   term Find_Theorems.criterion
val badnames =
   ["*nitpick*", "*Nitpick*", "*full_exhaustive*", "*_def*", "Enum.finite*",
    "*Quickcheck*", "ATP*", "*Nunchaku*", "*Code*", "*BNF*", "*SMT*",
    "*.*.*"]:
   string list
val unwanted_names =
   [(false, Name "*nitpick*"), (false, Name "*Nitpick*"),
    (false, Name "*full_exhaustive*"), (false, Name "*_def*"),
    (false, Name "Enum.finite*"), (false, Name "*Quickcheck*"),
    (false, Name "ATP*"), (false, Name "*Nunchaku*"),
    (false, Name "*Code*"), (false, Name "*BNF*"), (false, Name "*SMT*"),
    (false, Name "*.*.*")]:
   (bool * term Find_Theorems.criterion) list
val has_vars = fn: term -> bool
val get_all_eqs = fn: string -> Proof.context -> (string * thm) list
val get_all_thms = fn: string -> Proof.context -> (string * thm) list
val get_noneq_thms = fn: string -> Proof.context -> (string * thm) list
val template_eqs = fn:
   string -> Proof.context -> (string * thm * template) list
val template_thms = fn:
   string -> Proof.context -> (string * thm * template) list
### theory "Draft.ExtrEqs"
### 0.718s elapsed time, 2.855s cpu time, 0.204s GC time
Loading theory "HOL-Library.Discrete" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "HOL-Analysis.Multivariate_Analysis" via "HOL-Analysis.Cross3" via "HOL-Analysis.Cartesian_Euclidean_Space" via "HOL-Analysis.Derivative" via "HOL-Analysis.Bounded_Linear_Function" via "HOL-Analysis.Uniform_Limit" via "HOL-Analysis.Summation_Tests")
### Rewrite rule not in simpset:
### Wellfounded.accp log_rel ?n1 ==>
### log ?n1 == if ?n1 < 2 then 0 else Suc (log (?n1 div 2))
Found termination order: "size <*mlex*> {}"
### theory "HOL-Library.Discrete"
### 0.149s elapsed time, 0.592s cpu time, 0.000s GC time
Loading theory "HOL-Library.Indicator_Function" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "HOL-Analysis.Multivariate_Analysis" via "HOL-Analysis.Ordered_Euclidean_Space" via "HOL-Analysis.Convex_Euclidean_Space" via "HOL-Analysis.Topology_Euclidean_Space" via "HOL-Analysis.Elementary_Normed_Spaces" via "HOL-Analysis.Elementary_Metric_Spaces" via "HOL-Analysis.Abstract_Topology_2")
### theory "HOL-Library.Indicator_Function"
### 0.435s elapsed time, 1.720s cpu time, 0.226s GC time
Loading theory "HOL-Library.Lattice_Algebras" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "HOL-Decision_Procs.Approximation" via "HOL-Decision_Procs.Approximation_Bounds" via "HOL-Library.Interval_Float" via "HOL-Library.Interval")
instantiation
  real :: euclidean_space
  Basis_real == Basis :: real set
instantiation
  complex :: euclidean_space
  Basis_complex == Basis :: complex set
instantiation
  prod :: (real_inner, real_inner) real_inner
  inner_prod == inner :: 'a * 'b => 'a * 'b => real
instantiation
  prod :: (euclidean_space, euclidean_space) euclidean_space
  Basis_prod == Basis :: ('a * 'b) set
### Cannot skip proof of schematic goal statement
### Cannot skip proof of schematic goal statement
### theory "HOL-Analysis.Euclidean_Space"
### 2.380s elapsed time, 9.170s cpu time, 2.831s GC time
Loading theory "HOL-Analysis.Finite_Cartesian_Product" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "HOL-Analysis.Multivariate_Analysis" via "HOL-Analysis.Ordered_Euclidean_Space" via "HOL-Analysis.Convex_Euclidean_Space" via "HOL-Analysis.Topology_Euclidean_Space" via "HOL-Analysis.Elementary_Normed_Spaces" via "HOL-Analysis.Cartesian_Space")
### theory "HOL-Analysis.Elementary_Topology"
### 2.664s elapsed time, 10.302s cpu time, 2.831s GC time
Loading theory "HOL-Analysis.Linear_Algebra" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "HOL-Analysis.Multivariate_Analysis" via "HOL-Analysis.Ordered_Euclidean_Space" via "HOL-Analysis.Convex_Euclidean_Space" via "HOL-Analysis.Convex" via "HOL-Analysis.Affine")
class real_inner = real_normed_vector +
  fixes inner :: "'a => 'a => real"
  assumes "inner_commute": "!!x y. x \<bullet> y = y \<bullet> x"
    and
    "inner_add_left":
      "!!x y z. (x + y) \<bullet> z = x \<bullet> z + y \<bullet> z"
    and
    "inner_scaleR_left":
      "!!r x y. r *\<^sub>R x \<bullet> y = r * (x \<bullet> y)"
    and "inner_ge_zero": "!!x. 0 <= x \<bullet> x"
    and "inner_eq_zero_iff": "!!x. (x \<bullet> x = 0) = (x = (0::'a))"
    and "norm_eq_sqrt_inner": "!!x. norm x = sqrt (x \<bullet> x)"
bundle vec_syntax
bundle no_vec_syntax
instantiation
  vec :: (zero, finite) zero
  zero_vec == zero_class.zero :: ('a, 'b) vec
instantiation
  vec :: (plus, finite) plus
  plus_vec == plus :: ('a, 'b) vec => ('a, 'b) vec => ('a, 'b) vec
instantiation
  vec :: (minus, finite) minus
  minus_vec == minus :: ('a, 'b) vec => ('a, 'b) vec => ('a, 'b) vec
instantiation
  vec :: (uminus, finite) uminus
  uminus_vec == uminus :: ('a, 'b) vec => ('a, 'b) vec
instantiation
  vec :: (times, finite) times
  times_vec == times :: ('a, 'b) vec => ('a, 'b) vec => ('a, 'b) vec
instantiation
  vec :: (one, finite) one
  one_vec == one_class.one :: ('a, 'b) vec
instantiation
  vec :: (ord, finite) ord
  less_eq_vec == less_eq :: ('a, 'b) vec => ('a, 'b) vec => bool
  less_vec == less :: ('a, 'b) vec => ('a, 'b) vec => bool
instantiation
  vec :: (real_vector, finite) real_vector
  scaleR_vec == scaleR :: real => ('a, 'b) vec => ('a, 'b) vec
instantiation
  vec :: (topological_space, finite) topological_space
  open_vec == open :: ('a, 'b) vec set => bool
instantiation
  vec :: (metric_space, finite) dist
  dist_vec == dist :: ('a, 'b) vec => ('a, 'b) vec => real
instantiation
  vec :: (metric_space, finite) uniformity_dist
  uniformity_vec == uniformity :: (('a, 'b) vec * ('a, 'b) vec) filter
instantiation
  vec :: (metric_space, finite) metric_space
instantiation
  vec :: (real_normed_vector, finite) real_normed_vector
  sgn_vec == sgn :: ('a, 'b) vec => ('a, 'b) vec
  norm_vec == norm :: ('a, 'b) vec => real
instantiation
  vec :: (real_inner, finite) real_inner
  inner_vec == inner :: ('a, 'b) vec => ('a, 'b) vec => real
### theory "HOL-Analysis.Linear_Algebra"
### 0.987s elapsed time, 3.929s cpu time, 0.370s GC time
Loading theory "HOL-Analysis.Affine" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "HOL-Analysis.Multivariate_Analysis" via "HOL-Analysis.Ordered_Euclidean_Space" via "HOL-Analysis.Convex_Euclidean_Space" via "HOL-Analysis.Convex")
instantiation
  vec :: (euclidean_space, finite) euclidean_space
  Basis_vec == Basis :: ('a, 'b) vec set
### theory "HOL-Analysis.Finite_Cartesian_Product"
### 1.668s elapsed time, 6.633s cpu time, 0.689s GC time
Loading theory "HOL-Analysis.Cartesian_Space" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "HOL-Analysis.Multivariate_Analysis" via "HOL-Analysis.Ordered_Euclidean_Space" via "HOL-Analysis.Convex_Euclidean_Space" via "HOL-Analysis.Topology_Euclidean_Space" via "HOL-Analysis.Elementary_Normed_Spaces")
### theory "HOL-Analysis.Affine"
### 0.494s elapsed time, 1.962s cpu time, 0.319s GC time
Loading theory "HOL-Analysis.Convex" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "HOL-Analysis.Multivariate_Analysis" via "HOL-Analysis.Ordered_Euclidean_Space" via "HOL-Analysis.Convex_Euclidean_Space")
### theory "HOL-Computational_Algebra.Factorial_Ring"
### 8.040s elapsed time, 31.314s cpu time, 6.242s GC time
Loading theory "HOL-Computational_Algebra.Euclidean_Algorithm" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "Sturm_Sequences.Sturm" via "Sturm_Sequences.Sturm_Method" via "Sturm_Sequences.Sturm_Theorem" via "Sturm_Sequences.Sturm_Library" via "Sturm_Sequences.Misc_Polynomial" via "HOL-Computational_Algebra.Polynomial_Factorial" via "HOL-Computational_Algebra.Normalized_Fraction")
class lattice_ab_group_add_abs = abs + lattice_ab_group_add +
  assumes "abs_lattice": "!!a. \<bar>a\<bar> = sup a (- a)"
### theory "HOL-Analysis.Convex"
### 0.953s elapsed time, 3.791s cpu time, 0.367s GC time
Loading theory "HOL-Computational_Algebra.Polynomial" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "Sturm_Sequences.Sturm" via "Sturm_Sequences.Sturm_Method" via "Sturm_Sequences.Sturm_Theorem")
locale linear_first_finite_dimensional_vector_space
  fixes scaleB :: "'a => 'b => 'b"  (infixr \<open>*b\<close> 75)
    and scaleC :: "'a => 'c => 'c"  (infixr \<open>*c\<close> 75)
    and BasisB :: "'b set"
    and f :: "'b => 'c"
  assumes "linear_first_finite_dimensional_vector_space (*b) (*c) BasisB f"
### theory "HOL-Analysis.Cartesian_Space"
### 1.602s elapsed time, 6.378s cpu time, 0.622s GC time
Loading theory "HOL-Analysis.Determinants" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "HOL-Analysis.Multivariate_Analysis")
instantiation
  poly :: (zero) zero
  zero_poly == zero_class.zero :: 'a poly
consts
  Poly :: "'a list => 'a poly"
instantiation
  poly :: ({zero,equal}) equal
  equal_poly == equal_class.equal :: 'a poly => 'a poly => bool
class euclidean_semiring_gcd = normalization_euclidean_semiring + Gcd +
  assumes "gcd_eucl": "normalization_euclidean_semiring_class.gcd = gcd"
    and "lcm_eucl": "normalization_euclidean_semiring_class.lcm = lcm"
  assumes "Gcd_eucl": "normalization_euclidean_semiring_class.Gcd = Gcd"
    and "Lcm_eucl": "normalization_euclidean_semiring_class.Lcm = Lcm"
instantiation
  poly :: (comm_monoid_add) comm_monoid_add
  plus_poly == plus :: 'a poly => 'a poly => 'a poly
instantiation
  poly :: (cancel_comm_monoid_add) cancel_comm_monoid_add
  minus_poly == minus :: 'a poly => 'a poly => 'a poly
### theory "HOL-Library.Lattice_Algebras"
### 4.379s elapsed time, 17.404s cpu time, 1.790s GC time
Loading theory "HOL-Analysis.Abstract_Topology_2" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "HOL-Analysis.Multivariate_Analysis" via "HOL-Analysis.Ordered_Euclidean_Space" via "HOL-Analysis.Convex_Euclidean_Space" via "HOL-Analysis.Topology_Euclidean_Space" via "HOL-Analysis.Elementary_Normed_Spaces" via "HOL-Analysis.Elementary_Metric_Spaces")
instantiation
  poly :: (ab_group_add) ab_group_add
  uminus_poly == uminus :: 'a poly => 'a poly
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
### theory "HOL-Analysis.Determinants"
### 0.933s elapsed time, 3.719s cpu time, 0.311s GC time
Loading theory "HOL-Library.Interval" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "HOL-Decision_Procs.Approximation" via "HOL-Decision_Procs.Approximation_Bounds" via "HOL-Library.Interval_Float")
instantiation
  poly :: (comm_semiring_0) comm_semiring_0
  times_poly == times :: 'a poly => 'a poly => 'a poly
instantiation
  poly :: (comm_semiring_1) comm_semiring_1
  one_poly == one_class.one :: 'a poly
instantiation
  poly :: (linordered_idom) linordered_idom
  sgn_poly == sgn :: 'a poly => 'a poly
  abs_poly == abs :: 'a poly => 'a poly
  less_eq_poly == less_eq :: 'a poly => 'a poly => bool
  less_poly == less :: 'a poly => 'a poly => bool
instantiation
  interval :: ({equal,preorder}) equal
  equal_interval == equal_class.equal :: 'a interval => 'a interval => bool
instantiation
  interval :: (preorder) ord
  less_eq_interval == less_eq :: 'a interval => 'a interval => bool
  less_interval == less :: 'a interval => 'a interval => bool
instantiation
  interval :: (lattice) semilattice_sup
  sup_interval == sup :: 'a interval => 'a interval => 'a interval
instantiation
  interval :: (ordered_ab_semigroup_add) ab_semigroup_add
  plus_interval == plus :: 'a interval => 'a interval => 'a interval
instantiation
  interval :: ({zero,preorder}) zero
  zero_interval == zero_class.zero :: 'a interval
instantiation
  interval :: (ordered_ab_group_add) uminus
  uminus_interval == uminus :: 'a interval => 'a interval
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
instantiation
  interval :: (ordered_ab_group_add) minus
  minus_interval == minus :: 'a interval => 'a interval => 'a interval
instantiation
  interval :: (linordered_semiring) times
  times_interval == times :: 'a interval => 'a interval => 'a interval
instantiation
  interval :: ({one,preorder}) one
  one_interval == one_class.one :: 'a interval
Proofs for inductive predicate(s) "algebraic_int"
  Proving monotonicity ...
instantiation
  poly :: (idom_divide) idom_divide
  divide_poly == divide :: 'a poly => 'a poly => 'a poly
### theory "HOL-Analysis.Abstract_Topology_2"
### 1.377s elapsed time, 5.461s cpu time, 0.706s GC time
Loading theory "HOL-Analysis.Connected" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "HOL-Analysis.Multivariate_Analysis" via "HOL-Analysis.Ordered_Euclidean_Space" via "HOL-Analysis.Convex_Euclidean_Space" via "HOL-Analysis.Topology_Euclidean_Space" via "HOL-Analysis.Elementary_Normed_Spaces")
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
Found termination order:
  "(%p. size (snd (snd (snd (snd (snd p)))))) <*mlex*> {}"
### theory "HOL-Analysis.Connected"
### 0.305s elapsed time, 1.210s cpu time, 0.090s GC time
Loading theory "HOL-Analysis.Function_Topology" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "HOL-Analysis.Multivariate_Analysis" via "HOL-Analysis.Cross3" via "HOL-Analysis.Cartesian_Euclidean_Space" via "HOL-Analysis.Derivative" via "HOL-Analysis.Bounded_Linear_Function")
Found termination order:
  "(%p. size (snd (snd (snd (snd (snd p)))))) <*mlex*> {}"
instantiation
  poly :: ({idom_divide,semidom_divide_unit_factor}) normalization_semidom
  normalize_poly == normalize :: 'a poly => 'a poly
  unit_factor_poly == unit_factor :: 'a poly => 'a poly
instantiation
  interval :: ({preorder,topological_space}) topological_space
  open_interval == open :: 'a interval set => bool
instantiation
  interval :: ({preorder,exhaustive}) exhaustive
  exhaustive_interval == exhaustive_class.exhaustive ::
    ('a interval => (bool * term list) option)
    => natural => (bool * term list) option
instantiation
  interval :: ({preorder,full_exhaustive}) full_exhaustive
  full_exhaustive_interval == full_exhaustive_class.full_exhaustive ::
    ('a interval * (unit => term) => (bool * term list) option)
    => natural => (bool * term list) option
instantiation
  interval :: ({preorder,random}) random
  random_interval == random_class.random ::
    natural
    => natural * natural
       => ('a interval * (unit => term)) * natural * natural
instantiation
  fun :: (type, topological_space) topological_space
  open_fun == open :: ('a => 'b) set => bool
### theory "HOL-Library.Interval"
### 2.052s elapsed time, 8.127s cpu time, 1.020s GC time
Loading theory "HOL-Analysis.Elementary_Metric_Spaces" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "HOL-Analysis.Multivariate_Analysis" via "HOL-Analysis.Ordered_Euclidean_Space" via "HOL-Analysis.Convex_Euclidean_Space" via "HOL-Analysis.Topology_Euclidean_Space" via "HOL-Analysis.Elementary_Normed_Spaces")
### theory "HOL-Analysis.Function_Topology"
### 0.712s elapsed time, 2.823s cpu time, 0.342s GC time
Loading theory "HOL-Library.Liminf_Limsup" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "HOL-Analysis.Multivariate_Analysis" via "HOL-Analysis.Cross3" via "HOL-Analysis.Cartesian_Euclidean_Space" via "HOL-Analysis.Derivative" via "HOL-Analysis.Bounded_Linear_Function" via "HOL-Analysis.Uniform_Limit" via "HOL-Analysis.Summation_Tests" via "HOL-Library.Extended_Real")
### theory "HOL-Library.Liminf_Limsup"
### 0.544s elapsed time, 2.147s cpu time, 0.357s GC time
Loading theory "HOL-Library.Log_Nat" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "HOL-Decision_Procs.Approximation" via "HOL-Decision_Procs.Approximation_Bounds" via "HOL-Library.Interval_Float" via "HOL-Library.Float")
class field_unit_factor = field + unit_factor +
  assumes "unit_factor_field": "unit_factor = id"
### theory "HOL-Library.Log_Nat"
### 0.149s elapsed time, 0.582s cpu time, 0.102s GC time
Loading theory "HOL-Library.Float" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "HOL-Decision_Procs.Approximation" via "HOL-Decision_Procs.Approximation_Bounds" via "HOL-Library.Interval_Float")
class heine_borel = metric_space +
  assumes
    "bounded_imp_convergent_subsequence":
      "!!f. bounded (range f) ==>
            EX l r. strict_mono r & (f o r) \<longlonglongrightarrow> l"
Proofs for inductive predicate(s) "eucl_rel_poly"
  Proving monotonicity ...
instantiation
  poly :: (field) semidom_modulo
  modulo_poly == modulo :: 'a poly => 'a poly => 'a poly
instantiation
  float :: {equal,linordered_idom}
  sgn_float == sgn :: float => float
  abs_float == abs :: float => float
  uminus_float == uminus :: float => float
  one_float == one_class.one :: float
  times_float == times :: float => float => float
  zero_float == zero_class.zero :: float
  minus_float == minus :: float => float => float
  less_eq_float == less_eq :: float => float => bool
  less_float == less :: float => float => bool
  plus_float == plus :: float => float => float
  equal_float == equal_class.equal :: float => float => bool
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
instantiation
  float :: lattice_ab_group_add
  inf_float == inf :: float => float => float
  sup_float == sup :: float => float => float
instantiation
  float :: exhaustive
  exhaustive_float == exhaustive_class.exhaustive ::
    (float => (bool * term list) option)
    => natural => (bool * term list) option
instantiation
  float :: full_exhaustive
  full_exhaustive_float == full_exhaustive_class.full_exhaustive ::
    (float * (unit => term) => (bool * term list) option)
    => natural => (bool * term list) option
Found termination order: "(%p. size (snd (snd (snd (snd p))))) <*mlex*> {}"
instantiation
  float :: random
  random_float == random_class.random ::
    natural
    => natural * natural => (float * (unit => term)) * natural * natural
Found termination order: "(%p. size (snd (snd (snd p)))) <*mlex*> {}"
Found termination order: "(%p. size (snd (snd (snd p)))) <*mlex*> {}"
### theory "HOL-Analysis.Elementary_Metric_Spaces"
### 1.956s elapsed time, 7.727s cpu time, 1.071s GC time
Loading theory "HOL-Analysis.Elementary_Normed_Spaces" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "HOL-Analysis.Multivariate_Analysis" via "HOL-Analysis.Ordered_Euclidean_Space" via "HOL-Analysis.Convex_Euclidean_Space" via "HOL-Analysis.Topology_Euclidean_Space")
Found termination order: "(%p. size (snd (snd p))) <*mlex*> {}"
Found termination order: "(%p. size (snd (snd (snd (snd p))))) <*mlex*> {}"
Found termination order: "(%p. size (snd (snd p))) <*mlex*> {}"
Found termination order: "(%p. size (snd (snd p))) <*mlex*> {}"
### theory "HOL-Computational_Algebra.Polynomial"
### 6.337s elapsed time, 25.099s cpu time, 3.063s GC time
Loading theory "HOL-Library.Order_Continuity" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "HOL-Analysis.Multivariate_Analysis" via "HOL-Analysis.Cross3" via "HOL-Analysis.Cartesian_Euclidean_Space" via "HOL-Analysis.Derivative" via "HOL-Analysis.Bounded_Linear_Function" via "HOL-Analysis.Uniform_Limit" via "HOL-Analysis.Summation_Tests" via "HOL-Library.Extended_Real" via "HOL-Library.Extended_Nat")
### theory "HOL-Library.Float"
### 1.944s elapsed time, 7.683s cpu time, 0.984s GC time
Loading theory "HOL-Library.Code_Target_Numeral_Float" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "HOL-Decision_Procs.Approximation")
### theory "HOL-Library.Code_Target_Numeral_Float"
### 0.276s elapsed time, 1.090s cpu time, 0.144s GC time
Loading theory "HOL-Library.Interval_Float" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "HOL-Decision_Procs.Approximation" via "HOL-Decision_Procs.Approximation_Bounds")
### theory "HOL-Library.Order_Continuity"
### 0.643s elapsed time, 2.528s cpu time, 0.395s GC time
Loading theory "HOL-Library.Extended_Nat" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "HOL-Analysis.Multivariate_Analysis" via "HOL-Analysis.Cross3" via "HOL-Analysis.Cartesian_Euclidean_Space" via "HOL-Analysis.Derivative" via "HOL-Analysis.Bounded_Linear_Function" via "HOL-Analysis.Uniform_Limit" via "HOL-Analysis.Summation_Tests" via "HOL-Library.Extended_Real")
### theory "HOL-Analysis.Elementary_Normed_Spaces"
### 1.421s elapsed time, 5.603s cpu time, 0.800s GC time
Loading theory "HOL-Library.Sum_of_Squares" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "HOL-Analysis.Multivariate_Analysis" via "HOL-Analysis.Ordered_Euclidean_Space" via "HOL-Analysis.Convex_Euclidean_Space" via "HOL-Analysis.Topology_Euclidean_Space" via "HOL-Analysis.Norm_Arith")
class infinity = type +
  fixes infinity :: "'a"
instantiation
  enat :: infinity
  infinity_enat == infinity :: enat
Proofs for inductive predicate(s) "rec_set_enat"
### No equation for constructor "Extended_Nat.infinity_class.infinity"
### in definition of function "the_enat"
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
consts
  the_enat :: "enat => nat"
instantiation
  enat :: zero_neq_one
  one_enat == one_class.one :: enat
  zero_enat == zero_class.zero :: enat
instantiation
  enat :: comm_monoid_add
  plus_enat == plus :: enat => enat => enat
instantiation
  enat :: {comm_semiring_1,semiring_no_zero_divisors}
  times_enat == times :: enat => enat => enat
Found termination order: "length <*mlex*> {}"
instantiation
  enat :: minus
  minus_enat == minus :: enat => enat => enat
instantiation
  enat :: linordered_ab_semigroup_add
  less_eq_enat == less_eq :: enat => enat => bool
  less_enat == less :: enat => enat => bool
instantiation
  enat :: {order_bot,order_top}
  top_enat == top :: enat
  bot_enat == bot :: enat
structure Cancel_Enat_Common:
  sig
    val dest_sum: term -> term list
    val dest_summing: term * term list -> term list
    val find_first: term -> term list -> term list
    val find_first_t: term list -> term -> term list -> term list
    val mk_eq: term * term -> term
    val mk_sum: typ -> term list -> term
    val norm_ss: simpset
    val norm_tac: Proof.context -> tactic
    val simplify_meta_eq: Proof.context -> thm -> thm -> thm
    val trans_tac: Proof.context -> thm option -> tactic
  end
structure Eq_Enat_Cancel:
  sig val proc: Proof.context -> term -> thm option end
structure Le_Enat_Cancel:
  sig val proc: Proof.context -> term -> thm option end
structure Less_Enat_Cancel:
  sig val proc: Proof.context -> term -> thm option end
instantiation
  enat :: complete_lattice
  Inf_enat == Inf :: enat set => enat
  Sup_enat == Sup :: enat set => enat
  sup_enat == sup :: enat => enat => enat
  inf_enat == inf :: enat => enat => enat
### theory "HOL-Library.Extended_Nat"
### 0.774s elapsed time, 3.038s cpu time, 0.448s GC time
Loading theory "HOL-Library.Extended_Real" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "HOL-Analysis.Multivariate_Analysis" via "HOL-Analysis.Cross3" via "HOL-Analysis.Cartesian_Euclidean_Space" via "HOL-Analysis.Derivative" via "HOL-Analysis.Bounded_Linear_Function" via "HOL-Analysis.Uniform_Limit" via "HOL-Analysis.Summation_Tests")
### theory "HOL-Library.Interval_Float"
### 1.112s elapsed time, 4.372s cpu time, 0.717s GC time
Loading theory "HOL-Decision_Procs.Approximation_Bounds" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "HOL-Decision_Procs.Approximation")
### ML warning (line 261 of "~~/src/HOL/Library/Sum_of_Squares/positivstellensatz.ML"):
### Value identifier (pth_abs) has not been referenced.
### ML warning (line 265 of "~~/src/HOL/Library/Sum_of_Squares/positivstellensatz.ML"):
### Value identifier (pth_max) has not been referenced.
### ML warning (line 269 of "~~/src/HOL/Library/Sum_of_Squares/positivstellensatz.ML"):
### Value identifier (pth_min) has not been referenced.
### ML warning (line 379 of "~~/src/HOL/Library/Sum_of_Squares/positivstellensatz.ML"):
### Pattern is not exhaustive.
signature FUNC =
  sig
    exception DUP of key
    exception SAME
    exception UNDEF of key
    val apply: 'a table -> key -> 'a
    val applyd: 'a table -> (key -> 'a) -> key -> 'a
    val build: ('a table -> 'a table) -> 'a table
    val choose: 'a table -> key * 'a
    val combine:
       ('a -> 'a -> 'a) -> ('a -> bool) -> 'a table -> 'a table -> 'a table
    val cons_list: key * 'a -> 'a list table -> 'a list table
    val default: key * 'a -> 'a table -> 'a table
    val defined: 'a table -> key -> bool
    val delete: key -> 'a table -> 'a table
    val delete_safe: key -> 'a table -> 'a table
    val dest: 'a table -> (key * 'a) list
    val dest_list: 'a list table -> (key * 'a) list
    val dom: 'a table -> key list
    val empty: 'a table
    val exists: (key * 'a -> bool) -> 'a table -> bool
    val fold: (key * 'a -> 'b -> 'b) -> 'a table -> 'b -> 'b
    val fold_rev: (key * 'a -> 'b -> 'b) -> 'a table -> 'b -> 'b
    val forall: (key * 'a -> bool) -> 'a table -> bool
    val get_first: (key * 'a -> 'b option) -> 'a table -> 'b option
    val insert: ('a * 'a -> bool) -> key * 'a -> 'a table -> 'a table
    val insert_list:
       ('a * 'a -> bool) -> key * 'a -> 'a list table -> 'a list table
    val insert_set: key -> set -> set
    val is_empty: 'a table -> bool
    val is_single: 'a table -> bool
    val join: (key -> 'a * 'a -> 'a) -> 'a table * 'a table -> 'a table
    type key
    val keys: 'a table -> key list
    val lookup: 'a table -> key -> 'a option
    val lookup_key: 'a table -> key -> (key * 'a) option
    val lookup_list: 'a list table -> key -> 'a list
    val make: (key * 'a) list -> 'a table
    val make_list: (key * 'a) list -> 'a list table
    val make_set: key list -> set
    val map: (key -> 'a -> 'b) -> 'a table -> 'b table
    val map_default: key * 'a -> ('a -> 'a) -> 'a table -> 'a table
    val map_entry: key -> ('a -> 'a) -> 'a table -> 'a table
    val max: 'a table -> (key * 'a) option
    val member: ('a * 'b -> bool) -> 'b table -> key * 'a -> bool
    val merge: ('a * 'a -> bool) -> 'a table * 'a table -> 'a table
    val merge_list:
       ('a * 'a -> bool) -> 'a list table * 'a list table -> 'a list table
    val min: 'a table -> (key * 'a) option
    val onefunc: key * 'a -> 'a table
    val remove: ('a * 'b -> bool) -> key * 'a -> 'b table -> 'b table
    val remove_list:
       ('a * 'b -> bool) -> key * 'a -> 'b list table -> 'b list table
    val remove_set: key -> set -> set
    type set = unit table
    type 'a table
    val tryapplyd: 'a table -> key -> 'a -> 'a
    val update: key * 'a -> 'a table -> 'a table
    val update_list:
       ('a * 'a -> bool) -> key * 'a -> 'a list table -> 'a list table
    val update_new: key * 'a -> 'a table -> 'a table
    val updatep: (key * 'a -> bool) -> key * 'a -> 'a table -> 'a table
  end
functor FuncFun (Key: KEY): FUNC
signature REAL_ARITH =
  sig
    type cert_conv = cterm -> thm * pss_tree
    val cterm_of_rat: Rat.rat -> cterm
    val dest_ratconst: cterm -> Rat.rat
    val gen_gen_real_arith:
       Proof.context ->
         (Rat.rat -> cterm) * conv * conv * conv * conv * conv * conv *
         conv * conv * conv * prover
           -> cert_conv
    val gen_prover_real_arith: Proof.context -> prover -> cert_conv
    val gen_real_arith:
       Proof.context ->
         (Rat.rat -> cterm) * conv * conv * conv * conv * conv * conv *
         conv * prover
           -> cert_conv
    val is_ratconst: cterm -> bool
    datatype positivstellensatz
    =
         Axiom_eq of int
       | Axiom_le of int
       | Axiom_lt of int
       | Eqmul of FuncUtil.poly * positivstellensatz
       | Product of positivstellensatz * positivstellensatz
       | Rational_eq of Rat.rat
       | Rational_le of Rat.rat
       | Rational_lt of Rat.rat
       | Square of FuncUtil.poly
       | Sum of positivstellensatz * positivstellensatz
    type prover =
       tree_choice list ->
         (thm list * thm list * thm list -> positivstellensatz -> thm) ->
           thm list * thm list * thm list -> thm * pss_tree
    datatype pss_tree
    = Branch of pss_tree * pss_tree | Cert of positivstellensatz | Trivial
    val real_linear_prover:
       (thm list * thm list * thm list -> positivstellensatz -> thm) ->
         thm list * thm list * thm list -> thm * pss_tree
    datatype tree_choice = Left | Right
  end
structure FuncUtil:
  sig
    structure Ctermfunc: FUNC
    structure Intfunc: FUNC
    structure Intpairfunc: FUNC
    structure Monomialfunc: FUNC
    structure Ratfunc: FUNC
    structure Symfunc: FUNC
    structure Termfunc: FUNC
    val dest_monomial: 'a Ctermfunc.table -> (cterm * 'a) list
    type monomial = int Ctermfunc.table
    val monomial_ord: int Ctermfunc.table * int Ctermfunc.table -> order
    val monomial_order: int Ctermfunc.table * int Ctermfunc.table -> order
    type poly = Rat.rat Monomialfunc.table
  end
structure RealArith: REAL_ARITH
signature POSITIVSTELLENSATZ_TOOLS =
  sig
    val print_cert: RealArith.pss_tree -> string
    val read_cert: Proof.context -> string -> RealArith.pss_tree
  end
structure Positivstellensatz_Tools: POSITIVSTELLENSATZ_TOOLS
instantiation
  enat :: linorder_topology
  open_enat == open :: enat set => bool
consts
  horner ::
    "(nat => nat)
     => (nat => nat => nat) => nat => nat => nat => real => real"
signature SUM_OF_SQUARES =
  sig
    exception Failure of string
    val debug: bool Config.T
    val debug_message: Proof.context -> (unit -> string) -> unit
    datatype proof_method
    = Certificate of RealArith.pss_tree | Prover of string -> string
    val sos_tac:
       (RealArith.pss_tree -> unit) ->
         proof_method -> Proof.context -> int -> tactic
    val trace: bool Config.T
    val trace_message: Proof.context -> (unit -> string) -> unit
  end
structure Sum_of_Squares: SUM_OF_SQUARES
signature SOS_WRAPPER =
  sig val sos_tac: Proof.context -> string option -> int -> tactic end
structure SOS_Wrapper: SOS_WRAPPER
### theory "HOL-Library.Sum_of_Squares"
### 1.440s elapsed time, 5.671s cpu time, 0.888s GC time
Loading theory "HOL-Analysis.Norm_Arith" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "HOL-Analysis.Multivariate_Analysis" via "HOL-Analysis.Ordered_Euclidean_Space" via "HOL-Analysis.Convex_Euclidean_Space" via "HOL-Analysis.Topology_Euclidean_Space")
instantiation
  ereal :: uminus
  uminus_ereal == uminus :: ereal => ereal
Found termination order: "{}"
instantiation
  ereal :: infinity
  infinity_ereal == infinity :: ereal
### ML warning (line 103 of "~~/src/HOL/Analysis/normarith.ML"):
### Matches are not exhaustive.
signature NORM_ARITH =
  sig
    val norm_arith: Proof.context -> conv
    val norm_arith_tac: Proof.context -> int -> tactic
  end
structure NormArith: NORM_ARITH
### theory "HOL-Analysis.Norm_Arith"
### 0.300s elapsed time, 1.183s cpu time, 0.145s GC time
Loading theory "HOL-Analysis.Topology_Euclidean_Space" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "HOL-Analysis.Multivariate_Analysis" via "HOL-Analysis.Ordered_Euclidean_Space" via "HOL-Analysis.Convex_Euclidean_Space")
instantiation
  ereal :: abs
  abs_ereal == abs :: ereal => ereal
Found termination order: "(%p. size (fst (snd p))) <*mlex*> {}"
### theory "HOL-Computational_Algebra.Euclidean_Algorithm"
### 9.850s elapsed time, 38.963s cpu time, 4.930s GC time
Loading theory "HOL-Computational_Algebra.Normalized_Fraction" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "Sturm_Sequences.Sturm" via "Sturm_Sequences.Sturm_Method" via "Sturm_Sequences.Sturm_Theorem" via "Sturm_Sequences.Sturm_Library" via "Sturm_Sequences.Misc_Polynomial" via "HOL-Computational_Algebra.Polynomial_Factorial")
instantiation
  ereal :: {comm_monoid_add,zero_neq_one}
  one_ereal == one_class.one :: ereal
  zero_ereal == zero_class.zero :: ereal
  plus_ereal == plus :: ereal => ereal => ereal
instantiation
  ereal :: linorder
  less_eq_ereal == less_eq :: ereal => ereal => bool
  less_ereal == less :: ereal => ereal => bool
locale fract_as_normalized_quot
Found termination order:
  "case_sum (%p. size (fst (snd p))) (%p. size (fst (snd p))) <*mlex*> {}"
instantiation
  ereal :: {comm_monoid_mult,sgn}
  sgn_ereal == sgn :: ereal => ereal
  times_ereal == times :: ereal => ereal => ereal
### theory "HOL-Computational_Algebra.Normalized_Fraction"
### 0.560s elapsed time, 2.199s cpu time, 0.416s GC time
Loading theory "HOL-Computational_Algebra.Field_as_Ring" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "Sturm_Sequences.Sturm" via "Sturm_Sequences.Sturm_Method" via "Sturm_Sequences.Sturm_Theorem")
instantiation
  ereal :: minus
  minus_ereal == minus :: ereal => ereal => ereal
instantiation
  ereal :: inverse
  inverse_ereal == inverse :: ereal => ereal
  divide_ereal == divide :: ereal => ereal => ereal
instantiation
  ereal :: lattice
  inf_ereal == inf :: ereal => ereal => ereal
  sup_ereal == sup :: ereal => ereal => ereal
instantiation
  ereal :: complete_lattice
  Inf_ereal == Inf :: ereal set => ereal
  Sup_ereal == Sup :: ereal set => ereal
  bot_ereal == bot :: ereal
  top_ereal == top :: ereal
instantiation
  ereal :: linear_continuum_topology
  open_ereal == open :: ereal set => bool
class field = division_ring + idom_divide +
  assumes "field_inverse": "!!a. a ~= (0::'a) ==> inverse a * a = (1::'a)"
  assumes "field_divide_inverse": "!!a b. a / b = a * inverse b"
  assumes "field_inverse_zero": "inverse (0::'a) = (0::'a)"
Found termination order:
  "case_sum (%p. size (fst (snd p))) (%p. size (fst (snd p))) <*mlex*> {}"
instantiation
  real ::
    {normalization_euclidean_semiring,unique_euclidean_ring,normalization_semidom_multiplicative}
  division_segment_real == division_segment :: real => real
  normalize_real == normalize :: real => real
  unit_factor_real == unit_factor :: real => real
  euclidean_size_real == euclidean_size :: real => nat
  modulo_real == modulo :: real => real => real
instantiation
  real :: euclidean_ring_gcd
  Gcd_real == Gcd :: real set => real
  Lcm_real == Lcm :: real set => real
  gcd_real == gcd :: real => real => real
  lcm_real == lcm :: real => real => real
instantiation
  rat ::
    {normalization_euclidean_semiring,unique_euclidean_ring,normalization_semidom_multiplicative}
  division_segment_rat == division_segment :: rat => rat
  normalize_rat == normalize :: rat => rat
  unit_factor_rat == unit_factor :: rat => rat
  euclidean_size_rat == euclidean_size :: rat => nat
  modulo_rat == modulo :: rat => rat => rat
instantiation
  rat :: euclidean_ring_gcd
  Gcd_rat == Gcd :: rat set => rat
  Lcm_rat == Lcm :: rat set => rat
  gcd_rat == gcd :: rat => rat => rat
  lcm_rat == lcm :: rat => rat => rat
instantiation
  complex ::
    {normalization_euclidean_semiring,unique_euclidean_ring,normalization_semidom_multiplicative}
  division_segment_complex == division_segment :: complex => complex
  normalize_complex == normalize :: complex => complex
  unit_factor_complex == unit_factor :: complex => complex
  euclidean_size_complex == euclidean_size :: complex => nat
  modulo_complex == modulo :: complex => complex => complex
instantiation
  complex :: euclidean_ring_gcd
  Gcd_complex == Gcd :: complex set => complex
  Lcm_complex == Lcm :: complex set => complex
  gcd_complex == gcd :: complex => complex => complex
  lcm_complex == lcm :: complex => complex => complex
### theory "HOL-Computational_Algebra.Field_as_Ring"
### 2.662s elapsed time, 10.145s cpu time, 5.635s GC time
Loading theory "HOL-Computational_Algebra.Polynomial_Factorial" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "Sturm_Sequences.Sturm" via "Sturm_Sequences.Sturm_Method" via "Sturm_Sequences.Sturm_Theorem" via "Sturm_Sequences.Sturm_Library" via "Sturm_Sequences.Misc_Polynomial")
### theory "HOL-Library.Extended_Real"
### 4.411s elapsed time, 16.988s cpu time, 6.801s GC time
Loading theory "HOL-Library.Extended_Nonnegative_Real" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "HOL-Analysis.Multivariate_Analysis" via "HOL-Analysis.Cross3" via "HOL-Analysis.Cartesian_Euclidean_Space" via "HOL-Analysis.Derivative" via "HOL-Analysis.Bounded_Linear_Function" via "HOL-Analysis.Uniform_Limit" via "HOL-Analysis.Summation_Tests" via "HOL-Analysis.Extended_Real_Limits")
Found termination order:
  "case_sum (%p. size (fst (snd p))) (%p. size (fst (snd p))) <*mlex*> {}"
### theory "HOL-Analysis.Topology_Euclidean_Space"
### 3.648s elapsed time, 14.004s cpu time, 6.286s GC time
Loading theory "HOL-Analysis.Convex_Euclidean_Space" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "HOL-Analysis.Multivariate_Analysis" via "HOL-Analysis.Ordered_Euclidean_Space")
### Cannot skip proof of schematic goal statement
Found termination order:
  "case_sum (%p. size (fst (snd p))) (%p. size (fst (snd p))) <*mlex*> {}"
instantiation
  ennreal :: complete_linorder
  Inf_ennreal == Inf :: ennreal set => ennreal
  Sup_ennreal == Sup :: ennreal set => ennreal
  bot_ennreal == bot :: ennreal
  sup_ennreal == sup :: ennreal => ennreal => ennreal
  top_ennreal == top :: ennreal
  inf_ennreal == inf :: ennreal => ennreal => ennreal
  less_eq_ennreal == less_eq :: ennreal => ennreal => bool
  less_ennreal == less :: ennreal => ennreal => bool
instantiation
  ennreal :: infinity
  infinity_ennreal == infinity :: ennreal
instantiation
  ennreal :: {comm_semiring_1,semiring_1_no_zero_divisors}
  zero_ennreal == zero_class.zero :: ennreal
  plus_ennreal == plus :: ennreal => ennreal => ennreal
  one_ennreal == one_class.one :: ennreal
  times_ennreal == times :: ennreal => ennreal => ennreal
instantiation
  ennreal :: minus
  minus_ennreal == minus :: ennreal => ennreal => ennreal
instantiation
  poly :: ({factorial_ring_gcd,semiring_gcd_mult_normalize})
    factorial_ring_gcd
  Gcd_poly == Gcd :: 'a poly set => 'a poly
  Lcm_poly == Lcm :: 'a poly set => 'a poly
  gcd_poly == gcd :: 'a poly => 'a poly => 'a poly
  lcm_poly == lcm :: 'a poly => 'a poly => 'a poly
instantiation
  ennreal :: inverse
  inverse_ennreal == inverse :: ennreal => ennreal
  divide_ennreal == divide :: ennreal => ennreal => ennreal
instantiation
  poly :: ({factorial_ring_gcd,field,semiring_gcd_mult_normalize})
    {normalization_euclidean_semiring,unique_euclidean_ring}
  division_segment_poly == division_segment :: 'a poly => 'a poly
  euclidean_size_poly == euclidean_size :: 'a poly => nat
structure Cancel_Ennreal_Common:
  sig
    val dest_sum: term -> term list
    val dest_summing: term * term list -> term list
    val find_first: term -> term list -> term list
    val find_first_t: term list -> term -> term list -> term list
    val mk_eq: term * term -> term
    val mk_sum: typ -> term list -> term
    val norm_ss: simpset
    val norm_tac: Proof.context -> tactic
    val simplify_meta_eq: Proof.context -> thm -> thm -> thm
    val trans_tac: Proof.context -> thm option -> tactic
  end
structure Eq_Ennreal_Cancel:
  sig val proc: Proof.context -> term -> thm option end
structure Le_Ennreal_Cancel:
  sig val proc: Proof.context -> term -> thm option end
structure Less_Ennreal_Cancel:
  sig val proc: Proof.context -> term -> thm option end
### theory "HOL-Computational_Algebra.Polynomial_Factorial"
### 1.201s elapsed time, 4.699s cpu time, 0.664s GC time
Loading theory "Sturm_Sequences.Misc_Polynomial" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "Sturm_Sequences.Sturm" via "Sturm_Sequences.Sturm_Method" via "Sturm_Sequences.Sturm_Theorem" via "Sturm_Sequences.Sturm_Library")
### theory "HOL-Decision_Procs.Approximation_Bounds"
### 5.396s elapsed time, 20.852s cpu time, 7.269s GC time
Loading theory "HOL-Decision_Procs.Approximation" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance")
instantiation
  ennreal :: linear_continuum_topology
  open_ennreal == open :: ennreal set => bool
### theory "HOL-Analysis.Convex_Euclidean_Space"
### 1.110s elapsed time, 4.343s cpu time, 0.586s GC time
Loading theory "HOL-Analysis.Ordered_Euclidean_Space" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "HOL-Analysis.Multivariate_Analysis")
### theory "Sturm_Sequences.Misc_Polynomial"
### 0.559s elapsed time, 2.178s cpu time, 0.411s GC time
Loading theory "Sturm_Sequences.Sturm_Library" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "Sturm_Sequences.Sturm" via "Sturm_Sequences.Sturm_Method" via "Sturm_Sequences.Sturm_Theorem")
### theory "Sturm_Sequences.Sturm_Library"
### 0.049s elapsed time, 0.194s cpu time, 0.000s GC time
Loading theory "Sturm_Sequences.Sturm_Theorem" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "Sturm_Sequences.Sturm" via "Sturm_Sequences.Sturm_Method")
### theory "HOL-Library.Extended_Nonnegative_Real"
### 1.723s elapsed time, 6.727s cpu time, 1.073s GC time
Loading theory "HOL-Analysis.Extended_Real_Limits" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "HOL-Analysis.Multivariate_Analysis" via "HOL-Analysis.Cross3" via "HOL-Analysis.Cartesian_Euclidean_Space" via "HOL-Analysis.Derivative" via "HOL-Analysis.Bounded_Linear_Function" via "HOL-Analysis.Uniform_Limit" via "HOL-Analysis.Summation_Tests")
locale quasi_sturm_seq
  fixes ps :: "real poly list"
  assumes "quasi_sturm_seq ps"
locale sturm_seq
  fixes ps :: "real poly list"
    and p :: "real poly"
  assumes "sturm_seq ps p"
### Missing patterns in function definition:
### !!b. split_sign_changes [] b = undefined
Found termination order: "(%p. length (fst p)) <*mlex*> {}"
class ordered_euclidean_space = Inf + Sup + euclidean_space + abs + inf +
  sup + ord +
  assumes
    "eucl_le":
      "!!x y. (x <= y) = (ALL i:Basis. x \<bullet> i <= y \<bullet> i)"
  assumes "eucl_less_le_not_le": "!!x y. (x < y) = (x <= y & ~ y <= x)"
  assumes
    "eucl_inf":
      "!!x y.
          inf x y =
          (SUM i:Basis. inf (x \<bullet> i) (y \<bullet> i) *\<^sub>R i)"
  assumes
    "eucl_sup":
      "!!x y.
          sup x y =
          (SUM i:Basis. sup (x \<bullet> i) (y \<bullet> i) *\<^sub>R i)"
  assumes
    "eucl_Inf":
      "!!X. Inf X = (SUM i:Basis. (INF x\<in>X. x \<bullet> i) *\<^sub>R i)"
  assumes
    "eucl_Sup":
      "!!X. Sup X = (SUM i:Basis. (SUP x\<in>X. x \<bullet> i) *\<^sub>R i)"
  assumes
    "eucl_abs":
      "!!x. \<bar>x\<bar> =
            (SUM i:Basis. \<bar>x \<bullet> i\<bar> *\<^sub>R i)"
### theory "Sturm_Sequences.Sturm_Theorem"
### 1.192s elapsed time, 4.604s cpu time, 0.776s GC time
Loading theory "Sturm_Sequences.Sturm_Method" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "Sturm_Sequences.Sturm")
### theory "HOL-Analysis.Extended_Real_Limits"
### 1.179s elapsed time, 4.555s cpu time, 0.776s GC time
Loading theory "HOL-Analysis.Summation_Tests" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "HOL-Analysis.Multivariate_Analysis" via "HOL-Analysis.Cross3" via "HOL-Analysis.Cartesian_Euclidean_Space" via "HOL-Analysis.Derivative" via "HOL-Analysis.Bounded_Linear_Function" via "HOL-Analysis.Uniform_Limit")
### ML warning (line 98 of "$AFP/Sturm_Sequences/sturm.ML"):
### Matches are not exhaustive.
signature STURM =
  sig
    val sturm_conv: Proof.context -> conv
    val sturm_tac: Proof.context -> bool -> int -> tactic
  end
structure Sturm: STURM
### theory "Sturm_Sequences.Sturm_Method"
### 2.026s elapsed time, 7.614s cpu time, 5.921s GC time
Loading theory "Sturm_Sequences.Sturm" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance")
### theory "Sturm_Sequences.Sturm"
### 0.054s elapsed time, 0.221s cpu time, 0.000s GC time
Loading theory "HOL-Analysis.Line_Segment" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "HOL-Analysis.Multivariate_Analysis" via "HOL-Analysis.Cross3" via "HOL-Analysis.Cartesian_Euclidean_Space" via "HOL-Analysis.Derivative")
### theory "HOL-Analysis.Summation_Tests"
### 0.861s elapsed time, 3.378s cpu time, 0.285s GC time
Loading theory "HOL-Analysis.Uniform_Limit" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "HOL-Analysis.Multivariate_Analysis" via "HOL-Analysis.Cross3" via "HOL-Analysis.Cartesian_Euclidean_Space" via "HOL-Analysis.Derivative" via "HOL-Analysis.Bounded_Linear_Function")
### theory "HOL-Analysis.Line_Segment"
### 0.946s elapsed time, 3.709s cpu time, 0.404s GC time
Loading theory "HOL-Analysis.Starlike" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "HOL-Analysis.Multivariate_Analysis")
### theory "HOL-Analysis.Uniform_Limit"
### 0.662s elapsed time, 2.598s cpu time, 0.356s GC time
Loading theory "HOL-Analysis.Bounded_Linear_Function" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "HOL-Analysis.Multivariate_Analysis" via "HOL-Analysis.Cross3" via "HOL-Analysis.Cartesian_Euclidean_Space" via "HOL-Analysis.Derivative")
instantiation
  prod :: (abs, abs) abs
  abs_prod == abs :: 'a * 'b => 'a * 'b
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
instantiation
  vec :: (ordered_euclidean_space, finite) ordered_euclidean_space
  abs_vec == abs :: ('a, 'b) vec => ('a, 'b) vec
  inf_vec == inf :: ('a, 'b) vec => ('a, 'b) vec => ('a, 'b) vec
  sup_vec == sup :: ('a, 'b) vec => ('a, 'b) vec => ('a, 'b) vec
  Inf_vec == Inf :: ('a, 'b) vec set => ('a, 'b) vec
  Sup_vec == Sup :: ('a, 'b) vec set => ('a, 'b) vec
### theory "HOL-Analysis.Ordered_Euclidean_Space"
### 5.489s elapsed time, 21.118s cpu time, 8.044s GC time
"(bij, bij_betw, permutation)"
  :: "(('a => 'b) => bool) *
      (('c => 'd) => 'c set => 'd set => bool) * (('e => 'e) => bool)"
Found termination order: "{}"
"- \<infinity>"
  :: "ereal"
Found termination order: "{}"
Found termination order: "{}"
"\<infinity>"
  :: "ereal"
Found termination order: "{}"
instantiation
  blinfun :: (real_normed_vector, real_normed_vector) real_normed_vector
  uminus_blinfun == uminus ::
    'a \<Rightarrow>\<^sub>L 'b => 'a \<Rightarrow>\<^sub>L 'b
  zero_blinfun == zero_class.zero :: 'a \<Rightarrow>\<^sub>L 'b
  minus_blinfun == minus ::
    'a \<Rightarrow>\<^sub>L 'b
    => 'a \<Rightarrow>\<^sub>L 'b => 'a \<Rightarrow>\<^sub>L 'b
  plus_blinfun == plus ::
    'a \<Rightarrow>\<^sub>L 'b
    => 'a \<Rightarrow>\<^sub>L 'b => 'a \<Rightarrow>\<^sub>L 'b
  sgn_blinfun == sgn ::
    'a \<Rightarrow>\<^sub>L 'b => 'a \<Rightarrow>\<^sub>L 'b
  norm_blinfun == norm :: 'a \<Rightarrow>\<^sub>L 'b => real
  scaleR_blinfun == scaleR ::
    real => 'a \<Rightarrow>\<^sub>L 'b => 'a \<Rightarrow>\<^sub>L 'b
  dist_blinfun == dist ::
    'a \<Rightarrow>\<^sub>L 'b => 'a \<Rightarrow>\<^sub>L 'b => real
  uniformity_blinfun == uniformity ::
    ('a \<Rightarrow>\<^sub>L 'b * 'a \<Rightarrow>\<^sub>L 'b) filter
  open_blinfun == open :: ('a \<Rightarrow>\<^sub>L 'b) set => bool
"ereal (13 / 4)"
  :: "ereal"
"True"
  :: "bool"
"True"
  :: "bool"
locale bounded_bilinear
  fixes prod :: "'a => 'b => 'c"  (infixl \<open>**\<close> 70)
  assumes "bounded_bilinear (**)"
?a : affine hull ?S ==> aff_dim ?S = int (dim ((+) (- ?a) ` ?S))
locale bounded_bilinear
  fixes prod :: "'a => 'b => 'c"  (infixl \<open>**\<close> 70)
  assumes "bounded_bilinear (**)"
### theory "HOL-Analysis.Starlike"
### 2.017s elapsed time, 8.044s cpu time, 1.438s GC time
### theory "HOL-Analysis.Bounded_Linear_Function"
### 2.158s elapsed time, 8.433s cpu time, 1.510s GC time
Loading theory "HOL-Analysis.Derivative" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "HOL-Analysis.Multivariate_Analysis" via "HOL-Analysis.Cross3" via "HOL-Analysis.Cartesian_Euclidean_Space")
Found termination order:
  "case_sum (%p. size (fst (snd p))) (%p. size (fst (snd p))) <*mlex*>
   case_sum (%x. 0) (%x. Suc 0) <*mlex*> {}"
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
### theory "HOL-Analysis.Derivative"
### 24.968s elapsed time, 82.927s cpu time, 79.794s GC time
Loading theory "HOL-Analysis.Cartesian_Euclidean_Space" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "HOL-Analysis.Multivariate_Analysis" via "HOL-Analysis.Cross3")
Loading theory "HOL-Analysis.Lipschitz" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "HOL-Analysis.Multivariate_Analysis")
bundle lipschitz_syntax
bundle no_lipschitz_syntax
### theory "HOL-Analysis.Cartesian_Euclidean_Space"
### 0.313s elapsed time, 0.959s cpu time, 0.138s GC time
Loading theory "HOL-Analysis.Cross3" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance" via "HOL-Analysis.Multivariate_Analysis")
### theory "HOL-Analysis.Lipschitz"
### 0.537s elapsed time, 1.668s cpu time, 0.288s GC time
bundle cross3_syntax
bundle no_cross3_syntax
### theory "HOL-Analysis.Cross3"
### 2.045s elapsed time, 5.336s cpu time, 0.441s GC time
Loading theory "HOL-Analysis.Multivariate_Analysis" (required by "Draft.Safe_DistanceMoreTemplates" via "Draft.Safe_Distance")
### theory "HOL-Analysis.Multivariate_Analysis"
### 0.980s elapsed time, 1.999s cpu time, 0.099s GC time
Found termination order:
  "case_sum (%p. size (fst (snd p))) (%p. size (fst (snd p))) <*mlex*>
   case_sum (%x. Suc 0) (%x. 0) <*mlex*>
   case_sum (%p. size (fst (snd (snd p))))
    (%p. size_list size (snd (snd (snd p)))) <*mlex*>
   {}"
Found termination order: "(%p. size (fst (snd p))) <*mlex*> {}"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
Found termination order: "(%p. size (fst (snd (snd p)))) <*mlex*> {}"
Found termination order: "(%p. size (fst (snd (snd p)))) <*mlex*> {}"
Found termination order: "(%p. size (fst (snd (snd (snd p))))) <*mlex*> {}"
Found termination order: "(%p. size (fst (snd (snd p)))) <*mlex*> {}"
Found termination order: "(%p. size (fst (snd p))) <*mlex*> {}"
signature APPROXIMATION_COMPUTATION =
  sig
    val approx_arith: Proof.context -> term -> term
    val approx_bool: Proof.context -> term -> term
    val approx_conv: Proof.context -> conv
    val approx_form_eval: Proof.context -> term -> term
  end
structure Approximation_Computation: APPROXIMATION_COMPUTATION
signature APPROXIMATION =
  sig
    val approx: int -> Proof.context -> term -> term
    val approximate: Proof.context -> term -> term
    val approximation_tac:
       int ->
         (string * int) list -> int option -> Proof.context -> int -> tactic
    val reify_form: Proof.context -> term -> term
  end
structure Approximation:
  sig
    val apply_reify_form: Proof.context -> term -> term
    val apply_tactic: Proof.context -> term -> tactic -> term
    val approx: int -> Proof.context -> term -> term
    val approx_arith: int -> Proof.context -> term -> term
    val approx_form: int -> Proof.context -> term -> term
    val approximate: Proof.context -> term -> term
    val approximate_cmd: string list -> string -> Toplevel.state -> unit
    val approximation_tac:
       int ->
         (string * int) list -> int option -> Proof.context -> int -> tactic
    val calculated_subterms: term -> term list
    val dest_float: term -> int * int
    val dest_interpret: term -> term * term
    val dest_interpret_env: term -> term
    val dest_interpret_form: term -> term * term
    val dest_ivl: term -> ((int * int) * (int * int)) option
    val float2_float10: int -> bool -> int * int -> int * int
    val mk_approx': int -> term -> term
    val mk_approx_form_eval: int -> term -> term -> term
    val mk_result: int -> ((int * int) * (int * int)) option -> term
    val opt_modes: Token.T list -> string list * Token.T list
    val prepare_form: Proof.context -> term -> term
    val prepare_form_tac: Proof.context -> int -> tactic
    val preproc_form_conv: Proof.context -> conv
    val realify: term -> term
    val reify_form: Proof.context -> term -> term
    val reify_form_conv: Proof.context -> cterm -> thm
    val reify_form_tac: Proof.context -> int -> tactic
    val reorder_bounds_tac: Proof.context -> thm list -> int -> tactic
    val rewrite_interpret_form_tac:
       Proof.context ->
         int ->
           (string * int) list -> int option -> int -> thm -> thm Seq.seq
  end
### ML warning (line 201 of "~~/src/HOL/Decision_Procs/approximation_generator.ML"):
### Matches are not exhaustive.
signature APPROXIMATION_GENERATOR =
  sig
    val approximation_generator:
       Proof.context ->
         (term * term list) list ->
           bool ->
             int list ->
               (bool * term list) option * Quickcheck.report option
    val custom_seed: int Config.T
    val epsilon: real Config.T
    val precision: int Config.T
    val setup: theory -> theory
  end
structure Approximation_Generator: APPROXIMATION_GENERATOR
bundle floatarith_notation
bundle no_floatarith_notation
### theory "HOL-Decision_Procs.Approximation"
### 49.951s elapsed time, 138.272s cpu time, 95.363s GC time
Loading theory "Draft.Safe_Distance" (required by "Draft.Safe_DistanceMoreTemplates")
locale movement
  fixes a :: "real"
    and v :: "real"
    and s0 :: "real"
locale braking_movement
  fixes a :: "real"
    and v :: "real"
    and s0 :: "real"
  assumes "braking_movement a v"
locale safe_distance
  fixes a\<^sub>e :: "real"
    and v\<^sub>e :: "real"
    and s\<^sub>e :: "real"
    and a\<^sub>o :: "real"
    and v\<^sub>o :: "real"
    and s\<^sub>o :: "real"
  assumes
    "safe_distance a\<^sub>e v\<^sub>e s\<^sub>e a\<^sub>o v\<^sub>o
      s\<^sub>o"
### Cannot skip proof of schematic goal statement
### theory "Draft.Safe_Distance"
### 1.479s elapsed time, 1.638s cpu time, 0.107s GC time
Loading theory "Draft.Safe_DistanceMoreTemplates"
val templateLemmas =
   [("Safe_Distance.less_Suc_iff_disj",
     "(?i < Suc ?x) = (?i = ?x | ?i < ?x)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 3, template_var 1),
              template_app (template_hole 2, template_var 0))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 1,
               template_app
                (template_app (template_hole 0, template_var 1),
                 template_var 0)),
             template_app
              (template_app (template_hole 3, template_var 1),
               template_var 0))
           ))),
    ("Safe_Distance.card_iff_exists",
     "(0 < card ?X) = (finite ?X & (EX x. x : ?X))",
     template_equation
      (template_app
        (template_app (template_hole 6, template_hole 5),
         template_app (template_hole 4, template_var 0)),
       template_app
        (template_app
          (template_hole 3, template_app (template_hole 2, template_var 0)),
         template_app (template_hole 1, t_empty)))),
    ("Safe_Distance.rel_dist_to_stop'",
     "interpret_floatarith (rel_dist_to_stop_expr 0 1) [?v, ?a] =
      rel_dist_to_stop ?v ?a",
     template_equation
      (template_app
        (template_app
          (template_hole 6,
           template_app
            (template_app (template_hole 5, template_hole 4),
             template_hole 3)),
         template_app
          (template_app (template_hole 2, template_var 1),
           template_app
            (template_app (template_hole 2, template_var 0),
             template_hole 1))),
       template_app
        (template_app (template_hole 0, template_var 1), template_var 0))),
    ("Safe_Distance.check_precond_safe_distance",
     "check_precond ?s\<^sub>e ?v\<^sub>e ?a\<^sub>e ?s\<^sub>o ?v\<^sub>o
       ?a\<^sub>o =
      safe_distance ?a\<^sub>e ?v\<^sub>e ?s\<^sub>e ?a\<^sub>o ?v\<^sub>o
       ?s\<^sub>o",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_app
              (template_app
                (template_app (template_hole 1, template_var 5),
                 template_var 4),
               template_var 3),
             template_var 2),
           template_var 1),
         template_var 0),
       template_app
        (template_app
          (template_app
            (template_app
              (template_app
                (template_app (template_hole 0, template_var 3),
                 template_var 4),
               template_var 5),
             template_var 0),
           template_var 1),
         template_var 2))),
    ("Safe_Distance.checker_eq_checker2",
     "checker ?s\<^sub>e ?v\<^sub>e ?a\<^sub>e ?s\<^sub>o ?v\<^sub>o
       ?a\<^sub>o =
      checker2 ?s\<^sub>e ?v\<^sub>e ?a\<^sub>e ?s\<^sub>o ?v\<^sub>o
       ?a\<^sub>o",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_app
              (template_app
                (template_app (template_hole 1, template_var 5),
                 template_var 4),
               template_var 3),
             template_var 2),
           template_var 1),
         template_var 0),
       template_app
        (template_app
          (template_app
            (template_app
              (template_app
                (template_app (template_hole 0, template_var 5),
                 template_var 4),
               template_var 3),
             template_var 2),
           template_var 1),
         template_var 0))),
    ("Safe_Distance.checker2_eq_checker3",
     "checker2 ?s\<^sub>e ?v\<^sub>e ?a\<^sub>e ?s\<^sub>o ?v\<^sub>o
       ?a\<^sub>o =
      checker3 ?s\<^sub>e ?v\<^sub>e ?a\<^sub>e ?s\<^sub>o ?v\<^sub>o
       ?a\<^sub>o",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_app
              (template_app
                (template_app (template_hole 1, template_var 5),
                 template_var 4),
               template_var 3),
             template_var 2),
           template_var 1),
         template_var 0),
       template_app
        (template_app
          (template_app
            (template_app
              (template_app
                (template_app (template_hole 0, template_var 5),
                 template_var 4),
               template_var 3),
             template_var 2),
           template_var 1),
         template_var 0))),
    ("Safe_Distance.power2_less_sqrt_iff",
     "(?x\<^sup>2 < ?y) = (0 <= ?y & \<bar>?x\<bar> < sqrt ?y)",
     template_equation
      (template_app
        (template_app
          (template_hole 9,
           template_app
            (template_app (template_hole 8, template_var 1),
             template_app
              (template_hole 7,
               template_app (template_hole 6, template_hole 5)))),
         template_var 0),
       template_app
        (template_app
          (template_hole 4,
           template_app
            (template_app (template_hole 3, template_hole 2),
             template_var 0)),
         template_app
          (template_app
            (template_hole 9,
             template_app (template_hole 1, template_var 1)),
           template_app (template_hole 0, template_var 0))))),
    ("Safe_Distance.aux_logic",
     "[| ?a ==> ?b; ?b ==> ?a = ?c |] ==> ?a = (?b & ?c)",
     template_implication
      ([template_implication
         ([template_predicate (template_var 2)],
          template_predicate (template_var 1)),
        template_implication
         ([template_predicate (template_var 1)],
          template_equation (template_var 2, template_var 0))],
       template_equation
        (template_var 2,
         template_app
          (template_app (template_hole 0, template_var 1),
           template_var 0)))),
    ("Safe_Distance.less_sqrt_iff",
     "0 <= ?y ==> (?x < sqrt ?y) = (0 <= ?x --> ?x\<^sup>2 < ?y)",
     template_implication
      ([template_inequation (less_equals, template_hole 8, template_var 1)],
       template_equation
        (template_app
          (template_app (template_hole 6, template_var 0),
           template_app (template_hole 5, template_var 1)),
         template_app
          (template_app
            (template_hole 4,
             template_app
              (template_app (template_hole 9, template_hole 8),
               template_var 0)),
           template_app
            (template_app
              (template_hole 6,
               template_app
                (template_app (template_hole 3, template_var 0),
                 template_app
                  (template_hole 2,
                   template_app (template_hole 1, template_hole 0)))),
             template_var 1))))),
    ("Safe_Distance.second_safe_dist'",
     "interpret_floatarith (second_safe_dist_expr 0 1 2 3)
       [?v, ?a, ?v', ?a'] =
      second_safe_dist ?v ?a ?v' ?a'",
     template_equation
      (template_app
        (template_app
          (template_hole 10,
           template_app
            (template_app
              (template_app
                (template_app (template_hole 9, template_hole 8),
                 template_hole 7),
               template_app
                (template_hole 6,
                 template_app (template_hole 5, template_hole 4))),
             template_app
              (template_hole 6,
               template_app (template_hole 3, template_hole 4)))),
         template_app
          (template_app (template_hole 2, template_var 3),
           template_app
            (template_app (template_hole 2, template_var 2),
             template_app
              (template_app (template_hole 2, template_var 1),
               template_app
                (template_app (template_hole 2, template_var 0),
                 template_hole 1))))),
       template_app
        (template_app
          (template_app
            (template_app (template_hole 0, template_var 3),
             template_var 2),
           template_var 1),
         template_var 0))),
    ("Safe_Distance.soundness_correctness",
     "checker ?s\<^sub>e ?v\<^sub>e ?a\<^sub>e ?s\<^sub>o ?v\<^sub>o
       ?a\<^sub>o =
      (check_precond ?s\<^sub>e ?v\<^sub>e ?a\<^sub>e ?s\<^sub>o ?v\<^sub>o
        ?a\<^sub>o &
       ~ safe_distance.collision ?a\<^sub>e ?v\<^sub>e ?s\<^sub>e ?a\<^sub>o
          ?v\<^sub>o ?s\<^sub>o {0..})",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_app
              (template_app
                (template_app (template_hole 6, template_var 5),
                 template_var 4),
               template_var 3),
             template_var 2),
           template_var 1),
         template_var 0),
       template_app
        (template_app
          (template_hole 5,
           template_app
            (template_app
              (template_app
                (template_app
                  (template_app
                    (template_app (template_hole 4, template_var 5),
                     template_var 4),
                   template_var 3),
                 template_var 2),
               template_var 1),
             template_var 0)),
         template_app
          (template_hole 3,
           template_app
            (template_app
              (template_app
                (template_app
                  (template_app
                    (template_app
                      (template_app (template_hole 2, template_var 3),
                       template_var 4),
                     template_var 5),
                   template_var 0),
                 template_var 1),
               template_var 2),
             template_app (template_hole 1, template_hole 0)))))),
    ("Safe_Distance.symbolic_soundness_correctness",
     "symbolic_checker ?s\<^sub>e ?v\<^sub>e ?a\<^sub>e ?s\<^sub>o
       ?v\<^sub>o ?a\<^sub>o =
      (check_precond ?s\<^sub>e ?v\<^sub>e ?a\<^sub>e ?s\<^sub>o ?v\<^sub>o
        ?a\<^sub>o &
       ~ safe_distance.collision ?a\<^sub>e ?v\<^sub>e ?s\<^sub>e ?a\<^sub>o
          ?v\<^sub>o ?s\<^sub>o {0..})",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_app
              (template_app
                (template_app (template_hole 6, template_var 5),
                 template_var 4),
               template_var 3),
             template_var 2),
           template_var 1),
         template_var 0),
       template_app
        (template_app
          (template_hole 5,
           template_app
            (template_app
              (template_app
                (template_app
                  (template_app
                    (template_app (template_hole 4, template_var 5),
                     template_var 4),
                   template_var 3),
                 template_var 2),
               template_var 1),
             template_var 0)),
         template_app
          (template_hole 3,
           template_app
            (template_app
              (template_app
                (template_app
                  (template_app
                    (template_app
                      (template_app (template_hole 2, template_var 3),
                       template_var 4),
                     template_var 5),
                   template_var 0),
                 template_var 1),
               template_var 2),
             template_app (template_hole 1, template_hole 0)))))),
    ("Safe_Distance.ncheck_quadroot",
     "(~ quadroot_in ?m ?M ?a ?b ?c) =
      ((?a = 0 --> ~ quadroot_in ?m ?M ?a ?b ?c) &
       (?a = 0 | ~ quadroot_in ?m ?M ?a ?b ?c))",
     template_implication
      ([template_predicate
         (
            template_app
             (template_hole 6,
              template_app
               (template_app
                 (template_app
                   (template_app
                     (template_app (template_hole 5, template_var 4),
                      template_var 3),
                    template_var 2),
                  template_var 1),
                template_var 0))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 4,
               template_app
                (template_app
                  (template_hole 3,
                   template_app
                    (template_app (template_hole 2, template_var 2),
                     template_hole 1)),
                 template_app
                  (template_hole 6,
                   template_app
                    (template_app
                      (template_app
                        (template_app
                          (template_app (template_hole 5, template_var 4),
                           template_var 3),
                         template_var 2),
                       template_var 1),
                     template_var 0)))),
             template_app
              (template_app
                (template_hole 0,
                 template_app
                  (template_app (template_hole 2, template_var 2),
                   template_hole 1)),
               template_app
                (template_hole 6,
                 template_app
                  (template_app
                    (template_app
                      (template_app
                        (template_app (template_hole 5, template_var 4),
                         template_var 3),
                       template_var 2),
                     template_var 1),
                   template_var 0))))
           ))),
    ("Safe_Distance.discriminant",
     "?a * ?x\<^sup>2 + ?b * ?x + ?c = 0 ==> 0 <= ?b\<^sup>2 - 4 * ?a * ?c",
     template_implication
      ([template_equation
         (template_app
           (template_app
             (template_hole 9,
              template_app
               (template_app
                 (template_hole 9,
                  template_app
                   (template_app (template_hole 8, template_var 3),
                    template_app
                     (template_app (template_hole 7, template_var 2),
                      template_app
                       (template_hole 6,
                        template_app (template_hole 5, template_hole 4))))),
                template_app
                 (template_app (template_hole 8, template_var 1),
                  template_var 2))),
            template_var 0),
          template_hole 3)],
       template_inequation
        (less_equals, template_hole 3,
         template_app
          (template_app
            (template_hole 1,
             template_app
              (template_app (template_hole 7, template_var 1),
               template_app
                (template_hole 6,
                 template_app (template_hole 5, template_hole 4)))),
           template_app
            (template_app
              (template_hole 8,
               template_app
                (template_app
                  (template_hole 8,
                   template_app
                    (template_hole 0,
                     template_app
                      (template_hole 5,
                       template_app (template_hole 5, template_hole 4)))),
                 template_var 3)),
             template_var 0))))),
    ("Safe_Distance.p_convex",
     "[| ?p = (%x. ?a * x\<^sup>2 + ?b * x + ?c); ?x < ?y; ?y < ?z;
         ?p ?y < ?p ?x; ?p ?y <= ?p ?z |]
      ==> 0 < ?a",
     template_implication
      ([template_equation (template_var 6, t_empty),
        template_inequation (less_than, template_var 2, template_var 1),
        template_inequation (less_than, template_var 1, template_var 0),
        template_inequation
         (less_than, template_app (template_var 6, template_var 1),
          template_app (template_var 6, template_var 2)),
        template_inequation
         (less_equals, template_app (template_var 6, template_var 1),
          template_app (template_var 6, template_var 0))],
       template_inequation (less_than, template_hole 0, template_var 5))),
    ("Safe_Distance.quadroot_in_sturm",
     "quadroot_in ?m ?M ?a ?b ?c =
      (?a = 0 & ?b = 0 & ?c = 0 & ?m <= ?M |
       ?m <= ?M & poly [:?c, ?b, ?a:] ?m = 0 |
       0 < count_roots_between [:?c, ?b, ?a:] ?m ?M)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app
                   (template_app (template_hole 11, template_var 4),
                    template_var 3),
                  template_var 2),
                template_var 1),
              template_var 0)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 10,
               template_app
                (template_app
                  (template_hole 9,
                   template_app
                    (template_app (template_hole 8, template_var 2),
                     template_hole 7)),
                 template_app
                  (template_app
                    (template_hole 9,
                     template_app
                      (template_app (template_hole 8, template_var 1),
                       template_hole 7)),
                   template_app
                    (template_app
                      (template_hole 9,
                       template_app
                        (template_app (template_hole 8, template_var 0),
                         template_hole 7)),
                     template_app
                      (template_app (template_hole 6, template_var 4),
                       template_var 3))))),
             template_app
              (template_app
                (template_hole 10,
                 template_app
                  (template_app
                    (template_hole 9,
                     template_app
                      (template_app (template_hole 6, template_var 4),
                       template_var 3)),
                   template_app
                    (template_app
                      (template_hole 8,
                       template_app
                        (template_app
                          (template_hole 5,
                           template_app
                            (template_app (template_hole 4, template_var 0),
                             template_app
                              (template_app
                                (template_hole 4, template_var 1),
                               template_app
                                (template_app
                                  (template_hole 4, template_var 2),
                                 template_hole 3)))),
                         template_var 4)),
                     template_hole 7))),
               template_app
                (template_app (template_hole 2, template_hole 1),
                 template_app
                  (template_app
                    (template_app
                      (template_hole 0,
                       template_app
                        (template_app (template_hole 4, template_var 0),
                         template_app
                          (template_app (template_hole 4, template_var 1),
                           template_app
                            (template_app (template_hole 4, template_var 2),
                             template_hole 3)))),
                     template_var 4),
                   template_var 3))))
           ))),
    ("Safe_Distance.suff_cond_safe_dist2_code",
     "suff_cond_safe_dist2 ?s\<^sub>e ?v\<^sub>e ?a\<^sub>e ?s\<^sub>o
       ?v\<^sub>o ?a\<^sub>o =
      (let D2 = discriminant ?s\<^sub>e ?v\<^sub>e ?a\<^sub>e ?s\<^sub>o
                 ?v\<^sub>o ?a\<^sub>o
       in ?a\<^sub>e < ?a\<^sub>o -->
          ?v\<^sub>o < ?v\<^sub>e -->
          0 <= D2 -->
          0 <= ?v\<^sub>e - ?a\<^sub>e / ?a\<^sub>o * ?v\<^sub>o &
          D2 <= (?v\<^sub>e -
                 ?a\<^sub>e / ?a\<^sub>o * ?v\<^sub>o)\<^sup>2)",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_app
              (template_app
                (template_app (template_hole 14, template_var 5),
                 template_var 4),
               template_var 3),
             template_var 2),
           template_var 1),
         template_var 0),
       template_app
        (template_app
          (template_hole 13,
           template_app
            (template_app
              (template_app
                (template_app
                  (template_app
                    (template_app (template_hole 12, template_var 5),
                     template_var 4),
                   template_var 3),
                 template_var 2),
               template_var 1),
             template_var 0)),
         t_empty))),
    ("Safe_Distance.check_quadroot_linear",
     "?a = 0 ==>
      (~ quadroot_in ?m ?M ?a ?b ?c) =
      (?b = 0 & ?c = 0 & ?M < ?m |
       ?b = 0 & ?c ~= 0 |
       ?b ~= 0 & (let x = - ?c / ?b in x < ?m | ?M < x))",
     template_implication
      ([template_equation (template_var 4, template_hole 9)],
       template_implication
        ([template_predicate
           (
              template_app
               (template_hole 7,
                template_app
                 (template_app
                   (template_app
                     (template_app
                       (template_app (template_hole 6, template_var 3),
                        template_var 2),
                      template_var 4),
                    template_var 1),
                  template_var 0))
              )],
         template_predicate
          (
             template_app
              (template_app
                (template_hole 5,
                 template_app
                  (template_app
                    (template_hole 4,
                     template_app
                      (template_app (template_hole 10, template_var 1),
                       template_hole 9)),
                   template_app
                    (template_app
                      (template_hole 4,
                       template_app
                        (template_app (template_hole 10, template_var 0),
                         template_hole 9)),
                     template_app
                      (template_app (template_hole 3, template_var 2),
                       template_var 3)))),
               template_app
                (template_app
                  (template_hole 5,
                   template_app
                    (template_app
                      (template_hole 4,
                       template_app
                        (template_app (template_hole 10, template_var 1),
                         template_hole 9)),
                     template_app
                      (template_hole 7,
                       template_app
                        (template_app (template_hole 10, template_var 0),
                         template_hole 9)))),
                 template_app
                  (template_app
                    (template_hole 4,
                     template_app
                      (template_hole 7,
                       template_app
                        (template_app (template_hole 10, template_var 1),
                         template_hole 9))),
                   template_app
                    (template_app
                      (template_hole 2,
                       template_app
                        (template_app
                          (template_hole 1,
                           template_app (template_hole 0, template_var 0)),
                         template_var 1)),
                     t_empty))))
             )))),
    ("Safe_Distance.check_quadroot_nonlinear",
     "?a ~= 0 ==>
      quadroot_in ?m ?M ?a ?b ?c =
      (let D = ?b\<^sup>2 - 4 * ?a * ?c
       in 0 <= D &
          ((let x = (- ?b + sqrt D) / (2 * ?a) in ?m <= x & x <= ?M) |
           (let x = (- ?b - sqrt D) / (2 * ?a) in ?m <= x & x <= ?M)))",
     template_implication
      ([template_negation
         (template_equation (template_var 4, template_hole 17))],
       template_equation
        (template_app
          (template_app
            (template_app
              (template_app
                (template_app (template_hole 15, template_var 3),
                 template_var 2),
               template_var 4),
             template_var 1),
           template_var 0),
         template_app
          (template_app
            (template_hole 14,
             template_app
              (template_app
                (template_hole 13,
                 template_app
                  (template_app (template_hole 12, template_var 1),
                   template_app
                    (template_hole 11,
                     template_app (template_hole 10, template_hole 9)))),
               template_app
                (template_app
                  (template_hole 8,
                   template_app
                    (template_app
                      (template_hole 8,
                       template_app
                        (template_hole 7,
                         template_app
                          (template_hole 10,
                           template_app
                            (template_hole 10, template_hole 9)))),
                     template_var 4)),
                 template_var 0))),
           t_empty)))),
    ("Safe_Distance.quadratic_eq_zeroes_iff",
     "[| ?D = ?b\<^sup>2 - 4 * ?a * ?c;
         ?x\<^sub>1 = (- ?b + sqrt ?D) / (2 * ?a);
         ?x\<^sub>2 = (- ?b - sqrt ?D) / (2 * ?a); ?a ~= 0 |]
      ==> (?a * ?x\<^sup>2 + ?b * ?x + ?c = 0) =
          (0 <= ?D & (?x = ?x\<^sub>1 | ?x = ?x\<^sub>2))",
     template_implication
      ([template_equation
         (template_var 6,
          template_app
           (template_app
             (template_hole 16,
              template_app
               (template_app (template_hole 15, template_var 5),
                template_app
                 (template_hole 14,
                  template_app (template_hole 13, template_hole 12)))),
            template_app
             (template_app
               (template_hole 11,
                template_app
                 (template_app
                   (template_hole 11,
                    template_app
                     (template_hole 10,
                      template_app
                       (template_hole 13,
                        template_app
                         (template_hole 13, template_hole 12)))),
                  template_var 4)),
              template_var 3))),
        template_equation
         (template_var 2,
          template_app
           (template_app
             (template_hole 9,
              template_app
               (template_app
                 (template_hole 8,
                  template_app (template_hole 7, template_var 5)),
                template_app (template_hole 6, template_var 6))),
            template_app
             (template_app
               (template_hole 11,
                template_app
                 (template_hole 10,
                  template_app (template_hole 13, template_hole 12))),
              template_var 4))),
        template_equation
         (template_var 1,
          template_app
           (template_app
             (template_hole 9,
              template_app
               (template_app
                 (template_hole 16,
                  template_app (template_hole 7, template_var 5)),
                template_app (template_hole 6, template_var 6))),
            template_app
             (template_app
               (template_hole 11,
                template_app
                 (template_hole 10,
                  template_app (template_hole 13, template_hole 12))),
              template_var 4))),
        template_negation
         (template_equation (template_var 4, template_hole 4))],
       template_bimplication
        (template_equation
          (template_app
            (template_app
              (template_hole 8,
               template_app
                (template_app
                  (template_hole 8,
                   template_app
                    (template_app (template_hole 11, template_var 4),
                     template_app
                      (template_app (template_hole 15, template_var 0),
                       template_app
                        (template_hole 14,
                         template_app
                          (template_hole 13, template_hole 12))))),
                 template_app
                  (template_app (template_hole 11, template_var 5),
                   template_var 0))),
             template_var 3),
           template_hole 4),
         template_predicate
          (
             template_app
              (template_app
                (template_hole 2,
                 template_app
                  (template_app (template_hole 1, template_hole 4),
                   template_var 6)),
               template_app
                (template_app
                  (template_hole 0,
                   template_app
                    (template_app (template_hole 17, template_var 0),
                     template_var 2)),
                 template_app
                  (template_app (template_hole 17, template_var 0),
                   template_var 1)))
             )))),
    ("Safe_Distance.quadratic_eq_factoring",
     "[| ?D = ?b\<^sup>2 - 4 * ?a * ?c; 0 <= ?D;
         ?x\<^sub>1 = (- ?b + sqrt ?D) / (2 * ?a);
         ?x\<^sub>2 = (- ?b - sqrt ?D) / (2 * ?a); ?a ~= 0 |]
      ==> ?a * ?x\<^sup>2 + ?b * ?x + ?c =
          ?a * (?x - ?x\<^sub>1) * (?x - ?x\<^sub>2)",
     template_implication
      ([template_equation
         (template_var 6,
          template_app
           (template_app
             (template_hole 13,
              template_app
               (template_app (template_hole 12, template_var 5),
                template_app
                 (template_hole 11,
                  template_app (template_hole 10, template_hole 9)))),
            template_app
             (template_app
               (template_hole 8,
                template_app
                 (template_app
                   (template_hole 8,
                    template_app
                     (template_hole 7,
                      template_app
                       (template_hole 10,
                        template_app (template_hole 10, template_hole 9)))),
                  template_var 4)),
              template_var 3))),
        template_inequation (less_equals, template_hole 5, template_var 6),
        template_equation
         (template_var 2,
          template_app
           (template_app
             (template_hole 4,
              template_app
               (template_app
                 (template_hole 3,
                  template_app (template_hole 2, template_var 5)),
                template_app (template_hole 1, template_var 6))),
            template_app
             (template_app
               (template_hole 8,
                template_app
                 (template_hole 7,
                  template_app (template_hole 10, template_hole 9))),
              template_var 4))),
        template_equation
         (template_var 1,
          template_app
           (template_app
             (template_hole 4,
              template_app
               (template_app
                 (template_hole 13,
                  template_app (template_hole 2, template_var 5)),
                template_app (template_hole 1, template_var 6))),
            template_app
             (template_app
               (template_hole 8,
                template_app
                 (template_hole 7,
                  template_app (template_hole 10, template_hole 9))),
              template_var 4))),
        template_negation
         (template_equation (template_var 4, template_hole 5))],
       template_equation
        (template_app
          (template_app
            (template_hole 3,
             template_app
              (template_app
                (template_hole 3,
                 template_app
                  (template_app (template_hole 8, template_var 4),
                   template_app
                    (template_app (template_hole 12, template_var 0),
                     template_app
                      (template_hole 11,
                       template_app (template_hole 10, template_hole 9))))),
               template_app
                (template_app (template_hole 8, template_var 5),
                 template_var 0))),
           template_var 3),
         template_app
          (template_app
            (template_hole 8,
             template_app
              (template_app (template_hole 8, template_var 4),
               template_app
                (template_app (template_hole 13, template_var 0),
                 template_var 2))),
           template_app
            (template_app (template_hole 13, template_var 0),
             template_var 1))))),
    ("Safe_Distance.checker'_precond",
     "[| ?a : {real_of_float ?al..real_of_float ?au};
         ?b : {real_of_float ?bl..real_of_float ?bu};
         ?c : {real_of_float ?cl..real_of_float ?cu};
         ?d : {real_of_float ?dl..real_of_float ?du};
         ?e : {real_of_float ?el..real_of_float ?eu};
         ?f : {real_of_float ?fl..real_of_float ?fu};
         checker' ?p (Interval' ?al ?au) (Interval' ?bl ?bu)
          (Interval' ?cl ?cu) (Interval' ?dl ?du) (Interval' ?el ?eu)
          (Interval' ?fl ?fu) |]
      ==> check_precond ?a ?b ?c ?d ?e ?f",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 5, template_var 18),
              template_app
               (template_app
                 (template_hole 4,
                  template_app (template_hole 3, template_var 17)),
                template_app (template_hole 3, template_var 16)))
            ),
        template_predicate
         (
            template_app
             (template_app (template_hole 5, template_var 15),
              template_app
               (template_app
                 (template_hole 4,
                  template_app (template_hole 3, template_var 14)),
                template_app (template_hole 3, template_var 13)))
            ),
        template_predicate
         (
            template_app
             (template_app (template_hole 5, template_var 12),
              template_app
               (template_app
                 (template_hole 4,
                  template_app (template_hole 3, template_var 11)),
                template_app (template_hole 3, template_var 10)))
            ),
        template_predicate
         (
            template_app
             (template_app (template_hole 5, template_var 9),
              template_app
               (template_app
                 (template_hole 4,
                  template_app (template_hole 3, template_var 8)),
                template_app (template_hole 3, template_var 7)))
            ),
        template_predicate
         (
            template_app
             (template_app (template_hole 5, template_var 6),
              template_app
               (template_app
                 (template_hole 4,
                  template_app (template_hole 3, template_var 5)),
                template_app (template_hole 3, template_var 4)))
            ),
        template_predicate
         (
            template_app
             (template_app (template_hole 5, template_var 3),
              template_app
               (template_app
                 (template_hole 4,
                  template_app (template_hole 3, template_var 2)),
                template_app (template_hole 3, template_var 1)))
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app
                   (template_app
                     (template_app
                       (template_app (template_hole 2, template_var 0),
                        template_app
                         (template_app (template_hole 1, template_var 17),
                          template_var 16)),
                      template_app
                       (template_app (template_hole 1, template_var 14),
                        template_var 13)),
                    template_app
                     (template_app (template_hole 1, template_var 11),
                      template_var 10)),
                  template_app
                   (template_app (template_hole 1, template_var 8),
                    template_var 7)),
                template_app
                 (template_app (template_hole 1, template_var 5),
                  template_var 4)),
              template_app
               (template_app (template_hole 1, template_var 2),
                template_var 1))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_app
                  (template_app
                    (template_app (template_hole 0, template_var 18),
                     template_var 15),
                   template_var 12),
                 template_var 9),
               template_var 6),
             template_var 3)
           ))),
    ("Safe_Distance.checker'_soundness_correctness",
     "[| ?a : {real_of_float ?al..real_of_float ?au};
         ?b : {real_of_float ?bl..real_of_float ?bu};
         ?c : {real_of_float ?cl..real_of_float ?cu};
         ?d : {real_of_float ?dl..real_of_float ?du};
         ?e : {real_of_float ?el..real_of_float ?eu};
         ?f : {real_of_float ?fl..real_of_float ?fu};
         checker' ?p (Interval' ?al ?au) (Interval' ?bl ?bu)
          (Interval' ?cl ?cu) (Interval' ?dl ?du) (Interval' ?el ?eu)
          (Interval' ?fl ?fu) |]
      ==> checker ?a ?b ?c ?d ?e ?f",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 5, template_var 18),
              template_app
               (template_app
                 (template_hole 4,
                  template_app (template_hole 3, template_var 17)),
                template_app (template_hole 3, template_var 16)))
            ),
        template_predicate
         (
            template_app
             (template_app (template_hole 5, template_var 15),
              template_app
               (template_app
                 (template_hole 4,
                  template_app (template_hole 3, template_var 14)),
                template_app (template_hole 3, template_var 13)))
            ),
        template_predicate
         (
            template_app
             (template_app (template_hole 5, template_var 12),
              template_app
               (template_app
                 (template_hole 4,
                  template_app (template_hole 3, template_var 11)),
                template_app (template_hole 3, template_var 10)))
            ),
        template_predicate
         (
            template_app
             (template_app (template_hole 5, template_var 9),
              template_app
               (template_app
                 (template_hole 4,
                  template_app (template_hole 3, template_var 8)),
                template_app (template_hole 3, template_var 7)))
            ),
        template_predicate
         (
            template_app
             (template_app (template_hole 5, template_var 6),
              template_app
               (template_app
                 (template_hole 4,
                  template_app (template_hole 3, template_var 5)),
                template_app (template_hole 3, template_var 4)))
            ),
        template_predicate
         (
            template_app
             (template_app (template_hole 5, template_var 3),
              template_app
               (template_app
                 (template_hole 4,
                  template_app (template_hole 3, template_var 2)),
                template_app (template_hole 3, template_var 1)))
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app
                   (template_app
                     (template_app
                       (template_app (template_hole 2, template_var 0),
                        template_app
                         (template_app (template_hole 1, template_var 17),
                          template_var 16)),
                      template_app
                       (template_app (template_hole 1, template_var 14),
                        template_var 13)),
                    template_app
                     (template_app (template_hole 1, template_var 11),
                      template_var 10)),
                  template_app
                   (template_app (template_hole 1, template_var 8),
                    template_var 7)),
                template_app
                 (template_app (template_hole 1, template_var 5),
                  template_var 4)),
              template_app
               (template_app (template_hole 1, template_var 2),
                template_var 1))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_app
                  (template_app
                    (template_app (template_hole 0, template_var 18),
                     template_var 15),
                   template_var 12),
                 template_var 9),
               template_var 6),
             template_var 3)
           ))),
    ("Safe_Distance.checker'_no_collision",
     "[| ?a : {real_of_float ?al..real_of_float ?au};
         ?b : {real_of_float ?bl..real_of_float ?bu};
         ?c : {real_of_float ?cl..real_of_float ?cu};
         ?d : {real_of_float ?dl..real_of_float ?du};
         ?e : {real_of_float ?el..real_of_float ?eu};
         ?f : {real_of_float ?fl..real_of_float ?fu};
         checker' ?p (Interval' ?al ?au) (Interval' ?bl ?bu)
          (Interval' ?cl ?cu) (Interval' ?dl ?du) (Interval' ?el ?eu)
          (Interval' ?fl ?fu) |]
      ==> ~ safe_distance.collision ?c ?b ?a ?f ?e ?d {0..}",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 8, template_var 18),
              template_app
               (template_app
                 (template_hole 7,
                  template_app (template_hole 6, template_var 17)),
                template_app (template_hole 6, template_var 16)))
            ),
        template_predicate
         (
            template_app
             (template_app (template_hole 8, template_var 15),
              template_app
               (template_app
                 (template_hole 7,
                  template_app (template_hole 6, template_var 14)),
                template_app (template_hole 6, template_var 13)))
            ),
        template_predicate
         (
            template_app
             (template_app (template_hole 8, template_var 12),
              template_app
               (template_app
                 (template_hole 7,
                  template_app (template_hole 6, template_var 11)),
                template_app (template_hole 6, template_var 10)))
            ),
        template_predicate
         (
            template_app
             (template_app (template_hole 8, template_var 9),
              template_app
               (template_app
                 (template_hole 7,
                  template_app (template_hole 6, template_var 8)),
                template_app (template_hole 6, template_var 7)))
            ),
        template_predicate
         (
            template_app
             (template_app (template_hole 8, template_var 6),
              template_app
               (template_app
                 (template_hole 7,
                  template_app (template_hole 6, template_var 5)),
                template_app (template_hole 6, template_var 4)))
            ),
        template_predicate
         (
            template_app
             (template_app (template_hole 8, template_var 3),
              template_app
               (template_app
                 (template_hole 7,
                  template_app (template_hole 6, template_var 2)),
                template_app (template_hole 6, template_var 1)))
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app
                   (template_app
                     (template_app
                       (template_app (template_hole 5, template_var 0),
                        template_app
                         (template_app (template_hole 4, template_var 17),
                          template_var 16)),
                      template_app
                       (template_app (template_hole 4, template_var 14),
                        template_var 13)),
                    template_app
                     (template_app (template_hole 4, template_var 11),
                      template_var 10)),
                  template_app
                   (template_app (template_hole 4, template_var 8),
                    template_var 7)),
                template_app
                 (template_app (template_hole 4, template_var 5),
                  template_var 4)),
              template_app
               (template_app (template_hole 4, template_var 2),
                template_var 1))
            )],
       template_negation
        (
           template_predicate
            (
               template_app
                (template_app
                  (template_app
                    (template_app
                      (template_app
                        (template_app
                          (template_app (template_hole 2, template_var 12),
                           template_var 15),
                         template_var 18),
                       template_var 3),
                     template_var 6),
                   template_var 9),
                 template_app (template_hole 1, template_hole 0))
               )
           ))),
    ("Safe_Distance.checker_form",
     "interpret_form
       (Conj
         (Conj
           (Less (floatarith.Var (Suc (Suc 0)))
             (floatarith.Var (Suc (Suc (Suc 0)))))
           (Conj
             (LessEqual
               (floatarith.Var (Suc (Suc (Suc (Suc (Suc (Suc (Suc 0))))))))
               (floatarith.Var (Suc (Suc (Suc (Suc (Suc 0)))))))
             (Conj
               (LessEqual
                 (floatarith.Var
                   (Suc (Suc (Suc (Suc (Suc (Suc (Suc 0))))))))
                 (floatarith.Var (Suc (Suc (Suc (Suc (Suc (Suc 0))))))))
               (Conj
                 (Less (floatarith.Var 0)
                   (floatarith.Var
                     (Suc (Suc (Suc (Suc (Suc (Suc (Suc 0)))))))))
                 (Less (floatarith.Var (Suc 0))
                   (floatarith.Var
                     (Suc (Suc (Suc (Suc (Suc (Suc (Suc 0)))))))))))))
         (Disj
           (Less
             (floatarith.Add (floatarith.Var (Suc (Suc 0)))
               (floatarith.Mult
                 (floatarith.Minus
                   (floatarith.Power
                     (floatarith.Var (Suc (Suc (Suc (Suc (Suc 0)))))) 2))
                 (floatarith.Inverse
                   (floatarith.Mult
                     (floatarith.Var (Suc (Suc (Suc (Suc 0)))))
                     (floatarith.Var 0)))))
             (floatarith.Var (Suc (Suc (Suc 0)))))
           (Conj
             (LessEqual (floatarith.Var (Suc (Suc (Suc 0))))
               (floatarith.Add (floatarith.Var (Suc (Suc 0)))
                 (floatarith.Mult
                   (floatarith.Minus
                     (floatarith.Power
                       (floatarith.Var (Suc (Suc (Suc (Suc (Suc 0)))))) 2))
                   (floatarith.Inverse
                     (floatarith.Mult
                       (floatarith.Var (Suc (Suc (Suc (Suc 0)))))
                       (floatarith.Var 0))))))
             (Conj
               (Less
                 (floatarith.Add (floatarith.Var (Suc (Suc 0)))
                   (floatarith.Mult
                     (floatarith.Minus
                       (floatarith.Power
                         (floatarith.Var (Suc (Suc (Suc (Suc (Suc 0))))))
                         2))
                     (floatarith.Inverse
                       (floatarith.Mult
                         (floatarith.Var (Suc (Suc (Suc (Suc 0)))))
                         (floatarith.Var 0)))))
                 (floatarith.Add (floatarith.Var (Suc (Suc (Suc 0))))
                   (floatarith.Mult
                     (floatarith.Minus
                       (floatarith.Power
                         (floatarith.Var
                           (Suc (Suc (Suc (Suc (Suc (Suc 0)))))))
                         2))
                     (floatarith.Inverse
                       (floatarith.Mult
                         (floatarith.Var (Suc (Suc (Suc (Suc 0)))))
                         (floatarith.Var (Suc 0)))))))
               (Disj (LessEqual (floatarith.Var (Suc 0)) (floatarith.Var 0))
                 (Disj
                   (LessEqual
                     (floatarith.Var (Suc (Suc (Suc (Suc (Suc 0))))))
                     (floatarith.Var (Suc (Suc (Suc (Suc (Suc (Suc 0))))))))
                   (Disj
                     (LessEqual
                       (floatarith.Var
                         (Suc (Suc (Suc (Suc (Suc (Suc (Suc 0))))))))
                       (floatarith.Add
                         (floatarith.Var (Suc (Suc (Suc (Suc (Suc 0))))))
                         (floatarith.Minus
                           (floatarith.Mult
                             (floatarith.Mult (floatarith.Var 0)
                               (floatarith.Inverse
                                 (floatarith.Var (Suc 0))))
                             (floatarith.Var
                               (Suc (Suc (Suc (Suc (Suc (Suc 0)))))))))))
                     (Less
                       (floatarith.Mult
                         (floatarith.Power
                           (floatarith.Add
                             (floatarith.Var
                               (Suc (Suc (Suc (Suc (Suc (Suc 0)))))))
                             (floatarith.Minus
                               (floatarith.Var
                                 (Suc (Suc (Suc (Suc (Suc 0))))))))
                           2)
                         (floatarith.Inverse
                           (floatarith.Var (Suc (Suc (Suc (Suc 0)))))))
                       (floatarith.Mult
                         (floatarith.Add
                           (floatarith.Var (Suc (Suc (Suc 0))))
                           (floatarith.Minus
                             (floatarith.Var (Suc (Suc 0)))))
                         (floatarith.Add (floatarith.Var (Suc 0))
                           (floatarith.Minus (floatarith.Var 0))))))))))))
       [?a\<^sub>e, ?a\<^sub>o, ?s\<^sub>e, ?s\<^sub>o, 2, ?v\<^sub>e,
        ?v\<^sub>o, 0] ==>
      checker ?s\<^sub>e ?v\<^sub>e ?a\<^sub>e ?s\<^sub>o ?v\<^sub>o
       ?a\<^sub>o",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 20,
                template_app
                 (template_app
                   (template_hole 19,
                    template_app
                     (template_app
                       (template_hole 19,
                        template_app
                         (template_app
                           (template_hole 18,
                            template_app
                             (template_hole 17,
                              template_app
                               (template_hole 16,
                                template_app
                                 (template_hole 16, template_hole 15)))),
                          template_app
                           (template_hole 17,
                            template_app
                             (template_hole 16,
                              template_app
                               (template_hole 16,
                                template_app
                                 (template_hole 16, template_hole 15)))))),
                      template_app
                       (template_app
                         (template_hole 19,
                          template_app
                           (template_app
                             (template_hole 14,
                              template_app
                               (template_hole 17,
                                template_app
                                 (template_hole 16,
                                  template_app
                                   (template_hole 16,
                                    template_app
                                     (template_hole 16,
template_app
 (template_hole 16,
  template_app
   (template_hole 16,
    template_app
     (template_hole 16,
      template_app (template_hole 16, template_hole 15))))))))),
                            template_app
                             (template_hole 17,
                              template_app
                               (template_hole 16,
                                template_app
                                 (template_hole 16,
                                  template_app
                                   (template_hole 16,
                                    template_app
                                     (template_hole 16,
template_app (template_hole 16, template_hole 15)))))))),
                        template_app
                         (template_app
                           (template_hole 19,
                            template_app
                             (template_app
                               (template_hole 14,
                                template_app
                                 (template_hole 17,
                                  template_app
                                   (template_hole 16,
                                    template_app
                                     (template_hole 16,
template_app
 (template_hole 16,
  template_app
   (template_hole 16,
    template_app
     (template_hole 16,
      template_app
       (template_hole 16,
        template_app (template_hole 16, template_hole 15))))))))),
                              template_app
                               (template_hole 17,
                                template_app
                                 (template_hole 16,
                                  template_app
                                   (template_hole 16,
                                    template_app
                                     (template_hole 16,
template_app
 (template_hole 16,
  template_app
   (template_hole 16,
    template_app (template_hole 16, template_hole 15))))))))),
                          template_app
                           (template_app
                             (template_hole 19,
                              template_app
                               (template_app
                                 (template_hole 18,
                                  template_app
                                   (template_hole 17, template_hole 15)),
                                template_app
                                 (template_hole 17,
                                  template_app
                                   (template_hole 16,
                                    template_app
                                     (template_hole 16,
template_app
 (template_hole 16,
  template_app
   (template_hole 16,
    template_app
     (template_hole 16,
      template_app
       (template_hole 16,
        template_app (template_hole 16, template_hole 15)))))))))),
                            template_app
                             (template_app
                               (template_hole 18,
                                template_app
                                 (template_hole 17,
                                  template_app
                                   (template_hole 16, template_hole 15))),
                              template_app
                               (template_hole 17,
                                template_app
                                 (template_hole 16,
                                  template_app
                                   (template_hole 16,
                                    template_app
                                     (template_hole 16,
template_app
 (template_hole 16,
  template_app
   (template_hole 16,
    template_app
     (template_hole 16,
      template_app (template_hole 16, template_hole 15)))))))))))))),
                  template_app
                   (template_app
                     (template_hole 13,
                      template_app
                       (template_app
                         (template_hole 18,
                          template_app
                           (template_app
                             (template_hole 12,
                              template_app
                               (template_hole 17,
                                template_app
                                 (template_hole 16,
                                  template_app
                                   (template_hole 16, template_hole 15)))),
                            template_app
                             (template_app
                               (template_hole 11,
                                template_app
                                 (template_hole 10,
                                  template_app
                                   (template_app
                                     (template_hole 9,
template_app
 (template_hole 17,
  template_app
   (template_hole 16,
    template_app
     (template_hole 16,
      template_app
       (template_hole 16,
        template_app
         (template_hole 16,
          template_app (template_hole 16, template_hole 15))))))),
                                    template_app
                                     (template_hole 8,
template_app (template_hole 7, template_hole 6))))),
                              template_app
                               (template_hole 5,
                                template_app
                                 (template_app
                                   (template_hole 11,
                                    template_app
                                     (template_hole 17,
template_app
 (template_hole 16,
  template_app
   (template_hole 16,
    template_app
     (template_hole 16,
      template_app (template_hole 16, template_hole 15)))))),
                                  template_app
                                   (template_hole 17,
                                    template_hole 15)))))),
                        template_app
                         (template_hole 17,
                          template_app
                           (template_hole 16,
                            template_app
                             (template_hole 16,
                              template_app
                               (template_hole 16, template_hole 15)))))),
                    template_app
                     (template_app
                       (template_hole 19,
                        template_app
                         (template_app
                           (template_hole 14,
                            template_app
                             (template_hole 17,
                              template_app
                               (template_hole 16,
                                template_app
                                 (template_hole 16,
                                  template_app
                                   (template_hole 16, template_hole 15))))),
                          template_app
                           (template_app
                             (template_hole 12,
                              template_app
                               (template_hole 17,
                                template_app
                                 (template_hole 16,
                                  template_app
                                   (template_hole 16, template_hole 15)))),
                            template_app
                             (template_app
                               (template_hole 11,
                                template_app
                                 (template_hole 10,
                                  template_app
                                   (template_app
                                     (template_hole 9,
template_app
 (template_hole 17,
  template_app
   (template_hole 16,
    template_app
     (template_hole 16,
      template_app
       (template_hole 16,
        template_app
         (template_hole 16,
          template_app (template_hole 16, template_hole 15))))))),
                                    template_app
                                     (template_hole 8,
template_app (template_hole 7, template_hole 6))))),
                              template_app
                               (template_hole 5,
                                template_app
                                 (template_app
                                   (template_hole 11,
                                    template_app
                                     (template_hole 17,
template_app
 (template_hole 16,
  template_app
   (template_hole 16,
    template_app
     (template_hole 16,
      template_app (template_hole 16, template_hole 15)))))),
                                  template_app
                                   (template_hole 17,
                                    template_hole 15))))))),
                      template_app
                       (template_app
                         (template_hole 19,
                          template_app
                           (template_app
                             (template_hole 18,
                              template_app
                               (template_app
                                 (template_hole 12,
                                  template_app
                                   (template_hole 17,
                                    template_app
                                     (template_hole 16,
template_app (template_hole 16, template_hole 15)))),
                                template_app
                                 (template_app
                                   (template_hole 11,
                                    template_app
                                     (template_hole 10,
template_app
 (template_app
   (template_hole 9,
    template_app
     (template_hole 17,
      template_app
       (template_hole 16,
        template_app
         (template_hole 16,
          template_app
           (template_hole 16,
            template_app
             (template_hole 16,
              template_app (template_hole 16, template_hole 15))))))),
  template_app
   (template_hole 8, template_app (template_hole 7, template_hole 6))))),
                                  template_app
                                   (template_hole 5,
                                    template_app
                                     (template_app
 (template_hole 11,
  template_app
   (template_hole 17,
    template_app
     (template_hole 16,
      template_app
       (template_hole 16,
        template_app
         (template_hole 16,
          template_app (template_hole 16, template_hole 15)))))),
template_app (template_hole 17, template_hole 15)))))),
                            template_app
                             (template_app
                               (template_hole 12,
                                template_app
                                 (template_hole 17,
                                  template_app
                                   (template_hole 16,
                                    template_app
                                     (template_hole 16,
template_app (template_hole 16, template_hole 15))))),
                              template_app
                               (template_app
                                 (template_hole 11,
                                  template_app
                                   (template_hole 10,
                                    template_app
                                     (template_app
 (template_hole 9,
  template_app
   (template_hole 17,
    template_app
     (template_hole 16,
      template_app
       (template_hole 16,
        template_app
         (template_hole 16,
          template_app
           (template_hole 16,
            template_app
             (template_hole 16,
              template_app (template_hole 16, template_hole 15)))))))),
template_app
 (template_hole 8, template_app (template_hole 7, template_hole 6))))),
                                template_app
                                 (template_hole 5,
                                  template_app
                                   (template_app
                                     (template_hole 11,
template_app
 (template_hole 17,
  template_app
   (template_hole 16,
    template_app
     (template_hole 16,
      template_app
       (template_hole 16,
        template_app (template_hole 16, template_hole 15)))))),
                                    template_app
                                     (template_hole 17,
template_app (template_hole 16, template_hole 15)))))))),
                        template_app
                         (template_app
                           (template_hole 13,
                            template_app
                             (template_app
                               (template_hole 14,
                                template_app
                                 (template_hole 17,
                                  template_app
                                   (template_hole 16, template_hole 15))),
                              template_app
                               (template_hole 17, template_hole 15))),
                          template_app
                           (template_app
                             (template_hole 13,
                              template_app
                               (template_app
                                 (template_hole 14,
                                  template_app
                                   (template_hole 17,
                                    template_app
                                     (template_hole 16,
template_app
 (template_hole 16,
  template_app
   (template_hole 16,
    template_app
     (template_hole 16,
      template_app (template_hole 16, template_hole 15))))))),
                                template_app
                                 (template_hole 17,
                                  template_app
                                   (template_hole 16,
                                    template_app
                                     (template_hole 16,
template_app
 (template_hole 16,
  template_app
   (template_hole 16,
    template_app
     (template_hole 16,
      template_app (template_hole 16, template_hole 15))))))))),
                            template_app
                             (template_app
                               (template_hole 13,
                                template_app
                                 (template_app
                                   (template_hole 14,
                                    template_app
                                     (template_hole 17,
template_app
 (template_hole 16,
  template_app
   (template_hole 16,
    template_app
     (template_hole 16,
      template_app
       (template_hole 16,
        template_app
         (template_hole 16,
          template_app
           (template_hole 16,
            template_app (template_hole 16, template_hole 15))))))))),
                                  template_app
                                   (template_app
                                     (template_hole 12,
template_app
 (template_hole 17,
  template_app
   (template_hole 16,
    template_app
     (template_hole 16,
      template_app
       (template_hole 16,
        template_app
         (template_hole 16,
          template_app (template_hole 16, template_hole 15))))))),
                                    template_app
                                     (template_hole 10,
template_app
 (template_app
   (template_hole 11,
    template_app
     (template_app
       (template_hole 11,
        template_app (template_hole 17, template_hole 15)),
      template_app
       (template_hole 5,
        template_app
         (template_hole 17,
          template_app (template_hole 16, template_hole 15))))),
  template_app
   (template_hole 17,
    template_app
     (template_hole 16,
      template_app
       (template_hole 16,
        template_app
         (template_hole 16,
          template_app
           (template_hole 16,
            template_app
             (template_hole 16,
              template_app (template_hole 16, template_hole 15)))))))))))),
                              template_app
                               (template_app
                                 (template_hole 18,
                                  template_app
                                   (template_app
                                     (template_hole 11,
template_app
 (template_app
   (template_hole 9,
    template_app
     (template_app
       (template_hole 12,
        template_app
         (template_hole 17,
          template_app
           (template_hole 16,
            template_app
             (template_hole 16,
              template_app
               (template_hole 16,
                template_app
                 (template_hole 16,
                  template_app
                   (template_hole 16,
                    template_app
                     (template_hole 16, template_hole 15)))))))),
      template_app
       (template_hole 10,
        template_app
         (template_hole 17,
          template_app
           (template_hole 16,
            template_app
             (template_hole 16,
              template_app
               (template_hole 16,
                template_app
                 (template_hole 16,
                  template_app (template_hole 16, template_hole 15))))))))),
  template_app
   (template_hole 8, template_app (template_hole 7, template_hole 6)))),
                                    template_app
                                     (template_hole 5,
template_app
 (template_hole 17,
  template_app
   (template_hole 16,
    template_app
     (template_hole 16,
      template_app
       (template_hole 16,
        template_app (template_hole 16, template_hole 15)))))))),
                                template_app
                                 (template_app
                                   (template_hole 11,
                                    template_app
                                     (template_app
 (template_hole 12,
  template_app
   (template_hole 17,
    template_app
     (template_hole 16,
      template_app
       (template_hole 16,
        template_app (template_hole 16, template_hole 15))))),
template_app
 (template_hole 10,
  template_app
   (template_hole 17,
    template_app
     (template_hole 16,
      template_app (template_hole 16, template_hole 15)))))),
                                  template_app
                                   (template_app
                                     (template_hole 12,
template_app
 (template_hole 17, template_app (template_hole 16, template_hole 15))),
                                    template_app
                                     (template_hole 10,
template_app (template_hole 17, template_hole 15))))))))))))),
              template_app
               (template_app (template_hole 4, template_var 5),
                template_app
                 (template_app (template_hole 4, template_var 4),
                  template_app
                   (template_app (template_hole 4, template_var 3),
                    template_app
                     (template_app (template_hole 4, template_var 2),
                      template_app
                       (template_app
                         (template_hole 4,
                          template_app
                           (template_hole 3,
                            template_app
                             (template_hole 7, template_hole 6))),
                        template_app
                         (template_app (template_hole 4, template_var 1),
                          template_app
                           (template_app (template_hole 4, template_var 0),
                            template_app
                             (template_app
                               (template_hole 4, template_hole 2),
                              template_hole 1)))))))))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_app
                  (template_app
                    (template_app (template_hole 0, template_var 3),
                     template_var 1),
                   template_var 5),
                 template_var 2),
               template_var 0),
             template_var 4)
           )))]:
   (string * thm * template) list
### theory "Draft.Safe_DistanceMoreTemplates"
### 1.238s elapsed time, 1.573s cpu time, 0.096s GC time
val it = (): unit
