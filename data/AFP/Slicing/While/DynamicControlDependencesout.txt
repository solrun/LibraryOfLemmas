Loading theory "Draft.AuxLemmas" (required by "Draft.DynamicControlDependencesMoreTemplates" via "Draft.DynamicControlDependences" via "Draft.AdditionalLemmas" via "Draft.WellFormed" via "Draft.Interpretation" via "Draft.WCFG" via "Draft.BasicDefs")
Loading theory "Draft.Com" (required by "Draft.DynamicControlDependencesMoreTemplates" via "Draft.DynamicControlDependences" via "Draft.AdditionalLemmas" via "Draft.WellFormed" via "Draft.Interpretation" via "Draft.WCFG")
Loading theory "HOL-Library.Function_Algebras" (required by "Draft.DynamicControlDependencesMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
Loading theory "HOL-Library.Nat_Bijection" (required by "Draft.DynamicControlDependencesMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.Stream")
instantiation
  fun :: (type, plus) plus
  plus_fun == plus :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  fun :: (type, zero) zero
  zero_fun == zero_class.zero :: 'a => 'b
instantiation
  fun :: (type, times) times
  times_fun == times :: ('a => 'b) => ('a => 'b) => 'a => 'b
### theory "Draft.AuxLemmas"
### 0.053s elapsed time, 0.247s cpu time, 0.000s GC time
Loading theory "Draft.BasicDefs" (required by "Draft.DynamicControlDependencesMoreTemplates" via "Draft.DynamicControlDependences" via "Draft.AdditionalLemmas" via "Draft.WellFormed" via "Draft.Interpretation" via "Draft.WCFG")
instantiation
  fun :: (type, one) one
  one_fun == one_class.one :: 'a => 'b
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
### theory "HOL-Library.Function_Algebras"
### 0.134s elapsed time, 0.555s cpu time, 0.048s GC time
Loading theory "HOL-Library.Set_Algebras" (required by "Draft.DynamicControlDependencesMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
instantiation
  set :: (plus) plus
  plus_set == plus :: 'a set => 'a set => 'a set
instantiation
  set :: (times) times
  times_set == times :: 'a set => 'a set => 'a set
instantiation
  set :: (zero) zero
  zero_set == zero_class.zero :: 'a set
instantiation
  set :: (one) one
  one_set == one_class.one :: 'a set
Found termination order: "size_list size <*mlex*> {}"
### theory "HOL-Library.Set_Algebras"
### 0.204s elapsed time, 0.807s cpu time, 0.072s GC time
Loading theory "HOL-Library.Tree" (required by "Draft.DynamicControlDependencesMoreTemplates" via "Draft.ExtrEqs" via "Draft.Templates")
### theory "HOL-Library.Nat_Bijection"
### 0.356s elapsed time, 1.424s cpu time, 0.119s GC time
Loading theory "HOL-Library.Stream" (required by "Draft.DynamicControlDependencesMoreTemplates" via "Draft.ExtrEqs")
Found termination order: "{}"
Found termination order: "(%p. size_list size (fst p)) <*mlex*> {}"
Found termination order: "{}"
Found termination order: "(%p. size_list size (fst p)) <*mlex*> {}"
### theory "Draft.BasicDefs"
### 0.674s elapsed time, 2.647s cpu time, 0.260s GC time
Loading theory "Draft.CFG" (required by "Draft.DynamicControlDependencesMoreTemplates" via "Draft.DynamicControlDependences" via "Draft.AdditionalLemmas" via "Draft.WellFormed" via "Draft.Interpretation" via "Draft.CFGExit")
consts
  shift :: "'a list => 'a stream => 'a stream"
Proofs for coinductive predicate(s) "streamsp"
  Proving monotonicity ...
locale CFG
  fixes sourcenode :: "'edge => 'node"
    and targetnode :: "'edge => 'node"
    and kind :: "'edge => 'state edge_kind"
    and valid_edge :: "'edge => bool"
    and Entry :: "'node"  (\<open>'('_Entry'_')\<close>)
  assumes "CFG sourcenode targetnode valid_edge (_Entry_)"
Proofs for inductive predicate(s) "path"
  Proving monotonicity ...
### Ambiguous input (line 48 of "$AFP/Slicing/Basic/CFG.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.path" ("_position" n) ("\<^const>List.list.Nil")
###     ("\<^const>Pure.imp" ("\<^const>HOL.Trueprop" ("_position" n'))
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_position" n) ("_position" n'))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>local.path" ("_position" n) ("\<^const>List.list.Nil")
###       ("_position" n')))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq" ("_position" n) ("_position" n'))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>local.path" ("_position" n) ("\<^const>List.list.Nil")
###       ("\<^const>Pure.imp" ("\<^const>HOL.Trueprop" ("_position" n'))
###         ("\<^const>HOL.Trueprop" ("_position" n))))
###     ("_position" n')))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 51 of "$AFP/Slicing/Basic/CFG.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.path" ("_position" n) ("_position" as)
###     ("\<^const>Pure.imp" ("\<^const>HOL.Trueprop" ("_position" n'))
###       ("\<^const>HOL.Trueprop"
###         ("_Ball" ("_position" a)
###           ("_applC" ("_position" set) ("_position" as))
###           ("_applC" ("_position" valid_edge) ("_position" a)))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>local.path" ("_position" n) ("_position" as)
###       ("_position" n')))
###   ("\<^const>HOL.Trueprop"
###     ("_Ball" ("_position" a) ("_applC" ("_position" set) ("_position" as))
###       ("_applC" ("_position" valid_edge) ("_position" a)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
consts
  snth :: "'a stream => nat => 'a"
consts
  left :: "'a tree => 'a tree"
consts
  right :: "'a tree => 'a tree"
consts
  stake :: "nat => 'a stream => 'a list"
consts
  sdrop :: "nat => 'a stream => 'a stream"
### theory "Draft.CFG"
### 0.172s elapsed time, 0.678s cpu time, 0.070s GC time
Loading theory "Draft.CFGExit" (required by "Draft.DynamicControlDependencesMoreTemplates" via "Draft.DynamicControlDependences" via "Draft.AdditionalLemmas" via "Draft.WellFormed" via "Draft.Interpretation")
Found termination order: "size <*mlex*> {}"
consts
  sfilter :: "('a => bool) => 'a stream => 'a stream"
locale CFGExit
  fixes sourcenode :: "'edge => 'node"
    and targetnode :: "'edge => 'node"
    and kind :: "'edge => 'state edge_kind"
    and valid_edge :: "'edge => bool"
    and Entry :: "'node"  (\<open>'('_Entry'_')\<close>)
    and Exit :: "'node"  (\<open>'('_Exit'_')\<close>)
  assumes "CFGExit sourcenode targetnode kind valid_edge (_Entry_) (_Exit_)"
consts
  cycle :: "'a list => 'a stream"
### theory "Draft.CFGExit"
### 0.109s elapsed time, 0.421s cpu time, 0.031s GC time
Loading theory "Draft.Postdomination" (required by "Draft.DynamicControlDependencesMoreTemplates" via "Draft.DynamicControlDependences" via "Draft.AdditionalLemmas" via "Draft.WellFormed" via "Draft.CDepInstantiations" via "Draft.PDG" via "Draft.StandardControlDependence")
Found termination order: "size <*mlex*> {}"
consts
  siterate :: "('a => 'a) => 'a => 'a stream"
Found termination order: "size <*mlex*> {}"
locale Postdomination
  fixes sourcenode :: "'edge => 'node"
    and targetnode :: "'edge => 'node"
    and kind :: "'edge => 'state edge_kind"
    and valid_edge :: "'edge => bool"
    and Entry :: "'node"  (\<open>'('_Entry'_')\<close>)
    and Exit :: "'node"  (\<open>'('_Exit'_')\<close>)
  assumes
    "Postdomination sourcenode targetnode kind valid_edge (_Entry_)
      (_Exit_)"
### Ambiguous input (line 17 of "$AFP/Slicing/Basic/Postdomination.thy") produces 6 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>postdominate" ("_position" n')
###     ("\<^const>Pure.eq" ("_position" n)
###       ("\<^const>HOL.conj"
###         ("_applC" ("_position" valid_node) ("_position" n))
###         ("\<^const>HOL.conj"
###           ("_applC" ("_position" valid_node) ("_position" n'))
###           ("\<^const>HOL.All_binder" ("_position" as)
###             ("\<^const>HOL.implies"
###               ("\<^const>local.path" ("_position" n) ("_position" as)
###                 ("\<^fixed>Exit"))
###               ("\<^const>Set.member" ("_position" n')
###                 ("_applC" ("_position" set)
###                   ("_applC" ("_position" sourcenodes)
###                     ("_position" as)))))))))))
### ("\<^const>Pure.eq"
###   ("\<^fixed>postdominate" ("_position" n') ("_position" n))
###   ("\<^const>HOL.conj" ("_applC" ("_position" valid_node) ("_position" n))
###     ("\<^const>HOL.conj"
###       ("_applC" ("_position" valid_node) ("_position" n'))
###       ("\<^const>HOL.All_binder" ("_position" as)
###         ("\<^const>HOL.implies"
###           ("\<^const>local.path" ("_position" n) ("_position" as)
###             ("\<^fixed>Exit"))
###           ("\<^const>Set.member" ("_position" n')
###             ("_applC" ("_position" set)
###               ("_applC" ("_position" sourcenodes) ("_position" as)))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>postdominate" ("_position" n')
###     ("\<^const>Pure.eq" ("_position" n)
###       ("\<^const>HOL.conj"
###         ("_applC" ("_position" valid_node) ("_position" n))
###         ("\<^const>HOL.conj"
###           ("_applC" ("_position" valid_node) ("_position" n'))
###           ("\<^const>HOL.All_binder" ("_position" as)
###             ("\<^const>local.path" ("_position" n) ("_position" as)
###               ("\<^const>HOL.implies" ("\<^fixed>Exit")
###                 ("\<^const>Set.member" ("_position" n')
###                   ("_applC" ("_position" set)
###                     ("_applC" ("_position" sourcenodes)
###                       ("_position" as))))))))))))
### ("\<^const>Pure.eq"
###   ("\<^fixed>postdominate" ("_position" n') ("_position" n))
###   ("\<^const>HOL.conj" ("_applC" ("_position" valid_node) ("_position" n))
###     ("\<^const>HOL.conj"
###       ("_applC" ("_position" valid_node) ("_position" n'))
###       ("\<^const>HOL.All_binder" ("_position" as)
###         ("\<^const>local.path" ("_position" n) ("_position" as)
###           ("\<^const>HOL.implies" ("\<^fixed>Exit")
###             ("\<^const>Set.member" ("_position" n')
###               ("_applC" ("_position" set)
###                 ("_applC" ("_position" sourcenodes)
###                   ("_position" as))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>postdominate" ("_position" n')
###     ("\<^const>Pure.eq" ("_position" n)
###       ("\<^const>HOL.conj"
###         ("_applC" ("_position" valid_node) ("_position" n))
###         ("\<^const>HOL.conj"
###           ("_applC" ("_position" valid_node) ("_position" n'))
###           ("\<^const>HOL.All_binder" ("_position" as)
###             ("\<^const>Set.member"
###               ("\<^const>local.path" ("_position" n) ("_position" as)
###                 ("\<^const>HOL.implies" ("\<^fixed>Exit") ("_position" n')))
###               ("_applC" ("_position" set)
###                 ("_applC" ("_position" sourcenodes)
###                   ("_position" as))))))))))
### ("\<^const>Pure.eq"
###   ("\<^fixed>postdominate" ("_position" n') ("_position" n))
###   ("\<^const>HOL.conj" ("_applC" ("_position" valid_node) ("_position" n))
###     ("\<^const>HOL.conj"
###       ("_applC" ("_position" valid_node) ("_position" n'))
###       ("\<^const>HOL.All_binder" ("_position" as)
###         ("\<^const>Set.member"
###           ("\<^const>local.path" ("_position" n) ("_position" as)
###             ("\<^const>HOL.implies" ("\<^fixed>Exit") ("_position" n')))
###           ("_applC" ("_position" set)
###             ("_applC" ("_position" sourcenodes) ("_position" as))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
consts
  flat :: "'a list stream => 'a stream"
class height = type +
  fixes height :: "'a => nat"
instantiation
  tree :: (type) height
  height_tree == height :: 'a tree => nat
### Ambiguous input (line 182 of "$AFP/Slicing/Basic/Postdomination.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.postdominate" ("\<^fixed>Exit")
###     ("\<^const>Pure.imp" ("\<^const>HOL.Trueprop" ("_position" n))
###       ("\<^const>HOL.Trueprop" ("_position" False)))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>local.postdominate" ("\<^fixed>Exit") ("_position" n)))
###   ("\<^const>HOL.Trueprop" ("_position" False)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 214 of "$AFP/Slicing/Basic/Postdomination.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.Not"
###     ("_applC"
###       ("\<^const>local.postdominate" ("_position" n)
###         ("_position" targetnode))
###       ("_position" ax))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.Not"
###     ("\<^const>local.postdominate" ("_position" n)
###       ("_applC" ("_position" targetnode) ("_position" ax)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
consts
  sinterleave :: "'a stream => 'a stream => 'a stream"
consts
  szip :: "'a stream => 'b stream => ('a * 'b) stream"
Found termination order: "size <*mlex*> {}"
locale StrongPostdomination
  fixes sourcenode :: "'edge => 'node"
    and targetnode :: "'edge => 'node"
    and kind :: "'edge => 'state edge_kind"
    and valid_edge :: "'edge => bool"
    and Entry :: "'node"  (\<open>'('_Entry'_')\<close>)
    and Exit :: "'node"  (\<open>'('_Exit'_')\<close>)
  assumes
    "StrongPostdomination sourcenode targetnode kind valid_edge (_Entry_)
      (_Exit_)"
consts
  smap2 :: "('a => 'b => 'c) => 'a stream => 'b stream => 'c stream"
### Ambiguous input (line 334 of "$AFP/Slicing/Basic/Postdomination.thy") produces 20 parse trees (10 displayed):
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>strong_postdominate" ("_position" n')
###     ("\<^const>Pure.eq" ("_position" n)
###       ("\<^const>HOL.conj"
###         ("\<^const>local.postdominate" ("_position" n') ("_position" n))
###         ("_Ex_greater_eq" ("_position" k) ("\<^const>Groups.one_class.one")
###           ("\<^const>HOL.All_binder"
###             ("_idts" ("_position" as) ("_position" nx))
###             ("\<^const>Set.member"
###               ("\<^const>local.path" ("_position" n) ("_position" as)
###                 ("\<^const>HOL.implies"
###                   ("\<^const>HOL.conj" ("_position" nx)
###                     ("\<^const>Orderings.ord_class.greater_eq"
###                       ("_applC" ("_position" length) ("_position" as))
###                       ("_position" k)))
###                   ("_position" n')))
###               ("_applC" ("_position" set)
###                 ("_applC" ("_position" sourcenodes)
###                   ("_position" as))))))))))
### ("\<^const>Pure.eq"
###   ("\<^fixed>strong_postdominate" ("_position" n') ("_position" n))
###   ("\<^const>HOL.conj"
###     ("\<^const>local.postdominate" ("_position" n') ("_position" n))
###     ("_Ex_greater_eq" ("_position" k) ("\<^const>Groups.one_class.one")
###       ("\<^const>HOL.All_binder" ("_idts" ("_position" as) ("_position" nx))
###         ("\<^const>Set.member"
###           ("\<^const>local.path" ("_position" n) ("_position" as)
###             ("\<^const>HOL.implies"
###               ("\<^const>HOL.conj" ("_position" nx)
###                 ("\<^const>Orderings.ord_class.greater_eq"
###                   ("_applC" ("_position" length) ("_position" as))
###                   ("_position" k)))
###               ("_position" n')))
###           ("_applC" ("_position" set)
###             ("_applC" ("_position" sourcenodes) ("_position" as))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>strong_postdominate" ("_position" n')
###     ("\<^const>Pure.eq" ("_position" n)
###       ("\<^const>local.postdominate" ("_position" n')
###         ("\<^const>HOL.conj" ("_position" n)
###           ("_Ex_greater_eq" ("_position" k)
###             ("\<^const>Groups.one_class.one")
###             ("\<^const>HOL.All_binder"
###               ("_idts" ("_position" as) ("_position" nx))
###               ("\<^const>Set.member"
###                 ("\<^const>local.path" ("_position" n) ("_position" as)
###                   ("\<^const>HOL.implies"
###                     ("\<^const>HOL.conj" ("_position" nx)
###                       ("\<^const>Orderings.ord_class.greater_eq"
###                         ("_applC" ("_position" length) ("_position" as))
###                         ("_position" k)))
###                     ("_position" n')))
###                 ("_applC" ("_position" set)
###                   ("_applC" ("_position" sourcenodes)
###                     ("_position" as)))))))))))
### ("\<^const>Pure.eq"
###   ("\<^fixed>strong_postdominate" ("_position" n') ("_position" n))
###   ("\<^const>local.postdominate" ("_position" n')
###     ("\<^const>HOL.conj" ("_position" n)
###       ("_Ex_greater_eq" ("_position" k) ("\<^const>Groups.one_class.one")
###         ("\<^const>HOL.All_binder"
###           ("_idts" ("_position" as) ("_position" nx))
###           ("\<^const>Set.member"
###             ("\<^const>local.path" ("_position" n) ("_position" as)
###               ("\<^const>HOL.implies"
###                 ("\<^const>HOL.conj" ("_position" nx)
###                   ("\<^const>Orderings.ord_class.greater_eq"
###                     ("_applC" ("_position" length) ("_position" as))
###                     ("_position" k)))
###                 ("_position" n')))
###             ("_applC" ("_position" set)
###               ("_applC" ("_position" sourcenodes) ("_position" as)))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>strong_postdominate" ("_position" n')
###     ("\<^const>Pure.eq" ("_position" n)
###       ("\<^const>HOL.conj"
###         ("\<^const>local.postdominate" ("_position" n') ("_position" n))
###         ("_Ex_greater_eq" ("_position" k) ("\<^const>Groups.one_class.one")
###           ("\<^const>HOL.All_binder"
###             ("_idts" ("_position" as) ("_position" nx))
###             ("\<^const>local.path" ("_position" n) ("_position" as)
###               ("\<^const>HOL.implies"
###                 ("\<^const>HOL.conj" ("_position" nx)
###                   ("\<^const>Orderings.ord_class.greater_eq"
###                     ("_applC" ("_position" length) ("_position" as))
###                     ("_position" k)))
###                 ("\<^const>Set.member" ("_position" n')
###                   ("_applC" ("_position" set)
###                     ("_applC" ("_position" sourcenodes)
###                       ("_position" as))))))))))))
### ("\<^const>Pure.eq"
###   ("\<^fixed>strong_postdominate" ("_position" n') ("_position" n))
###   ("\<^const>HOL.conj"
###     ("\<^const>local.postdominate" ("_position" n') ("_position" n))
###     ("_Ex_greater_eq" ("_position" k) ("\<^const>Groups.one_class.one")
###       ("\<^const>HOL.All_binder" ("_idts" ("_position" as) ("_position" nx))
###         ("\<^const>local.path" ("_position" n) ("_position" as)
###           ("\<^const>HOL.implies"
###             ("\<^const>HOL.conj" ("_position" nx)
###               ("\<^const>Orderings.ord_class.greater_eq"
###                 ("_applC" ("_position" length) ("_position" as))
###                 ("_position" k)))
###             ("\<^const>Set.member" ("_position" n')
###               ("_applC" ("_position" set)
###                 ("_applC" ("_position" sourcenodes)
###                   ("_position" as))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>strong_postdominate" ("_position" n')
###     ("\<^const>Pure.eq" ("_position" n)
###       ("\<^const>local.postdominate" ("_position" n')
###         ("\<^const>HOL.conj" ("_position" n)
###           ("_Ex_greater_eq" ("_position" k)
###             ("\<^const>Groups.one_class.one")
###             ("\<^const>HOL.All_binder"
###               ("_idts" ("_position" as) ("_position" nx))
###               ("\<^const>local.path" ("_position" n) ("_position" as)
###                 ("\<^const>HOL.implies"
###                   ("\<^const>HOL.conj" ("_position" nx)
###                     ("\<^const>Orderings.ord_class.greater_eq"
###                       ("_applC" ("_position" length) ("_position" as))
###                       ("_position" k)))
###                   ("\<^const>Set.member" ("_position" n')
###                     ("_applC" ("_position" set)
###                       ("_applC" ("_position" sourcenodes)
###                         ("_position" as)))))))))))))
### ("\<^const>Pure.eq"
###   ("\<^fixed>strong_postdominate" ("_position" n') ("_position" n))
###   ("\<^const>local.postdominate" ("_position" n')
###     ("\<^const>HOL.conj" ("_position" n)
###       ("_Ex_greater_eq" ("_position" k) ("\<^const>Groups.one_class.one")
###         ("\<^const>HOL.All_binder"
###           ("_idts" ("_position" as) ("_position" nx))
###           ("\<^const>local.path" ("_position" n) ("_position" as)
###             ("\<^const>HOL.implies"
###               ("\<^const>HOL.conj" ("_position" nx)
###                 ("\<^const>Orderings.ord_class.greater_eq"
###                   ("_applC" ("_position" length) ("_position" as))
###                   ("_position" k)))
###               ("\<^const>Set.member" ("_position" n')
###                 ("_applC" ("_position" set)
###                   ("_applC" ("_position" sourcenodes)
###                     ("_position" as)))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>strong_postdominate" ("_position" n')
###     ("\<^const>Pure.eq" ("_position" n)
###       ("\<^const>HOL.conj"
###         ("\<^const>local.postdominate" ("_position" n') ("_position" n))
###         ("_Ex_greater_eq" ("_position" k) ("\<^const>Groups.one_class.one")
###           ("\<^const>HOL.All_binder"
###             ("_idts" ("_position" as) ("_position" nx))
###             ("\<^const>HOL.implies"
###               ("\<^const>local.path" ("_position" n) ("_position" as)
###                 ("\<^const>HOL.conj" ("_position" nx)
###                   ("\<^const>Orderings.ord_class.greater_eq"
###                     ("_applC" ("_position" length) ("_position" as))
###                     ("_position" k))))
###               ("\<^const>Set.member" ("_position" n')
###                 ("_applC" ("_position" set)
###                   ("_applC" ("_position" sourcenodes)
###                     ("_position" as)))))))))))
### ("\<^const>Pure.eq"
###   ("\<^fixed>strong_postdominate" ("_position" n') ("_position" n))
###   ("\<^const>HOL.conj"
###     ("\<^const>local.postdominate" ("_position" n') ("_position" n))
###     ("_Ex_greater_eq" ("_position" k) ("\<^const>Groups.one_class.one")
###       ("\<^const>HOL.All_binder" ("_idts" ("_position" as) ("_position" nx))
###         ("\<^const>HOL.implies"
###           ("\<^const>local.path" ("_position" n) ("_position" as)
###             ("\<^const>HOL.conj" ("_position" nx)
###               ("\<^const>Orderings.ord_class.greater_eq"
###                 ("_applC" ("_position" length) ("_position" as))
###                 ("_position" k))))
###           ("\<^const>Set.member" ("_position" n')
###             ("_applC" ("_position" set)
###               ("_applC" ("_position" sourcenodes) ("_position" as)))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 341 of "$AFP/Slicing/Basic/Postdomination.thy") produces 5 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.All_binder" ("_idts" ("_position" as) ("_position" nx))
###     ("\<^const>Set.member"
###       ("\<^const>local.path" ("_position" n) ("_position" as)
###         ("\<^const>HOL.implies"
###           ("\<^const>HOL.conj" ("_position" nx)
###             ("\<^const>Orderings.ord_class.greater_eq"
###               ("_applC" ("_position" length) ("_position" as))
###               ("_position" k)))
###           ("_position" n')))
###       ("_applC" ("_position" set)
###         ("_applC" ("_position" sourcenodes) ("_position" as))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.All_binder" ("_idts" ("_position" as) ("_position" nx))
###     ("\<^const>local.path" ("_position" n) ("_position" as)
###       ("\<^const>HOL.implies"
###         ("\<^const>HOL.conj" ("_position" nx)
###           ("\<^const>Orderings.ord_class.greater_eq"
###             ("_applC" ("_position" length) ("_position" as))
###             ("_position" k)))
###         ("\<^const>Set.member" ("_position" n')
###           ("_applC" ("_position" set)
###             ("_applC" ("_position" sourcenodes) ("_position" as))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.All_binder" ("_idts" ("_position" as) ("_position" nx))
###     ("\<^const>HOL.implies"
###       ("\<^const>local.path" ("_position" n) ("_position" as)
###         ("\<^const>HOL.conj" ("_position" nx)
###           ("\<^const>Orderings.ord_class.greater_eq"
###             ("_applC" ("_position" length) ("_position" as))
###             ("_position" k))))
###       ("\<^const>Set.member" ("_position" n')
###         ("_applC" ("_position" set)
###           ("_applC" ("_position" sourcenodes) ("_position" as)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.All_binder" ("_idts" ("_position" as) ("_position" nx))
###     ("\<^const>HOL.implies"
###       ("\<^const>HOL.conj"
###         ("\<^const>local.path" ("_position" n) ("_position" as)
###           ("_position" nx))
###         ("\<^const>Orderings.ord_class.greater_eq"
###           ("_applC" ("_position" length) ("_position" as)) ("_position" k)))
###       ("\<^const>Set.member" ("_position" n')
###         ("_applC" ("_position" set)
###           ("_applC" ("_position" sourcenodes) ("_position" as)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.All_binder" ("_idts" ("_position" as) ("_position" nx))
###     ("\<^const>HOL.implies"
###       ("\<^const>Orderings.ord_class.greater_eq"
###         ("\<^const>local.path" ("_position" n) ("_position" as)
###           ("\<^const>HOL.conj" ("_position" nx)
###             ("_applC" ("_position" length) ("_position" as))))
###         ("_position" k))
###       ("\<^const>Set.member" ("_position" n')
###         ("_applC" ("_position" set)
###           ("_applC" ("_position" sourcenodes) ("_position" as)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "HOL-Library.Stream"
### 1.077s elapsed time, 4.087s cpu time, 0.818s GC time
Loading theory "Draft.CFG_wf" (required by "Draft.DynamicControlDependencesMoreTemplates" via "Draft.DynamicControlDependences" via "Draft.AdditionalLemmas" via "Draft.WellFormed" via "Draft.CFGExit_wf")
Found termination order: "size <*mlex*> {}"
### theory "Draft.Postdomination"
### 0.283s elapsed time, 1.120s cpu time, 0.065s GC time
Loading theory "Draft.DynStandardControlDependence" (required by "Draft.DynamicControlDependencesMoreTemplates" via "Draft.DynamicControlDependences" via "Draft.AdditionalLemmas" via "Draft.WellFormed" via "Draft.CDepInstantiations" via "Draft.PDG" via "Draft.StandardControlDependence")
Found termination order: "size <*mlex*> {}"
locale CFG_wf
  fixes sourcenode :: "'edge => 'node"
    and targetnode :: "'edge => 'node"
    and kind :: "'edge => 'state edge_kind"
    and valid_edge :: "'edge => bool"
    and Entry :: "'node"  (\<open>'('_Entry'_')\<close>)
    and Def :: "'node => 'var set"
    and Use :: "'node => 'var set"
    and state_val :: "'state => 'var => 'val"
  assumes
    "CFG_wf sourcenode targetnode kind valid_edge (_Entry_) Def Use
      state_val"
locale Postdomination
  fixes sourcenode :: "'edge => 'node"
    and targetnode :: "'edge => 'node"
    and kind :: "'edge => 'state edge_kind"
    and valid_edge :: "'edge => bool"
    and Entry :: "'node"  (\<open>'('_Entry'_')\<close>)
    and Exit :: "'node"  (\<open>'('_Exit'_')\<close>)
  assumes
    "Postdomination sourcenode targetnode kind valid_edge (_Entry_)
      (_Exit_)"
Found termination order: "{}"
### theory "Draft.CFG_wf"
### 0.099s elapsed time, 0.388s cpu time, 0.047s GC time
Loading theory "Draft.DynWeakControlDependence" (required by "Draft.DynamicControlDependencesMoreTemplates" via "Draft.DynamicControlDependences" via "Draft.AdditionalLemmas" via "Draft.WellFormed" via "Draft.CDepInstantiations" via "Draft.PDG" via "Draft.WeakControlDependence")
### Ambiguous input (line 30 of "$AFP/Slicing/Basic/DynStandardControlDependence.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>local.dyn_standard_control_dependence" ("_position" n)
###       ("_position" n') ("_position" as))
###     ("\<^const>HOL.conj"
###       ("\<^const>local.path" ("_position" n) ("_position" as)
###         ("_position" n'))
###       ("\<^const>HOL.conj"
###         ("\<^const>HOL.not_equal" ("_position" n) ("_position" n'))
###         ("\<^const>HOL.conj"
###           ("\<^const>HOL.Not"
###             ("\<^const>local.postdominate" ("_position" n')
###               ("_position" n)))
###           ("\<^const>HOL.conj"
###             ("\<^const>Set.not_member" ("_position" n')
###               ("_applC" ("_position" set)
###                 ("_applC" ("_position" sourcenodes) ("_position" as))))
###             ("_Ball" ("_position" n'')
###               ("_applC" ("_position" set)
###                 ("_applC" ("_position" targetnodes) ("_position" as)))
###               ("\<^const>local.postdominate" ("_position" n')
###                 ("_position" n'')))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.dyn_standard_control_dependence" ("_position" n)
###     ("_position" n')
###     ("\<^const>HOL.eq" ("_position" as)
###       ("\<^const>HOL.conj"
###         ("\<^const>local.path" ("_position" n) ("_position" as)
###           ("_position" n'))
###         ("\<^const>HOL.conj"
###           ("\<^const>HOL.not_equal" ("_position" n) ("_position" n'))
###           ("\<^const>HOL.conj"
###             ("\<^const>HOL.Not"
###               ("\<^const>local.postdominate" ("_position" n')
###                 ("_position" n)))
###             ("\<^const>HOL.conj"
###               ("\<^const>Set.not_member" ("_position" n')
###                 ("_applC" ("_position" set)
###                   ("_applC" ("_position" sourcenodes) ("_position" as))))
###               ("_Ball" ("_position" n'')
###                 ("_applC" ("_position" set)
###                   ("_applC" ("_position" targetnodes) ("_position" as)))
###                 ("\<^const>local.postdominate" ("_position" n')
###                   ("_position" n''))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 217 of "$AFP/Slicing/Basic/DynStandardControlDependence.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.All_binder" ("_idts" ("_position" ax) ("_position" ax'))
###     ("\<^const>HOL.implies"
###       ("\<^const>HOL.conj"
###         ("\<^const>Set.member" ("_position" ax)
###           ("_applC" ("_position" set) ("_position" as')))
###         ("\<^const>HOL.conj"
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" sourcenode) ("_position" ax))
###             ("_applC" ("_position" sourcenode) ("_position" ax')))
###           ("_applC" ("_position" valid_edge) ("_position" ax'))))
###       ("_applC"
###         ("\<^const>local.postdominate" ("_position" n)
###           ("_position" targetnode))
###         ("_position" ax')))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.All_binder" ("_idts" ("_position" ax) ("_position" ax'))
###     ("\<^const>HOL.implies"
###       ("\<^const>HOL.conj"
###         ("\<^const>Set.member" ("_position" ax)
###           ("_applC" ("_position" set) ("_position" as')))
###         ("\<^const>HOL.conj"
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" sourcenode) ("_position" ax))
###             ("_applC" ("_position" sourcenode) ("_position" ax')))
###           ("_applC" ("_position" valid_edge) ("_position" ax'))))
###       ("\<^const>local.postdominate" ("_position" n)
###         ("_applC" ("_position" targetnode) ("_position" ax'))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 219 of "$AFP/Slicing/Basic/DynStandardControlDependence.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>List.list.Cons"
###     ("\<^const>local.dyn_standard_control_dependence" ("_position" n')
###       ("_position" n) ("_position" a))
###     ("_position" as')))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.dyn_standard_control_dependence" ("_position" n')
###     ("_position" n)
###     ("\<^const>List.list.Cons" ("_position" a) ("_position" as'))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
locale StrongPostdomination
  fixes sourcenode :: "'edge => 'node"
    and targetnode :: "'edge => 'node"
    and kind :: "'edge => 'state edge_kind"
    and valid_edge :: "'edge => bool"
    and Entry :: "'node"  (\<open>'('_Entry'_')\<close>)
    and Exit :: "'node"  (\<open>'('_Exit'_')\<close>)
  assumes
    "StrongPostdomination sourcenode targetnode kind valid_edge (_Entry_)
      (_Exit_)"
### theory "Draft.DynStandardControlDependence"
### 0.117s elapsed time, 0.469s cpu time, 0.047s GC time
Loading theory "Draft.StandardControlDependence" (required by "Draft.DynamicControlDependencesMoreTemplates" via "Draft.DynamicControlDependences" via "Draft.AdditionalLemmas" via "Draft.WellFormed" via "Draft.CDepInstantiations" via "Draft.PDG")
### theory "Draft.DynWeakControlDependence"
### 0.067s elapsed time, 0.271s cpu time, 0.000s GC time
Loading theory "Draft.WeakControlDependence" (required by "Draft.DynamicControlDependencesMoreTemplates" via "Draft.DynamicControlDependences" via "Draft.AdditionalLemmas" via "Draft.WellFormed" via "Draft.CDepInstantiations" via "Draft.PDG")
Found termination order: "size <*mlex*> {}"
locale Postdomination
  fixes sourcenode :: "'edge => 'node"
    and targetnode :: "'edge => 'node"
    and kind :: "'edge => 'state edge_kind"
    and valid_edge :: "'edge => bool"
    and Entry :: "'node"  (\<open>'('_Entry'_')\<close>)
    and Exit :: "'node"  (\<open>'('_Exit'_')\<close>)
  assumes
    "Postdomination sourcenode targetnode kind valid_edge (_Entry_)
      (_Exit_)"
### Ambiguous input (line 14 of "$AFP/Slicing/StaticIntra/StandardControlDependence.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.dyn_standard_control_dependence"
###     ("\<^fixed>standard_control_dependence" ("_position" n)
###       ("\<^const>Pure.eq" ("_position" n')
###         ("\<^const>HOL.Ex_binder" ("_position" as) ("_position" n))))
###     ("_position" n') ("_position" as)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.dyn_standard_control_dependence" ("_position" n)
###     ("\<^const>Pure.eq" ("_position" n')
###       ("\<^const>HOL.Ex_binder" ("_position" as)
###         ("\<^fixed>standard_control_dependence" ("_position" n)
###           ("_position" n'))))
###     ("_position" as)))
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>standard_control_dependence" ("_position" n)
###     ("\<^const>Pure.eq" ("_position" n')
###       ("\<^const>HOL.Ex_binder" ("_position" as)
###         ("\<^const>local.dyn_standard_control_dependence" ("_position" n)
###           ("_position" n') ("_position" as))))))
### ("\<^const>Pure.eq"
###   ("\<^fixed>standard_control_dependence" ("_position" n) ("_position" n'))
###   ("\<^const>HOL.Ex_binder" ("_position" as)
###     ("\<^const>local.dyn_standard_control_dependence" ("_position" n)
###       ("_position" n') ("_position" as))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
locale StrongPostdomination
  fixes sourcenode :: "'edge => 'node"
    and targetnode :: "'edge => 'node"
    and kind :: "'edge => 'state edge_kind"
    and valid_edge :: "'edge => bool"
    and Entry :: "'node"  (\<open>'('_Entry'_')\<close>)
    and Exit :: "'node"  (\<open>'('_Exit'_')\<close>)
  assumes
    "StrongPostdomination sourcenode targetnode kind valid_edge (_Entry_)
      (_Exit_)"
### Ambiguous input (line 16 of "$AFP/Slicing/StaticIntra/StandardControlDependence.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.standard_control_dependence" ("_position" n)
###     ("\<^const>HOL.eq" ("_position" n')
###       ("\<^const>HOL.Ex_binder"
###         ("_idts" ("_position" a)
###           ("_idts" ("_position" a') ("_position" as)))
###         ("\<^const>HOL.conj"
###           ("\<^const>Set.not_member" ("_position" n')
###             ("_applC" ("_position" set)
###               ("_applC" ("_position" sourcenodes)
###                 ("\<^const>List.list.Cons" ("_position" a)
###                   ("_position" as)))))
###           ("\<^const>HOL.conj"
###             ("\<^const>local.path" ("_position" n)
###               ("\<^const>List.list.Cons" ("_position" a) ("_position" as))
###               ("_position" n'))
###             ("\<^const>HOL.conj"
###               ("\<^const>local.postdominate" ("_position" n')
###                 ("_applC" ("_position" targetnode) ("_position" a)))
###               ("\<^const>HOL.conj"
###                 ("_applC" ("_position" valid_edge) ("_position" a'))
###                 ("\<^const>HOL.conj"
###                   ("\<^const>HOL.eq"
###                     ("_applC" ("_position" sourcenode) ("_position" a'))
###                     ("_position" n))
###                   ("\<^const>HOL.Not"
###                     ("\<^const>local.postdominate" ("_position" n')
###                       ("_applC" ("_position" targetnode)
###                         ("_position" a')))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>local.standard_control_dependence" ("_position" n)
###       ("_position" n'))
###     ("\<^const>HOL.Ex_binder"
###       ("_idts" ("_position" a) ("_idts" ("_position" a') ("_position" as)))
###       ("\<^const>HOL.conj"
###         ("\<^const>Set.not_member" ("_position" n')
###           ("_applC" ("_position" set)
###             ("_applC" ("_position" sourcenodes)
###               ("\<^const>List.list.Cons" ("_position" a)
###                 ("_position" as)))))
###         ("\<^const>HOL.conj"
###           ("\<^const>local.path" ("_position" n)
###             ("\<^const>List.list.Cons" ("_position" a) ("_position" as))
###             ("_position" n'))
###           ("\<^const>HOL.conj"
###             ("\<^const>local.postdominate" ("_position" n')
###               ("_applC" ("_position" targetnode) ("_position" a)))
###             ("\<^const>HOL.conj"
###               ("_applC" ("_position" valid_edge) ("_position" a'))
###               ("\<^const>HOL.conj"
###                 ("\<^const>HOL.eq"
###                   ("_applC" ("_position" sourcenode) ("_position" a'))
###                   ("_position" n))
###                 ("\<^const>HOL.Not"
###                   ("\<^const>local.postdominate" ("_position" n')
###                     ("_applC" ("_position" targetnode)
###                       ("_position" a'))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 14 of "$AFP/Slicing/StaticIntra/WeakControlDependence.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>weak_control_dependence" ("_position" n)
###     ("\<^const>Pure.eq" ("_position" n')
###       ("\<^const>HOL.Ex_binder" ("_position" as)
###         ("\<^const>local.dyn_weak_control_dependence" ("_position" n)
###           ("_position" n') ("_position" as))))))
### ("\<^const>Pure.eq"
###   ("\<^fixed>weak_control_dependence" ("_position" n) ("_position" n'))
###   ("\<^const>HOL.Ex_binder" ("_position" as)
###     ("\<^const>local.dyn_weak_control_dependence" ("_position" n)
###       ("_position" n') ("_position" as))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.dyn_weak_control_dependence" ("_position" n)
###     ("\<^const>Pure.eq" ("_position" n')
###       ("\<^const>HOL.Ex_binder" ("_position" as)
###         ("\<^fixed>weak_control_dependence" ("_position" n)
###           ("_position" n'))))
###     ("_position" as)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.dyn_weak_control_dependence"
###     ("\<^fixed>weak_control_dependence" ("_position" n)
###       ("\<^const>Pure.eq" ("_position" n')
###         ("\<^const>HOL.Ex_binder" ("_position" as) ("_position" n))))
###     ("_position" n') ("_position" as)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 25 of "$AFP/Slicing/StaticIntra/StandardControlDependence.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.standard_control_dependence" ("_position" n)
###     ("\<^const>Pure.imp" ("\<^const>HOL.Trueprop" ("\<^fixed>Exit"))
###       ("\<^const>HOL.Trueprop" ("_position" False)))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>local.standard_control_dependence" ("_position" n)
###       ("\<^fixed>Exit")))
###   ("\<^const>HOL.Trueprop" ("_position" False)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 31 of "$AFP/Slicing/StaticIntra/StandardControlDependence.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.standard_control_dependence" ("_position" n)
###     ("\<^const>HOL.eq" ("_position" n')
###       ("\<^const>HOL.Ex_binder" ("_position" as)
###         ("\<^const>HOL.conj"
###           ("\<^const>local.path" ("_position" n) ("_position" as)
###             ("_position" n'))
###           ("\<^const>HOL.conj"
###             ("\<^const>HOL.not_equal" ("_position" n) ("_position" n'))
###             ("\<^const>HOL.conj"
###               ("\<^const>HOL.Not"
###                 ("\<^const>local.postdominate" ("_position" n')
###                   ("_position" n)))
###               ("\<^const>HOL.conj"
###                 ("\<^const>Set.not_member" ("_position" n')
###                   ("_applC" ("_position" set)
###                     ("_applC" ("_position" sourcenodes) ("_position" as))))
###                 ("_Ball" ("_position" n'')
###                   ("_applC" ("_position" set)
###                     ("_applC" ("_position" targetnodes) ("_position" as)))
###                   ("\<^const>local.postdominate" ("_position" n')
###                     ("_position" n'')))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>local.standard_control_dependence" ("_position" n)
###       ("_position" n'))
###     ("\<^const>HOL.Ex_binder" ("_position" as)
###       ("\<^const>HOL.conj"
###         ("\<^const>local.path" ("_position" n) ("_position" as)
###           ("_position" n'))
###         ("\<^const>HOL.conj"
###           ("\<^const>HOL.not_equal" ("_position" n) ("_position" n'))
###           ("\<^const>HOL.conj"
###             ("\<^const>HOL.Not"
###               ("\<^const>local.postdominate" ("_position" n')
###                 ("_position" n)))
###             ("\<^const>HOL.conj"
###               ("\<^const>Set.not_member" ("_position" n')
###                 ("_applC" ("_position" set)
###                   ("_applC" ("_position" sourcenodes) ("_position" as))))
###               ("_Ball" ("_position" n'')
###                 ("_applC" ("_position" set)
###                   ("_applC" ("_position" targetnodes) ("_position" as)))
###                 ("\<^const>local.postdominate" ("_position" n')
###                   ("_position" n''))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 17 of "$AFP/Slicing/StaticIntra/WeakControlDependence.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.weak_control_dependence" ("_position" n)
###     ("\<^const>HOL.eq" ("_position" n')
###       ("\<^const>HOL.Ex_binder"
###         ("_idts" ("_position" a)
###           ("_idts" ("_position" a') ("_position" as)))
###         ("\<^const>HOL.conj"
###           ("\<^const>Set.not_member" ("_position" n')
###             ("_applC" ("_position" set)
###               ("_applC" ("_position" sourcenodes)
###                 ("\<^const>List.list.Cons" ("_position" a)
###                   ("_position" as)))))
###           ("\<^const>HOL.conj"
###             ("\<^const>local.path" ("_position" n)
###               ("\<^const>List.list.Cons" ("_position" a) ("_position" as))
###               ("_position" n'))
###             ("\<^const>HOL.conj"
###               ("\<^const>local.strong_postdominate" ("_position" n')
###                 ("_applC" ("_position" targetnode) ("_position" a)))
###               ("\<^const>HOL.conj"
###                 ("_applC" ("_position" valid_edge) ("_position" a'))
###                 ("\<^const>HOL.conj"
###                   ("\<^const>HOL.eq"
###                     ("_applC" ("_position" sourcenode) ("_position" a'))
###                     ("_position" n))
###                   ("\<^const>HOL.Not"
###                     ("\<^const>local.strong_postdominate" ("_position" n')
###                       ("_applC" ("_position" targetnode)
###                         ("_position" a')))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>local.weak_control_dependence" ("_position" n)
###       ("_position" n'))
###     ("\<^const>HOL.Ex_binder"
###       ("_idts" ("_position" a) ("_idts" ("_position" a') ("_position" as)))
###       ("\<^const>HOL.conj"
###         ("\<^const>Set.not_member" ("_position" n')
###           ("_applC" ("_position" set)
###             ("_applC" ("_position" sourcenodes)
###               ("\<^const>List.list.Cons" ("_position" a)
###                 ("_position" as)))))
###         ("\<^const>HOL.conj"
###           ("\<^const>local.path" ("_position" n)
###             ("\<^const>List.list.Cons" ("_position" a) ("_position" as))
###             ("_position" n'))
###           ("\<^const>HOL.conj"
###             ("\<^const>local.strong_postdominate" ("_position" n')
###               ("_applC" ("_position" targetnode) ("_position" a)))
###             ("\<^const>HOL.conj"
###               ("_applC" ("_position" valid_edge) ("_position" a'))
###               ("\<^const>HOL.conj"
###                 ("\<^const>HOL.eq"
###                   ("_applC" ("_position" sourcenode) ("_position" a'))
###                   ("_position" n))
###                 ("\<^const>HOL.Not"
###                   ("\<^const>local.strong_postdominate" ("_position" n')
###                     ("_applC" ("_position" targetnode)
###                       ("_position" a'))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 26 of "$AFP/Slicing/StaticIntra/WeakControlDependence.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.weak_control_dependence" ("_position" n)
###     ("\<^const>Pure.imp" ("\<^const>HOL.Trueprop" ("\<^fixed>Exit"))
###       ("\<^const>HOL.Trueprop" ("_position" False)))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>local.weak_control_dependence" ("_position" n)
###       ("\<^fixed>Exit")))
###   ("\<^const>HOL.Trueprop" ("_position" False)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "Draft.WeakControlDependence"
### 0.076s elapsed time, 0.303s cpu time, 0.000s GC time
Loading theory "Draft.CFGExit_wf" (required by "Draft.DynamicControlDependencesMoreTemplates" via "Draft.DynamicControlDependences" via "Draft.AdditionalLemmas" via "Draft.WellFormed")
### theory "Draft.StandardControlDependence"
### 0.093s elapsed time, 0.369s cpu time, 0.000s GC time
Loading theory "Draft.DynDataDependence" (required by "Draft.DynamicControlDependencesMoreTemplates" via "Draft.DynamicControlDependences" via "Draft.AdditionalLemmas" via "Draft.WellFormed" via "Draft.CDepInstantiations" via "Draft.Slice" via "Draft.DataDependence")
Found termination order: "size <*mlex*> {}"
locale CFG_wf
  fixes sourcenode :: "'edge => 'node"
    and targetnode :: "'edge => 'node"
    and kind :: "'edge => 'state edge_kind"
    and valid_edge :: "'edge => bool"
    and Entry :: "'node"  (\<open>'('_Entry'_')\<close>)
    and Def :: "'node => 'var set"
    and Use :: "'node => 'var set"
    and state_val :: "'state => 'var => 'val"
  assumes
    "CFG_wf sourcenode targetnode kind valid_edge (_Entry_) Def Use
      state_val"
### Ambiguous input (line 15 of "$AFP/Slicing/Basic/DynDataDependence.thy") produces 2 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>List.list.Cons"
###       ("\<^const>local.dyn_data_dependence" ("_position" n) ("_position" V)
###         ("_position" n') ("_position" a))
###       ("_position" as)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq" ("_applC" ("_position" sourcenode) ("_position" a))
###       ("_position" n))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>local.dyn_data_dependence" ("_position" n) ("_position" V)
###       ("_position" n')
###       ("\<^const>List.list.Cons" ("_position" a) ("_position" as))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq" ("_applC" ("_position" sourcenode) ("_position" a))
###       ("_position" n))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 20 of "$AFP/Slicing/Basic/DynDataDependence.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>List.list.Cons"
###     ("\<^const>local.dyn_data_dependence" ("_position" n) ("_position" V)
###       ("_position" n') ("_position" a))
###     ("_position" as)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.dyn_data_dependence" ("_position" n) ("_position" V)
###     ("_position" n')
###     ("\<^const>List.list.Cons" ("_position" a) ("_position" as))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 34 of "$AFP/Slicing/Basic/DynDataDependence.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>List.list.Cons"
###     ("\<^const>local.dyn_data_dependence" ("_position" n) ("_position" V)
###       ("_position" n') ("_position" a))
###     ("_position" as)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.dyn_data_dependence" ("_position" n) ("_position" V)
###     ("_position" n')
###     ("\<^const>List.list.Cons" ("_position" a) ("_position" as))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "Draft.DynDataDependence"
### 0.110s elapsed time, 0.437s cpu time, 0.058s GC time
Loading theory "Draft.DataDependence" (required by "Draft.DynamicControlDependencesMoreTemplates" via "Draft.DynamicControlDependences" via "Draft.AdditionalLemmas" via "Draft.WellFormed" via "Draft.CDepInstantiations" via "Draft.Slice")
Found termination order: "size <*mlex*> {}"
locale CFG_wf
  fixes sourcenode :: "'edge => 'node"
    and targetnode :: "'edge => 'node"
    and kind :: "'edge => 'state edge_kind"
    and valid_edge :: "'edge => bool"
    and Entry :: "'node"  (\<open>'('_Entry'_')\<close>)
    and Def :: "'node => 'var set"
    and Use :: "'node => 'var set"
    and state_val :: "'state => 'var => 'val"
  assumes
    "CFG_wf sourcenode targetnode kind valid_edge (_Entry_) Def Use
      state_val"
### Ambiguous input (line 9 of "$AFP/Slicing/StaticIntra/DataDependence.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.dyn_data_dependence"
###     ("\<^fixed>data_dependence" ("_position" n) ("_position" V)
###       ("\<^const>Pure.eq" ("_position" n')
###         ("\<^const>HOL.Ex_binder" ("_position" as) ("_position" n))))
###     ("_position" V) ("_position" n') ("_position" as)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.dyn_data_dependence" ("_position" n) ("_position" V)
###     ("\<^const>Pure.eq" ("_position" n')
###       ("\<^const>HOL.Ex_binder" ("_position" as)
###         ("\<^fixed>data_dependence" ("_position" n) ("_position" V)
###           ("_position" n'))))
###     ("_position" as)))
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>data_dependence" ("_position" n) ("_position" V)
###     ("\<^const>Pure.eq" ("_position" n')
###       ("\<^const>HOL.Ex_binder" ("_position" as)
###         ("\<^const>local.dyn_data_dependence" ("_position" n)
###           ("_position" V) ("_position" n') ("_position" as))))))
### ("\<^const>Pure.eq"
###   ("\<^fixed>data_dependence" ("_position" n) ("_position" V)
###     ("_position" n'))
###   ("\<^const>HOL.Ex_binder" ("_position" as)
###     ("\<^const>local.dyn_data_dependence" ("_position" n) ("_position" V)
###       ("_position" n') ("_position" as))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 11 of "$AFP/Slicing/StaticIntra/DataDependence.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.data_dependence" ("_position" n) ("_position" V)
###     ("\<^const>HOL.eq" ("_position" n')
###       ("\<^const>HOL.Ex_binder" ("_idts" ("_position" a') ("_position" as'))
###         ("\<^const>HOL.conj"
###           ("\<^const>Set.member" ("_position" V)
###             ("_applC" ("_position" Def) ("_position" n)))
###           ("\<^const>HOL.conj"
###             ("\<^const>Set.member" ("_position" V)
###               ("_applC" ("_position" Use) ("_position" n')))
###             ("\<^const>HOL.conj"
###               ("\<^const>local.path" ("_position" n)
###                 ("\<^const>List.list.Cons" ("_position" a')
###                   ("_position" as'))
###                 ("_position" n'))
###               ("_Ball" ("_position" n'')
###                 ("_applC" ("_position" set)
###                   ("_applC" ("_position" sourcenodes) ("_position" as')))
###                 ("\<^const>Set.not_member" ("_position" V)
###                   ("_applC" ("_position" Def) ("_position" n'')))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>local.data_dependence" ("_position" n) ("_position" V)
###       ("_position" n'))
###     ("\<^const>HOL.Ex_binder" ("_idts" ("_position" a') ("_position" as'))
###       ("\<^const>HOL.conj"
###         ("\<^const>Set.member" ("_position" V)
###           ("_applC" ("_position" Def) ("_position" n)))
###         ("\<^const>HOL.conj"
###           ("\<^const>Set.member" ("_position" V)
###             ("_applC" ("_position" Use) ("_position" n')))
###           ("\<^const>HOL.conj"
###             ("\<^const>local.path" ("_position" n)
###               ("\<^const>List.list.Cons" ("_position" a') ("_position" as'))
###               ("_position" n'))
###             ("_Ball" ("_position" n'')
###               ("_applC" ("_position" set)
###                 ("_applC" ("_position" sourcenodes) ("_position" as')))
###               ("\<^const>Set.not_member" ("_position" V)
###                 ("_applC" ("_position" Def) ("_position" n''))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "Draft.DataDependence"
### 0.061s elapsed time, 0.241s cpu time, 0.000s GC time
Loading theory "Draft.Distance" (required by "Draft.DynamicControlDependencesMoreTemplates" via "Draft.DynamicControlDependences" via "Draft.AdditionalLemmas" via "Draft.WellFormed" via "Draft.CDepInstantiations" via "Draft.Slice")
locale CFGExit_wf
  fixes sourcenode :: "'edge => 'node"
    and targetnode :: "'edge => 'node"
    and kind :: "'edge => 'state edge_kind"
    and valid_edge :: "'edge => bool"
    and Entry :: "'node"  (\<open>'('_Entry'_')\<close>)
    and Def :: "'node => 'var set"
    and Use :: "'node => 'var set"
    and state_val :: "'state => 'var => 'val"
    and Exit :: "'node"  (\<open>'('_Exit'_')\<close>)
  assumes
    "CFGExit_wf sourcenode targetnode kind valid_edge (_Entry_) Def Use
      state_val (_Exit_)"
### theory "Draft.CFGExit_wf"
### 0.184s elapsed time, 0.727s cpu time, 0.058s GC time
Loading theory "Draft.PDG" (required by "Draft.DynamicControlDependencesMoreTemplates" via "Draft.DynamicControlDependences" via "Draft.AdditionalLemmas" via "Draft.WellFormed" via "Draft.CDepInstantiations")
Found termination order: "size <*mlex*> {}"
locale CFG
  fixes sourcenode :: "'edge => 'node"
    and targetnode :: "'edge => 'node"
    and kind :: "'edge => 'state edge_kind"
    and valid_edge :: "'edge => bool"
    and Entry :: "'node"  (\<open>'('_Entry'_')\<close>)
  assumes "CFG sourcenode targetnode valid_edge (_Entry_)"
### Ambiguous input (line 37 of "$AFP/Slicing/StaticIntra/Distance.thy") produces 3 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>local.path" ("_position" n) ("_position" as)
###         ("_position" n')))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_applC" ("_position" length) ("_position" as))
###           ("_position" x)))
###       ("_asm"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.All_binder" ("_position" as')
###             ("\<^const>HOL.implies"
###               ("\<^const>local.path" ("_position" n) ("_position" as')
###                 ("_position" n'))
###               ("\<^const>Orderings.ord_class.less_eq" ("_position" x)
###                 ("_applC" ("_position" length) ("_position" as')))))))))
###   ("\<^const>HOL.Trueprop"
###     ("_applC" ("_position" distance)
###       ("_cargs" ("_position" n)
###         ("_cargs" ("_position" n') ("_position" x))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>local.path" ("_position" n) ("_position" as)
###         ("_position" n')))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_applC" ("_position" length) ("_position" as))
###           ("_position" x)))
###       ("_asm"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.All_binder" ("_position" as')
###             ("\<^const>local.path" ("_position" n) ("_position" as')
###               ("\<^const>HOL.implies" ("_position" n')
###                 ("\<^const>Orderings.ord_class.less_eq" ("_position" x)
###                   ("_applC" ("_position" length) ("_position" as'))))))))))
###   ("\<^const>HOL.Trueprop"
###     ("_applC" ("_position" distance)
###       ("_cargs" ("_position" n)
###         ("_cargs" ("_position" n') ("_position" x))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>local.path" ("_position" n) ("_position" as)
###         ("_position" n')))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_applC" ("_position" length) ("_position" as))
###           ("_position" x)))
###       ("_asm"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.All_binder" ("_position" as')
###             ("\<^const>Orderings.ord_class.less_eq"
###               ("\<^const>local.path" ("_position" n) ("_position" as')
###                 ("\<^const>HOL.implies" ("_position" n') ("_position" x)))
###               ("_applC" ("_position" length) ("_position" as'))))))))
###   ("\<^const>HOL.Trueprop"
###     ("_applC" ("_position" distance)
###       ("_cargs" ("_position" n)
###         ("_cargs" ("_position" n') ("_position" x))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Proofs for inductive predicate(s) "distance"
  Proving monotonicity ...
### theory "Draft.Distance"
### 0.104s elapsed time, 0.405s cpu time, 0.065s GC time
Loading theory "Draft.DynPDG" (required by "Draft.DynamicControlDependencesMoreTemplates" via "Draft.DynamicControlDependences")
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
### Ambiguous input (line 46 of "$AFP/Slicing/While/Com.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("\<^fixed>num_inner_nodes" ("_position" Skip))
###     ("\<^const>Groups.one_class.one")))
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>num_inner_nodes"
###     ("\<^const>HOL.eq" ("_position" Skip)
###       ("\<^const>Groups.one_class.one"))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 47 of "$AFP/Slicing/While/Com.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>num_inner_nodes"
###       ("\<^const>Com.cmd.LAss" ("_position" V) ("_position" e)))
###     ("_Numeral" ("_constify" ("_position" 2)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>num_inner_nodes"
###     ("\<^const>HOL.eq"
###       ("\<^const>Com.cmd.LAss" ("_position" V) ("_position" e))
###       ("_Numeral" ("_constify" ("_position" 2))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 48 of "$AFP/Slicing/While/Com.thy") produces 5 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>num_inner_nodes"
###       ("\<^const>Com.cmd.Seq" ("_position" c\<^sub>1)
###         ("_position" c\<^sub>2)))
###     ("\<^const>Groups.plus_class.plus"
###       ("\<^fixed>num_inner_nodes" ("_position" c\<^sub>1))
###       ("\<^fixed>num_inner_nodes" ("_position" c\<^sub>2)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>num_inner_nodes"
###     ("\<^const>HOL.eq"
###       ("\<^const>Com.cmd.Seq" ("_position" c\<^sub>1)
###         ("_position" c\<^sub>2))
###       ("\<^const>Groups.plus_class.plus"
###         ("\<^fixed>num_inner_nodes" ("_position" c\<^sub>1))
###         ("\<^fixed>num_inner_nodes" ("_position" c\<^sub>2))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Groups.plus_class.plus"
###     ("\<^fixed>num_inner_nodes"
###       ("\<^const>HOL.eq"
###         ("\<^const>Com.cmd.Seq" ("_position" c\<^sub>1)
###           ("_position" c\<^sub>2))
###         ("\<^fixed>num_inner_nodes" ("_position" c\<^sub>1))))
###     ("\<^fixed>num_inner_nodes" ("_position" c\<^sub>2))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>num_inner_nodes"
###       ("\<^const>Com.cmd.Seq" ("_position" c\<^sub>1)
###         ("_position" c\<^sub>2)))
###     ("\<^fixed>num_inner_nodes"
###       ("\<^const>Groups.plus_class.plus" ("_position" c\<^sub>1)
###         ("\<^fixed>num_inner_nodes" ("_position" c\<^sub>2))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>num_inner_nodes"
###     ("\<^const>HOL.eq"
###       ("\<^const>Com.cmd.Seq" ("_position" c\<^sub>1)
###         ("_position" c\<^sub>2))
###       ("\<^fixed>num_inner_nodes"
###         ("\<^const>Groups.plus_class.plus" ("_position" c\<^sub>1)
###           ("\<^fixed>num_inner_nodes" ("_position" c\<^sub>2)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 49 of "$AFP/Slicing/While/Com.thy") produces 14 parse trees (10 displayed):
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>num_inner_nodes"
###       ("\<^const>Com.cmd.Cond" ("_position" b) ("_position" c\<^sub>1)
###         ("_position" c\<^sub>2)))
###     ("\<^const>Groups.plus_class.plus"
###       ("\<^const>Groups.plus_class.plus"
###         ("\<^fixed>num_inner_nodes" ("_position" c\<^sub>1))
###         ("\<^fixed>num_inner_nodes" ("_position" c\<^sub>2)))
###       ("\<^const>Groups.one_class.one"))))
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>num_inner_nodes"
###     ("\<^const>HOL.eq"
###       ("\<^const>Com.cmd.Cond" ("_position" b) ("_position" c\<^sub>1)
###         ("_position" c\<^sub>2))
###       ("\<^const>Groups.plus_class.plus"
###         ("\<^const>Groups.plus_class.plus"
###           ("\<^fixed>num_inner_nodes" ("_position" c\<^sub>1))
###           ("\<^fixed>num_inner_nodes" ("_position" c\<^sub>2)))
###         ("\<^const>Groups.one_class.one")))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Groups.plus_class.plus"
###     ("\<^fixed>num_inner_nodes"
###       ("\<^const>HOL.eq"
###         ("\<^const>Com.cmd.Cond" ("_position" b) ("_position" c\<^sub>1)
###           ("_position" c\<^sub>2))
###         ("\<^const>Groups.plus_class.plus"
###           ("\<^fixed>num_inner_nodes" ("_position" c\<^sub>1))
###           ("\<^fixed>num_inner_nodes" ("_position" c\<^sub>2)))))
###     ("\<^const>Groups.one_class.one")))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Groups.plus_class.plus"
###     ("\<^const>Groups.plus_class.plus"
###       ("\<^fixed>num_inner_nodes"
###         ("\<^const>HOL.eq"
###           ("\<^const>Com.cmd.Cond" ("_position" b) ("_position" c\<^sub>1)
###             ("_position" c\<^sub>2))
###           ("\<^fixed>num_inner_nodes" ("_position" c\<^sub>1))))
###       ("\<^fixed>num_inner_nodes" ("_position" c\<^sub>2)))
###     ("\<^const>Groups.one_class.one")))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>num_inner_nodes"
###       ("\<^const>Com.cmd.Cond" ("_position" b) ("_position" c\<^sub>1)
###         ("_position" c\<^sub>2)))
###     ("\<^fixed>num_inner_nodes"
###       ("\<^const>Groups.plus_class.plus"
###         ("\<^const>Groups.plus_class.plus" ("_position" c\<^sub>1)
###           ("\<^fixed>num_inner_nodes" ("_position" c\<^sub>2)))
###         ("\<^const>Groups.one_class.one")))))
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>num_inner_nodes"
###     ("\<^const>HOL.eq"
###       ("\<^const>Com.cmd.Cond" ("_position" b) ("_position" c\<^sub>1)
###         ("_position" c\<^sub>2))
###       ("\<^fixed>num_inner_nodes"
###         ("\<^const>Groups.plus_class.plus"
###           ("\<^const>Groups.plus_class.plus" ("_position" c\<^sub>1)
###             ("\<^fixed>num_inner_nodes" ("_position" c\<^sub>2)))
###           ("\<^const>Groups.one_class.one"))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>num_inner_nodes"
###       ("\<^const>Com.cmd.Cond" ("_position" b) ("_position" c\<^sub>1)
###         ("_position" c\<^sub>2)))
###     ("\<^const>Groups.plus_class.plus"
###       ("\<^fixed>num_inner_nodes"
###         ("\<^const>Groups.plus_class.plus" ("_position" c\<^sub>1)
###           ("\<^fixed>num_inner_nodes" ("_position" c\<^sub>2))))
###       ("\<^const>Groups.one_class.one"))))
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>num_inner_nodes"
###     ("\<^const>HOL.eq"
###       ("\<^const>Com.cmd.Cond" ("_position" b) ("_position" c\<^sub>1)
###         ("_position" c\<^sub>2))
###       ("\<^const>Groups.plus_class.plus"
###         ("\<^fixed>num_inner_nodes"
###           ("\<^const>Groups.plus_class.plus" ("_position" c\<^sub>1)
###             ("\<^fixed>num_inner_nodes" ("_position" c\<^sub>2))))
###         ("\<^const>Groups.one_class.one")))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Groups.plus_class.plus"
###     ("\<^fixed>num_inner_nodes"
###       ("\<^const>HOL.eq"
###         ("\<^const>Com.cmd.Cond" ("_position" b) ("_position" c\<^sub>1)
###           ("_position" c\<^sub>2))
###         ("\<^fixed>num_inner_nodes"
###           ("\<^const>Groups.plus_class.plus" ("_position" c\<^sub>1)
###             ("\<^fixed>num_inner_nodes" ("_position" c\<^sub>2))))))
###     ("\<^const>Groups.one_class.one")))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>num_inner_nodes"
###       ("\<^const>Com.cmd.Cond" ("_position" b) ("_position" c\<^sub>1)
###         ("_position" c\<^sub>2)))
###     ("\<^const>Groups.plus_class.plus"
###       ("\<^fixed>num_inner_nodes" ("_position" c\<^sub>1))
###       ("\<^fixed>num_inner_nodes"
###         ("\<^const>Groups.plus_class.plus" ("_position" c\<^sub>2)
###           ("\<^const>Groups.one_class.one"))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 50 of "$AFP/Slicing/While/Com.thy") produces 5 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>num_inner_nodes"
###       ("\<^const>Com.cmd.While" ("_position" b) ("_position" c)))
###     ("\<^const>Groups.plus_class.plus"
###       ("\<^fixed>num_inner_nodes" ("_position" c))
###       ("_Numeral" ("_constify" ("_position" 2))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>num_inner_nodes"
###     ("\<^const>HOL.eq"
###       ("\<^const>Com.cmd.While" ("_position" b) ("_position" c))
###       ("\<^const>Groups.plus_class.plus"
###         ("\<^fixed>num_inner_nodes" ("_position" c))
###         ("_Numeral" ("_constify" ("_position" 2)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Groups.plus_class.plus"
###     ("\<^fixed>num_inner_nodes"
###       ("\<^const>HOL.eq"
###         ("\<^const>Com.cmd.While" ("_position" b) ("_position" c))
###         ("\<^fixed>num_inner_nodes" ("_position" c))))
###     ("_Numeral" ("_constify" ("_position" 2)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>num_inner_nodes"
###       ("\<^const>Com.cmd.While" ("_position" b) ("_position" c)))
###     ("\<^fixed>num_inner_nodes"
###       ("\<^const>Groups.plus_class.plus" ("_position" c)
###         ("_Numeral" ("_constify" ("_position" 2)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>num_inner_nodes"
###     ("\<^const>HOL.eq"
###       ("\<^const>Com.cmd.While" ("_position" b) ("_position" c))
###       ("\<^fixed>num_inner_nodes"
###         ("\<^const>Groups.plus_class.plus" ("_position" c)
###           ("_Numeral" ("_constify" ("_position" 2))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 19 of "$AFP/Slicing/StaticIntra/PDG.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>control_dependence" ("_position" n)
###     ("\<^const>Pure.imp" ("\<^const>HOL.Trueprop" ("_position" n'))
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.not_equal" ("_position" n') ("\<^fixed>Exit"))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>control_dependence" ("_position" n) ("_position" n')))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.not_equal" ("_position" n') ("\<^fixed>Exit"))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.not_equal"
###     ("\<^fixed>control_dependence" ("_position" n)
###       ("\<^const>Pure.imp" ("\<^const>HOL.Trueprop" ("_position" n'))
###         ("\<^const>HOL.Trueprop" ("_position" n'))))
###     ("\<^fixed>Exit")))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 21 of "$AFP/Slicing/StaticIntra/PDG.thy") produces 10 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.not_equal"
###     ("\<^fixed>control_dependence" ("_position" n)
###       ("\<^const>Pure.imp" ("\<^const>HOL.Trueprop" ("_position" n'))
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.Ex_binder" ("_position" as)
###             ("\<^const>HOL.conj"
###               ("_applC" ("_position" CFG.path)
###                 ("_cargs" ("_position" sourcenode)
###                   ("_cargs" ("_position" targetnode)
###                     ("_cargs" ("_position" valid_edge)
###                       ("_cargs" ("_position" n)
###                         ("_cargs" ("_position" as) ("_position" n')))))))
###               ("_position" as))))))
###     ("\<^const>List.list.Nil")))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.conj"
###     ("\<^fixed>control_dependence" ("_position" n)
###       ("\<^const>Pure.imp" ("\<^const>HOL.Trueprop" ("_position" n'))
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.Ex_binder" ("_position" as)
###             ("_applC" ("_position" CFG.path)
###               ("_cargs" ("_position" sourcenode)
###                 ("_cargs" ("_position" targetnode)
###                   ("_cargs" ("_position" valid_edge)
###                     ("_cargs" ("_position" n)
###                       ("_cargs" ("_position" as) ("_position" n')))))))))))
###     ("\<^const>HOL.not_equal" ("_position" as) ("\<^const>List.list.Nil"))))
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>control_dependence" ("_position" n)
###     ("\<^const>Pure.imp" ("\<^const>HOL.Trueprop" ("_position" n'))
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.Ex_binder" ("_position" as)
###           ("\<^const>HOL.conj"
###             ("_applC" ("_position" CFG.path)
###               ("_cargs" ("_position" sourcenode)
###                 ("_cargs" ("_position" targetnode)
###                   ("_cargs" ("_position" valid_edge)
###                     ("_cargs" ("_position" n)
###                       ("_cargs" ("_position" as) ("_position" n')))))))
###             ("\<^const>HOL.not_equal" ("_position" as)
###               ("\<^const>List.list.Nil"))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>control_dependence" ("_position" n) ("_position" n')))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.Ex_binder" ("_position" as)
###       ("\<^const>HOL.conj"
###         ("_applC" ("_position" CFG.path)
###           ("_cargs" ("_position" sourcenode)
###             ("_cargs" ("_position" targetnode)
###               ("_cargs" ("_position" valid_edge)
###                 ("_cargs" ("_position" n)
###                   ("_cargs" ("_position" as) ("_position" n')))))))
###         ("\<^const>HOL.not_equal" ("_position" as)
###           ("\<^const>List.list.Nil"))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.conj"
###     ("_applC"
###       ("\<^fixed>control_dependence" ("_position" n)
###         ("\<^const>Pure.imp" ("\<^const>HOL.Trueprop" ("_position" n'))
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.Ex_binder" ("_position" as)
###               ("_position" CFG.path)))))
###       ("_cargs" ("_position" sourcenode)
###         ("_cargs" ("_position" targetnode)
###           ("_cargs" ("_position" valid_edge)
###             ("_cargs" ("_position" n)
###               ("_cargs" ("_position" as) ("_position" n')))))))
###     ("\<^const>HOL.not_equal" ("_position" as) ("\<^const>List.list.Nil"))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.conj"
###     ("_applC"
###       ("\<^fixed>control_dependence" ("_position" n)
###         ("\<^const>Pure.imp" ("\<^const>HOL.Trueprop" ("_position" n'))
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.Ex_binder" ("_position" as)
###               ("_applC" ("_position" CFG.path) ("_position" sourcenode))))))
###       ("_cargs" ("_position" targetnode)
###         ("_cargs" ("_position" valid_edge)
###           ("_cargs" ("_position" n)
###             ("_cargs" ("_position" as) ("_position" n'))))))
###     ("\<^const>HOL.not_equal" ("_position" as) ("\<^const>List.list.Nil"))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.conj"
###     ("_applC"
###       ("\<^fixed>control_dependence" ("_position" n)
###         ("\<^const>Pure.imp" ("\<^const>HOL.Trueprop" ("_position" n'))
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.Ex_binder" ("_position" as)
###               ("_applC" ("_position" CFG.path)
###                 ("_cargs" ("_position" sourcenode)
###                   ("_position" targetnode)))))))
###       ("_cargs" ("_position" valid_edge)
###         ("_cargs" ("_position" n)
###           ("_cargs" ("_position" as) ("_position" n')))))
###     ("\<^const>HOL.not_equal" ("_position" as) ("\<^const>List.list.Nil"))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.conj"
###     ("_applC"
###       ("\<^fixed>control_dependence" ("_position" n)
###         ("\<^const>Pure.imp" ("\<^const>HOL.Trueprop" ("_position" n'))
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.Ex_binder" ("_position" as)
###               ("_applC" ("_position" CFG.path)
###                 ("_cargs" ("_position" sourcenode)
###                   ("_cargs" ("_position" targetnode)
###                     ("_position" valid_edge))))))))
###       ("_cargs" ("_position" n)
###         ("_cargs" ("_position" as) ("_position" n'))))
###     ("\<^const>HOL.not_equal" ("_position" as) ("\<^const>List.list.Nil"))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.conj"
###     ("_applC"
###       ("\<^fixed>control_dependence" ("_position" n)
###         ("\<^const>Pure.imp" ("\<^const>HOL.Trueprop" ("_position" n'))
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.Ex_binder" ("_position" as)
###               ("_applC" ("_position" CFG.path)
###                 ("_cargs" ("_position" sourcenode)
###                   ("_cargs" ("_position" targetnode)
###                     ("_cargs" ("_position" valid_edge)
###                       ("_position" n)))))))))
###       ("_cargs" ("_position" as) ("_position" n')))
###     ("\<^const>HOL.not_equal" ("_position" as) ("\<^const>List.list.Nil"))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.conj"
###     ("_applC"
###       ("\<^fixed>control_dependence" ("_position" n)
###         ("\<^const>Pure.imp" ("\<^const>HOL.Trueprop" ("_position" n'))
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.Ex_binder" ("_position" as)
###               ("_applC" ("_position" CFG.path)
###                 ("_cargs" ("_position" sourcenode)
###                   ("_cargs" ("_position" targetnode)
###                     ("_cargs" ("_position" valid_edge)
###                       ("_cargs" ("_position" n) ("_position" as))))))))))
###       ("_position" n'))
###     ("\<^const>HOL.not_equal" ("_position" as) ("\<^const>List.list.Nil"))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
locale PDG
  fixes sourcenode :: "'edge => 'node"
    and targetnode :: "'edge => 'node"
    and kind :: "'edge => 'state edge_kind"
    and valid_edge :: "'edge => bool"
    and Entry :: "'node"  (\<open>'('_Entry'_')\<close>)
    and Def :: "'node => 'var set"
    and Use :: "'node => 'var set"
    and state_val :: "'state => 'var => 'val"
    and Exit :: "'node"  (\<open>'('_Exit'_')\<close>)
    and
    control_dependence :: "'node => 'node => bool"
      (\<open>_ controls _ \<close> [51, 0])
  assumes
    "PDG sourcenode targetnode kind valid_edge (_Entry_) Def Use state_val
      (_Exit_) control_dependence"
### Ambiguous input (line 35 of "$AFP/Slicing/StaticIntra/PDG.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>cdep_edge" ("_position" n)
###     ("\<^const>Pure.eq" ("_position" n')
###       ("_applC" ("_position" PDG_edge)
###         ("_cargs" ("_position" n)
###           ("_cargs" ("_position" None) ("_position" n')))))))
### ("\<^const>Pure.eq" ("\<^fixed>cdep_edge" ("_position" n) ("_position" n'))
###   ("_applC" ("_position" PDG_edge)
###     ("_cargs" ("_position" n)
###       ("_cargs" ("_position" None) ("_position" n')))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 36 of "$AFP/Slicing/StaticIntra/PDG.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>ddep_edge" ("_position" n) ("_position" V)
###     ("\<^const>Pure.eq" ("_position" n')
###       ("_applC" ("_position" PDG_edge)
###         ("_cargs" ("_position" n)
###           ("_cargs" ("_applC" ("_position" Some) ("_position" V))
###             ("_position" n')))))))
### ("\<^const>Pure.eq"
###   ("\<^fixed>ddep_edge" ("_position" n) ("_position" V) ("_position" n'))
###   ("_applC" ("_position" PDG_edge)
###     ("_cargs" ("_position" n)
###       ("_cargs" ("_applC" ("_position" Some) ("_position" V))
###         ("_position" n')))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 40 of "$AFP/Slicing/StaticIntra/PDG.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>control_dependence" ("_position" n)
###     ("\<^const>Pure.imp" ("\<^const>HOL.Trueprop" ("_position" n'))
###       ("\<^const>HOL.Trueprop"
###         ("\<^fixed>cdep_edge" ("_position" n) ("_position" n'))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>control_dependence" ("_position" n) ("_position" n')))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>cdep_edge" ("_position" n) ("_position" n'))))
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>cdep_edge"
###     ("\<^fixed>control_dependence" ("_position" n)
###       ("\<^const>Pure.imp" ("\<^const>HOL.Trueprop" ("_position" n'))
###         ("\<^const>HOL.Trueprop" ("_position" n))))
###     ("_position" n')))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 43 of "$AFP/Slicing/StaticIntra/PDG.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.data_dependence" ("_position" n) ("_position" V)
###     ("\<^const>Pure.imp" ("\<^const>HOL.Trueprop" ("_position" n'))
###       ("\<^const>HOL.Trueprop"
###         ("\<^fixed>ddep_edge" ("_position" n) ("_position" V)
###           ("_position" n'))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>local.data_dependence" ("_position" n) ("_position" V)
###       ("_position" n')))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>ddep_edge" ("_position" n) ("_position" V)
###       ("_position" n'))))
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>ddep_edge"
###     ("\<^const>local.data_dependence" ("_position" n) ("_position" V)
###       ("\<^const>Pure.imp" ("\<^const>HOL.Trueprop" ("_position" n'))
###         ("\<^const>HOL.Trueprop" ("_position" n))))
###     ("_position" V) ("_position" n')))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Found termination order: "size <*mlex*> {}"
Proofs for inductive predicate(s) "PDG_edge"
### Ambiguous input (line 54 of "$AFP/Slicing/While/Com.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Orderings.ord_class.greater"
###     ("\<^const>Com.num_inner_nodes" ("_position" c))
###     ("\<^const>Groups.zero_class.zero")))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Com.num_inner_nodes"
###     ("\<^const>Orderings.ord_class.greater" ("_position" c)
###       ("\<^const>Groups.zero_class.zero"))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
  Proving monotonicity ...
### Ambiguous input (line 57 of "$AFP/Slicing/While/Com.thy") produces 2 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq" ("\<^const>Com.num_inner_nodes" ("_position" c))
###       ("\<^const>Groups.zero_class.zero")))
###   ("\<^const>HOL.Trueprop" ("_position" False)))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Com.num_inner_nodes"
###       ("\<^const>HOL.eq" ("_position" c)
###         ("\<^const>Groups.zero_class.zero"))))
###   ("\<^const>HOL.Trueprop" ("_position" False)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 25 of "$AFP/Slicing/Dynamic/DynPDG.thy") produces 3 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>dyn_control_dependence" ("_position" n) ("_position" n')
###       ("_position" as)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.not_equal"
###       ("\<^const>local.path" ("_position" n) ("_position" as)
###         ("\<^const>HOL.conj" ("_position" n') ("_position" as)))
###       ("\<^const>List.list.Nil"))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>dyn_control_dependence" ("_position" n) ("_position" n')
###       ("_position" as)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>local.path" ("_position" n) ("_position" as)
###       ("\<^const>HOL.conj" ("_position" n')
###         ("\<^const>HOL.not_equal" ("_position" as)
###           ("\<^const>List.list.Nil"))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>dyn_control_dependence" ("_position" n) ("_position" n')
###       ("_position" as)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.conj"
###       ("\<^const>local.path" ("_position" n) ("_position" as)
###         ("_position" n'))
###       ("\<^const>HOL.not_equal" ("_position" as)
###         ("\<^const>List.list.Nil")))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Proofs for inductive predicate(s) "PDG_path"
  Proving monotonicity ...
locale DynPDG
  fixes sourcenode :: "'edge => 'node"
    and targetnode :: "'edge => 'node"
    and kind :: "'edge => 'state edge_kind"
    and valid_edge :: "'edge => bool"
    and Entry :: "'node"  (\<open>'('_Entry'_')\<close>)
    and Def :: "'node => 'var set"
    and Use :: "'node => 'var set"
    and state_val :: "'state => 'var => 'val"
    and Exit :: "'node"  (\<open>'('_Exit'_')\<close>)
    and
    dyn_control_dependence :: "'node => 'node => 'edge list => bool"
      (\<open>_ controls _ via _\<close> [51, 0, 0])
  assumes
    "DynPDG sourcenode targetnode kind valid_edge (_Entry_) Def Use
      state_val (_Exit_) dyn_control_dependence"
### Ambiguous input (line 59 of "$AFP/Slicing/StaticIntra/PDG.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.cdep_edge" ("_position" n)
###     ("\<^const>Pure.imp" ("\<^const>HOL.Trueprop" ("_position" n'))
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>local.PDG_path" ("_position" n) ("_position" n'))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>local.cdep_edge" ("_position" n) ("_position" n')))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>local.PDG_path" ("_position" n) ("_position" n'))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.PDG_path"
###     ("\<^const>local.cdep_edge" ("_position" n)
###       ("\<^const>Pure.imp" ("\<^const>HOL.Trueprop" ("_position" n'))
###         ("\<^const>HOL.Trueprop" ("_position" n))))
###     ("_position" n')))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 64 of "$AFP/Slicing/StaticIntra/PDG.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.ddep_edge" ("_position" n) ("_position" V)
###     ("\<^const>Pure.imp" ("\<^const>HOL.Trueprop" ("_position" n'))
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>local.PDG_path" ("_position" n) ("_position" n'))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>local.ddep_edge" ("_position" n) ("_position" V)
###       ("_position" n')))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>local.PDG_path" ("_position" n) ("_position" n'))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.PDG_path"
###     ("\<^const>local.ddep_edge" ("_position" n) ("_position" V)
###       ("\<^const>Pure.imp" ("\<^const>HOL.Trueprop" ("_position" n'))
###         ("\<^const>HOL.Trueprop" ("_position" n))))
###     ("_position" n')))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 37 of "$AFP/Slicing/Dynamic/DynPDG.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>cdep_edge" ("_position" n) ("_position" as)
###     ("\<^const>Pure.eq" ("_position" n')
###       ("_applC" ("_position" DynPDG_edge)
###         ("_cargs" ("_position" n)
###           ("_cargs" ("_position" None)
###             ("_cargs" ("_position" as) ("_position" n'))))))))
### ("\<^const>Pure.eq"
###   ("\<^fixed>cdep_edge" ("_position" n) ("_position" as) ("_position" n'))
###   ("_applC" ("_position" DynPDG_edge)
###     ("_cargs" ("_position" n)
###       ("_cargs" ("_position" None)
###         ("_cargs" ("_position" as) ("_position" n'))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 38 of "$AFP/Slicing/Dynamic/DynPDG.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>ddep_edge" ("_position" n) ("_position" V) ("_position" as)
###     ("\<^const>Pure.eq" ("_position" n')
###       ("_applC" ("_position" DynPDG_edge)
###         ("_cargs" ("_position" n)
###           ("_cargs" ("_applC" ("_position" Some) ("_position" V))
###             ("_cargs" ("_position" as) ("_position" n'))))))))
### ("\<^const>Pure.eq"
###   ("\<^fixed>ddep_edge" ("_position" n) ("_position" V) ("_position" as)
###     ("_position" n'))
###   ("_applC" ("_position" DynPDG_edge)
###     ("_cargs" ("_position" n)
###       ("_cargs" ("_applC" ("_position" Some) ("_position" V))
###         ("_cargs" ("_position" as) ("_position" n'))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Proofs for inductive predicate(s) "DynPDG_edge"
### Ambiguous input (line 146 of "$AFP/Slicing/StaticIntra/PDG.thy") produces 4 parse trees:
### ("\<^const>Pure.eq" ("_applC" ("_position" PDG_BS) ("_position" S))
###   ("_Coll" ("_position" n')
###     ("\<^const>HOL.Ex_binder" ("_position" n)
###       ("\<^const>HOL.conj"
###         ("\<^const>local.PDG_path" ("_position" n')
###           ("\<^const>HOL.conj" ("_position" n)
###             ("\<^const>Set.member" ("_position" n) ("_position" S))))
###         ("_applC" ("_position" valid_node) ("_position" n))))))
### ("\<^const>Pure.eq" ("_applC" ("_position" PDG_BS) ("_position" S))
###   ("_Coll" ("_position" n')
###     ("\<^const>HOL.Ex_binder" ("_position" n)
###       ("\<^const>HOL.conj"
###         ("\<^const>local.PDG_path" ("_position" n') ("_position" n))
###         ("\<^const>HOL.conj"
###           ("\<^const>Set.member" ("_position" n) ("_position" S))
###           ("_applC" ("_position" valid_node) ("_position" n)))))))
### ("\<^const>Pure.eq" ("_applC" ("_position" PDG_BS) ("_position" S))
###   ("_Coll" ("_position" n')
###     ("\<^const>HOL.Ex_binder" ("_position" n)
###       ("\<^const>local.PDG_path" ("_position" n')
###         ("\<^const>HOL.conj" ("_position" n)
###           ("\<^const>HOL.conj"
###             ("\<^const>Set.member" ("_position" n) ("_position" S))
###             ("_applC" ("_position" valid_node) ("_position" n))))))))
### ("\<^const>Pure.eq" ("_applC" ("_position" PDG_BS) ("_position" S))
###   ("_Coll" ("_position" n')
###     ("\<^const>HOL.Ex_binder" ("_position" n)
###       ("\<^const>HOL.conj"
###         ("\<^const>Set.member"
###           ("\<^const>local.PDG_path" ("_position" n')
###             ("\<^const>HOL.conj" ("_position" n) ("_position" n)))
###           ("_position" S))
###         ("_applC" ("_position" valid_node) ("_position" n))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
  Proving monotonicity ...
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
### theory "Draft.Com"
### 2.426s elapsed time, 9.447s cpu time, 1.200s GC time
Loading theory "Draft.Observable" (required by "Draft.DynamicControlDependencesMoreTemplates" via "Draft.DynamicControlDependences" via "Draft.AdditionalLemmas" via "Draft.WellFormed" via "Draft.CDepInstantiations" via "Draft.Slice")
Found termination order: "size <*mlex*> {}"
Proofs for inductive predicate(s) "DynPDG_path"
  Proving monotonicity ...
locale CFG
  fixes sourcenode :: "'edge => 'node"
    and targetnode :: "'edge => 'node"
    and kind :: "'edge => 'state edge_kind"
    and valid_edge :: "'edge => bool"
    and Entry :: "'node"  (\<open>'('_Entry'_')\<close>)
  assumes "CFG sourcenode targetnode valid_edge (_Entry_)"
Proofs for inductive predicate(s) "obsp"
locale StandardControlDependencePDG
  fixes sourcenode :: "'edge => 'node"
    and targetnode :: "'edge => 'node"
    and kind :: "'edge => 'state edge_kind"
    and valid_edge :: "'edge => bool"
    and Entry :: "'node"  (\<open>'('_Entry'_')\<close>)
    and Def :: "'node => 'var set"
    and Use :: "'node => 'var set"
    and state_val :: "'state => 'var => 'val"
    and Exit :: "'node"  (\<open>'('_Exit'_')\<close>)
  assumes
    "StandardControlDependencePDG sourcenode targetnode kind valid_edge
      (_Entry_) Def Use state_val (_Exit_)"
### Ambiguous input (line 61 of "$AFP/Slicing/Dynamic/DynPDG.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.DynPDG_path" ("_position" n) ("\<^const>List.list.Nil")
###     ("\<^const>Pure.imp" ("\<^const>HOL.Trueprop" ("_position" n'))
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_position" n) ("_position" n'))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>local.DynPDG_path" ("_position" n) ("\<^const>List.list.Nil")
###       ("_position" n')))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq" ("_position" n) ("_position" n'))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>local.DynPDG_path" ("_position" n) ("\<^const>List.list.Nil")
###       ("\<^const>Pure.imp" ("\<^const>HOL.Trueprop" ("_position" n'))
###         ("\<^const>HOL.Trueprop" ("_position" n))))
###     ("_position" n')))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
  Proving monotonicity ...
### Ambiguous input (line 68 of "$AFP/Slicing/Dynamic/DynPDG.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.cdep_edge" ("_position" n) ("_position" as)
###     ("\<^const>Pure.imp" ("\<^const>HOL.Trueprop" ("_position" n'))
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>local.DynPDG_path" ("_position" n) ("_position" as)
###           ("_position" n'))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>local.cdep_edge" ("_position" n) ("_position" as)
###       ("_position" n')))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>local.DynPDG_path" ("_position" n) ("_position" as)
###       ("_position" n'))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.DynPDG_path"
###     ("\<^const>local.cdep_edge" ("_position" n) ("_position" as)
###       ("\<^const>Pure.imp" ("\<^const>HOL.Trueprop" ("_position" n'))
###         ("\<^const>HOL.Trueprop" ("_position" n))))
###     ("_position" as) ("_position" n')))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 74 of "$AFP/Slicing/Dynamic/DynPDG.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.ddep_edge" ("_position" n) ("_position" V)
###     ("_position" as)
###     ("\<^const>Pure.imp" ("\<^const>HOL.Trueprop" ("_position" n'))
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>local.DynPDG_path" ("_position" n) ("_position" as)
###           ("_position" n'))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>local.ddep_edge" ("_position" n) ("_position" V)
###       ("_position" as) ("_position" n')))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>local.DynPDG_path" ("_position" n) ("_position" as)
###       ("_position" n'))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.DynPDG_path"
###     ("\<^const>local.ddep_edge" ("_position" n) ("_position" V)
###       ("_position" as)
###       ("\<^const>Pure.imp" ("\<^const>HOL.Trueprop" ("_position" n'))
###         ("\<^const>HOL.Trueprop" ("_position" n))))
###     ("_position" as) ("_position" n')))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 130 of "$AFP/Slicing/Dynamic/DynPDG.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.DynPDG_path" ("_position" n) ("_position" as)
###     ("\<^const>Pure.imp" ("\<^const>HOL.Trueprop" ("_position" n'))
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>local.path" ("_position" n) ("_position" as)
###           ("_position" n'))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>local.DynPDG_path" ("_position" n) ("_position" as)
###       ("_position" n')))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>local.path" ("_position" n) ("_position" as)
###       ("_position" n'))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.path"
###     ("\<^const>local.DynPDG_path" ("_position" n) ("_position" as)
###       ("\<^const>Pure.imp" ("\<^const>HOL.Trueprop" ("_position" n'))
###         ("\<^const>HOL.Trueprop" ("_position" n))))
###     ("_position" as) ("_position" n')))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 147 of "$AFP/Slicing/Dynamic/DynPDG.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.disj"
###     ("\<^const>local.DynPDG_path" ("_position" n) ("_position" as)
###       ("\<^const>Pure.imp" ("\<^const>HOL.Trueprop" ("_position" n'))
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.disj"
###             ("\<^const>HOL.conj"
###               ("\<^const>HOL.eq" ("_position" as)
###                 ("\<^const>List.list.Nil"))
###               ("\<^const>HOL.eq" ("_position" n) ("_position" n')))
###             ("\<^const>HOL.Ex_binder"
###               ("_idts" ("_position" n'')
###                 ("_idts" ("_position" asx) ("_position" asx')))
###               ("\<^const>HOL.conj"
###                 ("\<^const>local.cdep_edge" ("_position" n)
###                   ("_position" asx) ("_position" n''))
###                 ("\<^const>HOL.conj"
###                   ("\<^const>local.DynPDG_path" ("_position" n'')
###                     ("_position" asx') ("_position" n'))
###                   ("\<^const>HOL.eq" ("_position" as)
###                     ("\<^const>List.append" ("_position" asx)
###                       ("_position" asx'))))))))))
###     ("\<^const>HOL.Ex_binder"
###       ("_idts" ("_position" n'')
###         ("_idts" ("_position" V)
###           ("_idts" ("_position" asx) ("_position" asx'))))
###       ("\<^const>HOL.conj"
###         ("\<^const>local.ddep_edge" ("_position" n) ("_position" V)
###           ("_position" asx) ("_position" n''))
###         ("\<^const>HOL.conj"
###           ("\<^const>local.DynPDG_path" ("_position" n'') ("_position" asx')
###             ("_position" n'))
###           ("\<^const>HOL.eq" ("_position" as)
###             ("\<^const>List.append" ("_position" asx)
###               ("_position" asx'))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.DynPDG_path" ("_position" n) ("_position" as)
###     ("\<^const>Pure.imp" ("\<^const>HOL.Trueprop" ("_position" n'))
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.disj"
###           ("\<^const>HOL.conj"
###             ("\<^const>HOL.eq" ("_position" as) ("\<^const>List.list.Nil"))
###             ("\<^const>HOL.eq" ("_position" n) ("_position" n')))
###           ("\<^const>HOL.disj"
###             ("\<^const>HOL.Ex_binder"
###               ("_idts" ("_position" n'')
###                 ("_idts" ("_position" asx) ("_position" asx')))
###               ("\<^const>HOL.conj"
###                 ("\<^const>local.cdep_edge" ("_position" n)
###                   ("_position" asx) ("_position" n''))
###                 ("\<^const>HOL.conj"
###                   ("\<^const>local.DynPDG_path" ("_position" n'')
###                     ("_position" asx') ("_position" n'))
###                   ("\<^const>HOL.eq" ("_position" as)
###                     ("\<^const>List.append" ("_position" asx)
###                       ("_position" asx'))))))
###             ("\<^const>HOL.Ex_binder"
###               ("_idts" ("_position" n'')
###                 ("_idts" ("_position" V)
###                   ("_idts" ("_position" asx) ("_position" asx'))))
###               ("\<^const>HOL.conj"
###                 ("\<^const>local.ddep_edge" ("_position" n) ("_position" V)
###                   ("_position" asx) ("_position" n''))
###                 ("\<^const>HOL.conj"
###                   ("\<^const>local.DynPDG_path" ("_position" n'')
###                     ("_position" asx') ("_position" n'))
###                   ("\<^const>HOL.eq" ("_position" as)
###                     ("\<^const>List.append" ("_position" asx)
###                       ("_position" asx'))))))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>local.DynPDG_path" ("_position" n) ("_position" as)
###       ("_position" n')))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.disj"
###       ("\<^const>HOL.conj"
###         ("\<^const>HOL.eq" ("_position" as) ("\<^const>List.list.Nil"))
###         ("\<^const>HOL.eq" ("_position" n) ("_position" n')))
###       ("\<^const>HOL.disj"
###         ("\<^const>HOL.Ex_binder"
###           ("_idts" ("_position" n'')
###             ("_idts" ("_position" asx) ("_position" asx')))
###           ("\<^const>HOL.conj"
###             ("\<^const>local.cdep_edge" ("_position" n) ("_position" asx)
###               ("_position" n''))
###             ("\<^const>HOL.conj"
###               ("\<^const>local.DynPDG_path" ("_position" n'')
###                 ("_position" asx') ("_position" n'))
###               ("\<^const>HOL.eq" ("_position" as)
###                 ("\<^const>List.append" ("_position" asx)
###                   ("_position" asx'))))))
###         ("\<^const>HOL.Ex_binder"
###           ("_idts" ("_position" n'')
###             ("_idts" ("_position" V)
###               ("_idts" ("_position" asx) ("_position" asx'))))
###           ("\<^const>HOL.conj"
###             ("\<^const>local.ddep_edge" ("_position" n) ("_position" V)
###               ("_position" asx) ("_position" n''))
###             ("\<^const>HOL.conj"
###               ("\<^const>local.DynPDG_path" ("_position" n'')
###                 ("_position" asx') ("_position" n'))
###               ("\<^const>HOL.eq" ("_position" as)
###                 ("\<^const>List.append" ("_position" asx)
###                   ("_position" asx'))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.disj"
###     ("\<^const>local.DynPDG_path" ("_position" n) ("_position" as)
###       ("\<^const>Pure.imp" ("\<^const>HOL.Trueprop" ("_position" n'))
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.conj"
###             ("\<^const>HOL.eq" ("_position" as) ("\<^const>List.list.Nil"))
###             ("\<^const>HOL.eq" ("_position" n) ("_position" n'))))))
###     ("\<^const>HOL.disj"
###       ("\<^const>HOL.Ex_binder"
###         ("_idts" ("_position" n'')
###           ("_idts" ("_position" asx) ("_position" asx')))
###         ("\<^const>HOL.conj"
###           ("\<^const>local.cdep_edge" ("_position" n) ("_position" asx)
###             ("_position" n''))
###           ("\<^const>HOL.conj"
###             ("\<^const>local.DynPDG_path" ("_position" n'')
###               ("_position" asx') ("_position" n'))
###             ("\<^const>HOL.eq" ("_position" as)
###               ("\<^const>List.append" ("_position" asx)
###                 ("_position" asx'))))))
###       ("\<^const>HOL.Ex_binder"
###         ("_idts" ("_position" n'')
###           ("_idts" ("_position" V)
###             ("_idts" ("_position" asx) ("_position" asx'))))
###         ("\<^const>HOL.conj"
###           ("\<^const>local.ddep_edge" ("_position" n) ("_position" V)
###             ("_position" asx) ("_position" n''))
###           ("\<^const>HOL.conj"
###             ("\<^const>local.DynPDG_path" ("_position" n'')
###               ("_position" asx') ("_position" n'))
###             ("\<^const>HOL.eq" ("_position" as)
###               ("\<^const>List.append" ("_position" asx)
###                 ("_position" asx')))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "Draft.Observable"
### 0.128s elapsed time, 0.506s cpu time, 0.043s GC time
Loading theory "Draft.SemanticsCFG" (required by "Draft.DynamicControlDependencesMoreTemplates" via "Draft.DynamicControlDependences" via "Draft.AdditionalLemmas" via "Draft.WellFormed" via "Draft.CDepInstantiations" via "Draft.Slice")
locale WeakControlDependencePDG
  fixes sourcenode :: "'edge => 'node"
    and targetnode :: "'edge => 'node"
    and kind :: "'edge => 'state edge_kind"
    and valid_edge :: "'edge => bool"
    and Entry :: "'node"  (\<open>'('_Entry'_')\<close>)
    and Def :: "'node => 'var set"
    and Use :: "'node => 'var set"
    and state_val :: "'state => 'var => 'val"
    and Exit :: "'node"  (\<open>'('_Exit'_')\<close>)
  assumes
    "WeakControlDependencePDG sourcenode targetnode kind valid_edge
      (_Entry_) Def Use state_val (_Exit_)"
### Ambiguous input (line 13 of "$AFP/Slicing/Basic/SemanticsCFG.thy") produces 6 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>identifies" ("_position" n) ("_position" c)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^fixed>sem" ("_position" c) ("_position" s) ("_position" c')
###           ("_position" s')))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.Ex_binder" ("_idts" ("_position" n') ("_position" as))
###       ("\<^fixed>identifies"
###         ("\<^const>local.path" ("_position" n) ("_position" as)
###           ("\<^const>HOL.conj" ("_position" n')
###             ("\<^const>HOL.conj"
###               ("\<^const>HOL.eq"
###                 ("_applC" ("_position" transfers)
###                   ("_cargs" ("_applC" ("_position" kinds) ("_position" as))
###                     ("_position" s)))
###                 ("_position" s'))
###               ("\<^const>HOL.conj"
###                 ("_applC" ("_position" preds)
###                   ("_cargs" ("_applC" ("_position" kinds) ("_position" as))
###                     ("_position" s)))
###                 ("_position" n')))))
###         ("_position" c')))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>identifies" ("_position" n) ("_position" c)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^fixed>sem" ("_position" c) ("_position" s) ("_position" c')
###           ("_position" s')))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.Ex_binder" ("_idts" ("_position" n') ("_position" as))
###       ("\<^const>HOL.conj"
###         ("\<^const>local.path" ("_position" n) ("_position" as)
###           ("\<^const>HOL.conj" ("_position" n')
###             ("\<^const>HOL.conj"
###               ("\<^const>HOL.eq"
###                 ("_applC" ("_position" transfers)
###                   ("_cargs" ("_applC" ("_position" kinds) ("_position" as))
###                     ("_position" s)))
###                 ("_position" s'))
###               ("_applC" ("_position" preds)
###                 ("_cargs" ("_applC" ("_position" kinds) ("_position" as))
###                   ("_position" s))))))
###         ("\<^fixed>identifies" ("_position" n') ("_position" c'))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>identifies" ("_position" n) ("_position" c)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^fixed>sem" ("_position" c) ("_position" s) ("_position" c')
###           ("_position" s')))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.Ex_binder" ("_idts" ("_position" n') ("_position" as))
###       ("\<^const>local.path" ("_position" n) ("_position" as)
###         ("\<^const>HOL.conj" ("_position" n')
###           ("\<^const>HOL.conj"
###             ("\<^const>HOL.eq"
###               ("_applC" ("_position" transfers)
###                 ("_cargs" ("_applC" ("_position" kinds) ("_position" as))
###                   ("_position" s)))
###               ("_position" s'))
###             ("\<^const>HOL.conj"
###               ("_applC" ("_position" preds)
###                 ("_cargs" ("_applC" ("_position" kinds) ("_position" as))
###                   ("_position" s)))
###               ("\<^fixed>identifies" ("_position" n')
###                 ("_position" c')))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>identifies" ("_position" n) ("_position" c)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^fixed>sem" ("_position" c) ("_position" s) ("_position" c')
###           ("_position" s')))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.Ex_binder" ("_idts" ("_position" n') ("_position" as))
###       ("\<^const>HOL.conj"
###         ("\<^const>local.path" ("_position" n) ("_position" as)
###           ("_position" n'))
###         ("\<^const>HOL.conj"
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" transfers)
###               ("_cargs" ("_applC" ("_position" kinds) ("_position" as))
###                 ("_position" s)))
###             ("_position" s'))
###           ("\<^const>HOL.conj"
###             ("_applC" ("_position" preds)
###               ("_cargs" ("_applC" ("_position" kinds) ("_position" as))
###                 ("_position" s)))
###             ("\<^fixed>identifies" ("_position" n') ("_position" c'))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>identifies" ("_position" n) ("_position" c)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^fixed>sem" ("_position" c) ("_position" s) ("_position" c')
###           ("_position" s')))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.Ex_binder" ("_idts" ("_position" n') ("_position" as))
###       ("\<^const>HOL.conj"
###         ("\<^const>local.path" ("_position" n) ("_position" as)
###           ("\<^const>HOL.conj" ("_position" n')
###             ("\<^const>HOL.eq"
###               ("_applC" ("_position" transfers)
###                 ("_cargs" ("_applC" ("_position" kinds) ("_position" as))
###                   ("_position" s)))
###               ("_position" s'))))
###         ("\<^const>HOL.conj"
###           ("_applC" ("_position" preds)
###             ("_cargs" ("_applC" ("_position" kinds) ("_position" as))
###               ("_position" s)))
###           ("\<^fixed>identifies" ("_position" n') ("_position" c')))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>identifies" ("_position" n) ("_position" c)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^fixed>sem" ("_position" c) ("_position" s) ("_position" c')
###           ("_position" s')))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.Ex_binder" ("_idts" ("_position" n') ("_position" as))
###       ("\<^const>HOL.conj"
###         ("\<^const>HOL.eq"
###           ("\<^const>local.path" ("_position" n) ("_position" as)
###             ("\<^const>HOL.conj" ("_position" n')
###               ("_applC" ("_position" transfers)
###                 ("_cargs" ("_applC" ("_position" kinds) ("_position" as))
###                   ("_position" s)))))
###           ("_position" s'))
###         ("\<^const>HOL.conj"
###           ("_applC" ("_position" preds)
###             ("_cargs" ("_applC" ("_position" kinds) ("_position" as))
###               ("_position" s)))
###           ("\<^fixed>identifies" ("_position" n') ("_position" c')))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
locale CFG_semantics_wf
  fixes sourcenode :: "'edge => 'node"
    and targetnode :: "'edge => 'node"
    and kind :: "'edge => 'state edge_kind"
    and valid_edge :: "'edge => bool"
    and Entry :: "'node"  (\<open>'('_Entry'_')\<close>)
    and
    sem :: "'com => 'state => 'com => 'state => bool"
      (\<open>((1\<langle>_,/_\<rangle>) \<Rightarrow>/ (1\<langle>_,/_\<rangle>))\<close>
        [0, 0, 0, 0] 81)
    and
    identifies :: "'node => 'com => bool"
      (\<open>_ \<triangleq> _\<close> [51, 0] 80)
  assumes
    "CFG_semantics_wf sourcenode targetnode kind valid_edge (_Entry_) sem
      identifies"
### theory "Draft.PDG"
### 0.750s elapsed time, 2.959s cpu time, 0.201s GC time
Loading theory "Draft.WeakOrderDependence" (required by "Draft.DynamicControlDependencesMoreTemplates" via "Draft.DynamicControlDependences" via "Draft.AdditionalLemmas" via "Draft.WellFormed" via "Draft.CDepInstantiations")
### theory "Draft.SemanticsCFG"
### 0.069s elapsed time, 0.280s cpu time, 0.000s GC time
Loading theory "Draft.Slice" (required by "Draft.DynamicControlDependencesMoreTemplates" via "Draft.DynamicControlDependences" via "Draft.AdditionalLemmas" via "Draft.WellFormed" via "Draft.CDepInstantiations")
### theory "HOL-Library.Tree"
### 2.298s elapsed time, 8.903s cpu time, 1.177s GC time
Loading theory "Draft.Labels" (required by "Draft.DynamicControlDependencesMoreTemplates" via "Draft.DynamicControlDependences" via "Draft.AdditionalLemmas" via "Draft.WellFormed")
locale DynStandardControlDependencePDG
  fixes sourcenode :: "'edge => 'node"
    and targetnode :: "'edge => 'node"
    and kind :: "'edge => 'state edge_kind"
    and valid_edge :: "'edge => bool"
    and Entry :: "'node"  (\<open>'('_Entry'_')\<close>)
    and Def :: "'node => 'var set"
    and Use :: "'node => 'var set"
    and state_val :: "'state => 'var => 'val"
    and Exit :: "'node"  (\<open>'('_Exit'_')\<close>)
  assumes
    "DynStandardControlDependencePDG sourcenode targetnode kind valid_edge
      (_Entry_) Def Use state_val (_Exit_)"
### Ambiguous input (line 27 of "$AFP/Slicing/While/Labels.thy") produces 2 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("_applC" ("_position" labels)
###       ("_cargs" ("_position" c\<^sub>2)
###         ("_cargs" ("_position" l) ("_position" c)))))
###   ("\<^const>HOL.Trueprop"
###     ("_applC" ("_position" labels)
###       ("_cargs"
###         ("\<^const>Com.cmd.Cond" ("_position" b) ("_position" c\<^sub>1)
###           ("_position" c\<^sub>2))
###         ("_cargs"
###           ("\<^const>Groups.plus_class.plus"
###             ("\<^const>Groups.plus_class.plus" ("_position" l)
###               ("\<^const>Com.num_inner_nodes" ("_position" c\<^sub>1)))
###             ("\<^const>Groups.one_class.one"))
###           ("_position" c))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("_applC" ("_position" labels)
###       ("_cargs" ("_position" c\<^sub>2)
###         ("_cargs" ("_position" l) ("_position" c)))))
###   ("\<^const>HOL.Trueprop"
###     ("_applC" ("_position" labels)
###       ("_cargs"
###         ("\<^const>Com.cmd.Cond" ("_position" b) ("_position" c\<^sub>1)
###           ("_position" c\<^sub>2))
###         ("_cargs"
###           ("\<^const>Groups.plus_class.plus" ("_position" l)
###             ("\<^const>Com.num_inner_nodes"
###               ("\<^const>Groups.plus_class.plus" ("_position" c\<^sub>1)
###                 ("\<^const>Groups.one_class.one"))))
###           ("_position" c))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Proofs for inductive predicate(s) "labels"
  Proving monotonicity ...
### Ambiguous input (line 11 of "$AFP/Slicing/StaticIntra/WeakOrderDependence.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>weak_order_dependence" ("_position" n) ("_position" n\<^sub>1)
###     ("\<^const>Pure.eq" ("_position" n\<^sub>2)
###       ("\<^const>HOL.conj"
###         ("\<^const>HOL.not_equal" ("_position" n\<^sub>1)
###           ("_position" n\<^sub>2))
###         ("\<^const>HOL.conj"
###           ("\<^const>HOL.Ex_binder" ("_position" as)
###             ("\<^const>HOL.conj"
###               ("\<^const>local.path" ("_position" n) ("_position" as)
###                 ("_position" n\<^sub>1))
###               ("\<^const>Set.not_member" ("_position" n\<^sub>2)
###                 ("_applC" ("_position" set)
###                   ("_applC" ("_position" sourcenodes) ("_position" as))))))
###           ("\<^const>HOL.conj"
###             ("\<^const>HOL.Ex_binder" ("_position" as)
###               ("\<^const>HOL.conj"
###                 ("\<^const>local.path" ("_position" n) ("_position" as)
###                   ("_position" n\<^sub>2))
###                 ("\<^const>Set.not_member" ("_position" n\<^sub>1)
###                   ("_applC" ("_position" set)
###                     ("_applC" ("_position" sourcenodes)
###                       ("_position" as))))))
###             ("\<^const>HOL.Ex_binder" ("_position" a)
###               ("\<^const>HOL.conj"
###                 ("_applC" ("_position" valid_edge) ("_position" a))
###                 ("\<^const>HOL.conj"
###                   ("\<^const>HOL.eq" ("_position" n)
###                     ("_applC" ("_position" sourcenode) ("_position" a)))
###                   ("\<^const>HOL.disj"
###                     ("\<^const>HOL.Ex_binder" ("_position" as)
###                       ("\<^const>HOL.conj"
###                         ("\<^const>local.path"
###                           ("_applC" ("_position" targetnode)
###                             ("_position" a))
###                           ("_position" as) ("_position" n\<^sub>1))
###                         ("\<^const>HOL.All_binder" ("_position" as')
###                           ("\<^const>HOL.implies"
###                             ("\<^const>local.path"
###                               ("_applC" ("_position" targetnode)
###                                 ("_position" a))
###                               ("_position" as') ("_position" n\<^sub>2))
###                             ("\<^const>Set.member" ("_position" n\<^sub>1)
###                               ("_applC" ("_position" set)
###                                 ("_applC" ("_position" sourcenodes)
###                                   ("_position" as'))))))))
###                     ("\<^const>HOL.Ex_binder" ("_position" as)
###                       ("\<^const>HOL.conj"
###                         ("\<^const>local.path"
###                           ("_applC" ("_position" targetnode)
###                             ("_position" a))
###                           ("_position" as) ("_position" n\<^sub>2))
###                         ("\<^const>HOL.All_binder" ("_position" as')
###                           ("\<^const>HOL.implies"
###                             ("\<^const>local.path"
###                               ("_applC" ("_position" targetnode)
###                                 ("_position" a))
###                               ("_position" as') ("_position" n\<^sub>1))
###                             ("\<^const>Set.member" ("_position" n\<^sub>2)
###                               ("_applC" ("_position" set)
###                                 ("_applC" ("_position" sourcenodes)
###                                   ("_position" as'))))))))))))))))))
### ("\<^const>Pure.eq"
###   ("\<^fixed>weak_order_dependence" ("_position" n) ("_position" n\<^sub>1)
###     ("_position" n\<^sub>2))
###   ("\<^const>HOL.conj"
###     ("\<^const>HOL.not_equal" ("_position" n\<^sub>1)
###       ("_position" n\<^sub>2))
###     ("\<^const>HOL.conj"
###       ("\<^const>HOL.Ex_binder" ("_position" as)
###         ("\<^const>HOL.conj"
###           ("\<^const>local.path" ("_position" n) ("_position" as)
###             ("_position" n\<^sub>1))
###           ("\<^const>Set.not_member" ("_position" n\<^sub>2)
###             ("_applC" ("_position" set)
###               ("_applC" ("_position" sourcenodes) ("_position" as))))))
###       ("\<^const>HOL.conj"
###         ("\<^const>HOL.Ex_binder" ("_position" as)
###           ("\<^const>HOL.conj"
###             ("\<^const>local.path" ("_position" n) ("_position" as)
###               ("_position" n\<^sub>2))
###             ("\<^const>Set.not_member" ("_position" n\<^sub>1)
###               ("_applC" ("_position" set)
###                 ("_applC" ("_position" sourcenodes) ("_position" as))))))
###         ("\<^const>HOL.Ex_binder" ("_position" a)
###           ("\<^const>HOL.conj"
###             ("_applC" ("_position" valid_edge) ("_position" a))
###             ("\<^const>HOL.conj"
###               ("\<^const>HOL.eq" ("_position" n)
###                 ("_applC" ("_position" sourcenode) ("_position" a)))
###               ("\<^const>HOL.disj"
###                 ("\<^const>HOL.Ex_binder" ("_position" as)
###                   ("\<^const>HOL.conj"
###                     ("\<^const>local.path"
###                       ("_applC" ("_position" targetnode) ("_position" a))
###                       ("_position" as) ("_position" n\<^sub>1))
###                     ("\<^const>HOL.All_binder" ("_position" as')
###                       ("\<^const>HOL.implies"
###                         ("\<^const>local.path"
###                           ("_applC" ("_position" targetnode)
###                             ("_position" a))
###                           ("_position" as') ("_position" n\<^sub>2))
###                         ("\<^const>Set.member" ("_position" n\<^sub>1)
###                           ("_applC" ("_position" set)
###                             ("_applC" ("_position" sourcenodes)
###                               ("_position" as'))))))))
###                 ("\<^const>HOL.Ex_binder" ("_position" as)
###                   ("\<^const>HOL.conj"
###                     ("\<^const>local.path"
###                       ("_applC" ("_position" targetnode) ("_position" a))
###                       ("_position" as) ("_position" n\<^sub>2))
###                     ("\<^const>HOL.All_binder" ("_position" as')
###                       ("\<^const>HOL.implies"
###                         ("\<^const>local.path"
###                           ("_applC" ("_position" targetnode)
###                             ("_position" a))
###                           ("_position" as') ("_position" n\<^sub>1))
###                         ("\<^const>Set.member" ("_position" n\<^sub>2)
###                           ("_applC" ("_position" set)
###                             ("_applC" ("_position" sourcenodes)
###                               ("_position" as'))))))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
locale DynWeakControlDependencePDG
  fixes sourcenode :: "'edge => 'node"
    and targetnode :: "'edge => 'node"
    and kind :: "'edge => 'state edge_kind"
    and valid_edge :: "'edge => bool"
    and Entry :: "'node"  (\<open>'('_Entry'_')\<close>)
    and Def :: "'node => 'var set"
    and Use :: "'node => 'var set"
    and state_val :: "'state => 'var => 'val"
    and Exit :: "'node"  (\<open>'('_Exit'_')\<close>)
  assumes
    "DynWeakControlDependencePDG sourcenode targetnode kind valid_edge
      (_Entry_) Def Use state_val (_Exit_)"
### theory "Draft.Labels"
### 0.091s elapsed time, 0.355s cpu time, 0.000s GC time
Loading theory "Draft.WCFG" (required by "Draft.DynamicControlDependencesMoreTemplates" via "Draft.DynamicControlDependences" via "Draft.AdditionalLemmas" via "Draft.WellFormed" via "Draft.Interpretation")
Proofs for inductive predicate(s) "wod_backward_slicep"
  Proving monotonicity ...
### theory "Draft.DynPDG"
### 0.802s elapsed time, 3.171s cpu time, 0.190s GC time
Loading theory "Draft.Templates" (required by "Draft.DynamicControlDependencesMoreTemplates" via "Draft.ExtrEqs")
datatype template_term
=
     t_empty
   | template_app of template_term * template_term
   | template_hole of int
   | template_var of int
datatype sign
= equals | greater_equals | greater_than | less_equals | less_than
datatype template
=
     template_bimplication of template * template
   | template_dunno
   | template_equation of template_term * template_term
   | template_implication of template list * template
   | template_inequation of sign * template_term * template_term
   | template_negation of template
   | template_predicate of template_term
constructor t_empty: template_term
constructor template_app: template_term * template_term -> template_term
constructor template_hole: int -> template_term
constructor template_var: int -> template_term
constructor equals: sign
constructor greater_equals: sign
constructor greater_than: sign
constructor less_equals: sign
constructor less_than: sign
constructor template_bimplication: template * template -> template
constructor template_dunno: template
constructor template_equation: template_term * template_term -> template
constructor template_implication: template list * template -> template
constructor template_inequation:
   sign * template_term * template_term -> template
constructor template_negation: template -> template
constructor template_predicate: template_term -> template
val vfs = fn: term -> (indexname * typ) list * (string * typ) list
val indexOf = fn: ''a list -> ''a -> int -> int
val has_eq = fn: term -> bool
val term2template = fn:
   (indexname * typ) list -> (string * typ) list -> term -> template_term
val lemma2predicate = fn: term -> term -> template
val makeTemplatewithContext = fn: term -> term -> template
val lemma2template = fn: term -> template
val thm2template = fn: thm -> template
val tterm2string = fn: template_term -> string
val template2string = fn: template -> string
val t = "height ?t <= size ?t": thm
val th =
   Const ("HOL.Trueprop", "bool => prop") $
     (Const ("Orderings.ord_class.less_eq", "nat => nat => bool") $
       (Const ("Tree.height_class.height", "?'a tree => nat") $
         Var (("t", 0), "?'a tree")) $
       (Const ("Nat.size_class.size", "?'a tree => nat") $
         Var (("t", 0), "?'a tree"))):
   term
### theory "Draft.Templates"
### 0.086s elapsed time, 0.338s cpu time, 0.065s GC time
Loading theory "HOL-Library.BigO" (required by "Draft.DynamicControlDependencesMoreTemplates" via "Draft.ExtrEqs")
### theory "Draft.WeakOrderDependence"
### 0.251s elapsed time, 0.975s cpu time, 0.119s GC time
locale BackwardSlice
  fixes sourcenode :: "'edge => 'node"
    and targetnode :: "'edge => 'node"
    and kind :: "'edge => 'state edge_kind"
    and valid_edge :: "'edge => bool"
    and Entry :: "'node"  (\<open>'('_Entry'_')\<close>)
    and Def :: "'node => 'var set"
    and Use :: "'node => 'var set"
    and state_val :: "'state => 'var => 'val"
    and backward_slice :: "'node set => 'node set"
  assumes
    "BackwardSlice sourcenode targetnode kind valid_edge (_Entry_) Def Use
      state_val backward_slice"
Proofs for inductive predicate(s) "silent_move"
  Proving monotonicity ...
Proofs for inductive predicate(s) "silent_moves"
  Proving monotonicity ...
### Ambiguous input (line 12 of "$AFP/Slicing/While/WCFG.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>label_incr" ("\<^const>WCFG.w_node.Node" ("_position" l))
###       ("_position" i))
###     ("\<^const>WCFG.w_node.Node"
###       ("\<^const>Groups.plus_class.plus" ("_position" l) ("_position" i)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>label_incr" ("\<^const>WCFG.w_node.Node" ("_position" l))
###     ("\<^const>HOL.eq" ("_position" i)
###       ("\<^const>WCFG.w_node.Node"
###         ("\<^const>Groups.plus_class.plus" ("_position" l)
###           ("_position" i))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 13 of "$AFP/Slicing/While/WCFG.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>label_incr" ("\<^const>WCFG.w_node.Entry") ("_position" i))
###     ("\<^const>WCFG.w_node.Entry")))
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>label_incr" ("\<^const>WCFG.w_node.Entry")
###     ("\<^const>HOL.eq" ("_position" i) ("\<^const>WCFG.w_node.Entry"))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 14 of "$AFP/Slicing/While/WCFG.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>label_incr" ("\<^const>WCFG.w_node.Exit") ("_position" i))
###     ("\<^const>WCFG.w_node.Exit")))
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>label_incr" ("\<^const>WCFG.w_node.Exit")
###     ("\<^const>HOL.eq" ("_position" i) ("\<^const>WCFG.w_node.Exit"))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Proofs for inductive predicate(s) "observable_move"
Found termination order: "{}"
  Proving monotonicity ...
### Ambiguous input (line 17 of "$AFP/Slicing/While/WCFG.thy") produces 2 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>WCFG.label_incr"
###       ("\<^const>HOL.eq" ("\<^const>WCFG.w_node.Exit") ("_position" n))
###       ("_position" i)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq" ("_position" n) ("\<^const>WCFG.w_node.Exit"))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq" ("\<^const>WCFG.w_node.Exit")
###       ("\<^const>WCFG.label_incr" ("_position" n) ("_position" i))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq" ("_position" n) ("\<^const>WCFG.w_node.Exit"))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 20 of "$AFP/Slicing/While/WCFG.thy") produces 2 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("\<^const>WCFG.label_incr" ("_position" n) ("_position" i))
###       ("\<^const>WCFG.w_node.Exit")))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq" ("_position" n) ("\<^const>WCFG.w_node.Exit"))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>WCFG.label_incr" ("_position" n)
###       ("\<^const>HOL.eq" ("_position" i) ("\<^const>WCFG.w_node.Exit"))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq" ("_position" n) ("\<^const>WCFG.w_node.Exit"))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 23 of "$AFP/Slicing/While/WCFG.thy") produces 2 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>WCFG.label_incr"
###       ("\<^const>HOL.eq" ("\<^const>WCFG.w_node.Entry") ("_position" n))
###       ("_position" i)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq" ("_position" n) ("\<^const>WCFG.w_node.Entry"))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq" ("\<^const>WCFG.w_node.Entry")
###       ("\<^const>WCFG.label_incr" ("_position" n) ("_position" i))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq" ("_position" n) ("\<^const>WCFG.w_node.Entry"))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 26 of "$AFP/Slicing/While/WCFG.thy") produces 2 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("\<^const>WCFG.label_incr" ("_position" n) ("_position" i))
###       ("\<^const>WCFG.w_node.Entry")))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq" ("_position" n) ("\<^const>WCFG.w_node.Entry"))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>WCFG.label_incr" ("_position" n)
###       ("\<^const>HOL.eq" ("_position" i) ("\<^const>WCFG.w_node.Entry"))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq" ("_position" n) ("\<^const>WCFG.w_node.Entry"))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 30 of "$AFP/Slicing/While/WCFG.thy") produces 5 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>WCFG.label_incr"
###       ("\<^const>HOL.eq"
###         ("\<^const>WCFG.label_incr" ("_position" n) ("_position" c))
###         ("_position" n'))
###       ("_position" c)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq" ("_position" n) ("_position" n'))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>WCFG.label_incr"
###       ("\<^const>WCFG.label_incr" ("_position" n)
###         ("\<^const>HOL.eq" ("_position" c) ("_position" n')))
###       ("_position" c)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq" ("_position" n) ("_position" n'))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>WCFG.label_incr" ("_position" n)
###       ("\<^const>WCFG.label_incr"
###         ("\<^const>HOL.eq" ("_position" c) ("_position" n'))
###         ("_position" c))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq" ("_position" n) ("_position" n'))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("\<^const>WCFG.label_incr" ("_position" n) ("_position" c))
###       ("\<^const>WCFG.label_incr" ("_position" n') ("_position" c))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq" ("_position" n) ("_position" n'))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>WCFG.label_incr" ("_position" n)
###       ("\<^const>HOL.eq" ("_position" c)
###         ("\<^const>WCFG.label_incr" ("_position" n') ("_position" c)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq" ("_position" n) ("_position" n'))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 33 of "$AFP/Slicing/While/WCFG.thy") produces 10 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>WCFG.label_incr"
###       ("\<^const>HOL.eq"
###         ("\<^const>WCFG.label_incr" ("_position" n) ("_position" i))
###         ("_position" m))
###       ("\<^const>Groups.plus_class.plus" ("_position" i) ("_position" j))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>WCFG.label_incr"
###       ("\<^const>HOL.eq" ("_position" n) ("_position" m)) ("_position" j))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>WCFG.label_incr"
###       ("\<^const>WCFG.label_incr" ("_position" n)
###         ("\<^const>HOL.eq" ("_position" i) ("_position" m)))
###       ("\<^const>Groups.plus_class.plus" ("_position" i) ("_position" j))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>WCFG.label_incr"
###       ("\<^const>HOL.eq" ("_position" n) ("_position" m)) ("_position" j))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>WCFG.label_incr" ("_position" n)
###       ("\<^const>WCFG.label_incr"
###         ("\<^const>HOL.eq" ("_position" i) ("_position" m))
###         ("\<^const>Groups.plus_class.plus" ("_position" i)
###           ("_position" j)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>WCFG.label_incr"
###       ("\<^const>HOL.eq" ("_position" n) ("_position" m)) ("_position" j))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("\<^const>WCFG.label_incr" ("_position" n) ("_position" i))
###       ("\<^const>WCFG.label_incr" ("_position" m)
###         ("\<^const>Groups.plus_class.plus" ("_position" i)
###           ("_position" j)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>WCFG.label_incr"
###       ("\<^const>HOL.eq" ("_position" n) ("_position" m)) ("_position" j))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>WCFG.label_incr" ("_position" n)
###       ("\<^const>HOL.eq" ("_position" i)
###         ("\<^const>WCFG.label_incr" ("_position" m)
###           ("\<^const>Groups.plus_class.plus" ("_position" i)
###             ("_position" j))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>WCFG.label_incr"
###       ("\<^const>HOL.eq" ("_position" n) ("_position" m)) ("_position" j))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>WCFG.label_incr"
###       ("\<^const>HOL.eq"
###         ("\<^const>WCFG.label_incr" ("_position" n) ("_position" i))
###         ("_position" m))
###       ("\<^const>Groups.plus_class.plus" ("_position" i) ("_position" j))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq" ("_position" n)
###       ("\<^const>WCFG.label_incr" ("_position" m) ("_position" j)))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>WCFG.label_incr"
###       ("\<^const>WCFG.label_incr" ("_position" n)
###         ("\<^const>HOL.eq" ("_position" i) ("_position" m)))
###       ("\<^const>Groups.plus_class.plus" ("_position" i) ("_position" j))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq" ("_position" n)
###       ("\<^const>WCFG.label_incr" ("_position" m) ("_position" j)))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>WCFG.label_incr" ("_position" n)
###       ("\<^const>WCFG.label_incr"
###         ("\<^const>HOL.eq" ("_position" i) ("_position" m))
###         ("\<^const>Groups.plus_class.plus" ("_position" i)
###           ("_position" j)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq" ("_position" n)
###       ("\<^const>WCFG.label_incr" ("_position" m) ("_position" j)))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("\<^const>WCFG.label_incr" ("_position" n) ("_position" i))
###       ("\<^const>WCFG.label_incr" ("_position" m)
###         ("\<^const>Groups.plus_class.plus" ("_position" i)
###           ("_position" j)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq" ("_position" n)
###       ("\<^const>WCFG.label_incr" ("_position" m) ("_position" j)))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>WCFG.label_incr" ("_position" n)
###       ("\<^const>HOL.eq" ("_position" i)
###         ("\<^const>WCFG.label_incr" ("_position" m)
###           ("\<^const>Groups.plus_class.plus" ("_position" i)
###             ("_position" j))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq" ("_position" n)
###       ("\<^const>WCFG.label_incr" ("_position" m) ("_position" j)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Proofs for inductive predicate(s) "observable_moves"
### Ambiguous input (line 36 of "$AFP/Slicing/While/WCFG.thy") produces 10 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>WCFG.label_incr"
###       ("\<^const>HOL.eq"
###         ("\<^const>WCFG.label_incr" ("_position" m)
###           ("\<^const>Groups.plus_class.plus" ("_position" j)
###             ("_position" i)))
###         ("_position" n))
###       ("_position" i)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("\<^const>WCFG.label_incr" ("_position" m) ("_position" j))
###       ("_position" n))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>WCFG.label_incr"
###       ("\<^const>WCFG.label_incr" ("_position" m)
###         ("\<^const>HOL.eq"
###           ("\<^const>Groups.plus_class.plus" ("_position" j)
###             ("_position" i))
###           ("_position" n)))
###       ("_position" i)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("\<^const>WCFG.label_incr" ("_position" m) ("_position" j))
###       ("_position" n))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>WCFG.label_incr" ("_position" m)
###       ("\<^const>WCFG.label_incr"
###         ("\<^const>HOL.eq"
###           ("\<^const>Groups.plus_class.plus" ("_position" j)
###             ("_position" i))
###           ("_position" n))
###         ("_position" i))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("\<^const>WCFG.label_incr" ("_position" m) ("_position" j))
###       ("_position" n))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("\<^const>WCFG.label_incr" ("_position" m)
###         ("\<^const>Groups.plus_class.plus" ("_position" j) ("_position" i)))
###       ("\<^const>WCFG.label_incr" ("_position" n) ("_position" i))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("\<^const>WCFG.label_incr" ("_position" m) ("_position" j))
###       ("_position" n))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>WCFG.label_incr" ("_position" m)
###       ("\<^const>HOL.eq"
###         ("\<^const>Groups.plus_class.plus" ("_position" j) ("_position" i))
###         ("\<^const>WCFG.label_incr" ("_position" n) ("_position" i)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("\<^const>WCFG.label_incr" ("_position" m) ("_position" j))
###       ("_position" n))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>WCFG.label_incr"
###       ("\<^const>HOL.eq"
###         ("\<^const>WCFG.label_incr" ("_position" m)
###           ("\<^const>Groups.plus_class.plus" ("_position" j)
###             ("_position" i)))
###         ("_position" n))
###       ("_position" i)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>WCFG.label_incr" ("_position" m)
###       ("\<^const>HOL.eq" ("_position" j) ("_position" n)))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>WCFG.label_incr"
###       ("\<^const>WCFG.label_incr" ("_position" m)
###         ("\<^const>HOL.eq"
###           ("\<^const>Groups.plus_class.plus" ("_position" j)
###             ("_position" i))
###           ("_position" n)))
###       ("_position" i)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>WCFG.label_incr" ("_position" m)
###       ("\<^const>HOL.eq" ("_position" j) ("_position" n)))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>WCFG.label_incr" ("_position" m)
###       ("\<^const>WCFG.label_incr"
###         ("\<^const>HOL.eq"
###           ("\<^const>Groups.plus_class.plus" ("_position" j)
###             ("_position" i))
###           ("_position" n))
###         ("_position" i))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>WCFG.label_incr" ("_position" m)
###       ("\<^const>HOL.eq" ("_position" j) ("_position" n)))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("\<^const>WCFG.label_incr" ("_position" m)
###         ("\<^const>Groups.plus_class.plus" ("_position" j) ("_position" i)))
###       ("\<^const>WCFG.label_incr" ("_position" n) ("_position" i))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>WCFG.label_incr" ("_position" m)
###       ("\<^const>HOL.eq" ("_position" j) ("_position" n)))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>WCFG.label_incr" ("_position" m)
###       ("\<^const>HOL.eq"
###         ("\<^const>Groups.plus_class.plus" ("_position" j) ("_position" i))
###         ("\<^const>WCFG.label_incr" ("_position" n) ("_position" i)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>WCFG.label_incr" ("_position" m)
###       ("\<^const>HOL.eq" ("_position" j) ("_position" n)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 40 of "$AFP/Slicing/While/WCFG.thy") produces 2 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>WCFG.label_incr"
###       ("\<^const>HOL.eq" ("\<^const>WCFG.w_node.Node" ("_position" l))
###         ("_position" n))
###       ("_position" i)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq" ("_position" n)
###       ("\<^const>WCFG.w_node.Node"
###         ("\<^const>Groups.minus_class.minus" ("_position" l)
###           ("_position" i))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq" ("\<^const>WCFG.w_node.Node" ("_position" l))
###       ("\<^const>WCFG.label_incr" ("_position" n) ("_position" i))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq" ("_position" n)
###       ("\<^const>WCFG.w_node.Node"
###         ("\<^const>Groups.minus_class.minus" ("_position" l)
###           ("_position" i))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 43 of "$AFP/Slicing/While/WCFG.thy") produces 2 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>WCFG.label_incr"
###       ("\<^const>HOL.eq" ("\<^const>WCFG.w_node.Node" ("_position" l))
###         ("_position" n))
###       ("_position" i)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Orderings.ord_class.greater_eq" ("_position" l)
###       ("_position" i))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq" ("\<^const>WCFG.w_node.Node" ("_position" l))
###       ("\<^const>WCFG.label_incr" ("_position" n) ("_position" i))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Orderings.ord_class.greater_eq" ("_position" l)
###       ("_position" i))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 47 of "$AFP/Slicing/While/WCFG.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq"
###         ("\<^const>WCFG.w_node.Node" ("\<^const>Groups.zero_class.zero"))
###         ("\<^const>WCFG.label_incr" ("_position" n) ("_position" i))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Orderings.ord_class.greater" ("_position" i)
###           ("\<^const>Groups.zero_class.zero")))))
###   ("\<^const>HOL.Trueprop" ("_position" False)))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>WCFG.label_incr"
###         ("\<^const>HOL.eq"
###           ("\<^const>WCFG.w_node.Node" ("\<^const>Groups.zero_class.zero"))
###           ("_position" n))
###         ("_position" i)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Orderings.ord_class.greater" ("_position" i)
###           ("\<^const>Groups.zero_class.zero")))))
###   ("\<^const>HOL.Trueprop" ("_position" False)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 51 of "$AFP/Slicing/While/WCFG.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>WCFG.label_incr" ("_position" n)
###         ("\<^const>HOL.eq" ("_position" i)
###           ("\<^const>WCFG.w_node.Node"
###             ("\<^const>Groups.zero_class.zero")))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Orderings.ord_class.greater" ("_position" i)
###           ("\<^const>Groups.zero_class.zero")))))
###   ("\<^const>HOL.Trueprop" ("_position" False)))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq"
###         ("\<^const>WCFG.label_incr" ("_position" n) ("_position" i))
###         ("\<^const>WCFG.w_node.Node" ("\<^const>Groups.zero_class.zero"))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Orderings.ord_class.greater" ("_position" i)
###           ("\<^const>Groups.zero_class.zero")))))
###   ("\<^const>HOL.Trueprop" ("_position" False)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
  Proving monotonicity ...
### Ambiguous input (line 93 of "$AFP/Slicing/While/WCFG.thy") produces 4 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>While_CFG" ("_position" c\<^sub>1) ("_position" n)
###         ("_position" et) ("_position" n')))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.not_equal" ("_position" n)
###           ("\<^const>WCFG.w_node.Entry")))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>WCFG.label_incr"
###       ("\<^fixed>While_CFG"
###         ("\<^const>Com.cmd.Cond" ("_position" b) ("_position" c\<^sub>1)
###           ("_position" c\<^sub>2))
###         ("\<^const>WCFG.label_incr" ("_position" n)
###           ("\<^const>Groups.one_class.one"))
###         ("_position" et) ("_position" n'))
###       ("\<^const>Groups.one_class.one"))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>While_CFG" ("_position" c\<^sub>1) ("_position" n)
###         ("_position" et) ("_position" n')))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.not_equal" ("_position" n)
###           ("\<^const>WCFG.w_node.Entry")))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>While_CFG"
###       ("\<^const>Com.cmd.Cond" ("_position" b) ("_position" c\<^sub>1)
###         ("_position" c\<^sub>2))
###       ("\<^const>WCFG.label_incr" ("_position" n)
###         ("\<^const>Groups.one_class.one"))
###       ("_position" et)
###       ("\<^const>WCFG.label_incr" ("_position" n')
###         ("\<^const>Groups.one_class.one")))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>While_CFG" ("_position" c\<^sub>1) ("_position" n)
###         ("_position" et) ("_position" n')))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.not_equal" ("_position" n)
###           ("\<^const>WCFG.w_node.Entry")))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Com.cmd.Cond" ("_position" b) ("_position" c\<^sub>1)
###       ("\<^fixed>While_CFG" ("_position" c\<^sub>2)
###         ("\<^const>WCFG.label_incr" ("_position" n)
###           ("\<^const>Groups.one_class.one"))
###         ("_position" et)
###         ("\<^const>WCFG.label_incr" ("_position" n')
###           ("\<^const>Groups.one_class.one"))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>While_CFG" ("_position" c\<^sub>1) ("_position" n)
###         ("_position" et) ("_position" n')))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.not_equal" ("_position" n)
###           ("\<^const>WCFG.w_node.Entry")))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>WCFG.label_incr"
###       ("\<^const>Com.cmd.Cond" ("_position" b) ("_position" c\<^sub>1)
###         ("\<^fixed>While_CFG" ("_position" c\<^sub>2)
###           ("\<^const>WCFG.label_incr" ("_position" n)
###             ("\<^const>Groups.one_class.one"))
###           ("_position" et) ("_position" n')))
###       ("\<^const>Groups.one_class.one"))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 72 of "$AFP/Slicing/While/WCFG.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>While_CFG"
###     ("\<^const>Com.cmd.LAss" ("_position" V) ("_position" e))
###     ("\<^const>WCFG.w_node.Node" ("\<^const>Groups.zero_class.zero"))
###     ("\<^const>BasicDefs.edge_kind.Update"
###       ("_lambda" ("_position" s)
###         ("_applC" ("_position" s)
###           ("\<^const>Com.cmd.LAss" ("_position" V)
###             ("_applC" ("_position" interpret)
###               ("_cargs" ("_position" e) ("_position" s)))))))
###     ("\<^const>WCFG.w_node.Node" ("\<^const>Groups.one_class.one"))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Com.cmd.LAss" ("_position" V)
###     ("\<^fixed>While_CFG" ("_position" e)
###       ("\<^const>WCFG.w_node.Node" ("\<^const>Groups.zero_class.zero"))
###       ("\<^const>BasicDefs.edge_kind.Update"
###         ("_lambda" ("_position" s)
###           ("_applC" ("_position" s)
###             ("\<^const>Com.cmd.LAss" ("_position" V)
###               ("_applC" ("_position" interpret)
###                 ("_cargs" ("_position" e) ("_position" s)))))))
###       ("\<^const>WCFG.w_node.Node" ("\<^const>Groups.one_class.one")))))
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>While_CFG"
###     ("\<^const>Com.cmd.LAss" ("_position" V) ("_position" e))
###     ("\<^const>WCFG.w_node.Node" ("\<^const>Groups.zero_class.zero"))
###     ("\<^const>BasicDefs.edge_kind.Update"
###       ("_lambda" ("_position" s)
###         ("_Update" ("_position" s)
###           ("_updbind" ("_position" V)
###             ("_applC" ("_position" interpret)
###               ("_cargs" ("_position" e) ("_position" s)))))))
###     ("\<^const>WCFG.w_node.Node" ("\<^const>Groups.one_class.one"))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Com.cmd.LAss" ("_position" V)
###     ("\<^fixed>While_CFG" ("_position" e)
###       ("\<^const>WCFG.w_node.Node" ("\<^const>Groups.zero_class.zero"))
###       ("\<^const>BasicDefs.edge_kind.Update"
###         ("_lambda" ("_position" s)
###           ("_Update" ("_position" s)
###             ("_updbind" ("_position" V)
###               ("_applC" ("_position" interpret)
###                 ("_cargs" ("_position" e) ("_position" s)))))))
###       ("\<^const>WCFG.w_node.Node" ("\<^const>Groups.one_class.one")))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 75 of "$AFP/Slicing/While/WCFG.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>While_CFG"
###     ("\<^const>Com.cmd.LAss" ("_position" V) ("_position" e))
###     ("\<^const>WCFG.w_node.Node" ("\<^const>Groups.one_class.one"))
###     ("\<^const>BasicDefs.edge_kind.Update" ("_position" id))
###     ("\<^const>WCFG.w_node.Exit")))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Com.cmd.LAss" ("_position" V)
###     ("\<^fixed>While_CFG" ("_position" e)
###       ("\<^const>WCFG.w_node.Node" ("\<^const>Groups.one_class.one"))
###       ("\<^const>BasicDefs.edge_kind.Update" ("_position" id))
###       ("\<^const>WCFG.w_node.Exit"))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 78 of "$AFP/Slicing/While/WCFG.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>While_CFG" ("_position" c\<^sub>1) ("_position" n)
###         ("_position" et) ("_position" n')))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.not_equal" ("_position" n')
###           ("\<^const>WCFG.w_node.Exit")))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>While_CFG"
###       ("\<^const>Com.cmd.Seq" ("_position" c\<^sub>1)
###         ("_position" c\<^sub>2))
###       ("_position" n) ("_position" et) ("_position" n'))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>While_CFG" ("_position" c\<^sub>1) ("_position" n)
###         ("_position" et) ("_position" n')))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.not_equal" ("_position" n')
###           ("\<^const>WCFG.w_node.Exit")))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Com.cmd.Seq" ("_position" c\<^sub>1)
###       ("\<^fixed>While_CFG" ("_position" c\<^sub>2) ("_position" n)
###         ("_position" et) ("_position" n')))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 81 of "$AFP/Slicing/While/WCFG.thy") produces 5 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>While_CFG" ("_position" c\<^sub>1) ("_position" n)
###         ("_position" et) ("\<^const>WCFG.w_node.Exit")))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.not_equal" ("_position" n)
###           ("\<^const>WCFG.w_node.Entry")))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>WCFG.label_incr"
###       ("\<^fixed>While_CFG"
###         ("\<^const>Com.cmd.Seq" ("_position" c\<^sub>1)
###           ("_position" c\<^sub>2))
###         ("_position" n) ("_position" et)
###         ("\<^const>WCFG.w_node.Node" ("\<^const>Groups.zero_class.zero")))
###       ("\<^const>Com.num_inner_nodes" ("_position" c\<^sub>1)))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>While_CFG" ("_position" c\<^sub>1) ("_position" n)
###         ("_position" et) ("\<^const>WCFG.w_node.Exit")))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.not_equal" ("_position" n)
###           ("\<^const>WCFG.w_node.Entry")))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>While_CFG"
###       ("\<^const>Com.cmd.Seq" ("_position" c\<^sub>1)
###         ("_position" c\<^sub>2))
###       ("_position" n) ("_position" et)
###       ("\<^const>WCFG.label_incr"
###         ("\<^const>WCFG.w_node.Node" ("\<^const>Groups.zero_class.zero"))
###         ("\<^const>Com.num_inner_nodes" ("_position" c\<^sub>1))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>While_CFG" ("_position" c\<^sub>1) ("_position" n)
###         ("_position" et) ("\<^const>WCFG.w_node.Exit")))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.not_equal" ("_position" n)
###           ("\<^const>WCFG.w_node.Entry")))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Com.cmd.Seq" ("_position" c\<^sub>1)
###       ("\<^fixed>While_CFG" ("_position" c\<^sub>2) ("_position" n)
###         ("_position" et)
###         ("\<^const>WCFG.label_incr"
###           ("\<^const>WCFG.w_node.Node" ("\<^const>Groups.zero_class.zero"))
###           ("\<^const>Com.num_inner_nodes" ("_position" c\<^sub>1)))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>While_CFG" ("_position" c\<^sub>1) ("_position" n)
###         ("_position" et) ("\<^const>WCFG.w_node.Exit")))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.not_equal" ("_position" n)
###           ("\<^const>WCFG.w_node.Entry")))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>WCFG.label_incr"
###       ("\<^const>Com.cmd.Seq" ("_position" c\<^sub>1)
###         ("\<^fixed>While_CFG" ("_position" c\<^sub>2) ("_position" n)
###           ("_position" et)
###           ("\<^const>WCFG.w_node.Node"
###             ("\<^const>Groups.zero_class.zero"))))
###       ("\<^const>Com.num_inner_nodes" ("_position" c\<^sub>1)))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>While_CFG" ("_position" c\<^sub>1) ("_position" n)
###         ("_position" et) ("\<^const>WCFG.w_node.Exit")))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.not_equal" ("_position" n)
###           ("\<^const>WCFG.w_node.Entry")))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Com.cmd.Seq" ("_position" c\<^sub>1)
###       ("\<^const>WCFG.label_incr"
###         ("\<^fixed>While_CFG" ("_position" c\<^sub>2) ("_position" n)
###           ("_position" et)
###           ("\<^const>WCFG.w_node.Node" ("\<^const>Groups.zero_class.zero")))
###         ("\<^const>Com.num_inner_nodes" ("_position" c\<^sub>1))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 96 of "$AFP/Slicing/While/WCFG.thy") produces 16 parse trees (10 displayed):
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>While_CFG" ("_position" c\<^sub>2) ("_position" n)
###         ("_position" et) ("_position" n')))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.not_equal" ("_position" n)
###           ("\<^const>WCFG.w_node.Entry")))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>WCFG.label_incr"
###       ("\<^fixed>While_CFG"
###         ("\<^const>Com.cmd.Cond" ("_position" b) ("_position" c\<^sub>1)
###           ("_position" c\<^sub>2))
###         ("\<^const>WCFG.label_incr" ("_position" n)
###           ("\<^const>Com.num_inner_nodes"
###             ("\<^const>Groups.plus_class.plus" ("_position" c\<^sub>1)
###               ("\<^const>Groups.one_class.one"))))
###         ("_position" et) ("_position" n'))
###       ("\<^const>Com.num_inner_nodes"
###         ("\<^const>Groups.plus_class.plus" ("_position" c\<^sub>1)
###           ("\<^const>Groups.one_class.one"))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>While_CFG" ("_position" c\<^sub>2) ("_position" n)
###         ("_position" et) ("_position" n')))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.not_equal" ("_position" n)
###           ("\<^const>WCFG.w_node.Entry")))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>While_CFG"
###       ("\<^const>Com.cmd.Cond" ("_position" b) ("_position" c\<^sub>1)
###         ("_position" c\<^sub>2))
###       ("\<^const>WCFG.label_incr" ("_position" n)
###         ("\<^const>Com.num_inner_nodes"
###           ("\<^const>Groups.plus_class.plus" ("_position" c\<^sub>1)
###             ("\<^const>Groups.one_class.one"))))
###       ("_position" et)
###       ("\<^const>WCFG.label_incr" ("_position" n')
###         ("\<^const>Com.num_inner_nodes"
###           ("\<^const>Groups.plus_class.plus" ("_position" c\<^sub>1)
###             ("\<^const>Groups.one_class.one")))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>While_CFG" ("_position" c\<^sub>2) ("_position" n)
###         ("_position" et) ("_position" n')))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.not_equal" ("_position" n)
###           ("\<^const>WCFG.w_node.Entry")))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Com.cmd.Cond" ("_position" b) ("_position" c\<^sub>1)
###       ("\<^fixed>While_CFG" ("_position" c\<^sub>2)
###         ("\<^const>WCFG.label_incr" ("_position" n)
###           ("\<^const>Com.num_inner_nodes"
###             ("\<^const>Groups.plus_class.plus" ("_position" c\<^sub>1)
###               ("\<^const>Groups.one_class.one"))))
###         ("_position" et)
###         ("\<^const>WCFG.label_incr" ("_position" n')
###           ("\<^const>Com.num_inner_nodes"
###             ("\<^const>Groups.plus_class.plus" ("_position" c\<^sub>1)
###               ("\<^const>Groups.one_class.one"))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>While_CFG" ("_position" c\<^sub>2) ("_position" n)
###         ("_position" et) ("_position" n')))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.not_equal" ("_position" n)
###           ("\<^const>WCFG.w_node.Entry")))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>While_CFG"
###       ("\<^const>Com.cmd.Cond" ("_position" b) ("_position" c\<^sub>1)
###         ("_position" c\<^sub>2))
###       ("\<^const>WCFG.label_incr" ("_position" n)
###         ("\<^const>Groups.plus_class.plus"
###           ("\<^const>Com.num_inner_nodes" ("_position" c\<^sub>1))
###           ("\<^const>Groups.one_class.one")))
###       ("_position" et)
###       ("\<^const>WCFG.label_incr" ("_position" n')
###         ("\<^const>Com.num_inner_nodes"
###           ("\<^const>Groups.plus_class.plus" ("_position" c\<^sub>1)
###             ("\<^const>Groups.one_class.one")))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>While_CFG" ("_position" c\<^sub>2) ("_position" n)
###         ("_position" et) ("_position" n')))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.not_equal" ("_position" n)
###           ("\<^const>WCFG.w_node.Entry")))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Com.cmd.Cond" ("_position" b) ("_position" c\<^sub>1)
###       ("\<^fixed>While_CFG" ("_position" c\<^sub>2)
###         ("\<^const>WCFG.label_incr" ("_position" n)
###           ("\<^const>Groups.plus_class.plus"
###             ("\<^const>Com.num_inner_nodes" ("_position" c\<^sub>1))
###             ("\<^const>Groups.one_class.one")))
###         ("_position" et)
###         ("\<^const>WCFG.label_incr" ("_position" n')
###           ("\<^const>Com.num_inner_nodes"
###             ("\<^const>Groups.plus_class.plus" ("_position" c\<^sub>1)
###               ("\<^const>Groups.one_class.one"))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>While_CFG" ("_position" c\<^sub>2) ("_position" n)
###         ("_position" et) ("_position" n')))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.not_equal" ("_position" n)
###           ("\<^const>WCFG.w_node.Entry")))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>WCFG.label_incr"
###       ("\<^const>Com.cmd.Cond" ("_position" b) ("_position" c\<^sub>1)
###         ("\<^fixed>While_CFG" ("_position" c\<^sub>2)
###           ("\<^const>WCFG.label_incr" ("_position" n)
###             ("\<^const>Com.num_inner_nodes"
###               ("\<^const>Groups.plus_class.plus" ("_position" c\<^sub>1)
###                 ("\<^const>Groups.one_class.one"))))
###           ("_position" et) ("_position" n')))
###       ("\<^const>Com.num_inner_nodes"
###         ("\<^const>Groups.plus_class.plus" ("_position" c\<^sub>1)
###           ("\<^const>Groups.one_class.one"))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>While_CFG" ("_position" c\<^sub>2) ("_position" n)
###         ("_position" et) ("_position" n')))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.not_equal" ("_position" n)
###           ("\<^const>WCFG.w_node.Entry")))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>WCFG.label_incr"
###       ("\<^fixed>While_CFG"
###         ("\<^const>Com.cmd.Cond" ("_position" b) ("_position" c\<^sub>1)
###           ("_position" c\<^sub>2))
###         ("\<^const>WCFG.label_incr" ("_position" n)
###           ("\<^const>Groups.plus_class.plus"
###             ("\<^const>Com.num_inner_nodes" ("_position" c\<^sub>1))
###             ("\<^const>Groups.one_class.one")))
###         ("_position" et) ("_position" n'))
###       ("\<^const>Com.num_inner_nodes"
###         ("\<^const>Groups.plus_class.plus" ("_position" c\<^sub>1)
###           ("\<^const>Groups.one_class.one"))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>While_CFG" ("_position" c\<^sub>2) ("_position" n)
###         ("_position" et) ("_position" n')))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.not_equal" ("_position" n)
###           ("\<^const>WCFG.w_node.Entry")))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>WCFG.label_incr"
###       ("\<^const>Com.cmd.Cond" ("_position" b) ("_position" c\<^sub>1)
###         ("\<^fixed>While_CFG" ("_position" c\<^sub>2)
###           ("\<^const>WCFG.label_incr" ("_position" n)
###             ("\<^const>Groups.plus_class.plus"
###               ("\<^const>Com.num_inner_nodes" ("_position" c\<^sub>1))
###               ("\<^const>Groups.one_class.one")))
###           ("_position" et) ("_position" n')))
###       ("\<^const>Com.num_inner_nodes"
###         ("\<^const>Groups.plus_class.plus" ("_position" c\<^sub>1)
###           ("\<^const>Groups.one_class.one"))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>While_CFG" ("_position" c\<^sub>2) ("_position" n)
###         ("_position" et) ("_position" n')))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.not_equal" ("_position" n)
###           ("\<^const>WCFG.w_node.Entry")))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>WCFG.label_incr"
###       ("\<^fixed>While_CFG"
###         ("\<^const>Com.cmd.Cond" ("_position" b) ("_position" c\<^sub>1)
###           ("_position" c\<^sub>2))
###         ("\<^const>WCFG.label_incr" ("_position" n)
###           ("\<^const>Com.num_inner_nodes"
###             ("\<^const>Groups.plus_class.plus" ("_position" c\<^sub>1)
###               ("\<^const>Groups.one_class.one"))))
###         ("_position" et) ("_position" n'))
###       ("\<^const>Groups.plus_class.plus"
###         ("\<^const>Com.num_inner_nodes" ("_position" c\<^sub>1))
###         ("\<^const>Groups.one_class.one")))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>While_CFG" ("_position" c\<^sub>2) ("_position" n)
###         ("_position" et) ("_position" n')))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.not_equal" ("_position" n)
###           ("\<^const>WCFG.w_node.Entry")))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>While_CFG"
###       ("\<^const>Com.cmd.Cond" ("_position" b) ("_position" c\<^sub>1)
###         ("_position" c\<^sub>2))
###       ("\<^const>WCFG.label_incr" ("_position" n)
###         ("\<^const>Com.num_inner_nodes"
###           ("\<^const>Groups.plus_class.plus" ("_position" c\<^sub>1)
###             ("\<^const>Groups.one_class.one"))))
###       ("_position" et)
###       ("\<^const>WCFG.label_incr" ("_position" n')
###         ("\<^const>Groups.plus_class.plus"
###           ("\<^const>Com.num_inner_nodes" ("_position" c\<^sub>1))
###           ("\<^const>Groups.one_class.one"))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 84 of "$AFP/Slicing/While/WCFG.thy") produces 5 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>While_CFG" ("_position" c\<^sub>2) ("_position" n)
###         ("_position" et) ("_position" n')))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.not_equal" ("_position" n)
###           ("\<^const>WCFG.w_node.Entry")))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>WCFG.label_incr"
###       ("\<^fixed>While_CFG"
###         ("\<^const>Com.cmd.Seq" ("_position" c\<^sub>1)
###           ("_position" c\<^sub>2))
###         ("\<^const>WCFG.label_incr" ("_position" n)
###           ("\<^const>Com.num_inner_nodes" ("_position" c\<^sub>1)))
###         ("_position" et) ("_position" n'))
###       ("\<^const>Com.num_inner_nodes" ("_position" c\<^sub>1)))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>While_CFG" ("_position" c\<^sub>2) ("_position" n)
###         ("_position" et) ("_position" n')))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.not_equal" ("_position" n)
###           ("\<^const>WCFG.w_node.Entry")))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>While_CFG"
###       ("\<^const>Com.cmd.Seq" ("_position" c\<^sub>1)
###         ("_position" c\<^sub>2))
###       ("\<^const>WCFG.label_incr" ("_position" n)
###         ("\<^const>Com.num_inner_nodes" ("_position" c\<^sub>1)))
###       ("_position" et)
###       ("\<^const>WCFG.label_incr" ("_position" n')
###         ("\<^const>Com.num_inner_nodes" ("_position" c\<^sub>1))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>While_CFG" ("_position" c\<^sub>2) ("_position" n)
###         ("_position" et) ("_position" n')))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.not_equal" ("_position" n)
###           ("\<^const>WCFG.w_node.Entry")))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Com.cmd.Seq" ("_position" c\<^sub>1)
###       ("\<^fixed>While_CFG" ("_position" c\<^sub>2)
###         ("\<^const>WCFG.label_incr" ("_position" n)
###           ("\<^const>Com.num_inner_nodes" ("_position" c\<^sub>1)))
###         ("_position" et)
###         ("\<^const>WCFG.label_incr" ("_position" n')
###           ("\<^const>Com.num_inner_nodes" ("_position" c\<^sub>1)))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>While_CFG" ("_position" c\<^sub>2) ("_position" n)
###         ("_position" et) ("_position" n')))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.not_equal" ("_position" n)
###           ("\<^const>WCFG.w_node.Entry")))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>WCFG.label_incr"
###       ("\<^const>Com.cmd.Seq" ("_position" c\<^sub>1)
###         ("\<^fixed>While_CFG" ("_position" c\<^sub>2)
###           ("\<^const>WCFG.label_incr" ("_position" n)
###             ("\<^const>Com.num_inner_nodes" ("_position" c\<^sub>1)))
###           ("_position" et) ("_position" n')))
###       ("\<^const>Com.num_inner_nodes" ("_position" c\<^sub>1)))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>While_CFG" ("_position" c\<^sub>2) ("_position" n)
###         ("_position" et) ("_position" n')))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.not_equal" ("_position" n)
###           ("\<^const>WCFG.w_node.Entry")))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Com.cmd.Seq" ("_position" c\<^sub>1)
###       ("\<^const>WCFG.label_incr"
###         ("\<^fixed>While_CFG" ("_position" c\<^sub>2)
###           ("\<^const>WCFG.label_incr" ("_position" n)
###             ("\<^const>Com.num_inner_nodes" ("_position" c\<^sub>1)))
###           ("_position" et) ("_position" n'))
###         ("\<^const>Com.num_inner_nodes" ("_position" c\<^sub>1))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 87 of "$AFP/Slicing/While/WCFG.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>WCFG.label_incr"
###     ("\<^fixed>While_CFG"
###       ("\<^const>Com.cmd.Cond" ("_position" b) ("_position" c\<^sub>1)
###         ("_position" c\<^sub>2))
###       ("\<^const>WCFG.w_node.Node" ("\<^const>Groups.zero_class.zero"))
###       ("\<^const>BasicDefs.edge_kind.Predicate"
###         ("_lambda" ("_position" s)
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" interpret)
###               ("_cargs" ("_position" b) ("_position" s)))
###             ("_applC" ("_position" Some) ("_position" true)))))
###       ("\<^const>WCFG.w_node.Node" ("\<^const>Groups.zero_class.zero")))
###     ("\<^const>Groups.one_class.one")))
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>While_CFG"
###     ("\<^const>Com.cmd.Cond" ("_position" b) ("_position" c\<^sub>1)
###       ("_position" c\<^sub>2))
###     ("\<^const>WCFG.w_node.Node" ("\<^const>Groups.zero_class.zero"))
###     ("\<^const>BasicDefs.edge_kind.Predicate"
###       ("_lambda" ("_position" s)
###         ("\<^const>HOL.eq"
###           ("_applC" ("_position" interpret)
###             ("_cargs" ("_position" b) ("_position" s)))
###           ("_applC" ("_position" Some) ("_position" true)))))
###     ("\<^const>WCFG.label_incr"
###       ("\<^const>WCFG.w_node.Node" ("\<^const>Groups.zero_class.zero"))
###       ("\<^const>Groups.one_class.one"))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Com.cmd.Cond" ("_position" b) ("_position" c\<^sub>1)
###     ("\<^fixed>While_CFG" ("_position" c\<^sub>2)
###       ("\<^const>WCFG.w_node.Node" ("\<^const>Groups.zero_class.zero"))
###       ("\<^const>BasicDefs.edge_kind.Predicate"
###         ("_lambda" ("_position" s)
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" interpret)
###               ("_cargs" ("_position" b) ("_position" s)))
###             ("_applC" ("_position" Some) ("_position" true)))))
###       ("\<^const>WCFG.label_incr"
###         ("\<^const>WCFG.w_node.Node" ("\<^const>Groups.zero_class.zero"))
###         ("\<^const>Groups.one_class.one")))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>WCFG.label_incr"
###     ("\<^const>Com.cmd.Cond" ("_position" b) ("_position" c\<^sub>1)
###       ("\<^fixed>While_CFG" ("_position" c\<^sub>2)
###         ("\<^const>WCFG.w_node.Node" ("\<^const>Groups.zero_class.zero"))
###         ("\<^const>BasicDefs.edge_kind.Predicate"
###           ("_lambda" ("_position" s)
###             ("\<^const>HOL.eq"
###               ("_applC" ("_position" interpret)
###                 ("_cargs" ("_position" b) ("_position" s)))
###               ("_applC" ("_position" Some) ("_position" true)))))
###         ("\<^const>WCFG.w_node.Node" ("\<^const>Groups.zero_class.zero"))))
###     ("\<^const>Groups.one_class.one")))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 100 of "$AFP/Slicing/While/WCFG.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Com.cmd.While" ("_position" b)
###     ("\<^fixed>While_CFG" ("_position" c')
###       ("\<^const>WCFG.w_node.Node" ("\<^const>Groups.zero_class.zero"))
###       ("\<^const>BasicDefs.edge_kind.Predicate"
###         ("_lambda" ("_position" s)
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" interpret)
###               ("_cargs" ("_position" b) ("_position" s)))
###             ("_applC" ("_position" Some) ("_position" true)))))
###       ("\<^const>WCFG.label_incr"
###         ("\<^const>WCFG.w_node.Node" ("\<^const>Groups.zero_class.zero"))
###         ("_Numeral" ("_constify" ("_position" 2)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>While_CFG"
###     ("\<^const>Com.cmd.While" ("_position" b) ("_position" c'))
###     ("\<^const>WCFG.w_node.Node" ("\<^const>Groups.zero_class.zero"))
###     ("\<^const>BasicDefs.edge_kind.Predicate"
###       ("_lambda" ("_position" s)
###         ("\<^const>HOL.eq"
###           ("_applC" ("_position" interpret)
###             ("_cargs" ("_position" b) ("_position" s)))
###           ("_applC" ("_position" Some) ("_position" true)))))
###     ("\<^const>WCFG.label_incr"
###       ("\<^const>WCFG.w_node.Node" ("\<^const>Groups.zero_class.zero"))
###       ("_Numeral" ("_constify" ("_position" 2))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>WCFG.label_incr"
###     ("\<^const>Com.cmd.While" ("_position" b)
###       ("\<^fixed>While_CFG" ("_position" c')
###         ("\<^const>WCFG.w_node.Node" ("\<^const>Groups.zero_class.zero"))
###         ("\<^const>BasicDefs.edge_kind.Predicate"
###           ("_lambda" ("_position" s)
###             ("\<^const>HOL.eq"
###               ("_applC" ("_position" interpret)
###                 ("_cargs" ("_position" b) ("_position" s)))
###               ("_applC" ("_position" Some) ("_position" true)))))
###         ("\<^const>WCFG.w_node.Node" ("\<^const>Groups.zero_class.zero"))))
###     ("_Numeral" ("_constify" ("_position" 2)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>WCFG.label_incr"
###     ("\<^fixed>While_CFG"
###       ("\<^const>Com.cmd.While" ("_position" b) ("_position" c'))
###       ("\<^const>WCFG.w_node.Node" ("\<^const>Groups.zero_class.zero"))
###       ("\<^const>BasicDefs.edge_kind.Predicate"
###         ("_lambda" ("_position" s)
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" interpret)
###               ("_cargs" ("_position" b) ("_position" s)))
###             ("_applC" ("_position" Some) ("_position" true)))))
###       ("\<^const>WCFG.w_node.Node" ("\<^const>Groups.zero_class.zero")))
###     ("_Numeral" ("_constify" ("_position" 2)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 103 of "$AFP/Slicing/While/WCFG.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Com.cmd.While" ("_position" b)
###     ("\<^fixed>While_CFG" ("_position" c')
###       ("\<^const>WCFG.w_node.Node" ("\<^const>Groups.zero_class.zero"))
###       ("\<^const>BasicDefs.edge_kind.Predicate"
###         ("_lambda" ("_position" s)
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" interpret)
###               ("_cargs" ("_position" b) ("_position" s)))
###             ("_applC" ("_position" Some) ("_position" false)))))
###       ("\<^const>WCFG.w_node.Node" ("\<^const>Groups.one_class.one")))))
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>While_CFG"
###     ("\<^const>Com.cmd.While" ("_position" b) ("_position" c'))
###     ("\<^const>WCFG.w_node.Node" ("\<^const>Groups.zero_class.zero"))
###     ("\<^const>BasicDefs.edge_kind.Predicate"
###       ("_lambda" ("_position" s)
###         ("\<^const>HOL.eq"
###           ("_applC" ("_position" interpret)
###             ("_cargs" ("_position" b) ("_position" s)))
###           ("_applC" ("_position" Some) ("_position" false)))))
###     ("\<^const>WCFG.w_node.Node" ("\<^const>Groups.one_class.one"))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 106 of "$AFP/Slicing/While/WCFG.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Com.cmd.While" ("_position" b)
###     ("\<^fixed>While_CFG" ("_position" c')
###       ("\<^const>WCFG.w_node.Node" ("\<^const>Groups.one_class.one"))
###       ("\<^const>BasicDefs.edge_kind.Update" ("_position" id))
###       ("\<^const>WCFG.w_node.Exit"))))
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>While_CFG"
###     ("\<^const>Com.cmd.While" ("_position" b) ("_position" c'))
###     ("\<^const>WCFG.w_node.Node" ("\<^const>Groups.one_class.one"))
###     ("\<^const>BasicDefs.edge_kind.Update" ("_position" id))
###     ("\<^const>WCFG.w_node.Exit")))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 90 of "$AFP/Slicing/While/WCFG.thy") produces 8 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>WCFG.label_incr"
###     ("\<^fixed>While_CFG"
###       ("\<^const>Com.cmd.Cond" ("_position" b) ("_position" c\<^sub>1)
###         ("_position" c\<^sub>2))
###       ("\<^const>WCFG.w_node.Node" ("\<^const>Groups.zero_class.zero"))
###       ("\<^const>BasicDefs.edge_kind.Predicate"
###         ("_lambda" ("_position" s)
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" interpret)
###               ("_cargs" ("_position" b) ("_position" s)))
###             ("_applC" ("_position" Some) ("_position" false)))))
###       ("\<^const>WCFG.w_node.Node" ("\<^const>Groups.zero_class.zero")))
###     ("\<^const>Com.num_inner_nodes"
###       ("\<^const>Groups.plus_class.plus" ("_position" c\<^sub>1)
###         ("\<^const>Groups.one_class.one")))))
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>While_CFG"
###     ("\<^const>Com.cmd.Cond" ("_position" b) ("_position" c\<^sub>1)
###       ("_position" c\<^sub>2))
###     ("\<^const>WCFG.w_node.Node" ("\<^const>Groups.zero_class.zero"))
###     ("\<^const>BasicDefs.edge_kind.Predicate"
###       ("_lambda" ("_position" s)
###         ("\<^const>HOL.eq"
###           ("_applC" ("_position" interpret)
###             ("_cargs" ("_position" b) ("_position" s)))
###           ("_applC" ("_position" Some) ("_position" false)))))
###     ("\<^const>WCFG.label_incr"
###       ("\<^const>WCFG.w_node.Node" ("\<^const>Groups.zero_class.zero"))
###       ("\<^const>Com.num_inner_nodes"
###         ("\<^const>Groups.plus_class.plus" ("_position" c\<^sub>1)
###           ("\<^const>Groups.one_class.one"))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Com.cmd.Cond" ("_position" b) ("_position" c\<^sub>1)
###     ("\<^fixed>While_CFG" ("_position" c\<^sub>2)
###       ("\<^const>WCFG.w_node.Node" ("\<^const>Groups.zero_class.zero"))
###       ("\<^const>BasicDefs.edge_kind.Predicate"
###         ("_lambda" ("_position" s)
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" interpret)
###               ("_cargs" ("_position" b) ("_position" s)))
###             ("_applC" ("_position" Some) ("_position" false)))))
###       ("\<^const>WCFG.label_incr"
###         ("\<^const>WCFG.w_node.Node" ("\<^const>Groups.zero_class.zero"))
###         ("\<^const>Com.num_inner_nodes"
###           ("\<^const>Groups.plus_class.plus" ("_position" c\<^sub>1)
###             ("\<^const>Groups.one_class.one")))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>WCFG.label_incr"
###     ("\<^const>Com.cmd.Cond" ("_position" b) ("_position" c\<^sub>1)
###       ("\<^fixed>While_CFG" ("_position" c\<^sub>2)
###         ("\<^const>WCFG.w_node.Node" ("\<^const>Groups.zero_class.zero"))
###         ("\<^const>BasicDefs.edge_kind.Predicate"
###           ("_lambda" ("_position" s)
###             ("\<^const>HOL.eq"
###               ("_applC" ("_position" interpret)
###                 ("_cargs" ("_position" b) ("_position" s)))
###               ("_applC" ("_position" Some) ("_position" false)))))
###         ("\<^const>WCFG.w_node.Node" ("\<^const>Groups.zero_class.zero"))))
###     ("\<^const>Com.num_inner_nodes"
###       ("\<^const>Groups.plus_class.plus" ("_position" c\<^sub>1)
###         ("\<^const>Groups.one_class.one")))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>WCFG.label_incr"
###     ("\<^fixed>While_CFG"
###       ("\<^const>Com.cmd.Cond" ("_position" b) ("_position" c\<^sub>1)
###         ("_position" c\<^sub>2))
###       ("\<^const>WCFG.w_node.Node" ("\<^const>Groups.zero_class.zero"))
###       ("\<^const>BasicDefs.edge_kind.Predicate"
###         ("_lambda" ("_position" s)
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" interpret)
###               ("_cargs" ("_position" b) ("_position" s)))
###             ("_applC" ("_position" Some) ("_position" false)))))
###       ("\<^const>WCFG.w_node.Node" ("\<^const>Groups.zero_class.zero")))
###     ("\<^const>Groups.plus_class.plus"
###       ("\<^const>Com.num_inner_nodes" ("_position" c\<^sub>1))
###       ("\<^const>Groups.one_class.one"))))
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>While_CFG"
###     ("\<^const>Com.cmd.Cond" ("_position" b) ("_position" c\<^sub>1)
###       ("_position" c\<^sub>2))
###     ("\<^const>WCFG.w_node.Node" ("\<^const>Groups.zero_class.zero"))
###     ("\<^const>BasicDefs.edge_kind.Predicate"
###       ("_lambda" ("_position" s)
###         ("\<^const>HOL.eq"
###           ("_applC" ("_position" interpret)
###             ("_cargs" ("_position" b) ("_position" s)))
###           ("_applC" ("_position" Some) ("_position" false)))))
###     ("\<^const>WCFG.label_incr"
###       ("\<^const>WCFG.w_node.Node" ("\<^const>Groups.zero_class.zero"))
###       ("\<^const>Groups.plus_class.plus"
###         ("\<^const>Com.num_inner_nodes" ("_position" c\<^sub>1))
###         ("\<^const>Groups.one_class.one")))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Com.cmd.Cond" ("_position" b) ("_position" c\<^sub>1)
###     ("\<^fixed>While_CFG" ("_position" c\<^sub>2)
###       ("\<^const>WCFG.w_node.Node" ("\<^const>Groups.zero_class.zero"))
###       ("\<^const>BasicDefs.edge_kind.Predicate"
###         ("_lambda" ("_position" s)
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" interpret)
###               ("_cargs" ("_position" b) ("_position" s)))
###             ("_applC" ("_position" Some) ("_position" false)))))
###       ("\<^const>WCFG.label_incr"
###         ("\<^const>WCFG.w_node.Node" ("\<^const>Groups.zero_class.zero"))
###         ("\<^const>Groups.plus_class.plus"
###           ("\<^const>Com.num_inner_nodes" ("_position" c\<^sub>1))
###           ("\<^const>Groups.one_class.one"))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>WCFG.label_incr"
###     ("\<^const>Com.cmd.Cond" ("_position" b) ("_position" c\<^sub>1)
###       ("\<^fixed>While_CFG" ("_position" c\<^sub>2)
###         ("\<^const>WCFG.w_node.Node" ("\<^const>Groups.zero_class.zero"))
###         ("\<^const>BasicDefs.edge_kind.Predicate"
###           ("_lambda" ("_position" s)
###             ("\<^const>HOL.eq"
###               ("_applC" ("_position" interpret)
###                 ("_cargs" ("_position" b) ("_position" s)))
###               ("_applC" ("_position" Some) ("_position" false)))))
###         ("\<^const>WCFG.w_node.Node" ("\<^const>Groups.zero_class.zero"))))
###     ("\<^const>Groups.plus_class.plus"
###       ("\<^const>Com.num_inner_nodes" ("_position" c\<^sub>1))
###       ("\<^const>Groups.one_class.one"))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 109 of "$AFP/Slicing/While/WCFG.thy") produces 4 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>While_CFG" ("_position" c') ("_position" n)
###         ("_position" et) ("_position" n')))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.not_equal" ("_position" n)
###           ("\<^const>WCFG.w_node.Entry")))
###       ("_asm"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.not_equal" ("_position" n')
###             ("\<^const>WCFG.w_node.Exit"))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Com.cmd.While" ("_position" b)
###       ("\<^fixed>While_CFG" ("_position" c')
###         ("\<^const>WCFG.label_incr" ("_position" n)
###           ("_Numeral" ("_constify" ("_position" 2))))
###         ("_position" et)
###         ("\<^const>WCFG.label_incr" ("_position" n')
###           ("_Numeral" ("_constify" ("_position" 2))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>While_CFG" ("_position" c') ("_position" n)
###         ("_position" et) ("_position" n')))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.not_equal" ("_position" n)
###           ("\<^const>WCFG.w_node.Entry")))
###       ("_asm"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.not_equal" ("_position" n')
###             ("\<^const>WCFG.w_node.Exit"))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>While_CFG"
###       ("\<^const>Com.cmd.While" ("_position" b) ("_position" c'))
###       ("\<^const>WCFG.label_incr" ("_position" n)
###         ("_Numeral" ("_constify" ("_position" 2))))
###       ("_position" et)
###       ("\<^const>WCFG.label_incr" ("_position" n')
###         ("_Numeral" ("_constify" ("_position" 2)))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>While_CFG" ("_position" c') ("_position" n)
###         ("_position" et) ("_position" n')))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.not_equal" ("_position" n)
###           ("\<^const>WCFG.w_node.Entry")))
###       ("_asm"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.not_equal" ("_position" n')
###             ("\<^const>WCFG.w_node.Exit"))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>WCFG.label_incr"
###       ("\<^const>Com.cmd.While" ("_position" b)
###         ("\<^fixed>While_CFG" ("_position" c')
###           ("\<^const>WCFG.label_incr" ("_position" n)
###             ("_Numeral" ("_constify" ("_position" 2))))
###           ("_position" et) ("_position" n')))
###       ("_Numeral" ("_constify" ("_position" 2))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>While_CFG" ("_position" c') ("_position" n)
###         ("_position" et) ("_position" n')))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.not_equal" ("_position" n)
###           ("\<^const>WCFG.w_node.Entry")))
###       ("_asm"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.not_equal" ("_position" n')
###             ("\<^const>WCFG.w_node.Exit"))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>WCFG.label_incr"
###       ("\<^fixed>While_CFG"
###         ("\<^const>Com.cmd.While" ("_position" b) ("_position" c'))
###         ("\<^const>WCFG.label_incr" ("_position" n)
###           ("_Numeral" ("_constify" ("_position" 2))))
###         ("_position" et) ("_position" n'))
###       ("_Numeral" ("_constify" ("_position" 2))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 113 of "$AFP/Slicing/While/WCFG.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>While_CFG" ("_position" c') ("_position" n)
###         ("_position" et) ("\<^const>WCFG.w_node.Exit")))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.not_equal" ("_position" n)
###           ("\<^const>WCFG.w_node.Entry")))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Com.cmd.While" ("_position" b)
###       ("\<^fixed>While_CFG" ("_position" c')
###         ("\<^const>WCFG.label_incr" ("_position" n)
###           ("_Numeral" ("_constify" ("_position" 2))))
###         ("_position" et)
###         ("\<^const>WCFG.w_node.Node"
###           ("\<^const>Groups.zero_class.zero"))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>While_CFG" ("_position" c') ("_position" n)
###         ("_position" et) ("\<^const>WCFG.w_node.Exit")))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.not_equal" ("_position" n)
###           ("\<^const>WCFG.w_node.Entry")))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>While_CFG"
###       ("\<^const>Com.cmd.While" ("_position" b) ("_position" c'))
###       ("\<^const>WCFG.label_incr" ("_position" n)
###         ("_Numeral" ("_constify" ("_position" 2))))
###       ("_position" et)
###       ("\<^const>WCFG.w_node.Node" ("\<^const>Groups.zero_class.zero")))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 659 of "$AFP/Slicing/StaticIntra/Slice.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>local.path" ("_position" n) ("_position" as)
###         ("_position" n')))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Set.member" ("_position" n')
###           ("_applC" ("_position" backward_slice) ("_position" S))))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>Set.member" ("_position" V)
###             ("_applC" ("_position" Use) ("_position" n'))))
###         ("_asm"
###           ("\<^const>HOL.Trueprop"
###             ("_Ball" ("_position" nx)
###               ("_applC" ("_position" set)
###                 ("_applC" ("_position" sourcenodes) ("_position" as)))
###               ("\<^const>Set.not_member" ("_position" V)
###                 ("_applC" ("_position" Def) ("_position" nx)))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Set.member" ("_position" V)
###       ("_applC" ("\<^fixed>relevant_vars" ("_position" S))
###         ("_position" n)))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>local.path" ("_position" n) ("_position" as)
###         ("_position" n')))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Set.member" ("_position" n')
###           ("_applC" ("_position" backward_slice) ("_position" S))))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>Set.member" ("_position" V)
###             ("_applC" ("_position" Use) ("_position" n'))))
###         ("_asm"
###           ("\<^const>HOL.Trueprop"
###             ("_Ball" ("_position" nx)
###               ("_applC" ("_position" set)
###                 ("_applC" ("_position" sourcenodes) ("_position" as)))
###               ("\<^const>Set.not_member" ("_position" V)
###                 ("_applC" ("_position" Def) ("_position" nx)))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Set.member" ("_position" V)
###       ("\<^fixed>relevant_vars"
###         ("_applC" ("_position" S) ("_position" n))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Proofs for inductive predicate(s) "relevant_varsp"
  Proving monotonicity ...
Proofs for inductive predicate(s) "While_CFG"
  Proving monotonicity ...
### Ambiguous input (line 665 of "$AFP/Slicing/StaticIntra/Slice.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member" ("_position" V)
###     ("_applC" ("\<^const>local.relevant_vars" ("_position" S))
###       ("_position" n))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member" ("_position" V)
###     ("\<^const>local.relevant_vars"
###       ("_applC" ("_position" S) ("_position" n)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 675 of "$AFP/Slicing/StaticIntra/Slice.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member" ("_position" x)
###     ("_applC" ("\<^const>local.relevant_vars" ("_position" S))
###       ("_position" n))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member" ("_position" x)
###     ("\<^const>local.relevant_vars"
###       ("_applC" ("_position" S) ("_position" n)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 675 of "$AFP/Slicing/StaticIntra/Slice.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member" ("_position" x)
###     ("_applC" ("\<^const>local.relevant_vars" ("_position" S))
###       ("_position" n'))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member" ("_position" x)
###     ("\<^const>local.relevant_vars"
###       ("_applC" ("_position" S) ("_position" n')))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 775 of "$AFP/Slicing/StaticIntra/Slice.thy") produces 7 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_applC"
###     ("\<^const>local.relevant_vars"
###       ("\<^const>HOL.eq" ("_applC" ("_position" S) ("_position" n))
###         ("\<^const>local.relevant_vars" ("_position" S))))
###     ("_position" n')))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.relevant_vars"
###     ("\<^const>HOL.eq" ("_applC" ("_position" S) ("_position" n))
###       ("\<^const>local.relevant_vars"
###         ("_applC" ("_position" S) ("_position" n'))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>local.relevant_vars"
###       ("_applC" ("_position" S) ("_position" n)))
###     ("\<^const>local.relevant_vars"
###       ("_applC" ("_position" S) ("_position" n')))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("\<^const>local.relevant_vars" ("_position" S))
###       ("_position" n))
###     ("\<^const>local.relevant_vars"
###       ("_applC" ("_position" S) ("_position" n')))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.relevant_vars"
###     ("\<^const>HOL.eq" ("_applC" ("_position" S) ("_position" n))
###       ("_applC" ("\<^const>local.relevant_vars" ("_position" S))
###         ("_position" n')))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>local.relevant_vars"
###       ("_applC" ("_position" S) ("_position" n)))
###     ("_applC" ("\<^const>local.relevant_vars" ("_position" S))
###       ("_position" n'))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("\<^const>local.relevant_vars" ("_position" S))
###       ("_position" n))
###     ("_applC" ("\<^const>local.relevant_vars" ("_position" S))
###       ("_position" n'))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 793 of "$AFP/Slicing/StaticIntra/Slice.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_Ball" ("_position" V)
###     ("_applC" ("\<^const>local.relevant_vars" ("_position" S))
###       ("_position" n))
###     ("\<^const>HOL.eq"
###       ("_applC" ("_position" state_val)
###         ("_cargs" ("_position" s) ("_position" V)))
###       ("_applC" ("_position" state_val)
###         ("_cargs" ("_position" s') ("_position" V))))))
### ("\<^const>HOL.Trueprop"
###   ("_Ball" ("_position" V)
###     ("\<^const>local.relevant_vars"
###       ("_applC" ("_position" S) ("_position" n)))
###     ("\<^const>HOL.eq"
###       ("_applC" ("_position" state_val)
###         ("_cargs" ("_position" s) ("_position" V)))
###       ("_applC" ("_position" state_val)
###         ("_cargs" ("_position" s') ("_position" V))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 795 of "$AFP/Slicing/StaticIntra/Slice.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_Ball" ("_position" V)
###     ("_applC" ("\<^const>local.relevant_vars" ("_position" S))
###       ("_position" n''))
###     ("\<^const>HOL.eq"
###       ("_applC" ("_position" state_val)
###         ("_cargs"
###           ("_applC" ("_position" transfer)
###             ("_cargs"
###               ("_applC" ("_position" slice_kind)
###                 ("_cargs" ("_position" S) ("_position" a)))
###               ("_position" s)))
###           ("_position" V)))
###       ("_applC" ("_position" state_val)
###         ("_cargs"
###           ("_applC" ("_position" transfer)
###             ("_cargs"
###               ("_applC" ("_position" slice_kind)
###                 ("_cargs" ("_position" S) ("_position" a)))
###               ("_position" s')))
###           ("_position" V))))))
### ("\<^const>HOL.Trueprop"
###   ("_Ball" ("_position" V)
###     ("\<^const>local.relevant_vars"
###       ("_applC" ("_position" S) ("_position" n'')))
###     ("\<^const>HOL.eq"
###       ("_applC" ("_position" state_val)
###         ("_cargs"
###           ("_applC" ("_position" transfer)
###             ("_cargs"
###               ("_applC" ("_position" slice_kind)
###                 ("_cargs" ("_position" S) ("_position" a)))
###               ("_position" s)))
###           ("_position" V)))
###       ("_applC" ("_position" state_val)
###         ("_cargs"
###           ("_applC" ("_position" transfer)
###             ("_cargs"
###               ("_applC" ("_position" slice_kind)
###                 ("_cargs" ("_position" S) ("_position" a)))
###               ("_position" s')))
###           ("_position" V))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 903 of "$AFP/Slicing/StaticIntra/Slice.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_Ball" ("_position" V)
###     ("_applC" ("\<^const>local.relevant_vars" ("_position" S))
###       ("_position" n))
###     ("\<^const>HOL.eq"
###       ("_applC" ("_position" state_val)
###         ("_cargs" ("_position" s) ("_position" V)))
###       ("_applC" ("_position" state_val)
###         ("_cargs" ("_position" s') ("_position" V))))))
### ("\<^const>HOL.Trueprop"
###   ("_Ball" ("_position" V)
###     ("\<^const>local.relevant_vars"
###       ("_applC" ("_position" S) ("_position" n)))
###     ("\<^const>HOL.eq"
###       ("_applC" ("_position" state_val)
###         ("_cargs" ("_position" s) ("_position" V)))
###       ("_applC" ("_position" state_val)
###         ("_cargs" ("_position" s') ("_position" V))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 966 of "$AFP/Slicing/StaticIntra/Slice.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq"
###         ("_applC" ("_position" obs)
###           ("_cargs" ("_position" n)
###             ("_applC" ("_position" backward_slice) ("_position" S))))
###         ("_applC" ("_position" obs)
###           ("_cargs" ("_position" n')
###             ("_applC" ("_position" backward_slice) ("_position" S))))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("_Ball" ("_position" V)
###           ("\<^const>local.relevant_vars"
###             ("_applC" ("_position" S) ("_position" n)))
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" state_val)
###               ("_cargs" ("_position" s) ("_position" V)))
###             ("_applC" ("_position" state_val)
###               ("_cargs" ("_position" s') ("_position" V))))))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("_applC" ("_position" valid_node) ("_position" n)))
###         ("_asm"
###           ("\<^const>HOL.Trueprop"
###             ("_applC" ("_position" valid_node) ("_position" n')))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Set.member"
###       ("_tuple" ("_tuple" ("_position" n) ("_tuple_arg" ("_position" s)))
###         ("_tuple_arg"
###           ("_tuple" ("_position" n') ("_tuple_arg" ("_position" s')))))
###       ("_applC" ("_position" WS) ("_position" S)))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq"
###         ("_applC" ("_position" obs)
###           ("_cargs" ("_position" n)
###             ("_applC" ("_position" backward_slice) ("_position" S))))
###         ("_applC" ("_position" obs)
###           ("_cargs" ("_position" n')
###             ("_applC" ("_position" backward_slice) ("_position" S))))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("_Ball" ("_position" V)
###           ("_applC" ("\<^const>local.relevant_vars" ("_position" S))
###             ("_position" n))
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" state_val)
###               ("_cargs" ("_position" s) ("_position" V)))
###             ("_applC" ("_position" state_val)
###               ("_cargs" ("_position" s') ("_position" V))))))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("_applC" ("_position" valid_node) ("_position" n)))
###         ("_asm"
###           ("\<^const>HOL.Trueprop"
###             ("_applC" ("_position" valid_node) ("_position" n')))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Set.member"
###       ("_tuple" ("_tuple" ("_position" n) ("_tuple_arg" ("_position" s)))
###         ("_tuple_arg"
###           ("_tuple" ("_position" n') ("_tuple_arg" ("_position" s')))))
###       ("_applC" ("_position" WS) ("_position" S)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Proofs for inductive predicate(s) "WSp"
  Proving monotonicity ...
### Ambiguous input (line 365 of "$AFP/Slicing/While/WCFG.thy") produces 12 parse trees (10 displayed):
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Orderings.ord_class.less" ("_position" l)
###       ("\<^const>Com.num_inner_nodes" ("_position" prog))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>WCFG.While_CFG"
###       ("\<^const>HOL.disj"
###         ("\<^const>WCFG.While_CFG"
###           ("\<^const>HOL.Ex_binder"
###             ("_idts" ("_position" n) ("_position" et)) ("_position" prog))
###           ("_position" n) ("_position" et)
###           ("\<^const>WCFG.w_node.Node" ("_position" l)))
###         ("_position" prog))
###       ("\<^const>WCFG.w_node.Node" ("_position" l)) ("_position" et)
###       ("_position" n))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Orderings.ord_class.less" ("_position" l)
###       ("\<^const>Com.num_inner_nodes" ("_position" prog))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.disj"
###       ("\<^const>WCFG.While_CFG"
###         ("\<^const>HOL.Ex_binder" ("_idts" ("_position" n) ("_position" et))
###           ("_position" prog))
###         ("_position" n) ("_position" et)
###         ("\<^const>WCFG.w_node.Node" ("_position" l)))
###       ("\<^const>WCFG.While_CFG" ("_position" prog)
###         ("\<^const>WCFG.w_node.Node" ("_position" l)) ("_position" et)
###         ("_position" n)))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Orderings.ord_class.less" ("_position" l)
###       ("\<^const>Com.num_inner_nodes" ("_position" prog))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>WCFG.While_CFG"
###       ("\<^const>HOL.Ex_binder" ("_idts" ("_position" n) ("_position" et))
###         ("_position" prog))
###       ("_position" n) ("_position" et)
###       ("\<^const>HOL.disj" ("\<^const>WCFG.w_node.Node" ("_position" l))
###         ("\<^const>WCFG.While_CFG" ("_position" prog)
###           ("\<^const>WCFG.w_node.Node" ("_position" l)) ("_position" et)
###           ("_position" n))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Orderings.ord_class.less" ("_position" l)
###       ("\<^const>Com.num_inner_nodes" ("_position" prog))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.Ex_binder" ("_idts" ("_position" n) ("_position" et))
###       ("\<^const>WCFG.While_CFG" ("_position" prog) ("_position" n)
###         ("_position" et)
###         ("\<^const>HOL.disj" ("\<^const>WCFG.w_node.Node" ("_position" l))
###           ("\<^const>WCFG.While_CFG" ("_position" prog)
###             ("\<^const>WCFG.w_node.Node" ("_position" l)) ("_position" et)
###             ("_position" n)))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Orderings.ord_class.less" ("_position" l)
###       ("\<^const>Com.num_inner_nodes" ("_position" prog))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.Ex_binder" ("_idts" ("_position" n) ("_position" et))
###       ("\<^const>HOL.disj"
###         ("\<^const>WCFG.While_CFG" ("_position" prog) ("_position" n)
###           ("_position" et) ("\<^const>WCFG.w_node.Node" ("_position" l)))
###         ("\<^const>WCFG.While_CFG" ("_position" prog)
###           ("\<^const>WCFG.w_node.Node" ("_position" l)) ("_position" et)
###           ("_position" n))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Orderings.ord_class.less" ("_position" l)
###       ("\<^const>Com.num_inner_nodes" ("_position" prog))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>WCFG.While_CFG"
###       ("\<^const>WCFG.While_CFG"
###         ("\<^const>HOL.Ex_binder" ("_idts" ("_position" n) ("_position" et))
###           ("_position" prog))
###         ("_position" n) ("_position" et)
###         ("\<^const>HOL.disj" ("\<^const>WCFG.w_node.Node" ("_position" l))
###           ("_position" prog)))
###       ("\<^const>WCFG.w_node.Node" ("_position" l)) ("_position" et)
###       ("_position" n))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Orderings.ord_class.less" ("_position" l)
###       ("\<^const>Com.num_inner_nodes" ("_position" prog))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>WCFG.While_CFG"
###       ("\<^const>HOL.Ex_binder" ("_idts" ("_position" n) ("_position" et))
###         ("_position" prog))
###       ("_position" n) ("_position" et)
###       ("\<^const>WCFG.While_CFG"
###         ("\<^const>HOL.disj" ("\<^const>WCFG.w_node.Node" ("_position" l))
###           ("_position" prog))
###         ("\<^const>WCFG.w_node.Node" ("_position" l)) ("_position" et)
###         ("_position" n)))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Orderings.ord_class.less" ("_position" l)
###       ("\<^const>Com.num_inner_nodes" ("_position" prog))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.Ex_binder" ("_idts" ("_position" n) ("_position" et))
###       ("\<^const>WCFG.While_CFG" ("_position" prog) ("_position" n)
###         ("_position" et)
###         ("\<^const>WCFG.While_CFG"
###           ("\<^const>HOL.disj" ("\<^const>WCFG.w_node.Node" ("_position" l))
###             ("_position" prog))
###           ("\<^const>WCFG.w_node.Node" ("_position" l)) ("_position" et)
###           ("_position" n))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Orderings.ord_class.less" ("_position" l)
###       ("\<^const>Com.num_inner_nodes" ("_position" prog))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>WCFG.While_CFG"
###       ("\<^const>HOL.Ex_binder" ("_idts" ("_position" n) ("_position" et))
###         ("\<^const>WCFG.While_CFG" ("_position" prog) ("_position" n)
###           ("_position" et)
###           ("\<^const>HOL.disj" ("\<^const>WCFG.w_node.Node" ("_position" l))
###             ("_position" prog))))
###       ("\<^const>WCFG.w_node.Node" ("_position" l)) ("_position" et)
###       ("_position" n))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Orderings.ord_class.less" ("_position" l)
###       ("\<^const>Com.num_inner_nodes" ("_position" prog))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.Ex_binder" ("_idts" ("_position" n) ("_position" et))
###       ("\<^const>WCFG.While_CFG"
###         ("\<^const>WCFG.While_CFG" ("_position" prog) ("_position" n)
###           ("_position" et)
###           ("\<^const>HOL.disj" ("\<^const>WCFG.w_node.Node" ("_position" l))
###             ("_position" prog)))
###         ("\<^const>WCFG.w_node.Node" ("_position" l)) ("_position" et)
###         ("_position" n)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "Draft.WCFG"
### 0.805s elapsed time, 2.586s cpu time, 0.201s GC time
Loading theory "Draft.Interpretation" (required by "Draft.DynamicControlDependencesMoreTemplates" via "Draft.DynamicControlDependences" via "Draft.AdditionalLemmas" via "Draft.WellFormed")
### Ambiguous input (line 973 of "$AFP/Slicing/StaticIntra/Slice.thy") produces 2 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Set.member"
###       ("_tuple" ("_tuple" ("_position" n) ("_tuple_arg" ("_position" s)))
###         ("_tuple_arg"
###           ("_tuple" ("_position" n') ("_tuple_arg" ("_position" s')))))
###       ("_applC" ("_position" WS) ("_position" S))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.conj"
###       ("\<^const>HOL.eq"
###         ("_applC" ("_position" obs)
###           ("_cargs" ("_position" n)
###             ("_applC" ("_position" backward_slice) ("_position" S))))
###         ("_applC" ("_position" obs)
###           ("_cargs" ("_position" n')
###             ("_applC" ("_position" backward_slice) ("_position" S)))))
###       ("\<^const>HOL.conj"
###         ("_Ball" ("_position" V)
###           ("\<^const>local.relevant_vars"
###             ("_applC" ("_position" S) ("_position" n)))
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" state_val)
###               ("_cargs" ("_position" s) ("_position" V)))
###             ("_applC" ("_position" state_val)
###               ("_cargs" ("_position" s') ("_position" V)))))
###         ("\<^const>HOL.conj"
###           ("_applC" ("_position" valid_node) ("_position" n))
###           ("_applC" ("_position" valid_node) ("_position" n')))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Set.member"
###       ("_tuple" ("_tuple" ("_position" n) ("_tuple_arg" ("_position" s)))
###         ("_tuple_arg"
###           ("_tuple" ("_position" n') ("_tuple_arg" ("_position" s')))))
###       ("_applC" ("_position" WS) ("_position" S))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.conj"
###       ("\<^const>HOL.eq"
###         ("_applC" ("_position" obs)
###           ("_cargs" ("_position" n)
###             ("_applC" ("_position" backward_slice) ("_position" S))))
###         ("_applC" ("_position" obs)
###           ("_cargs" ("_position" n')
###             ("_applC" ("_position" backward_slice) ("_position" S)))))
###       ("\<^const>HOL.conj"
###         ("_Ball" ("_position" V)
###           ("_applC" ("\<^const>local.relevant_vars" ("_position" S))
###             ("_position" n))
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" state_val)
###               ("_cargs" ("_position" s) ("_position" V)))
###             ("_applC" ("_position" state_val)
###               ("_cargs" ("_position" s') ("_position" V)))))
###         ("\<^const>HOL.conj"
###           ("_applC" ("_position" valid_node) ("_position" n))
###           ("_applC" ("_position" valid_node) ("_position" n')))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "HOL-Library.BigO"
### 0.792s elapsed time, 2.454s cpu time, 0.240s GC time
Loading theory "Draft.ExtrEqs" (required by "Draft.DynamicControlDependencesMoreTemplates")
Proofs for inductive predicate(s) "trans_observable_moves"
### Ambiguous input (line 21 of "$AFP/Slicing/While/Interpretation.thy") produces 2 parse trees:
### ("\<^const>Pure.eq"
###   ("_applC" ("_position" valid_edge)
###     ("_cargs" ("_position" prog) ("_position" a)))
###   ("\<^const>WCFG.While_CFG" ("_position" prog)
###     ("_applC" ("_position" sourcenode) ("_position" a))
###     ("_applC" ("_position" kind) ("_position" a))
###     ("_applC" ("_position" targetnode) ("_position" a))))
### ("\<^const>Pure.eq"
###   ("_applC" ("_position" valid_edge)
###     ("_cargs" ("_position" prog) ("_position" a)))
###   ("_applC"
###     ("\<^const>WCFG.While_CFG" ("_position" prog)
###       ("_applC" ("_position" sourcenode) ("_position" a))
###       ("_applC" ("_position" kind) ("_position" a))
###       ("_position" targetnode))
###     ("_position" a)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
  Proving monotonicity ...
### Ambiguous input (line 1271 of "$AFP/Slicing/StaticIntra/Slice.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>local.path" ("_position" n) ("_position" as)
###         ("_position" n')))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>local.path" ("_position" n) ("_position" as')
###           ("_position" n')))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" slice_edges)
###               ("_cargs" ("_position" S) ("_position" as)))
###             ("_applC" ("_position" slice_edges)
###               ("_cargs" ("_position" S) ("_position" as')))))
###         ("_asms"
###           ("\<^const>HOL.Trueprop"
###             ("_applC" ("_position" preds)
###               ("_cargs"
###                 ("_applC" ("_position" slice_kinds)
###                   ("_cargs" ("_position" S) ("_position" as)))
###                 ("_position" s))))
###           ("_asms"
###             ("\<^const>HOL.Trueprop"
###               ("_applC" ("_position" preds)
###                 ("_cargs"
###                   ("_applC" ("_position" slice_kinds)
###                     ("_cargs" ("_position" S) ("_position" as')))
###                   ("_position" s'))))
###             ("_asms"
###               ("\<^const>HOL.Trueprop"
###                 ("\<^const>Set.member" ("_position" n') ("_position" S)))
###               ("_asm"
###                 ("\<^const>HOL.Trueprop"
###                   ("_Ball" ("_position" V)
###                     ("\<^const>local.relevant_vars"
###                       ("_applC" ("_position" S) ("_position" n)))
###                     ("\<^const>HOL.eq"
###                       ("_applC" ("_position" state_val)
###                         ("_cargs" ("_position" s) ("_position" V)))
###                       ("_applC" ("_position" state_val)
###                         ("_cargs" ("_position" s')
###                           ("_position" V)))))))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq" ("_position" as) ("_position" as'))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>local.path" ("_position" n) ("_position" as)
###         ("_position" n')))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>local.path" ("_position" n) ("_position" as')
###           ("_position" n')))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" slice_edges)
###               ("_cargs" ("_position" S) ("_position" as)))
###             ("_applC" ("_position" slice_edges)
###               ("_cargs" ("_position" S) ("_position" as')))))
###         ("_asms"
###           ("\<^const>HOL.Trueprop"
###             ("_applC" ("_position" preds)
###               ("_cargs"
###                 ("_applC" ("_position" slice_kinds)
###                   ("_cargs" ("_position" S) ("_position" as)))
###                 ("_position" s))))
###           ("_asms"
###             ("\<^const>HOL.Trueprop"
###               ("_applC" ("_position" preds)
###                 ("_cargs"
###                   ("_applC" ("_position" slice_kinds)
###                     ("_cargs" ("_position" S) ("_position" as')))
###                   ("_position" s'))))
###             ("_asms"
###               ("\<^const>HOL.Trueprop"
###                 ("\<^const>Set.member" ("_position" n') ("_position" S)))
###               ("_asm"
###                 ("\<^const>HOL.Trueprop"
###                   ("_Ball" ("_position" V)
###                     ("_applC"
###                       ("\<^const>local.relevant_vars" ("_position" S))
###                       ("_position" n))
###                     ("\<^const>HOL.eq"
###                       ("_applC" ("_position" state_val)
###                         ("_cargs" ("_position" s) ("_position" V)))
###                       ("_applC" ("_position" state_val)
###                         ("_cargs" ("_position" s')
###                           ("_position" V)))))))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq" ("_position" as) ("_position" as'))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "Draft.Interpretation"
### 0.522s elapsed time, 1.690s cpu time, 1.021s GC time
locale BackwardSlice_wf
  fixes sourcenode :: "'edge => 'node"
    and targetnode :: "'edge => 'node"
    and kind :: "'edge => 'state edge_kind"
    and valid_edge :: "'edge => bool"
    and Entry :: "'node"  (\<open>'('_Entry'_')\<close>)
    and Def :: "'node => 'var set"
    and Use :: "'node => 'var set"
    and state_val :: "'state => 'var => 'val"
    and backward_slice :: "'node set => 'node set"
    and
    sem :: "'com => 'state => 'com => 'state => bool"
      (\<open>((1\<langle>_,/_\<rangle>) \<Rightarrow>/ (1\<langle>_,/_\<rangle>))\<close>
        [0, 0, 0, 0] 81)
    and
    identifies :: "'node => 'com => bool"
      (\<open>_ \<triangleq> _\<close> [51, 0] 80)
  assumes
    "BackwardSlice_wf sourcenode targetnode kind valid_edge (_Entry_) Def
      Use state_val backward_slice sem identifies"
### theory "Draft.Slice"
### 1.575s elapsed time, 4.951s cpu time, 1.241s GC time
Loading theory "Draft.CDepInstantiations" (required by "Draft.DynamicControlDependencesMoreTemplates" via "Draft.DynamicControlDependences" via "Draft.AdditionalLemmas" via "Draft.WellFormed")
locale StandardControlDependencePDG
  fixes sourcenode :: "'edge => 'node"
    and targetnode :: "'edge => 'node"
    and kind :: "'edge => 'state edge_kind"
    and valid_edge :: "'edge => bool"
    and Entry :: "'node"  (\<open>'('_Entry'_')\<close>)
    and Def :: "'node => 'var set"
    and Use :: "'node => 'var set"
    and state_val :: "'state => 'var => 'val"
    and Exit :: "'node"  (\<open>'('_Exit'_')\<close>)
  assumes
    "StandardControlDependencePDG sourcenode targetnode kind valid_edge
      (_Entry_) Def Use state_val (_Exit_)"
### Ambiguous input (line 18 of "$AFP/Slicing/StaticIntra/CDepInstantiations.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>PDG_path'" ("_position" n)
###     ("\<^const>Pure.eq" ("_position" n')
###       ("_applC" ("_position" PDG.PDG_path)
###         ("_cargs" ("_position" sourcenode)
###           ("_cargs" ("_position" targetnode)
###             ("_cargs" ("_position" valid_edge)
###               ("_cargs" ("_position" Def)
###                 ("_cargs" ("_position" Use)
###                   ("_cargs" ("_position" standard_control_dependence)
###                     ("_cargs" ("_position" n) ("_position" n'))))))))))))
### ("\<^const>Pure.eq" ("\<^fixed>PDG_path'" ("_position" n) ("_position" n'))
###   ("_applC" ("_position" PDG.PDG_path)
###     ("_cargs" ("_position" sourcenode)
###       ("_cargs" ("_position" targetnode)
###         ("_cargs" ("_position" valid_edge)
###           ("_cargs" ("_position" Def)
###             ("_cargs" ("_position" Use)
###               ("_cargs" ("_position" standard_control_dependence)
###                 ("_cargs" ("_position" n) ("_position" n'))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
val eqpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Var (("_dummy_", 2), "?'a"))
       ):
   term Find_Theorems.criterion
val badeqpattern = Pattern (Const ("Pure.eq", "?'a => ?'a => prop")):
   term Find_Theorems.criterion
val undefpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Const ("HOL.undefined", "?'a"))
       ):
   term Find_Theorems.criterion
val thmpattern =
   Pattern
    (Const ("HOL.Trueprop", "bool => prop") $ Var (("_dummy_", 1), "bool")):
   term Find_Theorems.criterion
val badnames =
   ["*nitpick*", "*Nitpick*", "*full_exhaustive*", "*_def*", "Enum.finite*",
    "*Quickcheck*", "ATP*", "*Nunchaku*", "*Code*", "*BNF*", "*SMT*",
    "*.*.*"]:
   string list
val unwanted_names =
   [(false, Name "*nitpick*"), (false, Name "*Nitpick*"),
    (false, Name "*full_exhaustive*"), (false, Name "*_def*"),
    (false, Name "Enum.finite*"), (false, Name "*Quickcheck*"),
    (false, Name "ATP*"), (false, Name "*Nunchaku*"),
    (false, Name "*Code*"), (false, Name "*BNF*"), (false, Name "*SMT*"),
    (false, Name "*.*.*")]:
   (bool * term Find_Theorems.criterion) list
val has_vars = fn: term -> bool
val get_all_eqs = fn: string -> Proof.context -> (string * thm) list
val get_all_thms = fn: string -> Proof.context -> (string * thm) list
val get_noneq_thms = fn: string -> Proof.context -> (string * thm) list
val template_eqs = fn:
   string -> Proof.context -> (string * thm * template) list
val template_thms = fn:
   string -> Proof.context -> (string * thm * template) list
### theory "Draft.ExtrEqs"
### 0.856s elapsed time, 2.257s cpu time, 0.976s GC time
locale WeakControlDependencePDG
  fixes sourcenode :: "'edge => 'node"
    and targetnode :: "'edge => 'node"
    and kind :: "'edge => 'state edge_kind"
    and valid_edge :: "'edge => bool"
    and Entry :: "'node"  (\<open>'('_Entry'_')\<close>)
    and Def :: "'node => 'var set"
    and Use :: "'node => 'var set"
    and state_val :: "'state => 'var => 'val"
    and Exit :: "'node"  (\<open>'('_Exit'_')\<close>)
  assumes
    "WeakControlDependencePDG sourcenode targetnode kind valid_edge
      (_Entry_) Def Use state_val (_Exit_)"
locale CFG_wf
  fixes sourcenode :: "'edge => 'node"
    and targetnode :: "'edge => 'node"
    and kind :: "'edge => 'state edge_kind"
    and valid_edge :: "'edge => bool"
    and Entry :: "'node"  (\<open>'('_Entry'_')\<close>)
    and Def :: "'node => 'var set"
    and Use :: "'node => 'var set"
    and state_val :: "'state => 'var => 'val"
  assumes
    "CFG_wf sourcenode targetnode kind valid_edge (_Entry_) Def Use
      state_val"
### theory "Draft.CDepInstantiations"
### 0.368s elapsed time, 0.658s cpu time, 0.040s GC time
Loading theory "Draft.WellFormed" (required by "Draft.DynamicControlDependencesMoreTemplates" via "Draft.DynamicControlDependences" via "Draft.AdditionalLemmas")
### Ambiguous input (line 15 of "$AFP/Slicing/While/WellFormed.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_Update" ("_position" lhs)
###       ("_updbind" ("_position" V) ("_position" e)))
###     ("_Finset" ("_position" V))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" lhs)
###       ("\<^const>Com.cmd.LAss" ("_position" V) ("_position" e)))
###     ("_Finset" ("_position" V))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
### Ambiguous input (line 29 of "$AFP/Slicing/While/WellFormed.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_Update" ("_position" rhs)
###       ("_updbind" ("_position" V) ("_position" e)))
###     ("_applC" ("_position" rhs_aux) ("_position" e))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" rhs)
###       ("\<^const>Com.cmd.LAss" ("_position" V) ("_position" e)))
###     ("_applC" ("_position" rhs_aux) ("_position" e))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Found termination order: "size <*mlex*> {}"
Found termination order: "{}"
Found termination order: "{}"
### theory "Draft.WellFormed"
### 0.486s elapsed time, 0.529s cpu time, 0.034s GC time
Loading theory "Draft.AdditionalLemmas" (required by "Draft.DynamicControlDependencesMoreTemplates" via "Draft.DynamicControlDependences")
### Ambiguous input (line 18 of "$AFP/Slicing/While/AdditionalLemmas.thy") produces 2 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>AdditionalLemmas.path" ("_position" prog) ("_position" n)
###       ("_position" as) ("\<^const>WCFG.w_node.Node" ("_position" l))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>AdditionalLemmas.path"
###       ("\<^const>Com.cmd.Seq" ("_position" prog) ("_position" c\<^sub>2))
###       ("_position" n) ("_position" as)
###       ("\<^const>WCFG.w_node.Node" ("_position" l)))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>AdditionalLemmas.path" ("_position" prog) ("_position" n)
###       ("_position" as) ("\<^const>WCFG.w_node.Node" ("_position" l))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Com.cmd.Seq" ("_position" prog)
###       ("\<^const>AdditionalLemmas.path" ("_position" c\<^sub>2)
###         ("_position" n) ("_position" as)
###         ("\<^const>WCFG.w_node.Node" ("_position" l))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 40 of "$AFP/Slicing/While/AdditionalLemmas.thy") produces 5 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>AdditionalLemmas.path" ("_position" prog) ("_position" n)
###         ("_position" as) ("_position" n')))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.not_equal" ("_position" n)
###           ("\<^const>WCFG.w_node.Entry")))
###       ("_asm"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.not_equal" ("_position" as)
###             ("\<^const>List.list.Nil"))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>WCFG.label_incr"
###       ("\<^const>AdditionalLemmas.path"
###         ("\<^const>Com.cmd.Seq" ("_position" c\<^sub>1) ("_position" prog))
###         ("\<^const>WCFG.label_incr" ("_position" n)
###           ("\<^const>Com.num_inner_nodes" ("_position" c\<^sub>1)))
###         ("\<^const>AdditionalLemmas.label_incrs" ("_position" as)
###           ("\<^const>Com.num_inner_nodes" ("_position" c\<^sub>1)))
###         ("_position" n'))
###       ("\<^const>Com.num_inner_nodes" ("_position" c\<^sub>1)))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>AdditionalLemmas.path" ("_position" prog) ("_position" n)
###         ("_position" as) ("_position" n')))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.not_equal" ("_position" n)
###           ("\<^const>WCFG.w_node.Entry")))
###       ("_asm"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.not_equal" ("_position" as)
###             ("\<^const>List.list.Nil"))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>AdditionalLemmas.path"
###       ("\<^const>Com.cmd.Seq" ("_position" c\<^sub>1) ("_position" prog))
###       ("\<^const>WCFG.label_incr" ("_position" n)
###         ("\<^const>Com.num_inner_nodes" ("_position" c\<^sub>1)))
###       ("\<^const>AdditionalLemmas.label_incrs" ("_position" as)
###         ("\<^const>Com.num_inner_nodes" ("_position" c\<^sub>1)))
###       ("\<^const>WCFG.label_incr" ("_position" n')
###         ("\<^const>Com.num_inner_nodes" ("_position" c\<^sub>1))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>AdditionalLemmas.path" ("_position" prog) ("_position" n)
###         ("_position" as) ("_position" n')))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.not_equal" ("_position" n)
###           ("\<^const>WCFG.w_node.Entry")))
###       ("_asm"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.not_equal" ("_position" as)
###             ("\<^const>List.list.Nil"))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Com.cmd.Seq" ("_position" c\<^sub>1)
###       ("\<^const>AdditionalLemmas.path" ("_position" prog)
###         ("\<^const>WCFG.label_incr" ("_position" n)
###           ("\<^const>Com.num_inner_nodes" ("_position" c\<^sub>1)))
###         ("\<^const>AdditionalLemmas.label_incrs" ("_position" as)
###           ("\<^const>Com.num_inner_nodes" ("_position" c\<^sub>1)))
###         ("\<^const>WCFG.label_incr" ("_position" n')
###           ("\<^const>Com.num_inner_nodes" ("_position" c\<^sub>1)))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>AdditionalLemmas.path" ("_position" prog) ("_position" n)
###         ("_position" as) ("_position" n')))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.not_equal" ("_position" n)
###           ("\<^const>WCFG.w_node.Entry")))
###       ("_asm"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.not_equal" ("_position" as)
###             ("\<^const>List.list.Nil"))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>WCFG.label_incr"
###       ("\<^const>Com.cmd.Seq" ("_position" c\<^sub>1)
###         ("\<^const>AdditionalLemmas.path" ("_position" prog)
###           ("\<^const>WCFG.label_incr" ("_position" n)
###             ("\<^const>Com.num_inner_nodes" ("_position" c\<^sub>1)))
###           ("\<^const>AdditionalLemmas.label_incrs" ("_position" as)
###             ("\<^const>Com.num_inner_nodes" ("_position" c\<^sub>1)))
###           ("_position" n')))
###       ("\<^const>Com.num_inner_nodes" ("_position" c\<^sub>1)))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>AdditionalLemmas.path" ("_position" prog) ("_position" n)
###         ("_position" as) ("_position" n')))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.not_equal" ("_position" n)
###           ("\<^const>WCFG.w_node.Entry")))
###       ("_asm"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.not_equal" ("_position" as)
###             ("\<^const>List.list.Nil"))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Com.cmd.Seq" ("_position" c\<^sub>1)
###       ("\<^const>WCFG.label_incr"
###         ("\<^const>AdditionalLemmas.path" ("_position" prog)
###           ("\<^const>WCFG.label_incr" ("_position" n)
###             ("\<^const>Com.num_inner_nodes" ("_position" c\<^sub>1)))
###           ("\<^const>AdditionalLemmas.label_incrs" ("_position" as)
###             ("\<^const>Com.num_inner_nodes" ("_position" c\<^sub>1)))
###           ("_position" n'))
###         ("\<^const>Com.num_inner_nodes" ("_position" c\<^sub>1))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 77 of "$AFP/Slicing/While/AdditionalLemmas.thy") produces 4 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>AdditionalLemmas.path" ("_position" prog)
###       ("\<^const>WCFG.w_node.Node" ("_position" l)) ("_position" as)
###       ("_position" n')))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>WCFG.label_incr"
###       ("\<^const>AdditionalLemmas.path"
###         ("\<^const>Com.cmd.Cond" ("_position" b) ("_position" prog)
###           ("_position" c\<^sub>2))
###         ("\<^const>WCFG.label_incr"
###           ("\<^const>WCFG.w_node.Node" ("_position" l))
###           ("\<^const>Groups.one_class.one"))
###         ("\<^const>AdditionalLemmas.label_incrs" ("_position" as)
###           ("\<^const>Groups.one_class.one"))
###         ("_position" n'))
###       ("\<^const>Groups.one_class.one"))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>AdditionalLemmas.path" ("_position" prog)
###       ("\<^const>WCFG.w_node.Node" ("_position" l)) ("_position" as)
###       ("_position" n')))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>AdditionalLemmas.path"
###       ("\<^const>Com.cmd.Cond" ("_position" b) ("_position" prog)
###         ("_position" c\<^sub>2))
###       ("\<^const>WCFG.label_incr"
###         ("\<^const>WCFG.w_node.Node" ("_position" l))
###         ("\<^const>Groups.one_class.one"))
###       ("\<^const>AdditionalLemmas.label_incrs" ("_position" as)
###         ("\<^const>Groups.one_class.one"))
###       ("\<^const>WCFG.label_incr" ("_position" n')
###         ("\<^const>Groups.one_class.one")))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>AdditionalLemmas.path" ("_position" prog)
###       ("\<^const>WCFG.w_node.Node" ("_position" l)) ("_position" as)
###       ("_position" n')))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Com.cmd.Cond" ("_position" b) ("_position" prog)
###       ("\<^const>AdditionalLemmas.path" ("_position" c\<^sub>2)
###         ("\<^const>WCFG.label_incr"
###           ("\<^const>WCFG.w_node.Node" ("_position" l))
###           ("\<^const>Groups.one_class.one"))
###         ("\<^const>AdditionalLemmas.label_incrs" ("_position" as)
###           ("\<^const>Groups.one_class.one"))
###         ("\<^const>WCFG.label_incr" ("_position" n')
###           ("\<^const>Groups.one_class.one"))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>AdditionalLemmas.path" ("_position" prog)
###       ("\<^const>WCFG.w_node.Node" ("_position" l)) ("_position" as)
###       ("_position" n')))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>WCFG.label_incr"
###       ("\<^const>Com.cmd.Cond" ("_position" b) ("_position" prog)
###         ("\<^const>AdditionalLemmas.path" ("_position" c\<^sub>2)
###           ("\<^const>WCFG.label_incr"
###             ("\<^const>WCFG.w_node.Node" ("_position" l))
###             ("\<^const>Groups.one_class.one"))
###           ("\<^const>AdditionalLemmas.label_incrs" ("_position" as)
###             ("\<^const>Groups.one_class.one"))
###           ("_position" n')))
###       ("\<^const>Groups.one_class.one"))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 132 of "$AFP/Slicing/While/AdditionalLemmas.thy") produces 32 parse trees (10 displayed):
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>AdditionalLemmas.path" ("_position" prog)
###       ("\<^const>WCFG.w_node.Node" ("_position" l)) ("_position" as)
###       ("_position" n')))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>WCFG.label_incr"
###       ("\<^const>AdditionalLemmas.path"
###         ("\<^const>Com.cmd.Cond" ("_position" b) ("_position" c\<^sub>1)
###           ("_position" prog))
###         ("\<^const>WCFG.label_incr"
###           ("\<^const>WCFG.w_node.Node" ("_position" l))
###           ("\<^const>Com.num_inner_nodes"
###             ("\<^const>Groups.plus_class.plus" ("_position" c\<^sub>1)
###               ("\<^const>Groups.one_class.one"))))
###         ("\<^const>AdditionalLemmas.label_incrs" ("_position" as)
###           ("\<^const>Com.num_inner_nodes"
###             ("\<^const>Groups.plus_class.plus" ("_position" c\<^sub>1)
###               ("\<^const>Groups.one_class.one"))))
###         ("_position" n'))
###       ("\<^const>Com.num_inner_nodes"
###         ("\<^const>Groups.plus_class.plus" ("_position" c\<^sub>1)
###           ("\<^const>Groups.one_class.one"))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>AdditionalLemmas.path" ("_position" prog)
###       ("\<^const>WCFG.w_node.Node" ("_position" l)) ("_position" as)
###       ("_position" n')))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>AdditionalLemmas.path"
###       ("\<^const>Com.cmd.Cond" ("_position" b) ("_position" c\<^sub>1)
###         ("_position" prog))
###       ("\<^const>WCFG.label_incr"
###         ("\<^const>WCFG.w_node.Node" ("_position" l))
###         ("\<^const>Com.num_inner_nodes"
###           ("\<^const>Groups.plus_class.plus" ("_position" c\<^sub>1)
###             ("\<^const>Groups.one_class.one"))))
###       ("\<^const>AdditionalLemmas.label_incrs" ("_position" as)
###         ("\<^const>Com.num_inner_nodes"
###           ("\<^const>Groups.plus_class.plus" ("_position" c\<^sub>1)
###             ("\<^const>Groups.one_class.one"))))
###       ("\<^const>WCFG.label_incr" ("_position" n')
###         ("\<^const>Com.num_inner_nodes"
###           ("\<^const>Groups.plus_class.plus" ("_position" c\<^sub>1)
###             ("\<^const>Groups.one_class.one")))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>AdditionalLemmas.path" ("_position" prog)
###       ("\<^const>WCFG.w_node.Node" ("_position" l)) ("_position" as)
###       ("_position" n')))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Com.cmd.Cond" ("_position" b) ("_position" c\<^sub>1)
###       ("\<^const>AdditionalLemmas.path" ("_position" prog)
###         ("\<^const>WCFG.label_incr"
###           ("\<^const>WCFG.w_node.Node" ("_position" l))
###           ("\<^const>Com.num_inner_nodes"
###             ("\<^const>Groups.plus_class.plus" ("_position" c\<^sub>1)
###               ("\<^const>Groups.one_class.one"))))
###         ("\<^const>AdditionalLemmas.label_incrs" ("_position" as)
###           ("\<^const>Com.num_inner_nodes"
###             ("\<^const>Groups.plus_class.plus" ("_position" c\<^sub>1)
###               ("\<^const>Groups.one_class.one"))))
###         ("\<^const>WCFG.label_incr" ("_position" n')
###           ("\<^const>Com.num_inner_nodes"
###             ("\<^const>Groups.plus_class.plus" ("_position" c\<^sub>1)
###               ("\<^const>Groups.one_class.one"))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>AdditionalLemmas.path" ("_position" prog)
###       ("\<^const>WCFG.w_node.Node" ("_position" l)) ("_position" as)
###       ("_position" n')))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>AdditionalLemmas.path"
###       ("\<^const>Com.cmd.Cond" ("_position" b) ("_position" c\<^sub>1)
###         ("_position" prog))
###       ("\<^const>WCFG.label_incr"
###         ("\<^const>WCFG.w_node.Node" ("_position" l))
###         ("\<^const>Groups.plus_class.plus"
###           ("\<^const>Com.num_inner_nodes" ("_position" c\<^sub>1))
###           ("\<^const>Groups.one_class.one")))
###       ("\<^const>AdditionalLemmas.label_incrs" ("_position" as)
###         ("\<^const>Com.num_inner_nodes"
###           ("\<^const>Groups.plus_class.plus" ("_position" c\<^sub>1)
###             ("\<^const>Groups.one_class.one"))))
###       ("\<^const>WCFG.label_incr" ("_position" n')
###         ("\<^const>Com.num_inner_nodes"
###           ("\<^const>Groups.plus_class.plus" ("_position" c\<^sub>1)
###             ("\<^const>Groups.one_class.one")))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>AdditionalLemmas.path" ("_position" prog)
###       ("\<^const>WCFG.w_node.Node" ("_position" l)) ("_position" as)
###       ("_position" n')))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Com.cmd.Cond" ("_position" b) ("_position" c\<^sub>1)
###       ("\<^const>AdditionalLemmas.path" ("_position" prog)
###         ("\<^const>WCFG.label_incr"
###           ("\<^const>WCFG.w_node.Node" ("_position" l))
###           ("\<^const>Groups.plus_class.plus"
###             ("\<^const>Com.num_inner_nodes" ("_position" c\<^sub>1))
###             ("\<^const>Groups.one_class.one")))
###         ("\<^const>AdditionalLemmas.label_incrs" ("_position" as)
###           ("\<^const>Com.num_inner_nodes"
###             ("\<^const>Groups.plus_class.plus" ("_position" c\<^sub>1)
###               ("\<^const>Groups.one_class.one"))))
###         ("\<^const>WCFG.label_incr" ("_position" n')
###           ("\<^const>Com.num_inner_nodes"
###             ("\<^const>Groups.plus_class.plus" ("_position" c\<^sub>1)
###               ("\<^const>Groups.one_class.one"))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>AdditionalLemmas.path" ("_position" prog)
###       ("\<^const>WCFG.w_node.Node" ("_position" l)) ("_position" as)
###       ("_position" n')))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>AdditionalLemmas.path"
###       ("\<^const>Com.cmd.Cond" ("_position" b) ("_position" c\<^sub>1)
###         ("_position" prog))
###       ("\<^const>WCFG.label_incr"
###         ("\<^const>WCFG.w_node.Node" ("_position" l))
###         ("\<^const>Com.num_inner_nodes"
###           ("\<^const>Groups.plus_class.plus" ("_position" c\<^sub>1)
###             ("\<^const>Groups.one_class.one"))))
###       ("\<^const>AdditionalLemmas.label_incrs" ("_position" as)
###         ("\<^const>Groups.plus_class.plus"
###           ("\<^const>Com.num_inner_nodes" ("_position" c\<^sub>1))
###           ("\<^const>Groups.one_class.one")))
###       ("\<^const>WCFG.label_incr" ("_position" n')
###         ("\<^const>Com.num_inner_nodes"
###           ("\<^const>Groups.plus_class.plus" ("_position" c\<^sub>1)
###             ("\<^const>Groups.one_class.one")))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>AdditionalLemmas.path" ("_position" prog)
###       ("\<^const>WCFG.w_node.Node" ("_position" l)) ("_position" as)
###       ("_position" n')))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Com.cmd.Cond" ("_position" b) ("_position" c\<^sub>1)
###       ("\<^const>AdditionalLemmas.path" ("_position" prog)
###         ("\<^const>WCFG.label_incr"
###           ("\<^const>WCFG.w_node.Node" ("_position" l))
###           ("\<^const>Com.num_inner_nodes"
###             ("\<^const>Groups.plus_class.plus" ("_position" c\<^sub>1)
###               ("\<^const>Groups.one_class.one"))))
###         ("\<^const>AdditionalLemmas.label_incrs" ("_position" as)
###           ("\<^const>Groups.plus_class.plus"
###             ("\<^const>Com.num_inner_nodes" ("_position" c\<^sub>1))
###             ("\<^const>Groups.one_class.one")))
###         ("\<^const>WCFG.label_incr" ("_position" n')
###           ("\<^const>Com.num_inner_nodes"
###             ("\<^const>Groups.plus_class.plus" ("_position" c\<^sub>1)
###               ("\<^const>Groups.one_class.one"))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>AdditionalLemmas.path" ("_position" prog)
###       ("\<^const>WCFG.w_node.Node" ("_position" l)) ("_position" as)
###       ("_position" n')))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>AdditionalLemmas.path"
###       ("\<^const>Com.cmd.Cond" ("_position" b) ("_position" c\<^sub>1)
###         ("_position" prog))
###       ("\<^const>WCFG.label_incr"
###         ("\<^const>WCFG.w_node.Node" ("_position" l))
###         ("\<^const>Groups.plus_class.plus"
###           ("\<^const>Com.num_inner_nodes" ("_position" c\<^sub>1))
###           ("\<^const>Groups.one_class.one")))
###       ("\<^const>AdditionalLemmas.label_incrs" ("_position" as)
###         ("\<^const>Groups.plus_class.plus"
###           ("\<^const>Com.num_inner_nodes" ("_position" c\<^sub>1))
###           ("\<^const>Groups.one_class.one")))
###       ("\<^const>WCFG.label_incr" ("_position" n')
###         ("\<^const>Com.num_inner_nodes"
###           ("\<^const>Groups.plus_class.plus" ("_position" c\<^sub>1)
###             ("\<^const>Groups.one_class.one")))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>AdditionalLemmas.path" ("_position" prog)
###       ("\<^const>WCFG.w_node.Node" ("_position" l)) ("_position" as)
###       ("_position" n')))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Com.cmd.Cond" ("_position" b) ("_position" c\<^sub>1)
###       ("\<^const>AdditionalLemmas.path" ("_position" prog)
###         ("\<^const>WCFG.label_incr"
###           ("\<^const>WCFG.w_node.Node" ("_position" l))
###           ("\<^const>Groups.plus_class.plus"
###             ("\<^const>Com.num_inner_nodes" ("_position" c\<^sub>1))
###             ("\<^const>Groups.one_class.one")))
###         ("\<^const>AdditionalLemmas.label_incrs" ("_position" as)
###           ("\<^const>Groups.plus_class.plus"
###             ("\<^const>Com.num_inner_nodes" ("_position" c\<^sub>1))
###             ("\<^const>Groups.one_class.one")))
###         ("\<^const>WCFG.label_incr" ("_position" n')
###           ("\<^const>Com.num_inner_nodes"
###             ("\<^const>Groups.plus_class.plus" ("_position" c\<^sub>1)
###               ("\<^const>Groups.one_class.one"))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>AdditionalLemmas.path" ("_position" prog)
###       ("\<^const>WCFG.w_node.Node" ("_position" l)) ("_position" as)
###       ("_position" n')))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>WCFG.label_incr"
###       ("\<^const>Com.cmd.Cond" ("_position" b) ("_position" c\<^sub>1)
###         ("\<^const>AdditionalLemmas.path" ("_position" prog)
###           ("\<^const>WCFG.label_incr"
###             ("\<^const>WCFG.w_node.Node" ("_position" l))
###             ("\<^const>Com.num_inner_nodes"
###               ("\<^const>Groups.plus_class.plus" ("_position" c\<^sub>1)
###                 ("\<^const>Groups.one_class.one"))))
###           ("\<^const>AdditionalLemmas.label_incrs" ("_position" as)
###             ("\<^const>Com.num_inner_nodes"
###               ("\<^const>Groups.plus_class.plus" ("_position" c\<^sub>1)
###                 ("\<^const>Groups.one_class.one"))))
###           ("_position" n')))
###       ("\<^const>Com.num_inner_nodes"
###         ("\<^const>Groups.plus_class.plus" ("_position" c\<^sub>1)
###           ("\<^const>Groups.one_class.one"))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 193 of "$AFP/Slicing/While/AdditionalLemmas.thy") produces 4 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>AdditionalLemmas.path" ("_position" prog)
###       ("\<^const>WCFG.w_node.Node" ("_position" l)) ("_position" as)
###       ("\<^const>WCFG.w_node.Node" ("_position" l'))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Com.cmd.While" ("_position" b)
###       ("\<^const>AdditionalLemmas.path" ("_position" prog)
###         ("\<^const>WCFG.label_incr"
###           ("\<^const>WCFG.w_node.Node" ("_position" l))
###           ("_Numeral" ("_constify" ("_position" 2))))
###         ("\<^const>AdditionalLemmas.label_incrs" ("_position" as)
###           ("_Numeral" ("_constify" ("_position" 2))))
###         ("\<^const>WCFG.label_incr"
###           ("\<^const>WCFG.w_node.Node" ("_position" l'))
###           ("_Numeral" ("_constify" ("_position" 2))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>AdditionalLemmas.path" ("_position" prog)
###       ("\<^const>WCFG.w_node.Node" ("_position" l)) ("_position" as)
###       ("\<^const>WCFG.w_node.Node" ("_position" l'))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>AdditionalLemmas.path"
###       ("\<^const>Com.cmd.While" ("_position" b) ("_position" prog))
###       ("\<^const>WCFG.label_incr"
###         ("\<^const>WCFG.w_node.Node" ("_position" l))
###         ("_Numeral" ("_constify" ("_position" 2))))
###       ("\<^const>AdditionalLemmas.label_incrs" ("_position" as)
###         ("_Numeral" ("_constify" ("_position" 2))))
###       ("\<^const>WCFG.label_incr"
###         ("\<^const>WCFG.w_node.Node" ("_position" l'))
###         ("_Numeral" ("_constify" ("_position" 2)))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>AdditionalLemmas.path" ("_position" prog)
###       ("\<^const>WCFG.w_node.Node" ("_position" l)) ("_position" as)
###       ("\<^const>WCFG.w_node.Node" ("_position" l'))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>WCFG.label_incr"
###       ("\<^const>Com.cmd.While" ("_position" b)
###         ("\<^const>AdditionalLemmas.path" ("_position" prog)
###           ("\<^const>WCFG.label_incr"
###             ("\<^const>WCFG.w_node.Node" ("_position" l))
###             ("_Numeral" ("_constify" ("_position" 2))))
###           ("\<^const>AdditionalLemmas.label_incrs" ("_position" as)
###             ("_Numeral" ("_constify" ("_position" 2))))
###           ("\<^const>WCFG.w_node.Node" ("_position" l'))))
###       ("_Numeral" ("_constify" ("_position" 2))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>AdditionalLemmas.path" ("_position" prog)
###       ("\<^const>WCFG.w_node.Node" ("_position" l)) ("_position" as)
###       ("\<^const>WCFG.w_node.Node" ("_position" l'))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>WCFG.label_incr"
###       ("\<^const>AdditionalLemmas.path"
###         ("\<^const>Com.cmd.While" ("_position" b) ("_position" prog))
###         ("\<^const>WCFG.label_incr"
###           ("\<^const>WCFG.w_node.Node" ("_position" l))
###           ("_Numeral" ("_constify" ("_position" 2))))
###         ("\<^const>AdditionalLemmas.label_incrs" ("_position" as)
###           ("_Numeral" ("_constify" ("_position" 2))))
###         ("\<^const>WCFG.w_node.Node" ("_position" l')))
###       ("_Numeral" ("_constify" ("_position" 2))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 243 of "$AFP/Slicing/While/AdditionalLemmas.thy") produces 4 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Orderings.ord_class.less" ("_position" l)
###       ("\<^const>Com.num_inner_nodes" ("_position" prog))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.conj"
###       ("\<^const>AdditionalLemmas.path"
###         ("\<^const>HOL.Ex_binder" ("_position" as) ("_position" prog))
###         ("\<^const>WCFG.w_node.Node" ("_position" l)) ("_position" as)
###         ("\<^const>WCFG.w_node.Exit"))
###       ("\<^const>AdditionalLemmas.path"
###         ("\<^const>HOL.Ex_binder" ("_position" as) ("_position" prog))
###         ("\<^const>WCFG.w_node.Entry") ("_position" as)
###         ("\<^const>WCFG.w_node.Node" ("_position" l))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Orderings.ord_class.less" ("_position" l)
###       ("\<^const>Com.num_inner_nodes" ("_position" prog))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.conj"
###       ("\<^const>HOL.Ex_binder" ("_position" as)
###         ("\<^const>AdditionalLemmas.path" ("_position" prog)
###           ("\<^const>WCFG.w_node.Node" ("_position" l)) ("_position" as)
###           ("\<^const>WCFG.w_node.Exit")))
###       ("\<^const>AdditionalLemmas.path"
###         ("\<^const>HOL.Ex_binder" ("_position" as) ("_position" prog))
###         ("\<^const>WCFG.w_node.Entry") ("_position" as)
###         ("\<^const>WCFG.w_node.Node" ("_position" l))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Orderings.ord_class.less" ("_position" l)
###       ("\<^const>Com.num_inner_nodes" ("_position" prog))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.conj"
###       ("\<^const>AdditionalLemmas.path"
###         ("\<^const>HOL.Ex_binder" ("_position" as) ("_position" prog))
###         ("\<^const>WCFG.w_node.Node" ("_position" l)) ("_position" as)
###         ("\<^const>WCFG.w_node.Exit"))
###       ("\<^const>HOL.Ex_binder" ("_position" as)
###         ("\<^const>AdditionalLemmas.path" ("_position" prog)
###           ("\<^const>WCFG.w_node.Entry") ("_position" as)
###           ("\<^const>WCFG.w_node.Node" ("_position" l)))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Orderings.ord_class.less" ("_position" l)
###       ("\<^const>Com.num_inner_nodes" ("_position" prog))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.conj"
###       ("\<^const>HOL.Ex_binder" ("_position" as)
###         ("\<^const>AdditionalLemmas.path" ("_position" prog)
###           ("\<^const>WCFG.w_node.Node" ("_position" l)) ("_position" as)
###           ("\<^const>WCFG.w_node.Exit")))
###       ("\<^const>HOL.Ex_binder" ("_position" as)
###         ("\<^const>AdditionalLemmas.path" ("_position" prog)
###           ("\<^const>WCFG.w_node.Entry") ("_position" as)
###           ("\<^const>WCFG.w_node.Node" ("_position" l)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 619 of "$AFP/Slicing/While/AdditionalLemmas.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>AdditionalLemmas.path"
###     ("\<^const>HOL.Ex_binder" ("_position" as) ("_position" prog))
###     ("_position" n) ("_position" as) ("\<^const>WCFG.w_node.Exit")))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.Ex_binder" ("_position" as)
###     ("\<^const>AdditionalLemmas.path" ("_position" prog) ("_position" n)
###       ("_position" as) ("\<^const>WCFG.w_node.Exit"))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 643 of "$AFP/Slicing/While/AdditionalLemmas.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>AdditionalLemmas.path"
###     ("\<^const>HOL.Ex_binder" ("_position" as) ("_position" prog))
###     ("\<^const>WCFG.w_node.Entry") ("_position" as) ("_position" n)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.Ex_binder" ("_position" as)
###     ("\<^const>AdditionalLemmas.path" ("_position" prog)
###       ("\<^const>WCFG.w_node.Entry") ("_position" as) ("_position" n))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "Draft.AdditionalLemmas"
### 0.105s elapsed time, 0.112s cpu time, 0.000s GC time
Loading theory "Draft.DynamicControlDependences" (required by "Draft.DynamicControlDependencesMoreTemplates")
### theory "Draft.DynamicControlDependences"
### 0.173s elapsed time, 0.234s cpu time, 0.082s GC time
Loading theory "Draft.DynamicControlDependencesMoreTemplates"
val templateLemmas = []: (string * thm * template) list
### theory "Draft.DynamicControlDependencesMoreTemplates"
### 0.385s elapsed time, 0.556s cpu time, 0.047s GC time
val it = (): unit
