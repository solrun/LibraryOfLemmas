Loading theory "Complex_Bounded_Operators.Extra_Lattice" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Complex_Bounded_Operators.Complex_L2" via "Complex_Bounded_Operators.Complex_Bounded_Linear_Function" via "Complex_Bounded_Operators.Complex_Inner_Product" via "Complex_Bounded_Operators.Complex_Inner_Product0" via "Complex_Bounded_Operators.Complex_Vector_Spaces")
Loading theory "Containers.Equal" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl" via "Containers.DList_Set")
Loading theory "Containers.Extend_Partial_Order" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl" via "Containers.RBT_Set2" via "Containers.RBT_Mapping2" via "Containers.Collection_Order" via "Containers.Set_Linorder")
Loading theory "Containers.List_Fusion" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl" via "Containers.RBT_Set2" via "Containers.RBT_Mapping2" via "Containers.Collection_Order" via "Containers.Set_Linorder" via "Containers.Lexicographic_Order")
locale equal_base
  fixes equal :: "'a => 'a => bool"
bundle lattice_notation
locale Equal.equal
  fixes equal :: "'a => 'a => bool"
  assumes "equal equal"
bundle no_lattice_notation
### theory "Containers.Equal"
### 0.042s elapsed time, 0.190s cpu time, 0.013s GC time
Loading theory "Containers.Closure_Set" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl")
Proofs for inductive predicate(s) "terminates_onp"
  Proving monotonicity ...
locale equal_base
  fixes equal :: "'a => 'a => bool"
### theory "Containers.Closure_Set"
### 0.041s elapsed time, 0.158s cpu time, 0.000s GC time
Loading theory "Deriving.Comparator" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl" via "Containers.RBT_Set2" via "Containers.RBT_Mapping2" via "Containers.Collection_Order" via "Deriving.Compare_Instances" via "Deriving.Compare_Generator" via "Deriving.Comparator_Generator")
### theory "Containers.Extend_Partial_Order"
### 0.117s elapsed time, 0.495s cpu time, 0.013s GC time
Loading theory "Deriving.Derive_Manager" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl" via "Containers.Collection_Enum" via "Containers.Containers_Generator")
signature DERIVE_MANAGER =
  sig
    val derive: string -> string -> string -> theory -> theory
    val derive_cmd: string -> string -> string -> theory -> theory
    val print_info: theory -> unit
    val register_derive:
       string ->
         string ->
           (string -> string -> theory -> theory) -> theory -> theory
  end
structure Derive_Manager: DERIVE_MANAGER
### theory "Deriving.Derive_Manager"
### 0.042s elapsed time, 0.162s cpu time, 0.000s GC time
Loading theory "Deriving.Generator_Aux" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl" via "Containers.Collection_Enum" via "Containers.Containers_Generator")
locale list
  fixes g :: "('a, 's) generator"
signature BNF_ACCESS =
  sig
    val bnf_types: Proof.context -> string list -> typ list
    val case_consts: Proof.context -> string list -> term list
    val case_simps: Proof.context -> string list -> thm list list
    val case_thms: Proof.context -> string list -> thm list
    val constr_argument_types:
       Proof.context -> string list -> typ list list list
    val constr_terms: Proof.context -> string -> term list
    val distinct_thms: Proof.context -> string list -> thm list list
    val induct_thms: Proof.context -> string list -> thm list
    val inject_thms: Proof.context -> string list -> thm list list
    val map_comps: Proof.context -> string list -> thm list
    val map_simps: Proof.context -> string list -> thm list list
    val map_terms: Proof.context -> string list -> term list
    val set_simps: Proof.context -> string list -> thm list list
    val set_terms: Proof.context -> string list -> term list list
  end
structure Bnf_Access: BNF_ACCESS
signature GENERATOR_AUX =
  sig
    val OF_option: thm -> thm option list -> thm
    val add_used_tycos:
       Proof.context -> string -> string list -> string list
    val alist_to_string: (string * 'a) list -> string
    val conjI_tac:
       thm list ->
         Proof.context ->
           'a list -> (Proof.context -> int -> tactic) -> tactic
    val create_map:
       (typ -> term) ->
         (string * typ -> 'a -> term) ->
           'a ->
             (typ -> bool) ->
               (local_theory -> string -> bool list) ->
                 (local_theory -> string -> term) ->
                   (local_theory -> string -> 'a -> term) ->
                     string list ->
                       (local_theory -> string -> 'a) ->
                         typ -> local_theory -> term
    val create_partial:
       'a ->
         (typ -> bool) ->
           (local_theory -> string -> bool list) ->
             (local_theory -> string -> term) ->
               (local_theory -> string -> 'a -> term) ->
                 string list ->
                   (local_theory -> string -> 'a) ->
                     typ -> local_theory -> term
    val define_overloaded:
       string * term -> local_theory -> thm * local_theory
    val define_overloaded_generic:
       Attrib.binding * term -> local_theory -> thm * local_theory
    val drop_last: 'a list -> 'a list
    val freeify_tvars: typ -> typ
    val ind_case_to_idxs: 'a list list -> int -> int * int
    val infer_type: Proof.context -> term -> term
    val ints_to_subscript: int list -> string
    val is_class_instance: theory -> string -> sort -> bool
    val lambdas: term list -> term -> term
    val mk_case_tac:
       Proof.context ->
         term option list list ->
           thm ->
             (int ->
                Proof.context * thm list * (string * cterm) list -> tactic)
               -> tactic
    val mk_def: typ -> string -> term -> term
    val mk_id: typ -> term
    val mk_infer_const: string -> Proof.context -> term -> term
    val mutual_recursive_types:
       string -> Proof.context -> string list * typ list
    val prove_multi_future:
       Proof.context ->
         string list ->
           term list ->
             term list ->
               ({context: Proof.context, prems: thm list} -> tactic) ->
                 thm list
    val recursor:
       (string -> 'a) * ('a -> bool list) * string list ->
         bool ->
           (typ -> 'b) ->
             (typ -> 'b) ->
               (typ -> 'b) ->
                 ((typ * 'b option) list * 'a -> 'b) -> typ -> 'b
    val rename_types: (typ * typ) list -> term -> term
    val split_IHs:
       (string -> 'a) * ('a -> bool list) * string list ->
         typ list -> thm list -> thm list list
    val std_recursor_tac:
       (string -> 'a) * ('a -> bool list) * string list ->
         typ list ->
           ('a -> thm) ->
             thm list -> typ -> thm list -> Proof.context -> tactic
    val sub: string -> string
    val subT: string -> typ -> string
    val typ_and_vs_of_typname:
       theory -> string -> sort -> typ * (string * sort) list
    val typ_and_vs_of_used_typname:
       string ->
         bool list -> string list -> typ * (string * string list) list
    val type_parameters:
       typ -> Proof.context -> (string * sort) list * typ list
  end
structure Generator_Aux: GENERATOR_AUX
consts
  list_has_next :: "'a list => bool"
### No equation for constructor "[]"
### theory "Deriving.Generator_Aux"
### 0.129s elapsed time, 0.514s cpu time, 0.053s GC time
Loading theory "Deriving.Equality_Generator" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl" via "Containers.DList_Set" via "Containers.Collection_Eq" via "Deriving.Equality_Instances")
consts
  list_next :: "'a list => 'a * 'a list"
class complemented_lattice = minus + uminus + bounded_lattice +
  assumes "inf_compl_bot": "!!x. x \<sqinter> - x = \<bottom>"
    and "sup_compl_top": "!!x. x \<squnion> - x = \<top>"
    and "diff_eq": "!!x y. x - y = x \<sqinter> - y"
Found termination order: "{}"
Found termination order: "{}"
locale comparator
  fixes comp :: "'a => 'a => order"
  assumes "comparator comp"
Found termination order: "case_sum (%x. Suc 0) (%x. 0) <*mlex*> {}"
signature EQUALITY_GENERATOR =
  sig
    val ensure_info: equality_type -> string -> local_theory -> local_theory
    datatype equality_type = BNF | EQ
    val generate_equality:
       equality_type -> string -> local_theory -> local_theory
    val generate_equalitys_from_bnf_fp:
       string ->
         local_theory ->
           ((term * thm list) list * (term * thm) list) * local_theory
    val get_info: Proof.context -> string -> info option
    type info =
       {equality: term,
        equality_def: thm option,
        equality_thm: thm,
        map: term,
        map_comp: thm option,
        partial_equality_thm: thm,
        pequality: term, used_positions: bool list}
    val register_equality_of: string -> local_theory -> local_theory
    val register_foreign_equality:
       typ -> term -> thm -> local_theory -> local_theory
    val register_foreign_partial_and_full_equality:
       string ->
         term ->
           term ->
             term ->
               thm option ->
                 thm option ->
                   thm -> thm -> bool list -> local_theory -> local_theory
  end
structure Equality_Generator: EQUALITY_GENERATOR
### theory "Deriving.Equality_Generator"
### 0.262s elapsed time, 1.027s cpu time, 0.086s GC time
Loading theory "Deriving.Equality_Instances" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl" via "Containers.DList_Set" via "Containers.Collection_Eq")
generating equality for type "Sum_Type.sum"
generating equality for type "List.list"
generating equality for type "Product_Type.prod"
generating equality for type "Option.option"
### theory "Deriving.Equality_Instances"
### 0.202s elapsed time, 0.698s cpu time, 0.326s GC time
Loading theory "HOL-Combinatorics.Transposition" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Jordan_Normal_Form.Matrix" via "Jordan_Normal_Form.Missing_Ring" via "Jordan_Normal_Form.Missing_Misc" via "HOL-Combinatorics.Permutations")
Proofs for inductive predicate(s) "filter_has_next"
  Proving monotonicity ...
### theory "Deriving.Comparator"
### 0.734s elapsed time, 2.778s cpu time, 0.481s GC time
Loading theory "Deriving.Compare" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl" via "Containers.RBT_Set2" via "Containers.RBT_Mapping2" via "Containers.Collection_Order" via "Deriving.Compare_Instances" via "Deriving.Compare_Generator")
class compare = type +
  fixes compare :: "'a => 'a => order"
  assumes "comparator_compare": "comparator compare"
### theory "HOL-Combinatorics.Transposition"
### 0.123s elapsed time, 0.488s cpu time, 0.000s GC time
Loading theory "Deriving.Comparator_Generator" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl" via "Containers.RBT_Set2" via "Containers.RBT_Mapping2" via "Containers.Collection_Order" via "Deriving.Compare_Instances" via "Deriving.Compare_Generator")
### theory "Containers.List_Fusion"
### 0.955s elapsed time, 3.661s cpu time, 0.541s GC time
Loading theory "HOL-Computational_Algebra.Fraction_Field" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Determinant_Impl" via "Polynomial_Interpolation.Missing_Polynomial" via "HOL-Computational_Algebra.Polynomial_Factorial" via "HOL-Computational_Algebra.Normalized_Fraction")
class compare_order = compare + ord +
  assumes "ord_defs": "le_of_comp compare = (<=)" "lt_of_comp compare = (<)"
Found termination order: "size_list size <*mlex*> {}"
class orthocomplemented_lattice = complemented_lattice +
  assumes "ortho_involution": "!!x. - (- x) = x"
    and "ortho_antimono": "!!x y. x <= y ==> - y <= - x"
instantiation
  fract :: (idom) comm_ring_1
  uminus_fract == uminus :: 'a fract => 'a fract
  one_fract == one_class.one :: 'a fract
  times_fract == times :: 'a fract => 'a fract => 'a fract
  zero_fract == zero_class.zero :: 'a fract
  minus_fract == minus :: 'a fract => 'a fract => 'a fract
  plus_fract == plus :: 'a fract => 'a fract => 'a fract
class compare_order = compare + linorder +
  assumes "ord_defs": "le_of_comp compare = (<=)" "lt_of_comp compare = (<)"
signature COMPARE_CODE =
  sig
    val change_compare_code:
       term -> string list -> local_theory -> local_theory
  end
structure Compare_Code: COMPARE_CODE
### theory "Deriving.Compare"
### 0.575s elapsed time, 2.253s cpu time, 0.161s GC time
Loading theory "HOL-Library.Adhoc_Overloading" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl" via "Containers.Collection_Enum" via "Containers.Containers_Auxiliary" via "HOL-Library.Monad_Syntax")
signature COMPARATOR_GENERATOR =
  sig
    datatype comparator_type = BNF | Linorder
    val ensure_info:
       comparator_type -> string -> local_theory -> local_theory
    val generate_comparator:
       comparator_type -> string -> local_theory -> local_theory
    val generate_comparators_from_bnf_fp:
       string ->
         local_theory ->
           ((term * thm list) list * (term * thm) list) * local_theory
    val get_info: Proof.context -> string -> info option
    type info =
       {comp: term,
        comp_def: thm option,
        comp_thm: thm,
        map: term,
        map_comp: thm option,
        partial_comp_thms: thm list, pcomp: term, used_positions: bool list}
    val register_comparator_of: string -> local_theory -> local_theory
    val register_foreign_comparator:
       typ -> term -> thm -> local_theory -> local_theory
    val register_foreign_partial_and_full_comparator:
       string ->
         term ->
           term ->
             term ->
               thm option ->
                 thm option ->
                   thm ->
                     thm ->
                       thm ->
                         thm -> bool list -> local_theory -> local_theory
  end
structure Comparator_Generator: COMPARATOR_GENERATOR
### theory "Deriving.Comparator_Generator"
### 0.526s elapsed time, 2.064s cpu time, 0.161s GC time
Loading theory "Deriving.Compare_Generator" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl" via "Containers.RBT_Set2" via "Containers.RBT_Mapping2" via "Containers.Collection_Order" via "Deriving.Compare_Instances")
signature ADHOC_OVERLOADING =
  sig
    val generic_add_overloaded: string -> Context.generic -> Context.generic
    val generic_add_variant:
       string -> term -> Context.generic -> Context.generic
    val generic_remove_overloaded:
       string -> Context.generic -> Context.generic
    val generic_remove_variant:
       string -> term -> Context.generic -> Context.generic
    val is_overloaded: Proof.context -> string -> bool
    val show_variants: bool Config.T
  end
structure Adhoc_Overloading: ADHOC_OVERLOADING
### theory "HOL-Library.Adhoc_Overloading"
### 0.077s elapsed time, 0.307s cpu time, 0.024s GC time
Loading theory "HOL-Library.Monad_Syntax" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl" via "Containers.Collection_Enum" via "Containers.Containers_Auxiliary")
### theory "HOL-Library.Monad_Syntax"
### 0.031s elapsed time, 0.126s cpu time, 0.000s GC time
Loading theory "Containers.Containers_Auxiliary" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl" via "Containers.Collection_Enum")
instantiation
  fract :: (idom) field
  inverse_fract == inverse :: 'a fract => 'a fract
  divide_fract == divide :: 'a fract => 'a fract => 'a fract
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
instantiation
  fract :: (linordered_idom) linorder
  less_eq_fract == less_eq :: 'a fract => 'a fract => bool
  less_fract == less :: 'a fract => 'a fract => bool
### Dropping global mixfix syntax: "less_eq_prod" (infix \<open>\<sqsubseteq>\<close> 50)
### Dropping global mixfix syntax: "less_prod" (infix \<open>\<sqsubset>\<close> 50)
instantiation
  fract :: (linordered_idom) linordered_field
  sgn_fract == sgn :: 'a fract => 'a fract
  abs_fract == abs :: 'a fract => 'a fract
### Dropping global mixfix syntax: "less_eq_prod'" (infix \<open>\<sqsubseteq>\<close> 50)
instantiation
  fract :: (linordered_idom) distrib_lattice
  inf_fract == inf :: 'a fract => 'a fract => 'a fract
  sup_fract == sup :: 'a fract => 'a fract => 'a fract
### Dropping global mixfix syntax: "less_prod'" (infix \<open>\<sqsubset>\<close> 50)
### theory "Containers.Containers_Auxiliary"
### 0.165s elapsed time, 0.650s cpu time, 0.029s GC time
Loading theory "HOL-Library.Cancellation" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Jordan_Normal_Form.Matrix" via "Polynomial_Interpolation.Ring_Hom" via "HOL-Library.Multiset")
signature COMPARE_GENERATOR =
  sig
    val compare_instance:
       Comparator_Generator.comparator_type -> string -> theory -> theory
    val compare_order_instance_via_comparator_of: string -> theory -> theory
    val compare_order_instance_via_compare: string -> theory -> theory
  end
structure Compare_Generator: COMPARE_GENERATOR
### theory "HOL-Computational_Algebra.Fraction_Field"
### 0.724s elapsed time, 2.850s cpu time, 0.168s GC time
Loading theory "HOL-Library.Char_ord" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl" via "Containers.RBT_Set2" via "Containers.RBT_Mapping2" via "Containers.Collection_Order" via "Containers.Set_Linorder" via "Containers.Lexicographic_Order")
### theory "Deriving.Compare_Generator"
### 0.274s elapsed time, 1.084s cpu time, 0.053s GC time
Loading theory "HOL-Library.Code_Abstract_Nat" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Quantum" via "HOL-Library.Code_Target_Numeral" via "HOL-Library.Code_Target_Nat")
instantiation
  char :: linorder
  less_eq_char == less_eq :: char => char => bool
  less_char == less :: char => char => bool
### theory "HOL-Library.Code_Abstract_Nat"
### 0.049s elapsed time, 0.192s cpu time, 0.000s GC time
Loading theory "HOL-Library.Code_Target_Nat" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Quantum" via "HOL-Library.Code_Target_Numeral")
instantiation
  char :: distrib_lattice
  inf_char == inf :: char => char => char
  sup_char == sup :: char => char => char
### theory "HOL-Library.Char_ord"
### 0.084s elapsed time, 0.335s cpu time, 0.000s GC time
Loading theory "Containers.Lexicographic_Order" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl" via "Containers.RBT_Set2" via "Containers.RBT_Mapping2" via "Containers.Collection_Order" via "Containers.Set_Linorder")
### Code generator: dropping subsumed code equation
### divmod_nat ?m ?n ==
### if ?n = 0 | ?m < ?n then (0, ?m)
### else let (q, y) = divmod_nat (?m - ?n) ?n in (Suc q, y)
### Code generator: dropping subsumed code equation
### divmod (num.Bit1 ?m) (num.Bit1 ?n) ==
### if ?m < ?n then (0, numeral (num.Bit1 ?m))
### else divmod_step (num.Bit1 ?n)
###       (divmod (num.Bit1 ?m) (num.Bit0 (num.Bit1 ?n)))
### Code generator: dropping subsumed code equation
### divmod (num.Bit0 ?m) (num.Bit1 ?n) ==
### if ?m <= ?n then (0, numeral (num.Bit0 ?m))
### else divmod_step (num.Bit1 ?n)
###       (divmod (num.Bit0 ?m) (num.Bit0 (num.Bit1 ?n)))
### Code generator: dropping subsumed code equation
### divmod (num.Bit1 ?m) (num.Bit0 ?n) ==
### case divmod ?m ?n of (q, r) => (q, 2 * r + 1)
### Code generator: dropping subsumed code equation
### divmod (num.Bit0 ?m) (num.Bit0 ?n) ==
### case divmod ?m ?n of (q, r) => (q, 2 * r)
### Code generator: dropping subsumed code equation
### divmod num.One (num.Bit1 ?n) == (0, Numeral1)
### Code generator: dropping subsumed code equation
### divmod num.One (num.Bit0 ?n) == (0, Numeral1)
### Code generator: dropping subsumed code equation
### divmod ?m num.One == (numeral ?m, 0)
### Code generator: dropping subsumed code equation
### Suc ?m <= ?n == ?m < ?n
### Code generator: dropping subsumed code equation
### 0 <= ?n == True
### Code generator: dropping subsumed code equation
### ?m < Suc ?n == ?m <= ?n
### Code generator: dropping subsumed code equation
### ?n < 0 == False
### Code generator: dropping subsumed code equation
### of_nat ?n == semiring_1_class.of_nat_aux (%i. i + (1::?'a)) ?n (0::?'a)
### theory "HOL-Library.Code_Target_Nat"
### 0.133s elapsed time, 0.520s cpu time, 0.034s GC time
Loading theory "Deriving.Compare_Instances" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl" via "Containers.RBT_Set2" via "Containers.RBT_Mapping2" via "Containers.Collection_Order")
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
signature CANCEL = sig val proc: Proof.context -> cterm -> thm option end
functor Cancel_Fun (Data: CANCEL_NUMERALS_DATA): CANCEL
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
signature CANCEL_DATA =
  sig
    val dest_coeff: term -> int * term
    val dest_sum: term -> term list
    val find_first_coeff: term -> term list -> int * term list
    val mk_coeff: int * term -> term
    val mk_sum: typ -> term list -> term
    val norm_ss1: simpset
    val norm_ss2: simpset
    val norm_tac: Proof.context -> tactic
    val numeral_simp_tac: Proof.context -> tactic
    val prove_conv:
       tactic list -> Proof.context -> thm list -> term * term -> thm option
    val simplify_meta_eq: Proof.context -> thm -> thm
    val trans_tac: Proof.context -> thm option -> tactic
  end
structure Cancel_Data: CANCEL_DATA
deriving "compare_order" instance for type "Int.int"
deriving "compare" instance for type "Int.int"
### theory "Containers.Lexicographic_Order"
### 0.282s elapsed time, 1.103s cpu time, 0.068s GC time
Loading theory "HOL-Library.Code_Target_Int" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Quantum" via "HOL-Library.Code_Target_Numeral")
deriving "compare_order" instance for type "Code_Numeral.integer"
deriving "compare" instance for type "Code_Numeral.integer"
deriving "compare_order" instance for type "Nat.nat"
deriving "compare" instance for type "Nat.nat"
deriving "compare_order" instance for type "String.char"
deriving "compare" instance for type "String.char"
deriving "compare" instance for type "Sum_Type.sum"
generating comparator for type "Sum_Type.sum"
### Code generator: dropping subsumed code equation
### 1 == Int.Pos num.One
### Code generator: dropping subsumed code equation
### Int.Neg ?m + Int.Neg ?n == Int.Neg (?m + ?n)
### Code generator: dropping subsumed code equation
### Int.Neg ?m + Int.Pos ?n == Int.sub ?n ?m
### Code generator: dropping subsumed code equation
### Int.Pos ?m + Int.Neg ?n == Int.sub ?m ?n
### Code generator: dropping subsumed code equation
### Int.Pos ?m + Int.Pos ?n == Int.Pos (?m + ?n)
### Code generator: dropping subsumed code equation
### 0 + ?l == ?l
signature CANCEL_SIMPROCS =
  sig
    val diff_cancel: Proof.context -> cterm -> thm option
    val eq_cancel: Proof.context -> cterm -> thm option
    val less_cancel: Proof.context -> cterm -> thm option
    val less_eq_cancel: Proof.context -> cterm -> thm option
  end
structure Cancel_Simprocs: CANCEL_SIMPROCS
### Code generator: dropping subsumed code equation
### ?k + 0 == ?k
### theory "HOL-Library.Cancellation"
### 0.443s elapsed time, 1.745s cpu time, 0.068s GC time
### Code generator: dropping subsumed code equation
### - Int.Neg ?m == Int.Pos ?m
### Code generator: dropping subsumed code equation
### - Int.Pos ?m == Int.Neg ?m
Loading theory "HOL-Library.Multiset" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Jordan_Normal_Form.Matrix" via "Polynomial_Interpolation.Ring_Hom")
### Code generator: dropping subsumed code equation
### - 0 == 0
### Code generator: dropping subsumed code equation
### Int.Neg ?m - Int.Neg ?n == Int.sub ?n ?m
### Code generator: dropping subsumed code equation
### Int.Neg ?m - Int.Pos ?n == Int.Neg (?m + ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m - Int.Neg ?n == Int.Pos (?m + ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m - Int.Pos ?n == Int.sub ?m ?n
### Code generator: dropping subsumed code equation
### 0 - ?l == - ?l
### Code generator: dropping subsumed code equation
### ?k - 0 == ?k
### Code generator: dropping subsumed code equation
### Int.dup (Int.Neg ?n) == Int.Neg (num.Bit0 ?n)
### Code generator: dropping subsumed code equation
### Int.dup (Int.Pos ?n) == Int.Pos (num.Bit0 ?n)
### Code generator: dropping subsumed code equation
### Int.dup 0 == 0
### Code generator: dropping subsumed code equation
### Int.Neg ?m * Int.Neg ?n == Int.Pos (?m * ?n)
### Code generator: dropping subsumed code equation
### Int.Neg ?m * Int.Pos ?n == Int.Neg (?m * ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m * Int.Neg ?n == Int.Neg (?m * ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m * Int.Pos ?n == Int.Pos (?m * ?n)
### Code generator: dropping subsumed code equation
### 0 * ?l == 0
### Code generator: dropping subsumed code equation
### ?k * 0 == 0
### Code generator: dropping subsumed code equation
### Int.Neg ?m div Int.Neg ?n == fst (divmod ?m ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m div Int.Neg ?n == - Divides.adjust_div (divmod ?m ?n)
### Code generator: dropping subsumed code equation
### Int.Neg ?m div Int.Pos ?n == - Divides.adjust_div (divmod ?m ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m div Int.Pos ?n == fst (divmod ?m ?n)
### Code generator: dropping subsumed code equation
### ?k div Int.Neg num.One == - ?k
### Code generator: dropping subsumed code equation
### ?k div Int.Pos num.One == ?k
### Code generator: dropping subsumed code equation
### 0 div ?k == 0
### Code generator: dropping subsumed code equation
### ?k div 0 == 0
### Code generator: dropping subsumed code equation
### Int.Neg ?m mod Int.Neg ?n == - snd (divmod ?m ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m mod Int.Neg ?n ==
### - Divides.adjust_mod (Int.Pos ?n) (snd (divmod ?m ?n))
### Code generator: dropping subsumed code equation
### Int.Neg ?m mod Int.Pos ?n ==
### Divides.adjust_mod (Int.Pos ?n) (snd (divmod ?m ?n))
### Code generator: dropping subsumed code equation
### Int.Pos ?m mod Int.Pos ?n == snd (divmod ?m ?n)
### Code generator: dropping subsumed code equation
### ?k mod Int.Neg num.One == 0
### Code generator: dropping subsumed code equation
### ?k mod Int.Pos num.One == 0
### Code generator: dropping subsumed code equation
### 0 mod ?k == 0
### Code generator: dropping subsumed code equation
### ?k mod 0 == ?k
### Code generator: dropping subsumed code equation
### divmod (num.Bit1 ?m) (num.Bit1 ?n) ==
### if ?m < ?n then (0, numeral (num.Bit1 ?m))
### else divmod_step (num.Bit1 ?n)
###       (divmod (num.Bit1 ?m) (num.Bit0 (num.Bit1 ?n)))
### Code generator: dropping subsumed code equation
### divmod (num.Bit0 ?m) (num.Bit1 ?n) ==
### if ?m <= ?n then (0, numeral (num.Bit0 ?m))
### else divmod_step (num.Bit1 ?n)
###       (divmod (num.Bit0 ?m) (num.Bit0 (num.Bit1 ?n)))
### Code generator: dropping subsumed code equation
### divmod (num.Bit1 ?m) (num.Bit0 ?n) ==
### case divmod ?m ?n of (q, r) => (q, 2 * r + 1)
### Code generator: dropping subsumed code equation
### divmod (num.Bit0 ?m) (num.Bit0 ?n) ==
### case divmod ?m ?n of (q, r) => (q, 2 * r)
### Code generator: dropping subsumed code equation
### divmod num.One (num.Bit1 ?n) == (0, Numeral1)
### Code generator: dropping subsumed code equation
### divmod num.One (num.Bit0 ?n) == (0, Numeral1)
### Code generator: dropping subsumed code equation
### divmod ?m num.One == (numeral ?m, 0)
### Code generator: dropping subsumed code equation
### equal_class.equal ?k ?k == True
### Code generator: dropping subsumed code equation
### equal_class.equal (Int.Neg ?k) (Int.Neg ?l) == equal_class.equal ?k ?l
### Code generator: dropping subsumed code equation
### equal_class.equal (Int.Neg ?k) (Int.Pos ?l) == False
### Code generator: dropping subsumed code equation
### equal_class.equal (Int.Neg ?k) 0 == False
### Code generator: dropping subsumed code equation
### equal_class.equal (Int.Pos ?k) (Int.Neg ?l) == False
### Code generator: dropping subsumed code equation
### equal_class.equal (Int.Pos ?k) (Int.Pos ?l) == equal_class.equal ?k ?l
### Code generator: dropping subsumed code equation
### equal_class.equal (Int.Pos ?k) 0 == False
### Code generator: dropping subsumed code equation
### equal_class.equal 0 (Int.Neg ?l) == False
### Code generator: dropping subsumed code equation
### equal_class.equal 0 (Int.Pos ?l) == False
### Code generator: dropping subsumed code equation
### equal_class.equal 0 0 == True
### Code generator: dropping subsumed code equation
### Int.Neg ?k <= Int.Neg ?l == ?l <= ?k
### Code generator: dropping subsumed code equation
### Int.Neg ?k <= Int.Pos ?l == True
### Code generator: dropping subsumed code equation
### Int.Neg ?k <= 0 == True
### Code generator: dropping subsumed code equation
### Int.Pos ?k <= Int.Neg ?l == False
### Code generator: dropping subsumed code equation
### Int.Pos ?k <= Int.Pos ?l == ?k <= ?l
### Code generator: dropping subsumed code equation
### Int.Pos ?k <= 0 == False
### Code generator: dropping subsumed code equation
### 0 <= Int.Neg ?l == False
### Code generator: dropping subsumed code equation
### 0 <= Int.Pos ?l == True
### Code generator: dropping subsumed code equation
### 0 <= 0 == True
deriving "compare" instance for type "List.list"
generating comparator for type "List.list"
### Code generator: dropping subsumed code equation
### Int.Neg ?k < Int.Neg ?l == ?l < ?k
### Code generator: dropping subsumed code equation
### Int.Neg ?k < Int.Pos ?l == True
### Code generator: dropping subsumed code equation
### Int.Neg ?k < 0 == True
### Code generator: dropping subsumed code equation
### Int.Pos ?k < Int.Neg ?l == False
### Code generator: dropping subsumed code equation
### Int.Pos ?k < Int.Pos ?l == ?k < ?l
### Code generator: dropping subsumed code equation
### Int.Pos ?k < 0 == False
### Code generator: dropping subsumed code equation
### 0 < Int.Neg ?l == False
### Code generator: dropping subsumed code equation
### 0 < Int.Pos ?l == True
### Code generator: dropping subsumed code equation
### 0 < 0 == False
deriving "compare" instance for type "Product_Type.prod"
generating comparator for type "Product_Type.prod"
class orthomodular_lattice = orthocomplemented_lattice +
  assumes
    "orthomodular": "!!x y. x <= y ==> x \<squnion> - x \<sqinter> y = y"
deriving "compare" instance for type "Option.option"
generating comparator for type "Option.option"
### Code generator: dropping subsumed code equation
### of_int (Int.Pos ?k) == numeral ?k
### Code generator: dropping subsumed code equation
### of_int 0 == 0::?'a
### Code generator: dropping subsumed code equation
### of_int (Int.Neg ?k) == - numeral ?k
### Code generator: dropping subsumed code equation
### nat (Int.Pos ?k) == nat_of_num ?k
### Code generator: dropping subsumed code equation
### nat 0 == 0
### Code generator: dropping subsumed code equation
### nat (Int.Neg ?k) == 0
### theory "HOL-Library.Code_Target_Int"
### 0.178s elapsed time, 0.696s cpu time, 0.078s GC time
Loading theory "HOL-Library.Code_Target_Numeral" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Quantum")
Found termination order: "{}"
instantiation
  multiset :: (type) cancel_comm_monoid_add
  zero_multiset == zero_class.zero :: 'a multiset
  minus_multiset == minus :: 'a multiset => 'a multiset => 'a multiset
  plus_multiset == plus :: 'a multiset => 'a multiset => 'a multiset
Found termination order: "{}"
deriving "compare" instance for type "HOL.bool"
deriving "compare" instance for type "Product_Type.unit"
deriving "compare_order" instance for type "HOL.bool"
### theory "HOL-Library.Code_Target_Numeral"
### 0.331s elapsed time, 1.149s cpu time, 0.638s GC time
Loading theory "HOL-Library.FuncSet" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Jordan_Normal_Form.Matrix" via "Jordan_Normal_Form.Missing_Ring" via "Jordan_Normal_Form.Missing_Misc")
deriving "compare_order" instance for type "Product_Type.unit"
### theory "Deriving.Compare_Instances"
### 0.702s elapsed time, 2.614s cpu time, 0.750s GC time
Loading theory "HOL-Library.Function_Algebras" (required by "Draft.TeleportMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
instantiation
  fun :: (type, plus) plus
  plus_fun == plus :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  fun :: (type, zero) zero
  zero_fun == zero_class.zero :: 'a => 'b
instantiation
  fun :: (type, times) times
  times_fun == times :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  fun :: (type, one) one
  one_fun == one_class.one :: 'a => 'b
### theory "HOL-Library.Function_Algebras"
### 0.171s elapsed time, 0.668s cpu time, 0.039s GC time
Loading theory "HOL-Library.IArray" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl")
### theory "HOL-Library.FuncSet"
### 0.452s elapsed time, 1.770s cpu time, 0.148s GC time
Loading theory "HOL-Algebra.Congruence" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Jordan_Normal_Form.Matrix" via "Jordan_Normal_Form.Missing_Ring" via "HOL-Algebra.Ring" via "HOL-Algebra.FiniteProduct" via "HOL-Algebra.Group" via "HOL-Algebra.Complete_Lattice" via "HOL-Algebra.Lattice" via "HOL-Algebra.Order")
### Partially applied constant "Multiset.inter_mset" on left hand side of equation, in theorem:
### semilattice_inf.Inf_fin (\<inter>#) (set (?x # ?xs)) ==
### fold (\<inter>#) ?xs ?x
consts
  list_of :: "'a iarray => 'a list"
### Partially applied constant "Multiset.union_mset" on left hand side of equation, in theorem:
### semilattice_sup.Sup_fin (\<union>#) (set (?x # ?xs)) ==
### fold (\<union>#) ?xs ?x
### theory "Complex_Bounded_Operators.Extra_Lattice"
### 3.253s elapsed time, 12.575s cpu time, 1.795s GC time
Loading theory "HOL-Library.Disjoint_Sets" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Jordan_Normal_Form.Matrix" via "Jordan_Normal_Form.Missing_Ring" via "Jordan_Normal_Form.Missing_Misc" via "HOL-Combinatorics.Permutations")
consts
  tabulate :: "integer * (integer => 'a) => 'a iarray"
consts
  sub' :: "'a iarray * integer => 'a"
### theory "HOL-Library.IArray"
### 0.559s elapsed time, 2.209s cpu time, 0.264s GC time
Loading theory "HOL-Library.Infinite_Set" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Determinant_Impl" via "Polynomial_Interpolation.Missing_Polynomial" via "HOL-Computational_Algebra.Polynomial_Factorial" via "HOL-Computational_Algebra.Polynomial")
locale comm_monoid_set
  fixes f :: "'a => 'a => 'a"  (infixl \<open>\<^bold>*\<close> 70)
    and z :: "'a"  (\<open>\<^bold>1\<close>)
  assumes "comm_monoid_set (\<^bold>*) \<^bold>1"
signature MULTISET_SIMPROCS =
  sig
    val subset_cancel_msets: Proof.context -> cterm -> thm option
    val subseteq_cancel_msets: Proof.context -> cterm -> thm option
  end
structure Multiset_Simprocs: MULTISET_SIMPROCS
consts
  enumerate :: "'a set => nat => 'a"
instantiation
  multiset :: (type) Inf
  Inf_multiset == Inf :: 'a multiset set => 'a multiset
instantiation
  multiset :: (type) Sup
  Sup_multiset == Sup :: 'a multiset set => 'a multiset
### theory "HOL-Library.Disjoint_Sets"
### 0.560s elapsed time, 2.029s cpu time, 0.940s GC time
Loading theory "HOL-Library.More_List" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Determinant_Impl" via "Polynomial_Interpolation.Missing_Polynomial" via "HOL-Computational_Algebra.Polynomial_Factorial" via "HOL-Computational_Algebra.Polynomial")
locale equivalence
  fixes S :: "('a, 'b) eq_object_scheme"  (structure)
  assumes "equivalence S"
locale partition
  fixes A :: "'a set"
    and B :: "'a set set"
  assumes "Congruence.partition A B"
### theory "HOL-Library.Infinite_Set"
### 0.588s elapsed time, 2.126s cpu time, 0.992s GC time
Loading theory "HOL-Library.Nat_Bijection" (required by "Draft.TeleportMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.Stream")
instantiation
  multiset :: (type) size
  size_multiset == size :: 'a multiset => nat
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
### theory "HOL-Library.More_List"
### 0.231s elapsed time, 0.900s cpu time, 0.156s GC time
Loading theory "HOL-Library.Old_Datatype" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Complex_Bounded_Operators.Complex_L2" via "Complex_Bounded_Operators.Complex_Bounded_Linear_Function" via "Complex_Bounded_Operators.Complex_Inner_Product" via "Complex_Bounded_Operators.Complex_Inner_Product0" via "Complex_Bounded_Operators.Complex_Vector_Spaces" via "HOL-Analysis.Elementary_Topology" via "HOL-Library.Set_Idioms" via "HOL-Library.Countable_Set" via "HOL-Library.Countable")
### theory "HOL-Algebra.Congruence"
### 1.041s elapsed time, 3.928s cpu time, 1.166s GC time
Loading theory "HOL-Algebra.Order" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Jordan_Normal_Form.Matrix" via "Jordan_Normal_Form.Missing_Ring" via "HOL-Algebra.Ring" via "HOL-Algebra.FiniteProduct" via "HOL-Algebra.Group" via "HOL-Algebra.Complete_Lattice" via "HOL-Algebra.Lattice")
locale comp_fun_commute
  fixes f :: "'a => 'b => 'b"
  assumes "comp_fun_commute f"
Found termination order: "size_list size <*mlex*> {}"
consts
  mset :: "'a list => 'a multiset"
### theory "HOL-Library.Nat_Bijection"
### 0.370s elapsed time, 1.461s cpu time, 0.202s GC time
Loading theory "HOL-Library.Stream" (required by "Draft.TeleportMoreTemplates" via "Draft.ExtrEqs")
locale weak_partial_order
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_partial_order L"
locale weak_partial_order
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_partial_order L"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
signature OLD_DATATYPE =
  sig
    val check_specs: spec list -> theory -> spec list * Proof.context
    type config = {quiet: bool, strict: bool}
    val default_config: config
    type descr =
       (int * (string * dtyp list * (string * dtyp list) list)) list
    val distinct_lemma: thm
    datatype dtyp
    = DtRec of int | DtTFree of string * sort | DtType of string * dtyp list
    type info =
       {case_cong: thm,
        case_cong_weak: thm,
        case_name: string,
        case_rewrites: thm list,
        descr: descr,
        distinct: thm list,
        exhaust: thm,
        index: int,
        induct: thm,
        inducts: thm list,
        inject: thm list,
        nchotomy: thm,
        rec_names: string list,
        rec_rewrites: thm list, split: thm, split_asm: thm}
    val read_specs: spec_cmd list -> theory -> spec list * Proof.context
    type spec =
       (binding * (string * sort) list * mixfix) *
       (binding * typ list * mixfix) list
    type spec_cmd =
       (binding * (string * string option) list * mixfix) *
       (binding * string list * mixfix) list
  end
structure Old_Datatype: OLD_DATATYPE
### theory "HOL-Library.Old_Datatype"
### 0.471s elapsed time, 1.852s cpu time, 0.294s GC time
Loading theory "HOL-Library.Phantom_Type" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl" via "Containers.Collection_Enum" via "Containers.Containers_Generator")
locale comm_monoid_mset
  fixes f :: "'a => 'a => 'a"  (infixl \<open>\<^bold>*\<close> 70)
    and z :: "'a"  (\<open>\<^bold>1\<close>)
  assumes "comm_monoid_mset (\<^bold>*) \<^bold>1"
class comm_monoid_add = ab_semigroup_add + monoid_add +
  assumes "add_0": "!!a. (0::'a) + a = a"
class comm_monoid_add = ab_semigroup_add + monoid_add +
  assumes "add_0": "!!a. (0::'a) + a = a"
class canonically_ordered_monoid_add = ordered_comm_monoid_add +
  assumes "le_iff_add": "!!a b. (a <= b) = (EX c. b = a + c)"
consts
  shift :: "'a list => 'a stream => 'a stream"
locale weak_partial_order
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_partial_order L"
Proofs for coinductive predicate(s) "streamsp"
  Proving monotonicity ...
consts
  snth :: "'a stream => nat => 'a"
locale partial_order
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "partial_order L"
consts
  stake :: "nat => 'a stream => 'a list"
consts
  sdrop :: "nat => 'a stream => 'a stream"
locale weak_partial_order_bottom
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_partial_order_bottom L"
consts
  sfilter :: "('a => bool) => 'a stream => 'a stream"
locale weak_partial_order_top
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_partial_order_top L"
consts
  cycle :: "'a list => 'a stream"
locale weak_total_order
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_total_order L"
class comm_monoid_mult = ab_semigroup_mult + monoid_mult + dvd +
  assumes "mult_1": "!!a. (1::'a) * a = a"
locale total_order
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "total_order L"
consts
  siterate :: "('a => 'a) => 'a => 'a stream"
### theory "HOL-Algebra.Order"
### 1.349s elapsed time, 5.129s cpu time, 1.768s GC time
Loading theory "HOL-Algebra.Lattice" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Jordan_Normal_Form.Matrix" via "Jordan_Normal_Form.Missing_Ring" via "HOL-Algebra.Ring" via "HOL-Algebra.FiniteProduct" via "HOL-Algebra.Group" via "HOL-Algebra.Complete_Lattice")
### theory "HOL-Library.Phantom_Type"
### 0.954s elapsed time, 3.580s cpu time, 1.474s GC time
Loading theory "Containers.Containers_Generator" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl" via "Containers.Collection_Enum")
consts
  flat :: "'a list stream => 'a stream"
consts
  sinterleave :: "'a stream => 'a stream => 'a stream"
consts
  szip :: "'a stream => 'b stream => ('a * 'b) stream"
locale weak_upper_semilattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_upper_semilattice L"
consts
  smap2 :: "('a => 'b => 'c) => 'a stream => 'b stream => 'c stream"
locale weak_lower_semilattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_lower_semilattice L"
### theory "HOL-Library.Stream"
### 1.366s elapsed time, 5.200s cpu time, 1.797s GC time
Loading theory "HOL-Library.Cardinality" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl" via "Containers.RBT_Set2" via "Containers.RBT_Mapping2" via "Containers.Collection_Order" via "Containers.Set_Linorder")
locale weak_lattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_lattice L"
### Additional type variable(s) in locale specification "CARD_1": 'a
class CARD_1 = type +
  assumes "CARD_1": "CARD('a) = 1"
### Additional type variable(s) in locale specification "card2": 'a
signature CONTAINERS_GENERATOR =
  sig
    val HOLogic_list_conj: term list -> term
    val all_tys: term -> typ list -> term -> term
    val derive_is_c_dots_lemma:
       typ -> string -> thm list -> string -> theory -> theory
    val derive_none:
       string -> sort -> (typ -> term) -> string -> theory -> theory
    val derive_set_map_impl:
       string ->
         sort ->
           (string * term) list -> string -> string -> theory -> theory
    val is_class_instance: theory -> string -> sort -> bool
    val mk_Some: term -> term
    val mk_is_c_dots: typ -> string -> term
    val register_is_c_dots_lemma:
       string -> string -> thm -> theory -> theory
  end
structure Containers_Generator: CONTAINERS_GENERATOR
### theory "Containers.Containers_Generator"
### 0.451s elapsed time, 1.794s cpu time, 0.248s GC time
Loading theory "Containers.Collection_Enum" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl")
class card2 = finite +
  assumes "two_le_card": "2 <= CARD('a)"
class finite_UNIV = type +
  fixes finite_UNIV :: "('a, bool) phantom"
  assumes "finite_UNIV": "finite_UNIV = Phantom('a) (finite UNIV)"
class cenum = type +
  fixes
    cEnum ::
      "('a list * (('a => bool) => bool) * (('a => bool) => bool)) option"
  assumes
    "UNIV_cenum":
      "!!enum enum_all enum_ex.
          cEnum = Some (enum, enum_all, enum_ex) ==> UNIV = set enum"
    and
    "cenum_all_UNIV":
      "!!enum enum_all enum_ex P.
          cEnum = Some (enum, enum_all, enum_ex) ==>
          enum_all P = Ball UNIV P"
    and
    "cenum_ex_UNIV":
      "!!enum enum_all enum_ex P.
          cEnum = Some (enum, enum_all, enum_ex) ==> enum_ex P = Bex UNIV P"
locale weak_bounded_lattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_bounded_lattice L"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
signature CENUM_GENERATOR =
  sig val derive_no_cenum: string -> theory -> theory end
structure Cenum_Generator: CENUM_GENERATOR
class card_UNIV = finite_UNIV +
  fixes card_UNIV :: "('a, nat) phantom"
  assumes "card_UNIV": "card_UNIV_class.card_UNIV = Phantom('a) CARD('a)"
instantiation
  nat :: card_UNIV
  card_UNIV_nat == card_UNIV_class.card_UNIV :: (nat, nat) phantom
  finite_UNIV_nat == finite_UNIV :: (nat, bool) phantom
instantiation
  int :: card_UNIV
  card_UNIV_int == card_UNIV_class.card_UNIV :: (int, nat) phantom
  finite_UNIV_int == finite_UNIV :: (int, bool) phantom
locale upper_semilattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "upper_semilattice L"
instantiation
  natural :: card_UNIV
  card_UNIV_natural == card_UNIV_class.card_UNIV :: (natural, nat) phantom
  finite_UNIV_natural == finite_UNIV :: (natural, bool) phantom
instantiation
  integer :: card_UNIV
  card_UNIV_integer == card_UNIV_class.card_UNIV :: (integer, nat) phantom
  finite_UNIV_integer == finite_UNIV :: (integer, bool) phantom
locale lower_semilattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "lower_semilattice L"
### Rewrite rule not in simpset:
### Wellfounded.accp all_n_lists_rel (?P1, ?n1) ==>
### all_n_lists ?P1 ?n1 ==
### if ?n1 = 0 then ?P1 []
### else cenum_all (%x. all_n_lists (%xs. ?P1 (x # xs)) (?n1 - 1))
instantiation
  list :: (type) card_UNIV
  card_UNIV_list == card_UNIV_class.card_UNIV :: ('a list, nat) phantom
  finite_UNIV_list == finite_UNIV :: ('a list, bool) phantom
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
instantiation
  unit :: card_UNIV
  card_UNIV_unit == card_UNIV_class.card_UNIV :: (unit, nat) phantom
  finite_UNIV_unit == finite_UNIV :: (unit, bool) phantom
locale Lattice.lattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "lattice L"
instantiation
  bool :: card_UNIV
  card_UNIV_bool == card_UNIV_class.card_UNIV :: (bool, nat) phantom
  finite_UNIV_bool == finite_UNIV :: (bool, bool) phantom
instantiation
  char :: card_UNIV
  card_UNIV_char == card_UNIV_class.card_UNIV :: (char, nat) phantom
  finite_UNIV_char == finite_UNIV :: (char, bool) phantom
instantiation
  prod :: (finite_UNIV, finite_UNIV) finite_UNIV
  finite_UNIV_prod == finite_UNIV :: ('a * 'b, bool) phantom
instantiation
  prod :: (card_UNIV, card_UNIV) card_UNIV
  card_UNIV_prod == card_UNIV_class.card_UNIV :: ('a * 'b, nat) phantom
### Rewrite rule not in simpset:
### Wellfounded.accp ex_n_lists_rel (?P1, ?n1) ==>
### ex_n_lists ?P1 ?n1 ==
### if ?n1 = 0 then ?P1 []
### else cenum_ex (%x. ex_n_lists (%xs. ?P1 (x # xs)) (?n1 - 1))
instantiation
  sum :: (finite_UNIV, finite_UNIV) finite_UNIV
  finite_UNIV_sum == finite_UNIV :: ('a + 'b, bool) phantom
instantiation
  sum :: (card_UNIV, card_UNIV) card_UNIV
  card_UNIV_sum == card_UNIV_class.card_UNIV :: ('a + 'b, nat) phantom
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
instantiation
  fun :: (finite_UNIV, card_UNIV) finite_UNIV
  finite_UNIV_fun == finite_UNIV :: ('a => 'b, bool) phantom
instantiation
  fun :: (cenum, cenum) cenum
  cEnum_fun == cEnum ::
    (('a => 'b) list *
     ((('a => 'b) => bool) => bool) * ((('a => 'b) => bool) => bool)) option
instantiation
  fun :: (card_UNIV, card_UNIV) card_UNIV
  card_UNIV_fun == card_UNIV_class.card_UNIV :: ('a => 'b, nat) phantom
instantiation
  option :: (finite_UNIV) finite_UNIV
  finite_UNIV_option == finite_UNIV :: ('a option, bool) phantom
### Ambiguous input (line 136 of "$AFP/Containers/Collection_Enum.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_CENUM" ("\<^type>fun" ("_position_sort" 'a) ("_position_sort" 'b)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CENUM" ("_position_sort" 'a)))
###       ("_case2" ("_case1" ("_position" None) ("_position" None))
###         ("_case1"
###           ("_applC" ("_position" Some)
###             ("_tuple" ("_position" enum_a)
###               ("_tuple_args" ("_position" enum_all_a)
###                 ("_tuple_arg" ("_position" enum_ex_a)))))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CENUM" ("_position_sort" 'b)))
###             ("_case2" ("_case1" ("_position" None) ("_position" None))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("_tuple" ("_position" enum_b)
###                     ("_tuple_args" ("_position" enum_all_b)
###                       ("_tuple_arg" ("_position" enum_ex_b)))))
###                 ("_applC" ("_position" Some)
###                   ("_tuple"
###                     ("_applC" ("_position" map)
###                       ("_cargs"
###                         ("_lambda" ("_position" ys)
###                           ("\<^const>Fun.comp" ("_position" the)
###                             ("_applC" ("_position" map_of)
###                               ("_applC" ("_position" zip)
###                                 ("_cargs" ("_position" enum_a)
###                                   ("_position" ys))))))
###                         ("_applC" ("_position" List.n_lists)
###                           ("_cargs"
###                             ("_applC" ("_position" length)
###                               ("_position" enum_a))
###                             ("_position" enum_b)))))
###                     ("_tuple_args"
###                       ("_lambda" ("_position" P)
###                         ("_applC" ("_position" all_n_lists)
###                           ("_cargs" ("_position" enum_all_b)
###                             ("_cargs"
###                               ("_lambda" ("_position" bs)
###                                 ("_applC" ("_position" P)
###                                   ("\<^const>Fun.comp" ("_position" the)
###                                     ("_applC" ("_position" map_of)
### ("_applC" ("_position" zip)
###   ("_cargs" ("_position" enum_a) ("_position" bs)))))))
###                               ("_applC" ("_position" length)
###                                 ("_position" enum_a))))))
###                       ("_tuple_arg"
###                         ("_lambda" ("_position" P)
###                           ("_applC" ("_position" ex_n_lists)
###                             ("_cargs" ("_position" enum_ex_b)
###                               ("_cargs"
###                                 ("_lambda" ("_position" bs)
###                                   ("_applC" ("_position" P)
###                                     ("\<^const>Fun.comp" ("_position" the)
### ("_applC" ("_position" map_of)
###   ("_applC" ("_position" zip)
###     ("_cargs" ("_position" enum_a) ("_position" bs)))))))
###                                 ("_applC" ("_position" length)
###                                   ("_position" enum_a))))))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_CENUM" ("\<^type>fun" ("_position_sort" 'a) ("_position_sort" 'b)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CENUM" ("_position_sort" 'a)))
###       ("_case2" ("_case1" ("_position" None) ("_position" None))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some)
###               ("_tuple" ("_position" enum_a)
###                 ("_tuple_args" ("_position" enum_all_a)
###                   ("_tuple_arg" ("_position" enum_ex_a)))))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CENUM" ("_position_sort" 'b)))
###               ("_case1" ("_position" None) ("_position" None))))
###           ("_case1"
###             ("_applC" ("_position" Some)
###               ("_tuple" ("_position" enum_b)
###                 ("_tuple_args" ("_position" enum_all_b)
###                   ("_tuple_arg" ("_position" enum_ex_b)))))
###             ("_applC" ("_position" Some)
###               ("_tuple"
###                 ("_applC" ("_position" map)
###                   ("_cargs"
###                     ("_lambda" ("_position" ys)
###                       ("\<^const>Fun.comp" ("_position" the)
###                         ("_applC" ("_position" map_of)
###                           ("_applC" ("_position" zip)
###                             ("_cargs" ("_position" enum_a)
###                               ("_position" ys))))))
###                     ("_applC" ("_position" List.n_lists)
###                       ("_cargs"
###                         ("_applC" ("_position" length) ("_position" enum_a))
###                         ("_position" enum_b)))))
###                 ("_tuple_args"
###                   ("_lambda" ("_position" P)
###                     ("_applC" ("_position" all_n_lists)
###                       ("_cargs" ("_position" enum_all_b)
###                         ("_cargs"
###                           ("_lambda" ("_position" bs)
###                             ("_applC" ("_position" P)
###                               ("\<^const>Fun.comp" ("_position" the)
###                                 ("_applC" ("_position" map_of)
###                                   ("_applC" ("_position" zip)
###                                     ("_cargs" ("_position" enum_a)
### ("_position" bs)))))))
###                           ("_applC" ("_position" length)
###                             ("_position" enum_a))))))
###                   ("_tuple_arg"
###                     ("_lambda" ("_position" P)
###                       ("_applC" ("_position" ex_n_lists)
###                         ("_cargs" ("_position" enum_ex_b)
###                           ("_cargs"
###                             ("_lambda" ("_position" bs)
###                               ("_applC" ("_position" P)
###                                 ("\<^const>Fun.comp" ("_position" the)
###                                   ("_applC" ("_position" map_of)
###                                     ("_applC" ("_position" zip)
### ("_cargs" ("_position" enum_a) ("_position" bs)))))))
###                             ("_applC" ("_position" length)
###                               ("_position" enum_a))))))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
instantiation
  option :: (card_UNIV) card_UNIV
  card_UNIV_option == card_UNIV_class.card_UNIV :: ('a option, nat) phantom
locale Lattice.bounded_lattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "bounded_lattice L"
instantiation
  String.literal :: card_UNIV
  card_UNIV_literal == card_UNIV_class.card_UNIV ::
    (String.literal, nat) phantom
  finite_UNIV_literal == finite_UNIV :: (String.literal, bool) phantom
instantiation
  set :: (finite_UNIV) finite_UNIV
  finite_UNIV_set == finite_UNIV :: ('a set, bool) phantom
instantiation
  set :: (cenum) cenum
  cEnum_set == cEnum ::
    ('a set list *
     (('a set => bool) => bool) * (('a set => bool) => bool)) option
locale Lattice.bounded_lattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "bounded_lattice L"
instantiation
  set :: (card_UNIV) card_UNIV
  card_UNIV_set == card_UNIV_class.card_UNIV :: ('a set, nat) phantom
### theory "HOL-Algebra.Lattice"
### 0.889s elapsed time, 3.531s cpu time, 0.479s GC time
Loading theory "HOL-Algebra.Complete_Lattice" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Jordan_Normal_Form.Matrix" via "Jordan_Normal_Form.Missing_Ring" via "HOL-Algebra.Ring" via "HOL-Algebra.FiniteProduct" via "HOL-Algebra.Group")
instantiation
  unit :: cenum
  cEnum_unit == cEnum ::
    (unit list * ((unit => bool) => bool) * ((unit => bool) => bool)) option
instantiation
  Enum.finite_1 :: card_UNIV
  card_UNIV_finite_1 == card_UNIV_class.card_UNIV ::
    (Enum.finite_1, nat) phantom
  finite_UNIV_finite_1 == finite_UNIV :: (Enum.finite_1, bool) phantom
instantiation
  bool :: cenum
  cEnum_bool == cEnum ::
    (bool list * ((bool => bool) => bool) * ((bool => bool) => bool)) option
instantiation
  multiset :: (preorder) order
  less_eq_multiset == less_eq :: 'a multiset => 'a multiset => bool
  less_multiset == less :: 'a multiset => 'a multiset => bool
instantiation
  prod :: (cenum, cenum) cenum
  cEnum_prod == cEnum ::
    (('a * 'b) list *
     (('a * 'b => bool) => bool) * (('a * 'b => bool) => bool)) option
instantiation
  Enum.finite_2 :: card_UNIV
  card_UNIV_finite_2 == card_UNIV_class.card_UNIV ::
    (Enum.finite_2, nat) phantom
  finite_UNIV_finite_2 == finite_UNIV :: (Enum.finite_2, bool) phantom
### Ambiguous input (line 225 of "$AFP/Containers/Collection_Enum.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_CENUM"
###       ("\<^type>Product_Type.prod" ("_position_sort" 'a)
###         ("_position_sort" 'b)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CENUM" ("_position_sort" 'a)))
###       ("_case2" ("_case1" ("_position" None) ("_position" None))
###         ("_case1"
###           ("_applC" ("_position" Some)
###             ("_tuple" ("_position" enum_a)
###               ("_tuple_args" ("_position" enum_all_a)
###                 ("_tuple_arg" ("_position" enum_ex_a)))))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CENUM" ("_position_sort" 'b)))
###             ("_case2" ("_case1" ("_position" None) ("_position" None))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("_tuple" ("_position" enum_b)
###                     ("_tuple_args" ("_position" enum_all_b)
###                       ("_tuple_arg" ("_position" enum_ex_b)))))
###                 ("_applC" ("_position" Some)
###                   ("_tuple"
###                     ("_applC" ("_position" List.product)
###                       ("_cargs" ("_position" enum_a) ("_position" enum_b)))
###                     ("_tuple_args"
###                       ("_lambda" ("_position" P)
###                         ("_applC" ("_position" enum_all_a)
###                           ("_lambda" ("_position" x)
###                             ("_applC" ("_position" enum_all_b)
###                               ("_lambda" ("_position" y)
###                                 ("_applC" ("_position" P)
###                                   ("_tuple" ("_position" x)
###                                     ("_tuple_arg" ("_position" y)))))))))
###                       ("_tuple_arg"
###                         ("_lambda" ("_position" P)
###                           ("_applC" ("_position" enum_ex_a)
###                             ("_lambda" ("_position" x)
###                               ("_applC" ("_position" enum_ex_b)
###                                 ("_lambda" ("_position" y)
###                                   ("_applC" ("_position" P)
###                                     ("_tuple" ("_position" x)
### ("_tuple_arg" ("_position" y)))))))))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_CENUM"
###       ("\<^type>Product_Type.prod" ("_position_sort" 'a)
###         ("_position_sort" 'b)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CENUM" ("_position_sort" 'a)))
###       ("_case2" ("_case1" ("_position" None) ("_position" None))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some)
###               ("_tuple" ("_position" enum_a)
###                 ("_tuple_args" ("_position" enum_all_a)
###                   ("_tuple_arg" ("_position" enum_ex_a)))))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CENUM" ("_position_sort" 'b)))
###               ("_case1" ("_position" None) ("_position" None))))
###           ("_case1"
###             ("_applC" ("_position" Some)
###               ("_tuple" ("_position" enum_b)
###                 ("_tuple_args" ("_position" enum_all_b)
###                   ("_tuple_arg" ("_position" enum_ex_b)))))
###             ("_applC" ("_position" Some)
###               ("_tuple"
###                 ("_applC" ("_position" List.product)
###                   ("_cargs" ("_position" enum_a) ("_position" enum_b)))
###                 ("_tuple_args"
###                   ("_lambda" ("_position" P)
###                     ("_applC" ("_position" enum_all_a)
###                       ("_lambda" ("_position" x)
###                         ("_applC" ("_position" enum_all_b)
###                           ("_lambda" ("_position" y)
###                             ("_applC" ("_position" P)
###                               ("_tuple" ("_position" x)
###                                 ("_tuple_arg" ("_position" y)))))))))
###                   ("_tuple_arg"
###                     ("_lambda" ("_position" P)
###                       ("_applC" ("_position" enum_ex_a)
###                         ("_lambda" ("_position" x)
###                           ("_applC" ("_position" enum_ex_b)
###                             ("_lambda" ("_position" y)
###                               ("_applC" ("_position" P)
###                                 ("_tuple" ("_position" x)
###                                   ("_tuple_arg"
###                                     ("_position" y)))))))))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
instantiation
  Enum.finite_3 :: card_UNIV
  card_UNIV_finite_3 == card_UNIV_class.card_UNIV ::
    (Enum.finite_3, nat) phantom
  finite_UNIV_finite_3 == finite_UNIV :: (Enum.finite_3, bool) phantom
instantiation
  multiset :: (preorder) ordered_ab_semigroup_add
instantiation
  Enum.finite_4 :: card_UNIV
  card_UNIV_finite_4 == card_UNIV_class.card_UNIV ::
    (Enum.finite_4, nat) phantom
  finite_UNIV_finite_4 == finite_UNIV :: (Enum.finite_4, bool) phantom
instantiation
  sum :: (cenum, cenum) cenum
  cEnum_sum == cEnum ::
    (('a + 'b) list *
     (('a + 'b => bool) => bool) * (('a + 'b => bool) => bool)) option
locale weak_complete_lattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_complete_lattice L"
instantiation
  Enum.finite_5 :: card_UNIV
  card_UNIV_finite_5 == card_UNIV_class.card_UNIV ::
    (Enum.finite_5, nat) phantom
  finite_UNIV_finite_5 == finite_UNIV :: (Enum.finite_5, bool) phantom
Proofs for inductive predicate(s) "pw_leq"
### Ambiguous input (line 237 of "$AFP/Containers/Collection_Enum.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_CENUM"
###       ("\<^type>Sum_Type.sum" ("_position_sort" 'a) ("_position_sort" 'b)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CENUM" ("_position_sort" 'a)))
###       ("_case2" ("_case1" ("_position" None) ("_position" None))
###         ("_case1"
###           ("_applC" ("_position" Some)
###             ("_tuple" ("_position" enum_a)
###               ("_tuple_args" ("_position" enum_all_a)
###                 ("_tuple_arg" ("_position" enum_ex_a)))))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CENUM" ("_position_sort" 'b)))
###             ("_case2" ("_case1" ("_position" None) ("_position" None))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("_tuple" ("_position" enum_b)
###                     ("_tuple_args" ("_position" enum_all_b)
###                       ("_tuple_arg" ("_position" enum_ex_b)))))
###                 ("_applC" ("_position" Some)
###                   ("_tuple"
###                     ("\<^const>List.append"
###                       ("_applC" ("_position" map)
###                         ("_cargs" ("_position" Inl) ("_position" enum_a)))
###                       ("_applC" ("_position" map)
###                         ("_cargs" ("_position" Inr) ("_position" enum_b))))
###                     ("_tuple_args"
###                       ("_lambda" ("_position" P)
###                         ("\<^const>HOL.conj"
###                           ("_applC" ("_position" enum_all_a)
###                             ("_lambda" ("_position" x)
###                               ("_applC" ("_position" P)
###                                 ("_applC" ("_position" Inl)
###                                   ("_position" x)))))
###                           ("_applC" ("_position" enum_all_b)
###                             ("_lambda" ("_position" x)
###                               ("_applC" ("_position" P)
###                                 ("_applC" ("_position" Inr)
###                                   ("_position" x)))))))
###                       ("_tuple_arg"
###                         ("_lambda" ("_position" P)
###                           ("\<^const>HOL.disj"
###                             ("_applC" ("_position" enum_ex_a)
###                               ("_lambda" ("_position" x)
###                                 ("_applC" ("_position" P)
###                                   ("_applC" ("_position" Inl)
###                                     ("_position" x)))))
###                             ("_applC" ("_position" enum_ex_b)
###                               ("_lambda" ("_position" x)
###                                 ("_applC" ("_position" P)
###                                   ("_applC" ("_position" Inr)
###                                     ("_position" x)))))))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_CENUM"
###       ("\<^type>Sum_Type.sum" ("_position_sort" 'a) ("_position_sort" 'b)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CENUM" ("_position_sort" 'a)))
###       ("_case2" ("_case1" ("_position" None) ("_position" None))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some)
###               ("_tuple" ("_position" enum_a)
###                 ("_tuple_args" ("_position" enum_all_a)
###                   ("_tuple_arg" ("_position" enum_ex_a)))))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CENUM" ("_position_sort" 'b)))
###               ("_case1" ("_position" None) ("_position" None))))
###           ("_case1"
###             ("_applC" ("_position" Some)
###               ("_tuple" ("_position" enum_b)
###                 ("_tuple_args" ("_position" enum_all_b)
###                   ("_tuple_arg" ("_position" enum_ex_b)))))
###             ("_applC" ("_position" Some)
###               ("_tuple"
###                 ("\<^const>List.append"
###                   ("_applC" ("_position" map)
###                     ("_cargs" ("_position" Inl) ("_position" enum_a)))
###                   ("_applC" ("_position" map)
###                     ("_cargs" ("_position" Inr) ("_position" enum_b))))
###                 ("_tuple_args"
###                   ("_lambda" ("_position" P)
###                     ("\<^const>HOL.conj"
###                       ("_applC" ("_position" enum_all_a)
###                         ("_lambda" ("_position" x)
###                           ("_applC" ("_position" P)
###                             ("_applC" ("_position" Inl) ("_position" x)))))
###                       ("_applC" ("_position" enum_all_b)
###                         ("_lambda" ("_position" x)
###                           ("_applC" ("_position" P)
###                             ("_applC" ("_position" Inr)
###                               ("_position" x)))))))
###                   ("_tuple_arg"
###                     ("_lambda" ("_position" P)
###                       ("\<^const>HOL.disj"
###                         ("_applC" ("_position" enum_ex_a)
###                           ("_lambda" ("_position" x)
###                             ("_applC" ("_position" P)
###                               ("_applC" ("_position" Inl)
###                                 ("_position" x)))))
###                         ("_applC" ("_position" enum_ex_b)
###                           ("_lambda" ("_position" x)
###                             ("_applC" ("_position" P)
###                               ("_applC" ("_position" Inr)
###                                 ("_position" x)))))))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
  Proving monotonicity ...
### theory "HOL-Library.Cardinality"
### 0.826s elapsed time, 3.288s cpu time, 0.520s GC time
Loading theory "Containers.Collection_Eq" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl" via "Containers.DList_Set")
instantiation
  option :: (cenum) cenum
  cEnum_option == cEnum ::
    ('a option list *
     (('a option => bool) => bool) * (('a option => bool) => bool)) option
instantiation
  Enum.finite_1 :: cenum
  cEnum_finite_1 == cEnum ::
    (Enum.finite_1 list *
     ((Enum.finite_1 => bool) => bool) *
     ((Enum.finite_1 => bool) => bool)) option
instantiation
  Enum.finite_2 :: cenum
  cEnum_finite_2 == cEnum ::
    (Enum.finite_2 list *
     ((Enum.finite_2 => bool) => bool) *
     ((Enum.finite_2 => bool) => bool)) option
instantiation
  Enum.finite_3 :: cenum
  cEnum_finite_3 == cEnum ::
    (Enum.finite_3 list *
     ((Enum.finite_3 => bool) => bool) *
     ((Enum.finite_3 => bool) => bool)) option
instantiation
  Enum.finite_4 :: cenum
  cEnum_finite_4 == cEnum ::
    (Enum.finite_4 list *
     ((Enum.finite_4 => bool) => bool) *
     ((Enum.finite_4 => bool) => bool)) option
instantiation
  Enum.finite_5 :: cenum
  cEnum_finite_5 == cEnum ::
    (Enum.finite_5 list *
     ((Enum.finite_5 => bool) => bool) *
     ((Enum.finite_5 => bool) => bool)) option
instantiation
  char :: cenum
  cEnum_char == cEnum ::
    (char list * ((char => bool) => bool) * ((char => bool) => bool)) option
use None as trivial implementation of cenum for type list
registered list in class cenum
use None as trivial implementation of cenum for type nat
registered nat in class cenum
use None as trivial implementation of cenum for type int
registered int in class cenum
use None as trivial implementation of cenum for type integer
registered integer in class cenum
use None as trivial implementation of cenum for type natural
registered natural in class cenum
use None as trivial implementation of cenum for type literal
registered literal in class cenum
### theory "Containers.Collection_Enum"
### 0.676s elapsed time, 2.687s cpu time, 0.398s GC time
Loading theory "Containers.Set_Linorder" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl" via "Containers.RBT_Set2" via "Containers.RBT_Mapping2" via "Containers.Collection_Order")
locale weak_complete_lattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_complete_lattice L"
class ceq = type +
  fixes ceq :: "('a => 'a => bool) option"
  assumes "ceq": "!!eqa. ceq = Some eqa ==> eqa = (=)"
Found termination order: "(%p. length (fst p)) <*mlex*> {}"
signature CEQ_GENERATOR =
  sig
    val ceq_instance_via_eq: string -> theory -> theory
    val ceq_instance_via_equality: string -> theory -> theory
    val derive_no_ceq: string -> theory -> theory
  end
structure Ceq_Generator: CEQ_GENERATOR
deriving "ceq" instance for type "Product_Type.unit" via "="
instantiation
  multiset :: (equal) equal
  equal_multiset == equal_class.equal :: 'a multiset => 'a multiset => bool
derived is_ceq_unit-lemma
### Code generator: dropping subsumed code equation
### CEQ(unit) == Some (=)
deriving "ceq" instance for type "HOL.bool" via "="
derived is_ceq_bool-lemma
deriving "ceq" instance for type "Nat.nat" via "="
locale weak_complete_lattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_complete_lattice L"
derived is_ceq_nat-lemma
deriving "ceq" instance for type "Int.int" via "="
instantiation
  multiset :: (random) random
  random_multiset == random_class.random ::
    natural
    => natural * natural
       => ('a multiset * (unit => term)) * natural * natural
derived is_ceq_int-lemma
deriving "ceq" instance for type "Enum.finite_1" via "="
derived is_ceq_finite_1-lemma
deriving "ceq" instance for type "Enum.finite_2" via "="
instantiation
  multiset :: (full_exhaustive) full_exhaustive
  full_exhaustive_multiset == full_exhaustive_class.full_exhaustive ::
    ('a multiset * (unit => term) => (bool * term list) option)
    => natural => (bool * term list) option
derived is_ceq_finite_2-lemma
deriving "ceq" instance for type "Enum.finite_3" via "="
derived is_ceq_finite_3-lemma
deriving "ceq" instance for type "Enum.finite_4" via "="
derived is_ceq_finite_4-lemma
deriving "ceq" instance for type "Enum.finite_5" via "="
derived is_ceq_finite_5-lemma
deriving "ceq" instance for type "Code_Numeral.integer" via "="
derived is_ceq_integer-lemma
deriving "ceq" instance for type "Code_Numeral.natural" via "="
Proofs for inductive predicate(s) "pred_mset"
  Proving monotonicity ...
derived is_ceq_natural-lemma
deriving "ceq" instance for type "String.char" via "="
derived is_ceq_char-lemma
deriving "ceq" instance for type "String.literal" via "="
derived is_ceq_literal-lemma
deriving "ceq" instance for type "Sum_Type.sum"
locale Complete_Lattice.complete_lattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "complete_lattice L"
derived is_ceq_sum-lemma
deriving "ceq" instance for type "Product_Type.prod"
derived is_ceq_prod-lemma
deriving "ceq" instance for type "List.list"
Proofs for inductive predicate(s) "rel_mset'"
derived is_ceq_list-lemma
deriving "ceq" instance for type "Option.option"
  Proving monotonicity ...
derived is_ceq_option-lemma
use None as trivial implementation of ceq for type fun
registered fun in class ceq
instantiation
  set :: (ceq) ceq
  ceq_set == ceq :: ('a set => 'a set => bool) option
locale Complete_Lattice.complete_lattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "complete_lattice L"
locale weak_complete_lattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_complete_lattice L"
instantiation
  Predicate.pred :: (ceq) ceq
  ceq_pred == ceq :: ('a Predicate.pred => 'a Predicate.pred => bool) option
### theory "HOL-Library.Multiset"
### 4.910s elapsed time, 18.854s cpu time, 4.820s GC time
Loading theory "HOL-Computational_Algebra.Factorial_Ring" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Jordan_Normal_Form.Matrix" via "Polynomial_Interpolation.Ring_Hom")
### theory "Containers.Collection_Eq"
### 0.585s elapsed time, 2.325s cpu time, 0.291s GC time
Loading theory "HOL-Combinatorics.Permutations" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Jordan_Normal_Form.Matrix" via "Jordan_Normal_Form.Missing_Ring" via "Jordan_Normal_Form.Missing_Misc")
### theory "HOL-Algebra.Complete_Lattice"
### 0.852s elapsed time, 3.383s cpu time, 0.641s GC time
Loading theory "HOL-Algebra.Group" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Jordan_Normal_Form.Matrix" via "Jordan_Normal_Form.Missing_Ring" via "HOL-Algebra.Ring" via "HOL-Algebra.FiniteProduct")
specification
  finite_complement_partition: finite ?A ==> ?A : infinite_complement_partition
  complement_partition: infinite UNIV ==>
(?A : infinite_complement_partition) =
(- ?A ~: infinite_complement_partition)
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
class order = preorder +
  assumes "order_antisym": "!!x y. [| x <= y; y <= x |] ==> x = y"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
locale Group.monoid
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "Group.monoid G"
locale Group.group
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "Group.group G"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
Proofs for inductive predicate(s) "swapidseq"
  Proving monotonicity ...
overloading
  nat_pow \<equiv> pow :: ('a, 'b) monoid_scheme => 'a => nat => 'a
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
overloading
  int_pow \<equiv> pow :: ('a, 'b) monoid_scheme => 'a => int => 'a
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
locale submonoid
  fixes H :: "'a set"
    and G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "submonoid H G"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
locale subgroup
  fixes H :: "'a set"
    and G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "subgroup H G"
locale comm_monoid_set
  fixes f :: "'a => 'a => 'a"  (infixl \<open>\<^bold>*\<close> 70)
    and z :: "'a"  (\<open>\<^bold>1\<close>)
  assumes "comm_monoid_set (\<^bold>*) \<^bold>1"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
Found termination order: "(%p. size_list size (fst p)) <*mlex*> {}"
### theory "HOL-Combinatorics.Permutations"
### 1.098s elapsed time, 4.363s cpu time, 0.797s GC time
Loading theory "Jordan_Normal_Form.Missing_Misc" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Jordan_Normal_Form.Matrix" via "Jordan_Normal_Form.Missing_Ring")
class proper_intrvl = ord +
  fixes proper_interval :: "'a option => 'a option => bool"
### theory "Jordan_Normal_Form.Missing_Misc"
### 0.124s elapsed time, 0.488s cpu time, 0.091s GC time
Loading theory "Containers.DList_Set" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl")
class normalization_semidom = algebraic_semidom +
  semidom_divide_unit_factor +
  fixes normalize :: "'a => 'a"
  assumes
    "unit_factor_mult_normalize": "!!a. unit_factor a * normalize a = a"
    and "normalize_0": "normalize (0::'a) = (0::'a)"
class proper_interval = proper_intrvl +
  assumes
    "proper_interval_simps": "proper_interval None None = True"
      "!!y. proper_interval None (Some y) = (EX z. z < y)"
      "!!x. proper_interval (Some x) None = (EX z. x < z)"
      "!!x y. proper_interval (Some x) (Some y) = (EX z>x. z < y)"
class proper_intrvl = ord +
  fixes proper_interval :: "'a option => 'a option => bool"
locale group_hom
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
    and H :: "('c, 'd) monoid_scheme"  (structure)
    and h :: "'a => 'c"
  assumes "group_hom G H h"
locale equal_base
  fixes equal :: "'a => 'a => bool"
consts
  list_member :: "'a list => 'a => bool"
consts
  list_distinct :: "'a list => bool"
consts
  list_remove1 :: "'a => 'a list => 'a list"
consts
  list_remdups :: "'a list => 'a list"
locale Equal.equal
  fixes equal :: "'a => 'a => bool"
  assumes "equal equal"
locale Group.comm_monoid
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "Group.comm_monoid G"
locale comm_group
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "comm_group G"
class semiring_gcd = gcd + normalization_semidom +
  assumes "gcd_dvd1": "!!a b. gcd a b dvd a"
    and "gcd_dvd2": "!!a b. gcd a b dvd b"
    and "gcd_greatest": "!!c a b. [| c dvd a; c dvd b |] ==> c dvd gcd a b"
    and "normalize_gcd": "!!a b. normalize (gcd a b) = gcd a b"
    and "lcm_gcd": "!!a b. lcm a b = normalize (a * b div gcd a b)"
### theory "HOL-Algebra.Group"
### 1.715s elapsed time, 6.815s cpu time, 1.020s GC time
Loading theory "HOL-Algebra.Coset" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Jordan_Normal_Form_Existence" via "Jordan_Normal_Form.Schur_Decomposition" via "Jordan_Normal_Form.Gram_Schmidt" via "Jordan_Normal_Form.VS_Connect" via "Jordan_Normal_Form.Missing_VectorSpace" via "VectorSpace.VectorSpace")
### theory "Containers.DList_Set"
### 0.702s elapsed time, 2.790s cpu time, 0.315s GC time
Loading theory "HOL-Algebra.FiniteProduct" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Jordan_Normal_Form.Matrix" via "Jordan_Normal_Form.Missing_Ring" via "HOL-Algebra.Ring")
locale normal
  fixes H :: "'a set"
    and G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "normal H G"
Found termination order:
  "(%p. length (snd (snd p))) <*mlex*>
   (%p. length (fst (snd p))) <*mlex*> {}"
Proofs for inductive predicate(s) "foldSetDp"
  Proving monotonicity ...
locale LCD
  fixes B :: "'b set"
    and D :: "'a set"
    and f :: "'b => 'a => 'a"  (infixl \<open>\<cdot>\<close> 70)
  assumes "LCD B D (\<cdot>)"
locale ACeD
  fixes D :: "'a set"
    and f :: "'a => 'a => 'a"  (infixl \<open>\<cdot>\<close> 70)
    and e :: "'a"
  assumes "ACeD D (\<cdot>) e"
class factorial_semiring = normalization_semidom +
  assumes
    "prime_factorization_exists":
      "!!x. x ~= (0::'a) ==>
            EX A. (ALL x. x :# A --> prime_elem x) &
                  normalize (\<Prod>\<^sub># A) = normalize x"
locale Group.comm_monoid
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "Group.comm_monoid G"
locale Group.comm_monoid
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "Group.comm_monoid G"
### Ambiguous input (line 611 of "~~/src/HOL/Algebra/Coset.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>r_congruent_indexed" ("_index" ("_position" G))
###       ("_position" H))
###     ("_Coll" ("_pattern" ("_position" x) ("_position" y))
###       ("\<^const>HOL.conj"
###         ("\<^const>Set.member" ("_position" x)
###           ("_applC" ("_position" carrier) ("_position" G)))
###         ("\<^const>HOL.conj"
###           ("\<^const>Set.member" ("_position" y)
###             ("_applC" ("_position" carrier) ("_position" G)))
###           ("\<^const>Set.member"
###             ("\<^const>Group.monoid.mult_indexed"
###               ("\<^const>Group.m_inv_indexed" ("_index" ("_position" G))
###                 ("_position" x))
###               ("_index" ("_position" G)) ("_position" y))
###             ("_position" H)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>r_congruent_indexed" ("_index" ("_position" G))
###     ("\<^const>HOL.eq" ("_position" H)
###       ("_Coll" ("_pattern" ("_position" x) ("_position" y))
###         ("\<^const>HOL.conj"
###           ("\<^const>Set.member" ("_position" x)
###             ("_applC" ("_position" carrier) ("_position" G)))
###           ("\<^const>HOL.conj"
###             ("\<^const>Set.member" ("_position" y)
###               ("_applC" ("_position" carrier) ("_position" G)))
###             ("\<^const>Set.member"
###               ("\<^const>Group.monoid.mult_indexed"
###                 ("\<^const>Group.m_inv_indexed" ("_index" ("_position" G))
###                   ("_position" x))
###                 ("_index" ("_position" G)) ("_position" y))
###               ("_position" H))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "HOL-Algebra.FiniteProduct"
### 0.541s elapsed time, 2.158s cpu time, 0.349s GC time
Loading theory "HOL-Algebra.Ring" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Jordan_Normal_Form.Matrix" via "Jordan_Normal_Form.Missing_Ring")
Found termination order:
  "(%p. length (snd (snd p))) <*mlex*>
   (%p. length (fst (snd p))) <*mlex*> {}"
class factorial_semiring = normalization_semidom +
  assumes
    "prime_factorization_exists":
      "!!x. x ~= (0::'a) ==>
            EX A. (ALL x. x :# A --> prime_elem x) &
                  normalize (\<Prod>\<^sub># A) = normalize x"
locale abelian_monoid
  fixes G :: "('a, 'b) ring_scheme"  (structure)
  assumes "abelian_monoid G"
locale abelian_group
  fixes G :: "('a, 'b) ring_scheme"  (structure)
  assumes "abelian_group G"
### Cannot skip proof of schematic goal statement
locale abelian_monoid
  fixes G :: "('a, 'b) ring_scheme"  (structure)
  assumes "abelian_monoid G"
### Cannot skip proof of schematic goal statement
locale abelian_monoid
  fixes G :: "('a, 'b) ring_scheme"  (structure)
  assumes "abelian_monoid G"
### Cannot skip proof of schematic goal statement
locale abelian_group
  fixes G :: "('a, 'b) ring_scheme"  (structure)
  assumes "abelian_group G"
### Cannot skip proof of schematic goal statement
### theory "HOL-Algebra.Coset"
### 1.328s elapsed time, 5.288s cpu time, 0.672s GC time
Loading theory "HOL-Library.Numeral_Type" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Complex_Bounded_Operators.Complex_L2" via "Complex_Bounded_Operators.Complex_Bounded_Linear_Function" via "Complex_Bounded_Operators.Complex_Inner_Product" via "Complex_Bounded_Operators.Complex_Inner_Product0" via "Complex_Bounded_Operators.Complex_Vector_Spaces" via "HOL-Analysis.Elementary_Normed_Spaces" via "HOL-Analysis.Cartesian_Space" via "HOL-Analysis.Finite_Cartesian_Product")
locale Ring.semiring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "semiring R"
instantiation
  num1 :: CARD_1
instantiation
  num1 :: {comm_monoid_mult,numeral,comm_ring}
  uminus_num1 == uminus :: num1 => num1
  zero_num1 == zero_class.zero :: num1
  minus_num1 == minus :: num1 => num1 => num1
  plus_num1 == plus :: num1 => num1 => num1
  one_num1 == one_class.one :: num1
  times_num1 == times :: num1 => num1 => num1
locale Ring.ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "ring R"
instantiation
  num1 :: linorder
  less_eq_num1 == less_eq :: num1 => num1 => bool
  less_num1 == less :: num1 => num1 => bool
locale mod_type
  fixes n :: "int"
    and Rep :: "'a => int"
    and Abs :: "int => 'a"
  assumes "mod_type n Rep Abs"
locale mod_ring
  fixes n :: "int"
    and Rep :: "'a => int"
    and Abs :: "int => 'a"
  assumes "mod_ring n Rep Abs"
locale cring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "cring R"
instantiation
  bit0 :: (finite) {minus,one,plus,times,uminus,zero}
  bit1 :: (finite) {minus,one,plus,times,uminus,zero}
  zero_bit0 == zero_class.zero :: 'a bit0
  uminus_bit0 == uminus :: 'a bit0 => 'a bit0
  times_bit0 == times :: 'a bit0 => 'a bit0 => 'a bit0
  plus_bit0 == plus :: 'a bit0 => 'a bit0 => 'a bit0
  one_bit0 == one_class.one :: 'a bit0
  minus_bit0 == minus :: 'a bit0 => 'a bit0 => 'a bit0
  zero_bit1 == zero_class.zero :: 'a bit1
  uminus_bit1 == uminus :: 'a bit1 => 'a bit1
  times_bit1 == times :: 'a bit1 => 'a bit1 => 'a bit1
  plus_bit1 == plus :: 'a bit1 => 'a bit1 => 'a bit1
  one_bit1 == one_class.one :: 'a bit1
  minus_bit1 == minus :: 'a bit1 => 'a bit1 => 'a bit1
locale domain
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "domain R"
instantiation
  bit0 :: (finite) linorder
  bit1 :: (finite) linorder
  less_eq_bit0 == less_eq :: 'a bit0 => 'a bit0 => bool
  less_bit0 == less :: 'a bit0 => 'a bit0 => bool
  less_eq_bit1 == less_eq :: 'a bit1 => 'a bit1 => bool
  less_bit1 == less :: 'a bit1 => 'a bit1 => bool
locale Ring.field
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "field R"
instantiation
  num0 :: equal
  equal_num0 == equal_class.equal :: num0 => num0 => bool
instantiation
  num1 :: equal
  equal_num1 == equal_class.equal :: num1 => num1 => bool
locale Ring.ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "ring R"
instantiation
  num1 :: enum
  enum_num1 == enum_class.enum :: num1 list
  enum_all_num1 == enum_class.enum_all :: (num1 => bool) => bool
  enum_ex_num1 == enum_class.enum_ex :: (num1 => bool) => bool
instantiation
  num0 :: card_UNIV
  num1 :: card_UNIV
  card_UNIV_num0 == card_UNIV_class.card_UNIV :: (num0, nat) phantom
  finite_UNIV_num0 == finite_UNIV :: (num0, bool) phantom
  card_UNIV_num1 == card_UNIV_class.card_UNIV :: (num1, nat) phantom
  finite_UNIV_num1 == finite_UNIV :: (num1, bool) phantom
class proper_intrvl = ord +
  fixes proper_interval :: "'a option => 'a option => bool"
instantiation
  bit0 :: (finite) equal
  bit1 :: (finite) equal
  equal_bit0 == equal_class.equal :: 'a bit0 => 'a bit0 => bool
  equal_bit1 == equal_class.equal :: 'a bit1 => 'a bit1 => bool
instantiation
  bit0 :: (finite) enum
  enum_bit0 == enum_class.enum :: 'a bit0 list
  enum_all_bit0 == enum_class.enum_all :: ('a bit0 => bool) => bool
  enum_ex_bit0 == enum_class.enum_ex :: ('a bit0 => bool) => bool
instantiation
  bit1 :: (finite) enum
  enum_bit1 == enum_class.enum :: 'a bit1 list
  enum_all_bit1 == enum_class.enum_all :: ('a bit1 => bool) => bool
  enum_ex_bit1 == enum_class.enum_ex :: ('a bit1 => bool) => bool
locale Ring.ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "ring R"
instantiation
  bit0 :: (finite) finite_UNIV
  bit1 :: (finite) finite_UNIV
  finite_UNIV_bit0 == finite_UNIV :: ('a bit0, bool) phantom
  finite_UNIV_bit1 == finite_UNIV :: ('a bit1, bool) phantom
instantiation
  bit0 :: ({card_UNIV,finite}) card_UNIV
  bit1 :: ({card_UNIV,finite}) card_UNIV
  card_UNIV_bit0 == card_UNIV_class.card_UNIV :: ('a bit0, nat) phantom
  card_UNIV_bit1 == card_UNIV_class.card_UNIV :: ('a bit1, nat) phantom
### ML warning (line 44 of "~~/src/HOL/Algebra/ringsimp.ML"):
### Value identifier (s) has not been referenced.
### ML warning (line 47 of "~~/src/HOL/Algebra/ringsimp.ML"):
### Matches are not exhaustive.
signature RINGSIMP =
  sig
    val add_struct: string * term list -> attribute
    val algebra_tac: Proof.context -> int -> tactic
    val del_struct: string * term list -> attribute
    val print_structures: Proof.context -> unit
  end
structure Ringsimp: RINGSIMP
### theory "HOL-Library.Numeral_Type"
### 0.762s elapsed time, 3.035s cpu time, 0.322s GC time
Loading theory "HOL-Library.Type_Length" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "HOL-Library.Word")
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
class len0 = type +
  fixes len_of :: "'a itself => nat"
class len = len0 +
  assumes "len_gt_0": "0 < LENGTH('a)"
instantiation
  0 :: len0
  1 :: len0
  len_of_num0 == len_of :: 0 itself => nat
  len_of_num1 == len_of :: 1 itself => nat
instantiation
  bit0 :: (len0) len0
  bit1 :: (len0) len0
  len_of_bit0 == len_of :: 'a bit0 itself => nat
  len_of_bit1 == len_of :: 'a bit1 itself => nat
instantiation
  Enum.finite_1 :: len
  len_of_finite_1 == len_of :: Enum.finite_1 itself => nat
instantiation
  Enum.finite_2 :: len
  len_of_finite_2 == len_of :: Enum.finite_2 itself => nat
instantiation
  Enum.finite_3 :: len
  len_of_finite_3 == len_of :: Enum.finite_3 itself => nat
Found termination order: "{}"
locale Ring.semiring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "semiring R"
class factorial_semiring_gcd = factorial_semiring + Gcd +
  assumes "gcd_eq_gcd_factorial": "!!a b. gcd a b = gcd_factorial a b"
    and "lcm_eq_lcm_factorial": "!!a b. lcm a b = lcm_factorial a b"
    and "Gcd_eq_Gcd_factorial": "!!A. Gcd A = Gcd_factorial A"
    and "Lcm_eq_Lcm_factorial": "!!A. Lcm A = Lcm_factorial A"
locale domain
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "domain R"
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
class linordered_idom = ring_char_0 + idom_abs_sgn +
  linordered_ring_strict + linordered_semidom +
  linordered_semiring_1_strict + ordered_comm_ring + ordered_ring_abs +
  assumes
    "sgn_if":
      "!!x. sgn x =
            (if x = (0::'a) then 0::'a
             else if (0::'a) < x then 1::'a else - (1::'a))"
### theory "HOL-Library.Type_Length"
### 0.582s elapsed time, 2.312s cpu time, 0.250s GC time
Loading theory "HOL-Library.Word" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport")
instantiation
  word :: (len) comm_ring_1
  uminus_word == uminus :: 'a word => 'a word
  one_word == one_class.one :: 'a word
  times_word == times :: 'a word => 'a word => 'a word
  zero_word == zero_class.zero :: 'a word
  minus_word == minus :: 'a word => 'a word => 'a word
  plus_word == plus :: 'a word => 'a word => 'a word
signature WORD_LIB =
  sig
    val dest_binT: typ -> int
    val dest_wordT: typ -> int
    val is_wordT: typ -> bool
    val mk_wordT: int -> typ
  end
structure Word_Lib: WORD_LIB
locale ring_hom_cring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and S :: "('c, 'd) ring_scheme"  (structure)
    and h :: "'a => 'c"
  assumes "ring_hom_cring R S h"
instantiation
  word :: (len) equal
  equal_word == equal_class.equal :: 'a word => 'a word => bool
class semiring_char_0 = semiring_1 +
  assumes "inj_of_nat": "inj of_nat"
Found termination order:
  "(%p. length (snd (snd (snd p)))) <*mlex*>
   (%p. length (fst (snd (snd p)))) <*mlex*> {}"
### theory "HOL-Algebra.Ring"
### 2.947s elapsed time, 11.709s cpu time, 1.220s GC time
Loading theory "HOL-Algebra.Module" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Jordan_Normal_Form.Matrix")
instantiation
  word :: (len) linorder
  less_eq_word == less_eq :: 'a word => 'a word => bool
  less_word == less :: 'a word => 'a word => bool
instantiation
  word :: (len) enum
  enum_word == enum_class.enum :: 'a word list
  enum_all_word == enum_class.enum_all :: ('a word => bool) => bool
  enum_ex_word == enum_class.enum_ex :: ('a word => bool) => bool
instantiation
  word :: (len) semiring_modulo
  modulo_word == modulo :: 'a word => 'a word => 'a word
  divide_word == divide :: 'a word => 'a word => 'a word
instantiation
  word :: (len) semiring_bits
  bit_word == bit :: 'a word => nat => bool
instantiation
  word :: (len) ring_bit_operations
  not_word == not :: 'a word => 'a word
  and_word == and :: 'a word => 'a word => 'a word
  or_word == or :: 'a word => 'a word => 'a word
  xor_word == xor :: 'a word => 'a word => 'a word
  mask_word == mask :: nat => 'a word
  set_bit_word == set_bit :: nat => 'a word => 'a word
  unset_bit_word == unset_bit :: nat => 'a word => 'a word
  flip_bit_word == flip_bit :: nat => 'a word => 'a word
  push_bit_word == push_bit :: nat => 'a word => 'a word
  drop_bit_word == drop_bit :: nat => 'a word => 'a word
  take_bit_word == take_bit :: nat => 'a word => 'a word
locale module
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and M :: "('a, 'c, 'd) module_scheme"  (structure)
  assumes "module R M"
Found termination order:
  "(%p. length (snd (snd p))) <*mlex*>
   (%p. length (fst (snd p))) <*mlex*> {}"
locale algebra
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and M :: "('a, 'c, 'd) module_scheme"  (structure)
  assumes "algebra R M"
class semiring_bits = semiring_parity +
  fixes bit :: "'a => nat => bool"
  assumes
    "bits_induct":
      "!!P a.
          [| !!a. a div (2::'a) = a ==> P a;
             !!a b.
                [| P a; (of_bool b + (2::'a) * a) div (2::'a) = a |]
                ==> P (of_bool b + (2::'a) * a) |]
          ==> P a"
  assumes "bits_div_0": "!!a. (0::'a) div a = (0::'a)"
    and "bits_div_by_1": "!!a. a div (1::'a) = a"
    and "bits_mod_div_trivial": "!!a b. a mod b div b = (0::'a)"
    and
    "even_succ_div_2":
      "!!a. even a ==> ((1::'a) + a) div (2::'a) = a div (2::'a)"
    and
    "even_mask_div_iff":
      "!!m n.
          even (((2::'a) ^ m - (1::'a)) div (2::'a) ^ n) =
          ((2::'a) ^ n = (0::'a) | m <= n)"
    and
    "exp_div_exp_eq":
      "!!m n.
          (2::'a) ^ m div (2::'a) ^ n =
          of_bool ((2::'a) ^ m ~= (0::'a) & n <= m) * (2::'a) ^ (m - n)"
    and
    "div_exp_eq":
      "!!a m n. a div (2::'a) ^ m div (2::'a) ^ n = a div (2::'a) ^ (m + n)"
    and
    "mod_exp_eq":
      "!!a m n. a mod (2::'a) ^ m mod (2::'a) ^ n = a mod (2::'a) ^ min m n"
    and
    "mult_exp_mod_exp_eq":
      "!!m n a.
          m <= n ==>
          a * (2::'a) ^ m mod (2::'a) ^ n =
          a mod (2::'a) ^ (n - m) * (2::'a) ^ m"
    and
    "div_exp_mod_exp_eq":
      "!!a n m.
          a div (2::'a) ^ n mod (2::'a) ^ m =
          a mod (2::'a) ^ (n + m) div (2::'a) ^ n"
    and
    "even_mult_exp_div_exp_iff":
      "!!a m n.
          even (a * (2::'a) ^ m div (2::'a) ^ n) =
          (n < m |
           (2::'a) ^ n = (0::'a) | m <= n & even (a div (2::'a) ^ (n - m)))"
  assumes "bit_iff_odd": "!!a n. bit a n = odd (a div (2::'a) ^ n)"
class semiring_bit_operations = semiring_bits +
  fixes "and" :: "'a => 'a => 'a"
    and or :: "'a => 'a => 'a"
    and xor :: "'a => 'a => 'a"
    and mask :: "nat => 'a"
    and set_bit :: "nat => 'a => 'a"
    and unset_bit :: "nat => 'a => 'a"
    and flip_bit :: "nat => 'a => 'a"
    and push_bit :: "nat => 'a => 'a"
    and drop_bit :: "nat => 'a => 'a"
    and take_bit :: "nat => 'a => 'a"
  assumes "bit_and_iff": "!!a b n. bit (and a b) n = (bit a n & bit b n)"
    and "bit_or_iff": "!!a b n. bit (or a b) n = (bit a n | bit b n)"
    and "bit_xor_iff": "!!a b n. bit (xor a b) n = (bit a n ~= bit b n)"
    and "mask_eq_exp_minus_1": "!!n. mask n = (2::'a) ^ n - (1::'a)"
    and "set_bit_eq_or": "!!n a. set_bit n a = or a (push_bit n (1::'a))"
    and
    "bit_unset_bit_iff":
      "!!m a n. bit (unset_bit m a) n = (bit a n & m ~= n)"
    and
    "flip_bit_eq_xor": "!!n a. flip_bit n a = xor a (push_bit n (1::'a))"
    and "push_bit_eq_mult": "!!n a. push_bit n a = a * (2::'a) ^ n"
    and "drop_bit_eq_div": "!!n a. drop_bit n a = a div (2::'a) ^ n"
    and "take_bit_eq_mod": "!!n a. take_bit n a = a mod (2::'a) ^ n"
instantiation
  unit :: proper_interval
  proper_interval_unit == proper_interval ::
    unit option => unit option => bool
Found termination order: "{}"
instantiation
  bool :: proper_interval
  proper_interval_bool == proper_interval ::
    bool option => bool option => bool
Found termination order: "{}"
instantiation
  nat :: proper_interval
  proper_interval_nat == proper_interval :: nat option => nat option => bool
Found termination order: "{}"
instantiation
  int :: proper_interval
  proper_interval_int == proper_interval :: int option => int option => bool
locale submodule
  fixes H :: "'c set"
    and R :: "('a, 'b) ring_scheme"
    and M :: "('a, 'c, 'd) module_scheme"  (structure)
  assumes "submodule H R M"
Found termination order: "{}"
instantiation
  integer :: proper_interval
  proper_interval_integer == proper_interval ::
    integer option => integer option => bool
instantiation
  natural :: proper_interval
  proper_interval_natural == proper_interval ::
    natural option => natural option => bool
instantiation
  char :: proper_interval
  proper_interval_char == proper_interval ::
    char option => char option => bool
class semiring_bit_operations = semiring_bits +
  fixes "and" :: "'a => 'a => 'a"
    and or :: "'a => 'a => 'a"
    and xor :: "'a => 'a => 'a"
    and mask :: "nat => 'a"
    and set_bit :: "nat => 'a => 'a"
    and unset_bit :: "nat => 'a => 'a"
    and flip_bit :: "nat => 'a => 'a"
    and push_bit :: "nat => 'a => 'a"
    and drop_bit :: "nat => 'a => 'a"
    and take_bit :: "nat => 'a => 'a"
  assumes "bit_and_iff": "!!a b n. bit (and a b) n = (bit a n & bit b n)"
    and "bit_or_iff": "!!a b n. bit (or a b) n = (bit a n | bit b n)"
    and "bit_xor_iff": "!!a b n. bit (xor a b) n = (bit a n ~= bit b n)"
    and "mask_eq_exp_minus_1": "!!n. mask n = (2::'a) ^ n - (1::'a)"
    and "set_bit_eq_or": "!!n a. set_bit n a = or a (push_bit n (1::'a))"
    and
    "bit_unset_bit_iff":
      "!!m a n. bit (unset_bit m a) n = (bit a n & m ~= n)"
    and
    "flip_bit_eq_xor": "!!n a. flip_bit n a = xor a (push_bit n (1::'a))"
    and "push_bit_eq_mult": "!!n a. push_bit n a = a * (2::'a) ^ n"
    and "drop_bit_eq_div": "!!n a. drop_bit n a = a div (2::'a) ^ n"
    and "take_bit_eq_mod": "!!n a. take_bit n a = a mod (2::'a) ^ n"
Found termination order: "{}"
instantiation
  Enum.finite_1 :: proper_interval
  proper_interval_finite_1 == proper_interval ::
    Enum.finite_1 option => Enum.finite_1 option => bool
instantiation
  Enum.finite_2 :: proper_interval
  proper_interval_finite_2 == proper_interval ::
    Enum.finite_2 option => Enum.finite_2 option => bool
### theory "HOL-Algebra.Module"
### 1.545s elapsed time, 6.133s cpu time, 0.528s GC time
Loading theory "Jordan_Normal_Form.Missing_Ring" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Jordan_Normal_Form.Matrix")
Found termination order: "{}"
instantiation
  Enum.finite_3 :: proper_interval
  proper_interval_finite_3 == proper_interval ::
    Enum.finite_3 option => Enum.finite_3 option => bool
Found termination order: "{}"
class ring_bit_operations = semiring_bit_operations + ring_parity +
  fixes not :: "'a => 'a"
  assumes
    "bit_not_iff_eq":
      "!!a n. bit (not a) n = ((2::'a) ^ n ~= (0::'a) & ~ bit a n)"
  assumes "minus_eq_not_minus_1": "!!a. - a = not (a - (1::'a))"
class proper_intrvl = ord +
  fixes proper_interval :: "'a option => 'a option => bool"
### theory "HOL-Computational_Algebra.Factorial_Ring"
### 7.313s elapsed time, 29.057s cpu time, 3.461s GC time
Loading theory "HOL-Computational_Algebra.Euclidean_Algorithm" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Determinant_Impl" via "Polynomial_Interpolation.Missing_Polynomial" via "HOL-Computational_Algebra.Polynomial_Factorial" via "HOL-Computational_Algebra.Normalized_Fraction")
class unique_euclidean_semiring_numeral =
  unique_euclidean_semiring_with_nat + linordered_semidom +
  fixes divmod :: "num => num => 'a * 'a"
    and divmod_step :: "num => 'a * 'a => 'a * 'a"
  assumes
    "div_less": "!!a b. [| (0::'a) <= a; a < b |] ==> a div b = (0::'a)"
    and "mod_less": "!!a b. [| (0::'a) <= a; a < b |] ==> a mod b = a"
    and
    "div_positive": "!!b a. [| (0::'a) < b; b <= a |] ==> (0::'a) < a div b"
    and "mod_less_eq_dividend": "!!a b. (0::'a) <= a ==> a mod b <= a"
    and "pos_mod_bound": "!!b a. (0::'a) < b ==> a mod b < b"
    and "pos_mod_sign": "!!b a. (0::'a) < b ==> (0::'a) <= a mod b"
    and
    "mod_mult2_eq":
      "!!c a b.
          (0::'a) <= c ==> a mod (b * c) = b * (a div b mod c) + a mod b"
    and
    "div_mult2_eq":
      "!!c a b. (0::'a) <= c ==> a div (b * c) = a div b div c"
  assumes "discrete": "!!a b. (a < b) = (a + (1::'a) <= b)"
  assumes
    "divmod_def":
      "!!m n.
          divmod m n = (numeral m div numeral n, numeral m mod numeral n)"
    and
    "divmod_step_def":
      "!!l qr.
          divmod_step l qr =
          (let (q, r) = qr
           in if numeral l <= r then ((2::'a) * q + (1::'a), r - numeral l)
              else ((2::'a) * q, r))"
class linordered_semidom = linordered_comm_semiring_strict +
  linordered_nonzero_semiring + semidom +
  assumes "le_add_diff_inverse2": "!!b a. b <= a ==> a - b + b = a"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
### theory "Containers.Set_Linorder"
### 8.265s elapsed time, 32.841s cpu time, 3.775s GC time
Loading theory "Containers.Collection_Order" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl" via "Containers.RBT_Set2" via "Containers.RBT_Mapping2")
class ordered_semiring_strict = comm_monoid_add +
  ordered_cancel_ab_semigroup_add + semiring +
  assumes
    "mult_strict_left_mono":
      "!!a b c. [| a < b; (0::'a) < c |] ==> c * a < c * b"
  assumes
    "mult_strict_right_mono":
      "!!a b c. [| a < b; (0::'a) < c |] ==> a * c < b * c"
class ring_bit_operations = semiring_bit_operations + ring_parity +
  fixes not :: "'a => 'a"
  assumes
    "bit_not_iff_eq":
      "!!a n. bit (not a) n = ((2::'a) ^ n ~= (0::'a) & ~ bit a n)"
  assumes "minus_eq_not_minus_1": "!!a. - a = not (a - (1::'a))"
class semiring_bit_operations = semiring_bits +
  fixes "and" :: "'a => 'a => 'a"
    and or :: "'a => 'a => 'a"
    and xor :: "'a => 'a => 'a"
    and mask :: "nat => 'a"
    and set_bit :: "nat => 'a => 'a"
    and unset_bit :: "nat => 'a => 'a"
    and flip_bit :: "nat => 'a => 'a"
    and push_bit :: "nat => 'a => 'a"
    and drop_bit :: "nat => 'a => 'a"
    and take_bit :: "nat => 'a => 'a"
  assumes "bit_and_iff": "!!a b n. bit (and a b) n = (bit a n & bit b n)"
    and "bit_or_iff": "!!a b n. bit (or a b) n = (bit a n | bit b n)"
    and "bit_xor_iff": "!!a b n. bit (xor a b) n = (bit a n ~= bit b n)"
    and "mask_eq_exp_minus_1": "!!n. mask n = (2::'a) ^ n - (1::'a)"
    and "set_bit_eq_or": "!!n a. set_bit n a = or a (push_bit n (1::'a))"
    and
    "bit_unset_bit_iff":
      "!!m a n. bit (unset_bit m a) n = (bit a n & m ~= n)"
    and
    "flip_bit_eq_xor": "!!n a. flip_bit n a = xor a (push_bit n (1::'a))"
    and "push_bit_eq_mult": "!!n a. push_bit n a = a * (2::'a) ^ n"
    and "drop_bit_eq_div": "!!n a. drop_bit n a = a div (2::'a) ^ n"
    and "take_bit_eq_mod": "!!n a. take_bit n a = a mod (2::'a) ^ n"
class ccompare = type +
  fixes ccompare :: "('a => 'a => order) option"
  assumes "ccompare": "!!comp. ccompare = Some comp ==> comparator comp"
class ccompare = type +
  fixes ccompare :: "('a => 'a => order) option"
  assumes "ccompare": "!!comp. ccompare = Some comp ==> comparator comp"
signature CCOMPARE_GENERATOR =
  sig
    val ccompare_instance_via_comparator: string -> theory -> theory
    val ccompare_instance_via_compare: string -> theory -> theory
    val derive_no_ccompare: string -> theory -> theory
  end
structure CCompare_Generator: CCOMPARE_GENERATOR
deriving "compare_order" instance for type "Enum.finite_1"
deriving "compare" instance for type "Enum.finite_1"
deriving "compare_order" instance for type "Enum.finite_2"
deriving "compare" instance for type "Enum.finite_2"
deriving "compare_order" instance for type "Enum.finite_3"
deriving "compare" instance for type "Enum.finite_3"
deriving "compare_order" instance for type "Code_Numeral.natural"
deriving "compare" instance for type "Code_Numeral.natural"
deriving "compare_order" instance for type "String.literal"
deriving "compare" instance for type "String.literal"
deriving "ccompare_order" instance for type "Product_Type.unit" via compare_order
derived is_ccompare_unit-lemma
deriving "ccompare_order" instance for type "HOL.bool" via compare_order
derived is_ccompare_bool-lemma
deriving "ccompare_order" instance for type "Nat.nat" via compare_order
derived is_ccompare_nat-lemma
deriving "ccompare_order" instance for type "Int.int" via compare_order
derived is_ccompare_int-lemma
deriving "ccompare_order" instance for type "Enum.finite_1" via compare_order
derived is_ccompare_finite_1-lemma
deriving "ccompare_order" instance for type "Enum.finite_2" via compare_order
derived is_ccompare_finite_2-lemma
deriving "ccompare_order" instance for type "Enum.finite_3" via compare_order
derived is_ccompare_finite_3-lemma
deriving "ccompare_order" instance for type "Code_Numeral.integer" via compare_order
class ring_bit_operations = semiring_bit_operations + ring_parity +
  fixes not :: "'a => 'a"
  assumes
    "bit_not_iff_eq":
      "!!a n. bit (not a) n = ((2::'a) ^ n ~= (0::'a) & ~ bit a n)"
  assumes "minus_eq_not_minus_1": "!!a. - a = not (a - (1::'a))"
derived is_ccompare_integer-lemma
deriving "ccompare_order" instance for type "Code_Numeral.natural" via compare_order
derived is_ccompare_natural-lemma
deriving "ccompare_order" instance for type "String.char" via compare_order
derived is_ccompare_char-lemma
deriving "ccompare_order" instance for type "String.literal" via compare_order
derived is_ccompare_literal-lemma
use None as trivial implementation of ccompare for type finite_4
registered finite_4 in class ccompare
use None as trivial implementation of ccompare for type finite_5
registered finite_5 in class ccompare
deriving "ccompare" instance for type "Sum_Type.sum"
instantiation
  word :: (len) size
  size_word == size :: 'a word => nat
derived is_ccompare_sum-lemma
deriving "ccompare" instance for type "List.list"
derived is_ccompare_list-lemma
deriving "ccompare" instance for type "Option.option"
derived is_ccompare_option-lemma
deriving "ccompare" instance for type "Product_Type.prod"
derived is_ccompare_prod-lemma
use None as trivial implementation of ccompare for type fun
registered fun in class ccompare
instantiation
  set :: (ccompare) ccompare
  ccompare_set == ccompare :: ('a set => 'a set => order) option
use None as trivial implementation of ccompare for type pred
registered pred in class ccompare
class cproper_interval = ccompare +
  fixes cproper_interval :: "'a option => 'a option => bool"
  assumes
    "cproper_interval":
      "[| ID ccompare ~= None; finite UNIV |]
       ==> class.proper_interval cless cproper_interval"
instantiation
  unit :: cproper_interval
  cproper_interval_unit == cproper_interval ::
    unit option => unit option => bool
instantiation
  bool :: cproper_interval
  cproper_interval_bool == cproper_interval ::
    bool option => bool option => bool
instantiation
  nat :: cproper_interval
  cproper_interval_nat == cproper_interval ::
    nat option => nat option => bool
instantiation
  int :: cproper_interval
  cproper_interval_int == cproper_interval ::
    int option => int option => bool
instantiation
  integer :: cproper_interval
  cproper_interval_integer == cproper_interval ::
    integer option => integer option => bool
instantiation
  natural :: cproper_interval
  cproper_interval_natural == cproper_interval ::
    natural option => natural option => bool
instantiation
  char :: cproper_interval
  cproper_interval_char == cproper_interval ::
    char option => char option => bool
instantiation
  Enum.finite_1 :: cproper_interval
  cproper_interval_finite_1 == cproper_interval ::
    Enum.finite_1 option => Enum.finite_1 option => bool
instantiation
  Enum.finite_2 :: cproper_interval
  cproper_interval_finite_2 == cproper_interval ::
    Enum.finite_2 option => Enum.finite_2 option => bool
instantiation
  Enum.finite_3 :: cproper_interval
  cproper_interval_finite_3 == cproper_interval ::
    Enum.finite_3 option => Enum.finite_3 option => bool
instantiation
  Enum.finite_4 :: cproper_interval
  cproper_interval_finite_4 == cproper_interval ::
    Enum.finite_4 option => Enum.finite_4 option => bool
instantiation
  Enum.finite_5 :: cproper_interval
  cproper_interval_finite_5 == cproper_interval ::
    Enum.finite_5 option => Enum.finite_5 option => bool
### Partially applied constant "Word.word_sle" on left hand side of equation, in theorem:
### linorder.Min (\<le>s) (set (?x # ?xs)) == fold signed.min ?xs ?x
instantiation
  sum :: (cproper_interval, cproper_interval) cproper_interval
  cproper_interval_sum == cproper_interval ::
    ('a + 'b) option => ('a + 'b) option => bool
### Partially applied constant "Word.word_sle" on left hand side of equation, in theorem:
### linorder.Max (\<le>s) (set (?x # ?xs)) == fold signed.max ?xs ?x
### Partially applied constant "Word.word_sle" on left hand side of equation, in theorem:
### signed.sorted [] == True
### Partially applied constant "Word.word_sle" on left hand side of equation, in theorem:
### signed.sorted [?x] == True
### Partially applied constant "Word.word_sle" on left hand side of equation, in theorem:
### signed.sorted (?x # ?y # ?zs) == ?x \<le>s ?y & signed.sorted (?y # ?zs)
### Partially applied constant "Word.word_sle" on left hand side of equation, in theorem:
### signed.sorted_list_of_set (set ?xs) == signed.sort (remdups ?xs)
Found termination order: "{}"
instantiation
  prod :: (cproper_interval, cproper_interval) cproper_interval
  cproper_interval_prod == cproper_interval ::
    ('a * 'b) option => ('a * 'b) option => bool
class ordered_idom = ordered_semiring_strict + idom +
  assumes "zero_less_one": "(0::'a) < (1::'a)"
Found termination order: "{}"
instantiation
  list :: (ccompare) cproper_interval
  cproper_interval_list == cproper_interval ::
    'a list option => 'a list option => bool
instantiation
  String.literal :: cproper_interval
  cproper_interval_literal == cproper_interval ::
    String.literal option => String.literal option => bool
instantiation
  option :: (cproper_interval) cproper_interval
  cproper_interval_option == cproper_interval ::
    'a option option => 'a option option => bool
Found termination order: "{}"
instantiation
  set :: (cproper_interval) cproper_interval
  cproper_interval_set == cproper_interval ::
    'a set option => 'a set option => bool
### Not an equation, in theorem:
### cproper_interval_set_dom (None, None) ==> cproper_interval None None == True
### Not an equation, in theorem:
### cproper_interval_set_dom (None, Some ?B) ==>
### cproper_interval None (Some ?B) == ?B ~= {}
### Not an equation, in theorem:
### cproper_interval_set_dom (Some ?A, None) ==>
### cproper_interval (Some ?A) None == ?A ~= UNIV
### Not an equation, in theorem:
### cproper_interval_set_dom (Some ?A, Some ?B) ==>
### cproper_interval (Some ?A) (Some ?B) ==
### finite UNIV & (EX C. cless ?A C & cless C ?B)
Found termination order: "{}"
instantiation
  fun :: (type, type) cproper_interval
  cproper_interval_fun == cproper_interval ::
    ('a => 'b) option => ('a => 'b) option => bool
### theory "Containers.Collection_Order"
### 1.790s elapsed time, 7.117s cpu time, 0.669s GC time
Loading theory "HOL-Library.Product_Plus" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Complex_Bounded_Operators.Complex_L2" via "Complex_Bounded_Operators.Complex_Bounded_Linear_Function" via "Complex_Bounded_Operators.Complex_Inner_Product" via "Complex_Bounded_Operators.Complex_Inner_Product0" via "Complex_Bounded_Operators.Complex_Vector_Spaces" via "HOL-Analysis.Elementary_Topology" via "HOL-Analysis.Product_Vector")
class euclidean_semiring_gcd = normalization_euclidean_semiring + Gcd +
  assumes "gcd_eucl": "normalization_euclidean_semiring_class.gcd = gcd"
    and "lcm_eucl": "normalization_euclidean_semiring_class.lcm = lcm"
  assumes "Gcd_eucl": "normalization_euclidean_semiring_class.Gcd = Gcd"
    and "Lcm_eucl": "normalization_euclidean_semiring_class.Lcm = Lcm"
instantiation
  prod :: (zero, zero) zero
  zero_prod == zero_class.zero :: 'a * 'b
instantiation
  prod :: (plus, plus) plus
  plus_prod == plus :: 'a * 'b => 'a * 'b => 'a * 'b
instantiation
  prod :: (minus, minus) minus
  minus_prod == minus :: 'a * 'b => 'a * 'b => 'a * 'b
instantiation
  prod :: (uminus, uminus) uminus
  uminus_prod == uminus :: 'a * 'b => 'a * 'b
### theory "HOL-Library.Product_Plus"
### 0.116s elapsed time, 0.463s cpu time, 0.075s GC time
Loading theory "HOL-Library.RBT_Impl" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl" via "Containers.RBT_Set2" via "Containers.RBT_Mapping2" via "Containers.RBT_ext")
val unat_arith_simpset =
   Simpset
    ({depth = (0, ref false), prems = [], rules =
      Net {atoms =
           {("Int.Pos",
              Leaf
               [{elhs = "Int.Pos", extra = false, fo = true, lhs =
                 Const ("Int.Pos", "num => int"), name = "Int.Pos_def",
                 perm = false, thm = "Int.Pos == numeral"}]),
             ("Word.Word",
               Leaf
                [{elhs = "Word.Word", extra = false, fo = true, lhs =
                  Const ("Word.Word", "int => ?'a1 word"), name =
                  "Word.Word_eq_word_of_int", perm = false, thm =
                  "Word.Word == word_of_int"}]),
             ("Word.cast",
               Leaf
                [{elhs = "Word.cast", extra = false, fo = true, lhs =
                  Const ("Word.cast", "?'a1 word => ?'b1 word"), name =
                  "??.unknown", perm = false, thm = "Word.cast == ucast"}]),
             ("Word.of_int",
               Leaf
                [{elhs = "Word.of_int", extra = false, fo = true, lhs =
                  Const ("Word.of_int", "int => ?'a1 word"), name =
                  "??.unknown", perm = false, thm =
                  "Word.of_int == word_of_int"}]),
             ("Word.of_nat",
               Leaf
                [{elhs = "Word.of_nat", extra = false, fo = true, lhs =
                  Const ("Word.of_nat", "nat => ?'a1 word"), name =
                  "??.unknown", perm = false, thm =
                  "Word.of_nat == word_of_nat"}]),
             ("Word.the_int",
               Leaf
                [{elhs = "Word.the_int", extra = false, fo = true, lhs =
                  Const ("Word.the_int", "?'a1 word => int"), name =
                  "??.unknown", perm = false, thm =
                  "Word.the_int == uint"}]),
             ("Word.the_nat",
               Leaf
                [{elhs = "Word.the_nat", extra = false, fo = true, lhs =
                  Const ("Word.the_nat", "?'a1 word ... nat"), name =
                  "??.unknown", perm = false, thm =
                  "Word.the_nat == unat"}]),
             ("String.Literal'",
               Leaf
                [{elhs = "String.Literal'", extra = false, fo = true, lhs =
                  Const ("String.Literal'", "... ... ..."), name =
                  "String.Literal'_def", perm = false, thm =
                  "String.Literal' ... String.Literal"}]),
             ("Code_Numeral.Pos",
               Leaf
                [{elhs = "Code_Numeral.Pos", extra = false, fo = true, lhs =
                  Const ("Code_Numeral.Pos", "..."), name =
                  "Code_Numeral.Pos_def", perm = false, thm =
                  "... ... ..."}]),
             ("Word.signed_cast",
               Leaf
                [{elhs = "Word.signed_cast", extra = false, fo = true, lhs =
                  Const ("Word.signed_cast", "..."), name = "??.unknown",
                  ...}]),
             ("Word.the_signed_int",
               Leaf
                [{elhs = "...", extra = false, fo = true, lhs =
                  Const ("...", ...), ...}]),
             ("Groups.abs_class.abs",
               Leaf [{elhs = "...", extra = false, fo = true, ...}]),
             ("Groups.one_class.one",
               Leaf [{elhs = ..., extra = false, ...}, ...]),
             ("Groups.sgn_class.sgn", Leaf [...]),
             ("Code_Numeral.negative", ...), ...},
           comb =
           Net {atoms =
                {("Fun.id",
                   Net {atoms = {}, comb = Leaf [], var =
                        Leaf
                         [{elhs = "id ?y", extra = false, fo = true, lhs =
                           Const ("Fun.id", "?'a => ?'a") $
                             Var (("y", 0), "?'a"),
                           name = "Fun.id_apply", perm = false, thm =
                           "id ?y == ?y"}]}),
                  ("HOL.Ex",
                    Net {atoms = {}, comb =
                         Net {atoms =
                              {("HOL.eq",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf
 [{elhs = "...", extra = false, fo = true, lhs =
   Const ("...", "(?'d1 => bool) => bool") $ ..., ...}]})},
                              comb = Leaf [], var = Leaf []},
                         var =
                         Leaf
                          [{elhs = "Ex ?P1", extra = false, fo = true, lhs =
                            Const ("HOL.Ex", "(...) ... bool") $
                              Abs ("x", "1",
                                Var ((...), "1 => bool") $ ...),
                            name = "Numeral_Type.ex_1", perm = false, thm =
                            "EX x. ?P1 x == ?P1 1"},
                           {elhs = "Ex ?P1", extra = false, fo = true, lhs =
                            Const ("HOL.Ex", "... ... ...") $
                              Abs ("x", "...", ... $ ...),
                            name = "Product_Type.split_paired_Ex", perm =
                            false, thm =
                            "... x... ... ... == ... a b... ... ..."},
                           {elhs = "EX x y. ?p1 ... ......... ......",
                            extra = false, fo = true, lhs =
                            Const ("HOL.Ex", "...") $ Abs ("x", "...", ...),
                            name = "Product_Type.surj_pair", perm = false,
                            thm = "... ... ...... ... ... True"},
                           {elhs = "... x... ... ... ...", extra = false,
                            fo = false, lhs =
                            Const ("HOL.Ex", "...") $ Abs ("x", ..., ...),
                            name = "Set.ex_image_cong_iff_2", perm = false,
                            thm = "... ... ..."},
                           {elhs = "... ...... ...", extra = false, fo =
                            true, lhs =
                            Const ("...", ...) $ Abs ("...", "?'a1", ...),
                            name = "Set.ex_image_cong_iff_1", ...},
                           {elhs = "...", extra = false, fo = false, lhs =
                            Const ("...", "(?'d1 => bool) => bool") $ ...,
                            ...},
                           {elhs = "...", extra = false, fo = false, ...},
                           {elhs = ..., extra = false, ...}, ...]}),
                  ("HOL.All",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [{elhs = "All ?P1", extra = false, fo = true,
                            lhs =
                            Const ("HOL.All", "... ... ...") $
                              Abs ("i", "...", ... $ ...),
                            name = "Numeral_Type.forall_1", perm = false,
                            thm = "... i... ... ... == ?P1 ..."},
                           {elhs = "ALL y. ?x1 ... ... ...", extra = false,
                            fo = true, lhs =
                            Const ("HOL.All", "...") $
                              Abs ("y", "...", ...),
                            name = "Option.not_Some_eq", perm = false, thm =
                            "... ...... ... ... ... ... ..."},
                           {elhs = "All ?P1", extra = false, fo = true,
                            lhs =
                            Const ("HOL.All", "...") $ Abs ("x", ..., ...),
                            name = "Product_Type.split_paired_All", perm =
                            false, thm = "... ... ..."},
                           {elhs = "... ...... ...", extra = false, fo =
                            true, lhs =
                            Const ("...", ...) $ Abs ("...", "?'a1", ...),
                            name = "Set.all_not_in_conv", ...},
                           {elhs = "...", extra = false, fo = true, lhs =
                            Const ("...", "(?'d1 => bool) => bool") $ ...,
                            ...},
                           {elhs = "...", extra = false, fo = true, ...},
                           {elhs = ..., extra = false, ...}, ...]}),
                  ("HOL.Ex1",
                    Net {atoms = {}, comb =
                         Net {atoms =
                              {("HOL.eq",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf [{elhs = ..., extra = false, ...}]})},
                              comb = Leaf [], var = Leaf []},
                         var =
                         Leaf
                          [{elhs = "EX! x. x ... ?t1", extra = false, fo =
                            true, lhs =
                            Const ("HOL.Ex1", "...") $
                              Abs ("x", "...", ...),
                            name = "HOL.ex1_eq_1", perm = false, thm =
                            "... ...... ... ... True"}]}),
                  ("HOL.Not",
                    Net {atoms =
                         {("HOL.True",
                            Leaf
                             [{elhs = "... True", extra = false, fo = true,
                               lhs =
                               Const ("...", ...) $ Const ("...", "bool"),
                               name = "HOL.simp_thms_7", ...}]),
                           ("HOL.False",
                             Leaf
                              [{elhs = "... ...", extra = false, fo = true,
                                lhs = Const ("...", "bool => bool") $ ...,
                                ...}])},
                         comb =
                         Net {atoms =
                              {("HOL.Ex",
                                 Net {atoms = {}, comb = Leaf [...], var =
Leaf [...]}),
                                ("HOL.All",
                                  Net {atoms = {}, comb = ..., var = ...}),
                                ("HOL.Not", Net {atoms = {}, ...}),
                                ("Finite_Set.finite", ...)},
                              comb =
                              Net {atoms =
                                   {("HOL.eq", Net {atoms = {...}, ...}),
                                     ("Set.Bex", ...), ...},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []},
                         var = Leaf []}),
                  ("HOL.The",
                    Net {atoms = {}, comb =
                         Net {atoms =
                              {("HOL.eq",
                                 Net {atoms = {}, comb = ..., var = ...}),
                                ("Product_Type.prod.case_prod",
                                  Net {atoms = {}, ...})},
                              comb = Leaf [], var = Leaf []},
                         var =
                         Leaf
                          [{elhs = "... ...... ...", extra = false, fo =
                            true, lhs =
                            Const ("...", ...) $ Abs ("...", "?'a", ...),
                            name = "HOL.the_eq_trivial", ...}]}),
                  ("Int.Neg",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [{elhs = "...", extra = false, fo = true, lhs =
                            Const ("...", "num => int") $ ..., ...}]}),
                  ("Int.dup",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [{elhs = "...", extra = false, fo = true, ...}]}),
                  ("Int.nat",
                    Net {atoms =
                         {("Groups.one_class.one", Leaf [...]),
                           ("Groups.zero_class.zero", ...)},
                         comb = Net {atoms = {...}, comb = ..., var = ...},
                         var = Leaf [{elhs = ..., extra = false, ...}]}),
                  ("Map.dom",
                    Net {atoms = {}, comb = Net {atoms = {...}, ...}, var =
                         Leaf [...]}),
                  ("Map.ran", Net {atoms = {}, comb = ..., var = ...}),
                  ("Nat.Suc", Net {atoms = {...}, ...}), ("Num.inc", ...),
                  ...},
                comb =
                Net {atoms =
                     {("HOL.eq",
                        Net {atoms =
                             {("HOL.True",
                                Net {atoms =
                                     {("HOL.False",
  Leaf
   [{elhs = "...", extra = false, fo = true, lhs =
     Const ("...", "bool => bool => bool") $ ... $ ..., ...}])},
                                     comb = Leaf [], var =
                                     Leaf
[{elhs = "... ... ...", extra = false, fo = true, lhs =
  Const ("...", ...) $ Const ("...", "bool") $ ..., name =
  "HOL.simp_thms_11", ...}]}),
                               ("HOL.False",
                                 Net {atoms =
{("HOL.True", Leaf [{elhs = "...", extra = false, fo = true, ...}])}, comb =
Leaf [], var =
Leaf
 [{elhs = "...", extra = false, fo = true, lhs =
   Const ("...", "bool => bool => bool") $ ... $ ..., ...}]}),
                               ("Num.num.One",
                                 Net {atoms = {}, comb =
Net {atoms = {("Num.num.Bit0", ...), ...}, comb = Leaf [...], var =
     Leaf [...]},
var = Leaf []}),
                               ("Filter.at_bot",
                                 Net {atoms =
{("Orderings.bot_class.bot", Leaf [...])}, comb = Leaf [], var = Leaf []}),
                               ("Filter.at_top",
                                 Net {atoms =
{("Orderings.bot_class.bot", ...)}, comb = Leaf [...], var = Leaf [...]}),
                               ("List.list.Nil",
                                 Net {atoms = {}, comb = ..., var = ...}),
                               ("Filter.cofinite",
                                 Net {atoms = {...}, ...}),
                               ("Option.option.None", ...), ...},
                             comb =
                             Net {atoms =
                                  {("HOL.Not",
                                     Net
{atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Net {atoms = {...}, ...}, var = Leaf [...]}}),
                                    ("Int.nat",
Net {atoms = {}, comb = Leaf [], var =
     Net {atoms = {...}, comb = ..., var = ...}}),
                                    ("Map.dom",
Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {...}, ...}}),
                                    ("Nat.Suc",
Net {atoms = {...}, comb = ..., var = ...}),
                                    ("Set.Pow", Net {atoms = {}, ...}),
                                    ("List.rev", ...), ...},
                                  comb =
                                  Net {atoms =
 {("List.upt",
    Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}}),
   ("List.zip", Net {atoms = {}, comb = ..., var = ...}),
   ("List.drop", Net {atoms = {}, ...}), ("List.take", ...), ...},
 comb =
 Net {atoms =
      {("Fun.fun_upd", Net {atoms = {}, ...}), ("Map.map_add", ...), ...},
      comb = Net {atoms = {...}, comb = ..., var = ...}, var = Leaf []},
 var = Leaf []},
                                  var = Leaf []},
                             var =
                             Net {atoms =
                                  {("HOL.True",
                                     Leaf
[{elhs = "... ... ...", extra = false, fo = true, lhs =
  Const ("...", ...) $ Var ((...), "bool") $ ..., name = "HOL.simp_thms_12",
  ...}]),
                                    ("HOL.False",
Leaf
 [{elhs = "...", extra = false, fo = true, lhs =
   Const ("...", "bool => bool => bool") $ ... $ ..., ...}]),
                                    ("Groups.one_class.one",
Leaf [{elhs = "...", extra = false, fo = true, ...}])},
                                  comb =
                                  Net {atoms =
 {("HOL.Not", Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}),
   ("Map.map_of", Net {atoms = {}, comb = ..., var = ...}),
   ("Groups.uminus_class.uminus", Net {atoms = {}, ...})},
 comb =
 Net {atoms =
      {("List.append", Net {atoms = {}, ...}), ("Map.map_add", ...), ...},
      comb = Leaf [], var = Leaf []},
 var = Leaf []},
                                  var =
                                  Leaf
                                   [{elhs = "?v1 ... ?w1", extra = false,
                                     fo = true, lhs =
                                     Const ("HOL.eq", "...") $
 Var (("...", 1), ...) $ Var ((...), "?'a1 word"),
                                     name = "local.unat_arith_simps_3",
                                     perm = false, thm = "... ... ..."},
                                    {elhs = "... ... ...", extra = false,
                                     fo = true, lhs =
                                     Const ("...", ...) $
 Var ((...), "?'a1") $ ...,
                                     name = "HOL.simp_thms_6", ...}]}}),
                       ("HOL.Let",
                         Net {atoms =
                              {("Groups.one_class.one",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf
 [{elhs = "...", extra = false, fo = true, lhs =
   Const ("...", "?'b1 => (?'b1 => ?'a) => ?'a") $ ... $ ..., ...}]}),
                                ("Groups.zero_class.zero",
                                  Net {atoms = {}, comb = Leaf [], var =
 Leaf [{elhs = "...", extra = false, fo = true, ...}]})},
                              comb =
                              Net {atoms =
                                   {("Nat.Suc",
Net {atoms = {}, comb = Leaf [], var =
     Net {atoms = {}, comb = ..., var = ...}}),
                                     ("Num.numeral_class.numeral",
 Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}}),
                                     ("Groups.uminus_class.uminus",
 Net {atoms = {}, comb = ..., var = ...})},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []}),
                       ("Int.sub",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [], var =
                                   Leaf
                                    [{elhs = "...", extra = false, fo =
true, lhs = Const ("...", "num => num => int") $ ... $ ..., ...}]}}),
                       ("Num.pow",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms =
                                   {("Num.num.One",
Leaf [{elhs = ..., extra = false, ...}])},
                                   comb =
                                   Net {atoms =
  {("Num.num.Bit0", ...), ...}, comb = Leaf [...], var = Leaf [...]},
                                   var = Leaf []}}),
                       ("Set.Bex",
                         Net {atoms =
                              {("Orderings.bot_class.bot",
                                 Net {atoms = {}, comb = Leaf [...], var =
Leaf [...]}),
                                ("Orderings.top_class.top",
                                  Net {atoms = {}, comb = ..., var = ...})},
                              comb =
                              Net {atoms =
                                   {("Set.Collect", Net {atoms = {}, ...}),
                                     ("List.list.set", ...), ...},
                                   comb =
                                   Net {atoms = {...}, comb = ..., var =
  ...},
                                   var = Leaf []},
                              var =
                              Net {atoms = {}, comb =
                                   Net {atoms = {...}, comb = ..., var =
  ...},
                                   var =
                                   Leaf
                                    [{elhs = ..., extra = false, ...},
                                     ...]}}),
                       ("Fun.comp",
                         Net {atoms =
                              {("Fun.id",
                                 Net {atoms = {}, comb = ..., var = ...}),
                                ("Option.option.the",
                                  Net {atoms = {...}, ...}),
                                ("Product_Type.prod.fst", ...), ...},
                              comb =
                              Net {atoms = {("List.list.map", ...), ...},
                                   comb = Net {atoms = {...}, ...}, var =
                                   Leaf [...]},
                              var =
                              Net {atoms = {("Fun.id", ...)}, comb =
                                   Leaf [...], var = Leaf [...]}}),
                       ("GCD.bezw",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {...}, comb = ..., var = ...}}),
                       ("HOL.conj",
                         Net {atoms = {("HOL.True", ...), ...}, comb =
                              Net {atoms = {...}, ...}, var =
                              Net {atoms = {...}, ...}}),
                       ("HOL.disj",
                         Net {atoms = {...}, comb = ..., var = ...}),
                       ("List.nth", Net {atoms = {}, ...}),
                       ("List.upt", ...), ...},
                     comb =
                     Net {atoms =
                          {("HOL.If",
                             Net {atoms =
                                  {("HOL.True",
                                     Net
{atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}}),
                                    ("HOL.False",
Net {atoms = {}, comb = Leaf [], var =
     Net {atoms = {}, comb = ..., var = ...}})},
                                  comb =
                                  Net {atoms = {}, comb =
 Net {atoms = {("HOL.eq", Net {atoms = {}, ...})}, comb = Leaf [], var =
      Leaf []},
 var = Leaf []},
                                  var =
                                  Net {atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Leaf [], var =
      Leaf [{elhs = ..., extra = false, ...}]}}}),
                            ("Fun.comp",
                              Net {atoms = {}, comb = Leaf [], var =
                                   Net {atoms = {}, comb = Leaf [], var =
  Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}}}),
                            ("Fun.fcomp",
                              Net {atoms = {}, comb = Leaf [], var =
                                   Net {atoms = {}, comb = Leaf [], var =
  Net {atoms = {}, comb = ..., var = ...}}}),
                            ("List.foldl",
                              Net {atoms = {}, comb = Leaf [], var =
                                   Net {atoms = {}, comb = Leaf [...], var =
  Net {atoms = {...}, ...}}}),
                            ("List.foldr",
                              Net {atoms = {}, comb = Leaf [], var =
                                   Net {atoms = {}, comb = ..., var =
  ...}}),
                            ("Nat.compow",
                              Net {atoms =
                                   {("Groups.zero_class.zero", ...)}, comb =
                                   Leaf [...], var = Leaf [...]}),
                            ("Fun.fun_upd",
                              Net {atoms = {}, comb = ..., var = ...}),
                            ("Map.map_add", Net {atoms = {}, ...}),
                            ("Fun.bij_betw", ...), ...},
                          comb =
                          Net {atoms =
                               {("Fun.fun_upd",
                                  Net {atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Leaf [], var =
      Net {atoms = {}, comb = ..., var = ...}}}),
                                 ("Fun.map_fun",
                                   Net {atoms = {}, comb = Leaf [], var =
  Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}}}),
                                 ("Map.map_upds",
                                   Net {atoms = {}, comb = Leaf [], var =
  Net {atoms = {}, comb = ..., var = ...}}),
                                 ("BNF_Def.rel_sum",
                                   Net {atoms = {}, comb = Leaf [...], var =
  Net {atoms = {}, ...}}),
                                 ("Fun.override_on",
                                   Net {atoms = {}, comb = ..., var = ...}),
                                 ("Num.num.rec_num", Net {atoms = {}, ...}),
                                 ("Num.num.case_num", ...), ...},
                               comb =
                               Net {atoms =
                                    {("Enum.finite_4.rec_finite_4",
 Net {atoms = {}, comb = Leaf [], var =
      Net {atoms = {}, comb = ..., var = ...}}),
("Enum.finite_4.case_finite_4",
  Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}})},
                                    comb =
                                    Net {atoms =
   {("Enum.finite_5.rec_finite_5", Net {atoms = {}, comb = ..., var = ...}),
     ("Enum.finite_5.case_finite_5", Net {atoms = {}, ...})},
   comb =
   Net {atoms = {}, comb = Net {atoms = {...}, ...}, var = Leaf [...]},
   var = Leaf []},
                                    var = Leaf []},
                               var = Leaf []},
                          var = Leaf []},
                     var = Leaf []},
                var = Leaf []},
           var =
           Leaf
            [{elhs = "%u. EX x y. u = (x, y) & ?P1 x y", extra = false, fo =
              false, lhs =
              Abs ("u", "?'a1 * ?'b1",
                Const ("HOL.Ex", "(?'a1 => bool) => bool") $
                  Abs ("x", "?'a1",
                    Const ("HOL.Ex", "...") $ Abs ("y", "...", ...))),
              name = "Product_Type.split_eta_SetCompr2", perm = false, thm =
              "%u. EX x y. u = (x, y) & ?P1 x y == %(x, y). ?P1 x y"},
             {elhs = "%u. EX x y. u = (x, y) & ?y (x, y)", extra = false,
              fo = true, lhs =
              Abs ("u", "?'a1 * ?'b1",
                Const ("HOL.Ex", "(?'a1 ... bool) => bool") $
                  Abs ("x", "?'a1",
                    Const ("HOL.Ex", "...") $ Abs ("y", ..., ...))),
              name = "Product_Type.split_eta_SetCompr", perm = false, thm =
              "%u. EX x y. u = (x, y) & ?y (x, y) == ?y"},
             {elhs = "%a. ?y ()", extra = false, fo = true, lhs =
              Abs ("", "unit",
                Var (("y", 0), "unit => ?'a1") $
                  Const ("Product_Type.Unity", "unit")),
              name = "Product_Type.unit_abs_eta_conv", perm = false, thm =
              "%a. ?y () == ?y"},
             {elhs = "%A f. Inf (f ` A)", extra = false, fo = true, lhs =
              Abs ("A", "?'a1 set",
                Abs ("f", "?'a1 => bool",
                  Const ("Complete_Lattices.Inf_class.Inf", "...") $
                    (Const ("...",
                            "(?'a1 => bool) => ?'a1 set => bool set") $
                      ... $ ...))),
              name = "Complete_Lattices.INF_bool_eq", perm = false, thm =
              "%A f. Inf (f ` A) == Ball"},
             {elhs = "%A f. Sup (f ` A)", extra = false, fo = true, lhs =
              Abs ("A", "?'a1 set",
                Abs ("f", "?'a1 ... bool",
                  Const ("...", ...) $ (... $ ... $ ...))),
              name = "Complete_Lattices.SUP_bool_eq", perm = false, thm =
              "%A f. Sup (f ... A) == Bex"}]}},
     {congs =
      ({((true, "HOL.If"),
          "?b == ?c ==> if ?b then ?x else ?y == if ?c then ?x else ?y"),
         ((true, "Set.Bex"),
           "[| ?A == ?B; !!x. x : ?B =simp=> ?P x == ?Q x |]
            ==> EX x:?A. ?P x == EX x:?B. ?Q x"),
         ((true, "Set.Ball"),
           "[| ?A == ?B; !!x. x : ?B =simp=> ?P x == ?Q x |]
            ==> ALL x:?A. ?P x == ALL x:?B. ?Q x"),
         ((true, "Set.image"),
           "[| ?M == ?N; !!x. x : ?N =simp=> ?f x == ?g x |]
            ==> ?f ` ?M == ?g ` ?N"),
         ((true, "HOL.implies"),
           "[| ?P == ?P'; ?P' ==> ?Q == ?Q' |]
            ==> ?P --> ?Q == ?P' --> ?Q'"),
         ((true, "HOL.NO_MATCH"),
           "NO_MATCH ?pat ?val == NO_MATCH ?pat ?val"),
         ((true, "HOL.ASSUMPTION"), "ASSUMPTION ?A == ASSUMPTION ?A"),
         ((true, "HOL.simp_implies"),
           "[| PROP ?P == PROP ?P'; PROP ?P' ==> PROP ?Q ... PROP ?Q' |]
            ==> (PROP ?P ... PROP ?Q) == (PROP ?P' ... PROP ?Q')"),
         ((true, "Nat.nat.case_nat"),
           "?M == ?M' ==>
            case ?M of ... ... ... | ... ... ... ==
            case ?M' of ... ... ... | ... ... ..."),
         ((true, "Num.num.case_num"),
           "?num ... ?num' ==>
            ... ... ... ... ... ... ... ... ...
            ... ... ... ... ... ... ... ..."),
         ((true, "List.successively"),
           "... ...... ... ... ==> ... ... ..."),
         ((true, "List.list.case_list"), "... ... ..."),
         ((true, "String.char.case_char"), "..."),
         ((true, "Sum_Type.sum.case_sum"), "..."),
         ((true, "Nitpick.word.case_word"), ...), ((true, "..."), ...),
         ...},
       [(true, "Power.power_class.power"),
        (true, "Phantom_Type.phantom.case_phantom"),
        (true, "Nitpick.word.case_word"),
        (true, "Nitpick.pair_box.case_pair_box"),
        (true, "Nitpick.fun_box.case_fun_box"),
        (true, "Record.tuple_isomorphism.case_tuple_isomorphism"),
        (true, "Extraction.sumbool.case_sumbool"),
        (true, "Quickcheck_Exhaustive.three_valued.case_three_valued"),
        (true, "Quickcheck_Exhaustive.unknown.case_unknown"),
        (true, "Quickcheck_Narrowing.cfun.case_cfun"),
        (true, "Quickcheck_Narrowing.ffun.case_ffun"),
        (true, "Quickcheck_Narrowing.property.case_property"),
        (true, "Quickcheck_Narrowing.narrowing_cons.case_narrowing_cons"),
        (true, "Quickcheck_Narrowing.narrowing_term.case_narrowing_term"),
        (true, "Quickcheck_Narrowing.narrowing_type.case_narrowing_type"),
        (true, "..."), ...]),
      loop_tacs =
      [("split asm HOL.If :: (HOL.bool, (_, (_, _)fun)fun)fun", fn),
       ("split asm Rings.zero_neq_one_class.of_bool :: (HOL.bool, _)fun",
        fn),
       ("split Rings.zero_neq_one_class.of_bool :: (HOL.bool, _)fun", fn),
       ("split HOL.If :: (HOL.bool, (_, (_, _)fun)fun)fun", fn)],
      mk_rews =
      {mk = fn, mk_cong = fn, mk_eq_True = fn, mk_sym = fn, reorient = fn},
      procs =
      Net {atoms = {}, comb =
           Net {atoms =
                {("HOL.Ex",
                   Net {atoms = {}, comb = Leaf [], var =
                        Leaf
                         [Proc
                           {lhs =
                            Const ("HOL.Ex", "(...) ... bool") $
                              Abs ("x", "?'a",
                                Var ((...), "?'a => bool") $ ...),
                            name = "HOL.defined_Ex", proc = fn, stamp =
                            Stamp 91198}]}),
                  ("HOL.All",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [Proc
                            {lhs =
                             Const ("HOL.All", "... ... ...") $
                               Abs ("x", "...", ... $ ...),
                             name = "HOL.defined_All", proc = fn, stamp =
                             Stamp 91244}]}),
                  ("HOL.Not",
                    Net {atoms = {}, comb =
                         Net {atoms = {}, comb =
                              Net {atoms =
                                   {("Orderings.ord_class.less",
Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}})},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []},
                         var = Leaf []}),
                  ("Nat.Suc",
                    Net {atoms = {}, comb =
                         Net {atoms = {}, comb =
                              Net {atoms =
                                   {("Groups.plus_class.plus",
Net {atoms = {}, comb = ..., var = ...})},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []},
                         var = Leaf []}),
                  ("Pure.all",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [Proc
                            {lhs =
                             Const ("...", ...) $ Abs ("...", "?'a", ...),
                             name = "HOL.defined_all", proc = fn, stamp =
                             Stamp 91290}]}),
                  ("Set.Collect",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [Proc
                            {lhs =
                             Const ("...", "(?'a => bool) => ?'a set") $
                               ...,
                             name = "Product_Type.Collect_mem", proc = fn,
                             stamp = Stamp 616364},
                           Proc
                            {lhs = ... $ ..., name = "Set.defined_Collect",
                             proc = fn, stamp = Stamp 299868}]}),
                  ("List.list.set",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [Proc
                            {lhs = ... $ ..., name =
                             "List.list_to_set_comprehension", proc = fn,
                             stamp = Stamp 2625594}]}),
                  ("Product_Type.prod.case_prod",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf [Proc {lhs = ..., name = "...", ...}]})},
                comb =
                Net {atoms =
                     {("HOL.eq",
                        Net {atoms =
                             {("Groups.one_class.one",
                                Net {atoms = {}, comb = Leaf [], var =
                                     Leaf
[Proc
  {lhs = Const ("...", "?'a => ?'a => bool") $ ... $ ..., name =
   "Groups.reorient_one", proc = fn, stamp = Stamp 171260}]}),
                               ("Groups.zero_class.zero",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf
 [Proc
   {lhs = ... $ ... $ ..., name = "Groups.reorient_zero", proc = fn, stamp =
    Stamp 171216}]})},
                             comb =
                             Net {atoms =
                                  {("Nat.Suc",
                                     Net
{atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}}),
                                    ("Num.numeral_class.numeral",
Net {atoms = {}, comb = Leaf [], var =
     Net {atoms = {}, comb = ..., var = ...}}),
                                    ("Groups.uminus_class.uminus",
Net {atoms = {}, comb = Net {atoms = {...}, ...}, var =
     Net {atoms = {}, ...}})},
                                  comb =
                                  Net {atoms =
 {("Groups.plus_class.plus",
    Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}}),
   ("Groups.minus_class.minus", Net {atoms = {}, comb = ..., var = ...}),
   ("Groups.times_class.times", Net {atoms = {}, ...})},
 comb = Leaf [], var = Leaf []},
                                  var = Leaf []},
                             var =
                             Net {atoms = {}, comb =
                                  Net {atoms =
 {("Nat.Suc", Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}),
   ("Groups.uminus_class.uminus", Net {atoms = {}, comb = ..., var = ...})},
 comb =
 Net {atoms =
      {("Groups.plus_class.plus", Net {atoms = {}, ...}),
        ("Groups.minus_class.minus", ...), ...},
      comb = Leaf [], var = Leaf []},
 var = Leaf []},
                                  var =
                                  Leaf
                                   [Proc
                                     {lhs =
Const ("...", ...) $ Var ((...), "?'a") $ ..., name = "record_eq", proc =
fn, stamp = Stamp 4153886},
                                    Proc
                                     {lhs =
Const ("...", "?'a list => ?'a list => bool") $ ... $ ..., name =
"List.list_neq", proc = fn, stamp = Stamp 2645062},
                                    Proc
                                     {lhs = ... $ ... $ ..., name =
"List.list_eq", proc = fn, stamp = Stamp 2633172},
                                    Proc {lhs = ..., name = "...", ...},
                                    Proc {lhs = ..., ...}, ...]}}),
                       ("HOL.Let",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [], var =
                                   Leaf
                                    [Proc
{lhs = Const ("...", "?'a => (?'a => ?'b) => ?'b") $ ... $ ..., name =
 "HOL.let_simp", proc = fn, stamp = Stamp 91526}]}}),
                       ("Set.Bex",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [], var =
                                   Leaf
                                    [Proc
{lhs = ... $ ... $ ..., name = "Set.defined_Bex", proc = fn, stamp =
 Stamp 303020}]}}),
                       ("Pure.imp",
                         Net {atoms = {}, comb =
                              Net {atoms =
                                   {("HOL.Trueprop",
Net {atoms = {...}, comb = ..., var = ...})},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []}),
                       ("Set.Ball",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [], var =
                                   Leaf [Proc {lhs = ..., ...}]}}),
                       ("HOL.NO_MATCH",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [...], var =
                                   Leaf [...]}}),
                       ("Rings.dvd_class.dvd",
                         Net {atoms = {}, comb =
                              Net {atoms = {}, comb = ..., var = ...}, var =
                              Net {atoms = {}, comb = ..., var = ...}}),
                       ("Groups.plus_class.plus",
                         Net {atoms = {}, comb = Leaf [...], var =
                              Net {atoms = {}, ...}}),
                       ("Lattices.inf_class.inf",
                         Net {atoms = {}, comb = ..., var = ...}),
                       ("Lattices.sup_class.sup", Net {atoms = {}, ...}),
                       ("Groups.minus_class.minus", ...), ...},
                     comb =
                     Net {atoms =
                          {("Fun.fun_upd",
                             Net {atoms = {}, comb =
                                  Net {atoms = {}, comb =
 Net {atoms = {}, comb = Net {atoms = {...}, comb = ..., var = ...}, var =
      Leaf []},
 var = Leaf []},
                                  var = Leaf []})},
                          comb = Leaf [], var = Leaf []},
                     var = Leaf []},
                var = Leaf []},
           var =
           Leaf
            [Proc
              {lhs = Var (("x", 0), "?'a"), name = "record", proc = fn,
               stamp = Stamp 4153844},
             Proc
              {lhs = Var (("x", 0), "?'a"), name = "record_upd", proc = fn,
               stamp = Stamp 4153854},
             Proc
              {lhs = Var (("x", 0), "unit"), name = "Product_Type.unit_eq",
               proc = fn, stamp = Stamp 562196}]},
      solvers =
      ([Solver {id = Stamp 1038750, name = "Rtranclp", solver = fn},
        Solver {id = Stamp 1038748, name = "Tranclp", solver = fn},
        Solver {id = Stamp 1038746, name = "Rtrancl", solver = fn},
        Solver {id = Stamp 1038744, name = "Trancl", solver = fn},
        Solver {id = Stamp 781564, name = "lin_arith", solver = fn},
        Solver {id = Stamp 132670, name = "Transitivity", solver = fn},
        Solver {id = Stamp 102528, name = "ASSUMPTION", solver = fn},
        Solver {id = Stamp 90936, name = "HOL unsafe", solver = fn}],
       [Solver {id = Stamp 90938, name = "HOL safe", solver = fn}]),
      subgoal_tac = fn, term_ord = fn}):
   simpset
val unat_arith_tacs = fn: Proof.context -> tactic list
val unat_arith_tac = fn: Proof.context -> int -> tactic
val uint_arith_simpset =
   Simpset
    ({depth = (0, ref false), prems = [], rules =
      Net {atoms =
           {("Int.Pos",
              Leaf
               [{elhs = "Int.Pos", extra = false, fo = true, lhs =
                 Const ("Int.Pos", "num => int"), name = "Int.Pos_def",
                 perm = false, thm = "Int.Pos == numeral"}]),
             ("Word.Word",
               Leaf
                [{elhs = "Word.Word", extra = false, fo = true, lhs =
                  Const ("Word.Word", "int => ?'a1 word"), name =
                  "Word.Word_eq_word_of_int", perm = false, thm =
                  "Word.Word == word_of_int"}]),
             ("Word.cast",
               Leaf
                [{elhs = "Word.cast", extra = false, fo = true, lhs =
                  Const ("Word.cast", "?'a1 word => ?'b1 word"), name =
                  "??.unknown", perm = false, thm = "Word.cast == ucast"}]),
             ("Word.of_int",
               Leaf
                [{elhs = "Word.of_int", extra = false, fo = true, lhs =
                  Const ("Word.of_int", "int => ?'a1 word"), name =
                  "??.unknown", perm = false, thm =
                  "Word.of_int == word_of_int"}]),
             ("Word.of_nat",
               Leaf
                [{elhs = "Word.of_nat", extra = false, fo = true, lhs =
                  Const ("Word.of_nat", "nat => ?'a1 word"), name =
                  "??.unknown", perm = false, thm =
                  "Word.of_nat == word_of_nat"}]),
             ("Word.the_int",
               Leaf
                [{elhs = "Word.the_int", extra = false, fo = true, lhs =
                  Const ("Word.the_int", "?'a1 word => int"), name =
                  "??.unknown", perm = false, thm =
                  "Word.the_int == uint"}]),
             ("Word.the_nat",
               Leaf
                [{elhs = "Word.the_nat", extra = false, fo = true, lhs =
                  Const ("Word.the_nat", "?'a1 word ... nat"), name =
                  "??.unknown", perm = false, thm =
                  "Word.the_nat == unat"}]),
             ("String.Literal'",
               Leaf
                [{elhs = "String.Literal'", extra = false, fo = true, lhs =
                  Const ("String.Literal'", "... ... ..."), name =
                  "String.Literal'_def", perm = false, thm =
                  "String.Literal' ... String.Literal"}]),
             ("Code_Numeral.Pos",
               Leaf
                [{elhs = "Code_Numeral.Pos", extra = false, fo = true, lhs =
                  Const ("Code_Numeral.Pos", "..."), name =
                  "Code_Numeral.Pos_def", perm = false, thm =
                  "... ... ..."}]),
             ("Word.signed_cast",
               Leaf
                [{elhs = "Word.signed_cast", extra = false, fo = true, lhs =
                  Const ("Word.signed_cast", "..."), name = "??.unknown",
                  ...}]),
             ("Word.the_signed_int",
               Leaf
                [{elhs = "...", extra = false, fo = true, lhs =
                  Const ("...", ...), ...}]),
             ("Groups.abs_class.abs",
               Leaf [{elhs = "...", extra = false, fo = true, ...}]),
             ("Groups.one_class.one",
               Leaf [{elhs = ..., extra = false, ...}, ...]),
             ("Groups.sgn_class.sgn", Leaf [...]),
             ("Code_Numeral.negative", ...), ...},
           comb =
           Net {atoms =
                {("Fun.id",
                   Net {atoms = {}, comb = Leaf [], var =
                        Leaf
                         [{elhs = "id ?y", extra = false, fo = true, lhs =
                           Const ("Fun.id", "?'a => ?'a") $
                             Var (("y", 0), "?'a"),
                           name = "Fun.id_apply", perm = false, thm =
                           "id ?y == ?y"}]}),
                  ("HOL.Ex",
                    Net {atoms = {}, comb =
                         Net {atoms =
                              {("HOL.eq",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf
 [{elhs = "...", extra = false, fo = true, lhs =
   Const ("...", "(?'d1 => bool) => bool") $ ..., ...}]})},
                              comb = Leaf [], var = Leaf []},
                         var =
                         Leaf
                          [{elhs = "Ex ?P1", extra = false, fo = true, lhs =
                            Const ("HOL.Ex", "(...) ... bool") $
                              Abs ("x", "1",
                                Var ((...), "1 => bool") $ ...),
                            name = "Numeral_Type.ex_1", perm = false, thm =
                            "EX x. ?P1 x == ?P1 1"},
                           {elhs = "Ex ?P1", extra = false, fo = true, lhs =
                            Const ("HOL.Ex", "... ... ...") $
                              Abs ("x", "...", ... $ ...),
                            name = "Product_Type.split_paired_Ex", perm =
                            false, thm =
                            "... x... ... ... == ... a b... ... ..."},
                           {elhs = "EX x y. ?p1 ... ......... ......",
                            extra = false, fo = true, lhs =
                            Const ("HOL.Ex", "...") $ Abs ("x", "...", ...),
                            name = "Product_Type.surj_pair", perm = false,
                            thm = "... ... ...... ... ... True"},
                           {elhs = "... x... ... ... ...", extra = false,
                            fo = false, lhs =
                            Const ("HOL.Ex", "...") $ Abs ("x", ..., ...),
                            name = "Set.ex_image_cong_iff_2", perm = false,
                            thm = "... ... ..."},
                           {elhs = "... ...... ...", extra = false, fo =
                            true, lhs =
                            Const ("...", ...) $ Abs ("...", "?'a1", ...),
                            name = "Set.ex_image_cong_iff_1", ...},
                           {elhs = "...", extra = false, fo = false, lhs =
                            Const ("...", "(?'d1 => bool) => bool") $ ...,
                            ...},
                           {elhs = "...", extra = false, fo = false, ...},
                           {elhs = ..., extra = false, ...}, ...]}),
                  ("HOL.All",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [{elhs = "All ?P1", extra = false, fo = true,
                            lhs =
                            Const ("HOL.All", "... ... ...") $
                              Abs ("i", "...", ... $ ...),
                            name = "Numeral_Type.forall_1", perm = false,
                            thm = "... i... ... ... == ?P1 ..."},
                           {elhs = "ALL y. ?x1 ... ... ...", extra = false,
                            fo = true, lhs =
                            Const ("HOL.All", "...") $
                              Abs ("y", "...", ...),
                            name = "Option.not_Some_eq", perm = false, thm =
                            "... ...... ... ... ... ... ..."},
                           {elhs = "All ?P1", extra = false, fo = true,
                            lhs =
                            Const ("HOL.All", "...") $ Abs ("x", ..., ...),
                            name = "Product_Type.split_paired_All", perm =
                            false, thm = "... ... ..."},
                           {elhs = "... ...... ...", extra = false, fo =
                            true, lhs =
                            Const ("...", ...) $ Abs ("...", "?'a1", ...),
                            name = "Set.all_not_in_conv", ...},
                           {elhs = "...", extra = false, fo = true, lhs =
                            Const ("...", "(?'d1 => bool) => bool") $ ...,
                            ...},
                           {elhs = "...", extra = false, fo = true, ...},
                           {elhs = ..., extra = false, ...}, ...]}),
                  ("HOL.Ex1",
                    Net {atoms = {}, comb =
                         Net {atoms =
                              {("HOL.eq",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf [{elhs = ..., extra = false, ...}]})},
                              comb = Leaf [], var = Leaf []},
                         var =
                         Leaf
                          [{elhs = "EX! x. x ... ?t1", extra = false, fo =
                            true, lhs =
                            Const ("HOL.Ex1", "...") $
                              Abs ("x", "...", ...),
                            name = "HOL.ex1_eq_1", perm = false, thm =
                            "... ...... ... ... True"}]}),
                  ("HOL.Not",
                    Net {atoms =
                         {("HOL.True",
                            Leaf
                             [{elhs = "... True", extra = false, fo = true,
                               lhs =
                               Const ("...", ...) $ Const ("...", "bool"),
                               name = "HOL.simp_thms_7", ...}]),
                           ("HOL.False",
                             Leaf
                              [{elhs = "... ...", extra = false, fo = true,
                                lhs = Const ("...", "bool => bool") $ ...,
                                ...}])},
                         comb =
                         Net {atoms =
                              {("HOL.Ex",
                                 Net {atoms = {}, comb = Leaf [...], var =
Leaf [...]}),
                                ("HOL.All",
                                  Net {atoms = {}, comb = ..., var = ...}),
                                ("HOL.Not", Net {atoms = {}, ...}),
                                ("Finite_Set.finite", ...)},
                              comb =
                              Net {atoms =
                                   {("HOL.eq", Net {atoms = {...}, ...}),
                                     ("Set.Bex", ...), ...},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []},
                         var = Leaf []}),
                  ("HOL.The",
                    Net {atoms = {}, comb =
                         Net {atoms =
                              {("HOL.eq",
                                 Net {atoms = {}, comb = ..., var = ...}),
                                ("Product_Type.prod.case_prod",
                                  Net {atoms = {}, ...})},
                              comb = Leaf [], var = Leaf []},
                         var =
                         Leaf
                          [{elhs = "... ...... ...", extra = false, fo =
                            true, lhs =
                            Const ("...", ...) $ Abs ("...", "?'a", ...),
                            name = "HOL.the_eq_trivial", ...}]}),
                  ("Int.Neg",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [{elhs = "...", extra = false, fo = true, lhs =
                            Const ("...", "num => int") $ ..., ...}]}),
                  ("Int.dup",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [{elhs = "...", extra = false, fo = true, ...}]}),
                  ("Int.nat",
                    Net {atoms =
                         {("Groups.one_class.one", Leaf [...]),
                           ("Groups.zero_class.zero", ...)},
                         comb = Net {atoms = {...}, comb = ..., var = ...},
                         var = Leaf [{elhs = ..., extra = false, ...}]}),
                  ("Map.dom",
                    Net {atoms = {}, comb = Net {atoms = {...}, ...}, var =
                         Leaf [...]}),
                  ("Map.ran", Net {atoms = {}, comb = ..., var = ...}),
                  ("Nat.Suc", Net {atoms = {...}, ...}), ("Num.inc", ...),
                  ...},
                comb =
                Net {atoms =
                     {("HOL.eq",
                        Net {atoms =
                             {("HOL.True",
                                Net {atoms =
                                     {("HOL.False",
  Leaf
   [{elhs = "...", extra = false, fo = true, lhs =
     Const ("...", "bool => bool => bool") $ ... $ ..., ...}])},
                                     comb = Leaf [], var =
                                     Leaf
[{elhs = "... ... ...", extra = false, fo = true, lhs =
  Const ("...", ...) $ Const ("...", "bool") $ ..., name =
  "HOL.simp_thms_11", ...}]}),
                               ("HOL.False",
                                 Net {atoms =
{("HOL.True", Leaf [{elhs = "...", extra = false, fo = true, ...}])}, comb =
Leaf [], var =
Leaf
 [{elhs = "...", extra = false, fo = true, lhs =
   Const ("...", "bool => bool => bool") $ ... $ ..., ...}]}),
                               ("Num.num.One",
                                 Net {atoms = {}, comb =
Net {atoms = {("Num.num.Bit0", ...), ...}, comb = Leaf [...], var =
     Leaf [...]},
var = Leaf []}),
                               ("Filter.at_bot",
                                 Net {atoms =
{("Orderings.bot_class.bot", Leaf [...])}, comb = Leaf [], var = Leaf []}),
                               ("Filter.at_top",
                                 Net {atoms =
{("Orderings.bot_class.bot", ...)}, comb = Leaf [...], var = Leaf [...]}),
                               ("List.list.Nil",
                                 Net {atoms = {}, comb = ..., var = ...}),
                               ("Filter.cofinite",
                                 Net {atoms = {...}, ...}),
                               ("Option.option.None", ...), ...},
                             comb =
                             Net {atoms =
                                  {("HOL.Not",
                                     Net
{atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Net {atoms = {...}, ...}, var = Leaf [...]}}),
                                    ("Int.nat",
Net {atoms = {}, comb = Leaf [], var =
     Net {atoms = {...}, comb = ..., var = ...}}),
                                    ("Map.dom",
Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {...}, ...}}),
                                    ("Nat.Suc",
Net {atoms = {...}, comb = ..., var = ...}),
                                    ("Set.Pow", Net {atoms = {}, ...}),
                                    ("List.rev", ...), ...},
                                  comb =
                                  Net {atoms =
 {("List.upt",
    Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}}),
   ("List.zip", Net {atoms = {}, comb = ..., var = ...}),
   ("List.drop", Net {atoms = {}, ...}), ("List.take", ...), ...},
 comb =
 Net {atoms =
      {("Fun.fun_upd", Net {atoms = {}, ...}), ("Map.map_add", ...), ...},
      comb = Net {atoms = {...}, comb = ..., var = ...}, var = Leaf []},
 var = Leaf []},
                                  var = Leaf []},
                             var =
                             Net {atoms =
                                  {("HOL.True",
                                     Leaf
[{elhs = "... ... ...", extra = false, fo = true, lhs =
  Const ("...", ...) $ Var ((...), "bool") $ ..., name = "HOL.simp_thms_12",
  ...}]),
                                    ("HOL.False",
Leaf
 [{elhs = "...", extra = false, fo = true, lhs =
   Const ("...", "bool => bool => bool") $ ... $ ..., ...}]),
                                    ("Groups.one_class.one",
Leaf [{elhs = "...", extra = false, fo = true, ...}])},
                                  comb =
                                  Net {atoms =
 {("HOL.Not", Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}),
   ("Map.map_of", Net {atoms = {}, comb = ..., var = ...}),
   ("Groups.uminus_class.uminus", Net {atoms = {}, ...})},
 comb =
 Net {atoms =
      {("List.append", Net {atoms = {}, ...}), ("Map.map_add", ...), ...},
      comb = Leaf [], var = Leaf []},
 var = Leaf []},
                                  var =
                                  Leaf
                                   [{elhs = "?a1 ... ?b1", extra = false,
                                     fo = true, lhs =
                                     Const ("HOL.eq", "...") $
 Var (("...", 1), ...) $ Var ((...), "?'a1 word"),
                                     name = "local.uint_arith_simps_3",
                                     perm = false, thm = "... ... ..."},
                                    {elhs = "... ... ...", extra = false,
                                     fo = true, lhs =
                                     Const ("...", ...) $
 Var ((...), "?'a1") $ ...,
                                     name = "HOL.simp_thms_6", ...}]}}),
                       ("HOL.Let",
                         Net {atoms =
                              {("Groups.one_class.one",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf
 [{elhs = "...", extra = false, fo = true, lhs =
   Const ("...", "?'b1 => (?'b1 => ?'a) => ?'a") $ ... $ ..., ...}]}),
                                ("Groups.zero_class.zero",
                                  Net {atoms = {}, comb = Leaf [], var =
 Leaf [{elhs = "...", extra = false, fo = true, ...}]})},
                              comb =
                              Net {atoms =
                                   {("Nat.Suc",
Net {atoms = {}, comb = Leaf [], var =
     Net {atoms = {}, comb = ..., var = ...}}),
                                     ("Num.numeral_class.numeral",
 Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}}),
                                     ("Groups.uminus_class.uminus",
 Net {atoms = {}, comb = ..., var = ...})},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []}),
                       ("Int.sub",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [], var =
                                   Leaf
                                    [{elhs = "...", extra = false, fo =
true, lhs = Const ("...", "num => num => int") $ ... $ ..., ...}]}}),
                       ("Num.pow",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms =
                                   {("Num.num.One",
Leaf [{elhs = ..., extra = false, ...}])},
                                   comb =
                                   Net {atoms =
  {("Num.num.Bit0", ...), ...}, comb = Leaf [...], var = Leaf [...]},
                                   var = Leaf []}}),
                       ("Set.Bex",
                         Net {atoms =
                              {("Orderings.bot_class.bot",
                                 Net {atoms = {}, comb = Leaf [...], var =
Leaf [...]}),
                                ("Orderings.top_class.top",
                                  Net {atoms = {}, comb = ..., var = ...})},
                              comb =
                              Net {atoms =
                                   {("Set.Collect", Net {atoms = {}, ...}),
                                     ("List.list.set", ...), ...},
                                   comb =
                                   Net {atoms = {...}, comb = ..., var =
  ...},
                                   var = Leaf []},
                              var =
                              Net {atoms = {}, comb =
                                   Net {atoms = {...}, comb = ..., var =
  ...},
                                   var =
                                   Leaf
                                    [{elhs = ..., extra = false, ...},
                                     ...]}}),
                       ("Fun.comp",
                         Net {atoms =
                              {("Fun.id",
                                 Net {atoms = {}, comb = ..., var = ...}),
                                ("Option.option.the",
                                  Net {atoms = {...}, ...}),
                                ("Product_Type.prod.fst", ...), ...},
                              comb =
                              Net {atoms = {("List.list.map", ...), ...},
                                   comb = Net {atoms = {...}, ...}, var =
                                   Leaf [...]},
                              var =
                              Net {atoms = {("Fun.id", ...)}, comb =
                                   Leaf [...], var = Leaf [...]}}),
                       ("GCD.bezw",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {...}, comb = ..., var = ...}}),
                       ("HOL.conj",
                         Net {atoms = {("HOL.True", ...), ...}, comb =
                              Net {atoms = {...}, ...}, var =
                              Net {atoms = {...}, ...}}),
                       ("HOL.disj",
                         Net {atoms = {...}, comb = ..., var = ...}),
                       ("List.nth", Net {atoms = {}, ...}),
                       ("List.upt", ...), ...},
                     comb =
                     Net {atoms =
                          {("HOL.If",
                             Net {atoms =
                                  {("HOL.True",
                                     Net
{atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}}),
                                    ("HOL.False",
Net {atoms = {}, comb = Leaf [], var =
     Net {atoms = {}, comb = ..., var = ...}})},
                                  comb =
                                  Net {atoms = {}, comb =
 Net {atoms = {("HOL.eq", Net {atoms = {}, ...})}, comb = Leaf [], var =
      Leaf []},
 var = Leaf []},
                                  var =
                                  Net {atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Leaf [], var =
      Leaf [{elhs = ..., extra = false, ...}]}}}),
                            ("Fun.comp",
                              Net {atoms = {}, comb = Leaf [], var =
                                   Net {atoms = {}, comb = Leaf [], var =
  Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}}}),
                            ("Fun.fcomp",
                              Net {atoms = {}, comb = Leaf [], var =
                                   Net {atoms = {}, comb = Leaf [], var =
  Net {atoms = {}, comb = ..., var = ...}}}),
                            ("List.foldl",
                              Net {atoms = {}, comb = Leaf [], var =
                                   Net {atoms = {}, comb = Leaf [...], var =
  Net {atoms = {...}, ...}}}),
                            ("List.foldr",
                              Net {atoms = {}, comb = Leaf [], var =
                                   Net {atoms = {}, comb = ..., var =
  ...}}),
                            ("Nat.compow",
                              Net {atoms =
                                   {("Groups.zero_class.zero", ...)}, comb =
                                   Leaf [...], var = Leaf [...]}),
                            ("Fun.fun_upd",
                              Net {atoms = {}, comb = ..., var = ...}),
                            ("Map.map_add", Net {atoms = {}, ...}),
                            ("Fun.bij_betw", ...), ...},
                          comb =
                          Net {atoms =
                               {("Fun.fun_upd",
                                  Net {atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Leaf [], var =
      Net {atoms = {}, comb = ..., var = ...}}}),
                                 ("Fun.map_fun",
                                   Net {atoms = {}, comb = Leaf [], var =
  Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}}}),
                                 ("Map.map_upds",
                                   Net {atoms = {}, comb = Leaf [], var =
  Net {atoms = {}, comb = ..., var = ...}}),
                                 ("BNF_Def.rel_sum",
                                   Net {atoms = {}, comb = Leaf [...], var =
  Net {atoms = {}, ...}}),
                                 ("Fun.override_on",
                                   Net {atoms = {}, comb = ..., var = ...}),
                                 ("Num.num.rec_num", Net {atoms = {}, ...}),
                                 ("Num.num.case_num", ...), ...},
                               comb =
                               Net {atoms =
                                    {("Enum.finite_4.rec_finite_4",
 Net {atoms = {}, comb = Leaf [], var =
      Net {atoms = {}, comb = ..., var = ...}}),
("Enum.finite_4.case_finite_4",
  Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}})},
                                    comb =
                                    Net {atoms =
   {("Enum.finite_5.rec_finite_5", Net {atoms = {}, comb = ..., var = ...}),
     ("Enum.finite_5.case_finite_5", Net {atoms = {}, ...})},
   comb =
   Net {atoms = {}, comb = Net {atoms = {...}, ...}, var = Leaf [...]},
   var = Leaf []},
                                    var = Leaf []},
                               var = Leaf []},
                          var = Leaf []},
                     var = Leaf []},
                var = Leaf []},
           var =
           Leaf
            [{elhs = "%u. EX x y. u = (x, y) & ?P1 x y", extra = false, fo =
              false, lhs =
              Abs ("u", "?'a1 * ?'b1",
                Const ("HOL.Ex", "(?'a1 => bool) => bool") $
                  Abs ("x", "?'a1",
                    Const ("HOL.Ex", "...") $ Abs ("y", "...", ...))),
              name = "Product_Type.split_eta_SetCompr2", perm = false, thm =
              "%u. EX x y. u = (x, y) & ?P1 x y == %(x, y). ?P1 x y"},
             {elhs = "%u. EX x y. u = (x, y) & ?y (x, y)", extra = false,
              fo = true, lhs =
              Abs ("u", "?'a1 * ?'b1",
                Const ("HOL.Ex", "(?'a1 ... bool) => bool") $
                  Abs ("x", "?'a1",
                    Const ("HOL.Ex", "...") $ Abs ("y", ..., ...))),
              name = "Product_Type.split_eta_SetCompr", perm = false, thm =
              "%u. EX x y. u = (x, y) & ?y (x, y) == ?y"},
             {elhs = "%a. ?y ()", extra = false, fo = true, lhs =
              Abs ("", "unit",
                Var (("y", 0), "unit => ?'a1") $
                  Const ("Product_Type.Unity", "unit")),
              name = "Product_Type.unit_abs_eta_conv", perm = false, thm =
              "%a. ?y () == ?y"},
             {elhs = "%A f. Inf (f ` A)", extra = false, fo = true, lhs =
              Abs ("A", "?'a1 set",
                Abs ("f", "?'a1 => bool",
                  Const ("Complete_Lattices.Inf_class.Inf", "...") $
                    (Const ("...",
                            "(?'a1 => bool) => ?'a1 set => bool set") $
                      ... $ ...))),
              name = "Complete_Lattices.INF_bool_eq", perm = false, thm =
              "%A f. Inf (f ` A) == Ball"},
             {elhs = "%A f. Sup (f ` A)", extra = false, fo = true, lhs =
              Abs ("A", "?'a1 set",
                Abs ("f", "?'a1 ... bool",
                  Const ("...", ...) $ (... $ ... $ ...))),
              name = "Complete_Lattices.SUP_bool_eq", perm = false, thm =
              "%A f. Sup (f ... A) == Bex"}]}},
     {congs =
      ({((true, "HOL.If"),
          "?b == ?c ==> if ?b then ?x else ?y == if ?c then ?x else ?y"),
         ((true, "Set.Bex"),
           "[| ?A == ?B; !!x. x : ?B =simp=> ?P x == ?Q x |]
            ==> EX x:?A. ?P x == EX x:?B. ?Q x"),
         ((true, "Set.Ball"),
           "[| ?A == ?B; !!x. x : ?B =simp=> ?P x == ?Q x |]
            ==> ALL x:?A. ?P x == ALL x:?B. ?Q x"),
         ((true, "Set.image"),
           "[| ?M == ?N; !!x. x : ?N =simp=> ?f x == ?g x |]
            ==> ?f ` ?M == ?g ` ?N"),
         ((true, "HOL.implies"),
           "[| ?P == ?P'; ?P' ==> ?Q == ?Q' |]
            ==> ?P --> ?Q == ?P' --> ?Q'"),
         ((true, "HOL.NO_MATCH"),
           "NO_MATCH ?pat ?val == NO_MATCH ?pat ?val"),
         ((true, "HOL.ASSUMPTION"), "ASSUMPTION ?A == ASSUMPTION ?A"),
         ((true, "HOL.simp_implies"),
           "[| PROP ?P == PROP ?P'; PROP ?P' ==> PROP ?Q ... PROP ?Q' |]
            ==> (PROP ?P ... PROP ?Q) == (PROP ?P' ... PROP ?Q')"),
         ((true, "Nat.nat.case_nat"),
           "?M == ?M' ==>
            case ?M of ... ... ... | ... ... ... ==
            case ?M' of ... ... ... | ... ... ..."),
         ((true, "Num.num.case_num"),
           "?num ... ?num' ==>
            ... ... ... ... ... ... ... ... ...
            ... ... ... ... ... ... ... ..."),
         ((true, "List.successively"),
           "... ...... ... ... ==> ... ... ..."),
         ((true, "List.list.case_list"), "... ... ..."),
         ((true, "String.char.case_char"), "..."),
         ((true, "Sum_Type.sum.case_sum"), "..."),
         ((true, "Nitpick.word.case_word"), ...), ((true, "..."), ...),
         ...},
       [(true, "Power.power_class.power"),
        (true, "Phantom_Type.phantom.case_phantom"),
        (true, "Nitpick.word.case_word"),
        (true, "Nitpick.pair_box.case_pair_box"),
        (true, "Nitpick.fun_box.case_fun_box"),
        (true, "Record.tuple_isomorphism.case_tuple_isomorphism"),
        (true, "Extraction.sumbool.case_sumbool"),
        (true, "Quickcheck_Exhaustive.three_valued.case_three_valued"),
        (true, "Quickcheck_Exhaustive.unknown.case_unknown"),
        (true, "Quickcheck_Narrowing.cfun.case_cfun"),
        (true, "Quickcheck_Narrowing.ffun.case_ffun"),
        (true, "Quickcheck_Narrowing.property.case_property"),
        (true, "Quickcheck_Narrowing.narrowing_cons.case_narrowing_cons"),
        (true, "Quickcheck_Narrowing.narrowing_term.case_narrowing_term"),
        (true, "Quickcheck_Narrowing.narrowing_type.case_narrowing_type"),
        (true, "..."), ...]),
      loop_tacs =
      [("split asm HOL.If :: (HOL.bool, (_, (_, _)fun)fun)fun", fn),
       ("split asm Rings.zero_neq_one_class.of_bool :: (HOL.bool, _)fun",
        fn),
       ("split Rings.zero_neq_one_class.of_bool :: (HOL.bool, _)fun", fn),
       ("split HOL.If :: (HOL.bool, (_, (_, _)fun)fun)fun", fn)],
      mk_rews =
      {mk = fn, mk_cong = fn, mk_eq_True = fn, mk_sym = fn, reorient = fn},
      procs =
      Net {atoms = {}, comb =
           Net {atoms =
                {("HOL.Ex",
                   Net {atoms = {}, comb = Leaf [], var =
                        Leaf
                         [Proc
                           {lhs =
                            Const ("HOL.Ex", "(...) ... bool") $
                              Abs ("x", "?'a",
                                Var ((...), "?'a => bool") $ ...),
                            name = "HOL.defined_Ex", proc = fn, stamp =
                            Stamp 91198}]}),
                  ("HOL.All",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [Proc
                            {lhs =
                             Const ("HOL.All", "... ... ...") $
                               Abs ("x", "...", ... $ ...),
                             name = "HOL.defined_All", proc = fn, stamp =
                             Stamp 91244}]}),
                  ("HOL.Not",
                    Net {atoms = {}, comb =
                         Net {atoms = {}, comb =
                              Net {atoms =
                                   {("Orderings.ord_class.less",
Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}})},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []},
                         var = Leaf []}),
                  ("Nat.Suc",
                    Net {atoms = {}, comb =
                         Net {atoms = {}, comb =
                              Net {atoms =
                                   {("Groups.plus_class.plus",
Net {atoms = {}, comb = ..., var = ...})},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []},
                         var = Leaf []}),
                  ("Pure.all",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [Proc
                            {lhs =
                             Const ("...", ...) $ Abs ("...", "?'a", ...),
                             name = "HOL.defined_all", proc = fn, stamp =
                             Stamp 91290}]}),
                  ("Set.Collect",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [Proc
                            {lhs =
                             Const ("...", "(?'a => bool) => ?'a set") $
                               ...,
                             name = "Product_Type.Collect_mem", proc = fn,
                             stamp = Stamp 616364},
                           Proc
                            {lhs = ... $ ..., name = "Set.defined_Collect",
                             proc = fn, stamp = Stamp 299868}]}),
                  ("List.list.set",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [Proc
                            {lhs = ... $ ..., name =
                             "List.list_to_set_comprehension", proc = fn,
                             stamp = Stamp 2625594}]}),
                  ("Product_Type.prod.case_prod",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf [Proc {lhs = ..., name = "...", ...}]})},
                comb =
                Net {atoms =
                     {("HOL.eq",
                        Net {atoms =
                             {("Groups.one_class.one",
                                Net {atoms = {}, comb = Leaf [], var =
                                     Leaf
[Proc
  {lhs = Const ("...", "?'a => ?'a => bool") $ ... $ ..., name =
   "Groups.reorient_one", proc = fn, stamp = Stamp 171260}]}),
                               ("Groups.zero_class.zero",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf
 [Proc
   {lhs = ... $ ... $ ..., name = "Groups.reorient_zero", proc = fn, stamp =
    Stamp 171216}]})},
                             comb =
                             Net {atoms =
                                  {("Nat.Suc",
                                     Net
{atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}}),
                                    ("Num.numeral_class.numeral",
Net {atoms = {}, comb = Leaf [], var =
     Net {atoms = {}, comb = ..., var = ...}}),
                                    ("Groups.uminus_class.uminus",
Net {atoms = {}, comb = Net {atoms = {...}, ...}, var =
     Net {atoms = {}, ...}})},
                                  comb =
                                  Net {atoms =
 {("Groups.plus_class.plus",
    Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}}),
   ("Groups.minus_class.minus", Net {atoms = {}, comb = ..., var = ...}),
   ("Groups.times_class.times", Net {atoms = {}, ...})},
 comb = Leaf [], var = Leaf []},
                                  var = Leaf []},
                             var =
                             Net {atoms = {}, comb =
                                  Net {atoms =
 {("Nat.Suc", Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}),
   ("Groups.uminus_class.uminus", Net {atoms = {}, comb = ..., var = ...})},
 comb =
 Net {atoms =
      {("Groups.plus_class.plus", Net {atoms = {}, ...}),
        ("Groups.minus_class.minus", ...), ...},
      comb = Leaf [], var = Leaf []},
 var = Leaf []},
                                  var =
                                  Leaf
                                   [Proc
                                     {lhs =
Const ("...", ...) $ Var ((...), "?'a") $ ..., name = "record_eq", proc =
fn, stamp = Stamp 4153886},
                                    Proc
                                     {lhs =
Const ("...", "?'a list => ?'a list => bool") $ ... $ ..., name =
"List.list_neq", proc = fn, stamp = Stamp 2645062},
                                    Proc
                                     {lhs = ... $ ... $ ..., name =
"List.list_eq", proc = fn, stamp = Stamp 2633172},
                                    Proc {lhs = ..., name = "...", ...},
                                    Proc {lhs = ..., ...}, ...]}}),
                       ("HOL.Let",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [], var =
                                   Leaf
                                    [Proc
{lhs = Const ("...", "?'a => (?'a => ?'b) => ?'b") $ ... $ ..., name =
 "HOL.let_simp", proc = fn, stamp = Stamp 91526}]}}),
                       ("Set.Bex",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [], var =
                                   Leaf
                                    [Proc
{lhs = ... $ ... $ ..., name = "Set.defined_Bex", proc = fn, stamp =
 Stamp 303020}]}}),
                       ("Pure.imp",
                         Net {atoms = {}, comb =
                              Net {atoms =
                                   {("HOL.Trueprop",
Net {atoms = {...}, comb = ..., var = ...})},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []}),
                       ("Set.Ball",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [], var =
                                   Leaf [Proc {lhs = ..., ...}]}}),
                       ("HOL.NO_MATCH",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [...], var =
                                   Leaf [...]}}),
                       ("Rings.dvd_class.dvd",
                         Net {atoms = {}, comb =
                              Net {atoms = {}, comb = ..., var = ...}, var =
                              Net {atoms = {}, comb = ..., var = ...}}),
                       ("Groups.plus_class.plus",
                         Net {atoms = {}, comb = Leaf [...], var =
                              Net {atoms = {}, ...}}),
                       ("Lattices.inf_class.inf",
                         Net {atoms = {}, comb = ..., var = ...}),
                       ("Lattices.sup_class.sup", Net {atoms = {}, ...}),
                       ("Groups.minus_class.minus", ...), ...},
                     comb =
                     Net {atoms =
                          {("Fun.fun_upd",
                             Net {atoms = {}, comb =
                                  Net {atoms = {}, comb =
 Net {atoms = {}, comb = Net {atoms = {...}, comb = ..., var = ...}, var =
      Leaf []},
 var = Leaf []},
                                  var = Leaf []})},
                          comb = Leaf [], var = Leaf []},
                     var = Leaf []},
                var = Leaf []},
           var =
           Leaf
            [Proc
              {lhs = Var (("x", 0), "?'a"), name = "record", proc = fn,
               stamp = Stamp 4153844},
             Proc
              {lhs = Var (("x", 0), "?'a"), name = "record_upd", proc = fn,
               stamp = Stamp 4153854},
             Proc
              {lhs = Var (("x", 0), "unit"), name = "Product_Type.unit_eq",
               proc = fn, stamp = Stamp 562196}]},
      solvers =
      ([Solver {id = Stamp 1038750, name = "Rtranclp", solver = fn},
        Solver {id = Stamp 1038748, name = "Tranclp", solver = fn},
        Solver {id = Stamp 1038746, name = "Rtrancl", solver = fn},
        Solver {id = Stamp 1038744, name = "Trancl", solver = fn},
        Solver {id = Stamp 781564, name = "lin_arith", solver = fn},
        Solver {id = Stamp 132670, name = "Transitivity", solver = fn},
        Solver {id = Stamp 102528, name = "ASSUMPTION", solver = fn},
        Solver {id = Stamp 90936, name = "HOL unsafe", solver = fn}],
       [Solver {id = Stamp 90938, name = "HOL safe", solver = fn}]),
      subgoal_tac = fn, term_ord = fn}):
   simpset
val uint_arith_tacs = fn: Proof.context -> tactic list
val uint_arith_tac = fn: Proof.context -> int -> tactic
locale word_rotate
locale Group.comm_monoid
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "Group.comm_monoid G"
locale csemiring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "csemiring R"
locale cring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "cring R"
signature SMT_WORD =
  sig
    val add_word_shift': term * string -> Context.generic -> Context.generic
  end
structure SMT_Word: SMT_WORD
### theory "HOL-Library.Word"
### 6.074s elapsed time, 24.109s cpu time, 2.391s GC time
Loading theory "HOL-Library.Rewrite" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum")
infix 1 then_cconv
infix 0 else_cconv
type cconv = conv
signature BASIC_CCONV =
  sig
    val CCONVERSION: cconv -> int -> tactic
    type cconv = conv
    val else_cconv: cconv * cconv -> cconv
    val then_cconv: cconv * cconv -> cconv
  end
signature CCONV =
  sig
    val CCONVERSION: cconv -> int -> tactic
    val abs_cconv:
       (cterm * Proof.context -> cconv) -> Proof.context -> cconv
    val all_cconv: cconv
    val arg1_cconv: cconv -> cconv
    val arg_cconv: cconv -> cconv
    type cconv = conv
    val comb_cconv: cconv -> cconv
    val combination_cconv: cconv -> cconv -> cconv
    val concl_cconv: int -> cconv -> cconv
    val else_cconv: cconv * cconv -> cconv
    val fconv_rule: cconv -> thm -> thm
    val first_cconv: cconv list -> cconv
    val fun2_cconv: cconv -> cconv
    val fun_cconv: cconv -> cconv
    val gconv_rule: cconv -> int -> thm -> thm
    val no_cconv: cconv
    val params_cconv:
       int -> (Proof.context -> cconv) -> Proof.context -> cconv
    val prems_cconv: int -> cconv -> cconv
    val rewr_cconv: thm -> cconv
    val rewrs_cconv: thm list -> cconv
    val then_cconv: cconv * cconv -> cconv
    val with_prems_cconv: int -> cconv -> cconv
  end
structure CConv: CCONV
structure Basic_CConv: BASIC_CCONV
val then_cconv = fn: cconv * cconv -> cconv
val CCONVERSION = fn: cconv -> int -> tactic
val else_cconv = fn: cconv * cconv -> cconv
locale Group.comm_monoid
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "Group.comm_monoid G"
infix 1 then_pconv
infix 0 else_pconv
signature REWRITE =
  sig
    val abs_pconv: patconv -> string option * typ -> patconv
    val all_pconv: patconv
    val arg_pconv: patconv -> patconv
    val asm_pconv: patconv -> patconv
    val asms_pconv: patconv -> patconv
    val concl_pconv: patconv -> patconv
    val else_pconv: patconv * patconv -> patconv
    val for_pconv: patconv -> (string option * typ option) list -> patconv
    val forall_pconv: patconv -> string option * typ option -> patconv
    val fun_pconv: patconv -> patconv
    val imp_pconv: patconv -> patconv
    val in_pconv: patconv -> patconv
    val judgment_pconv: patconv -> patconv
    val match_pconv: patconv -> term * (string option * typ) list -> patconv
    val mk_hole: int -> typ -> term
    val params_pconv: patconv -> patconv
    type patconv =
       Proof.context -> Type.tyenv * (string * term) list -> cconv
    datatype ('a, 'b) pattern
    = Asm | At | Concl | For of 'b list | In | Term of 'a
    val rewrite_conv:
       Proof.context ->
         (term * (string * typ) list, string * typ option) pattern list *
         term option
           -> thm list -> conv
    val rewrs_pconv: term option -> thm list -> patconv
    val then_pconv: patconv * patconv -> patconv
  end
structure Rewrite: REWRITE
### theory "HOL-Library.Rewrite"
### 0.214s elapsed time, 0.844s cpu time, 0.081s GC time
Loading theory "HOL-Library.Set_Algebras" (required by "Draft.TeleportMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
consts
  entries :: "('a, 'b) rbt => ('a * 'b) list"
locale cring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "cring R"
instantiation
  set :: (plus) plus
  plus_set == plus :: 'a set => 'a set => 'a set
### theory "Jordan_Normal_Form.Missing_Ring"
### 3.959s elapsed time, 15.717s cpu time, 1.708s GC time
Loading theory "HOL-Library.Tree" (required by "Draft.TeleportMoreTemplates" via "Draft.ExtrEqs" via "Draft.Templates")
instantiation
  set :: (times) times
  times_set == times :: 'a set => 'a set => 'a set
instantiation
  set :: (zero) zero
  zero_set == zero_class.zero :: 'a set
instantiation
  set :: (one) one
  one_set == one_class.one :: 'a set
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
consts
  rbt_sorted :: "('a, 'b) rbt => bool"
### theory "HOL-Library.Set_Algebras"
### 0.259s elapsed time, 1.027s cpu time, 0.202s GC time
Loading theory "HOL-Library.Z2" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Draft.Finite_Tensor_Product" via "Draft.Misc")
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
instantiation
  bit :: zero_neq_one
  one_bit == one_class.one :: bit
  zero_bit == zero_class.zero :: bit
consts
  rbt_lookup :: "('a, 'b) rbt => 'a => 'b option"
instantiation
  bit :: semidom_modulo
  modulo_bit == modulo :: bit => bit => bit
  divide_bit == divide :: bit => bit => bit
  minus_bit == minus :: bit => bit => bit
  times_bit == times :: bit => bit => bit
  plus_bit == plus :: bit => bit => bit
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
class zero_neq_one = one + zero +
  assumes "zero_neq_one": "(0::'a) ~= (1::'a)"
### Type
### bit => nat => bit
### of constant "Power.power_class.power"
### is too specific compared to declared type
### ?'a::{} => nat => ?'a::{}, in theorem:
### ?a ^ ?n == of_bool (odd ?a | ?n = 0)
instantiation
  bit :: field
  inverse_bit == inverse :: bit => bit
  uminus_bit == uminus :: bit => bit
instantiation
  bit :: semiring_bits
  bit_bit == bit :: bit => nat => bool
instantiation
  bit :: ring_bit_operations
  not_bit == not :: bit => bit
  and_bit == and :: bit => bit => bit
  or_bit == or :: bit => bit => bit
  xor_bit == xor :: bit => bit => bit
  mask_bit == mask :: nat => bit
  set_bit_bit == set_bit :: nat => bit => bit
  unset_bit_bit == unset_bit :: nat => bit => bit
  flip_bit_bit == flip_bit :: nat => bit => bit
  push_bit_bit == push_bit :: nat => bit => bit
  drop_bit_bit == drop_bit :: nat => bit => bit
  take_bit_bit == take_bit :: nat => bit => bit
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
consts
  color_of :: "('a, 'b) rbt => color"
consts
  bheight :: "('a, 'b) rbt => nat"
consts
  inv1 :: "('a, 'b) rbt => bool"
consts
  inv1l :: "('a, 'b) rbt => bool"
consts
  inv2 :: "('a, 'b) rbt => bool"
### theory "HOL-Library.Z2"
### 0.347s elapsed time, 1.383s cpu time, 0.208s GC time
Loading theory "HOL-Types_To_Sets.Types_To_Sets" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Complex_Bounded_Operators.Complex_L2" via "Complex_Bounded_Operators.Complex_Bounded_Linear_Function" via "Complex_Bounded_Operators.Complex_Inner_Product" via "Complex_Bounded_Operators.Complex_Inner_Product0" via "Complex_Bounded_Operators.Complex_Vector_Spaces")
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
signature LOCAL_TYPEDEF =
  sig
    val cancel_type_definition: thm -> thm
    val cancel_type_definition_attr: attribute
  end
structure Local_Typedef: LOCAL_TYPEDEF
consts
  left :: "'a tree => 'a tree"
consts
  right :: "'a tree => 'a tree"
signature UNOVERLOADING =
  sig
    val unoverload: cterm -> thm -> thm
    val unoverload_attr: cterm -> attribute
  end
structure Unoverloading: UNOVERLOADING
signature INTERNALIZE_SORT =
  sig
    val internalize_sort: ctyp -> thm -> typ * thm
    val internalize_sort_attr: typ -> attribute
  end
structure Internalize_Sort: INTERNALIZE_SORT
### ML warning (line 41 of "~~/src/HOL/Types_To_Sets/unoverload_type.ML"):
### Matches are not exhaustive.
signature UNOVERLOAD_TYPE =
  sig
    val unoverload_type: Context.generic -> indexname list -> thm -> thm
    val unoverload_type_attr: indexname list -> attribute
  end
structure Unoverload_Type: UNOVERLOAD_TYPE
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
### ML warning (line 36 of "~~/src/HOL/Types_To_Sets/unoverload_def.ML"):
### Pattern is not exhaustive.
### ML warning (line 36 of "~~/src/HOL/Types_To_Sets/unoverload_def.ML"):
### Value identifier (ctxt') has not been referenced.
### ML warning (line 40 of "~~/src/HOL/Types_To_Sets/unoverload_def.ML"):
### Pattern is not exhaustive.
### ML warning (line 66 of "~~/src/HOL/Types_To_Sets/unoverload_def.ML"):
### Pattern is not exhaustive.
structure Unoverload_Def:
  sig
    val unoverload_def: binding option -> thm -> theory -> theory
    val unoverload_def1_cmd:
       binding option * (Facts.ref * Token.src list) -> theory -> theory
  end
### theory "HOL-Types_To_Sets.Types_To_Sets"
### 0.292s elapsed time, 1.156s cpu time, 0.171s GC time
Loading theory "HOL-Library.Countable" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Complex_Bounded_Operators.Complex_L2" via "Complex_Bounded_Operators.Complex_Bounded_Linear_Function" via "Complex_Bounded_Operators.Complex_Inner_Product" via "Complex_Bounded_Operators.Complex_Inner_Product0" via "Complex_Bounded_Operators.Complex_Vector_Spaces" via "HOL-Analysis.Elementary_Topology" via "HOL-Library.Set_Idioms" via "HOL-Library.Countable_Set")
Found termination order: "size <*mlex*> {}"
class height = type +
  fixes height :: "'a => nat"
instantiation
  tree :: (type) height
  height_tree == height :: 'a tree => nat
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
### Additional type variable(s) in locale specification "countable": 'a
class countable = type +
  assumes "ex_inj": "EX to_nat. inj to_nat"
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
Proofs for inductive predicate(s) "finite_item"
  Proving monotonicity ...
Found termination order: "size <*mlex*> {}"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
val old_countable_datatype_tac = fn: Proof.context -> int -> tactic
### ML warning (line 93 of "~~/src/HOL/Tools/BNF/bnf_lfp_countable.ML"):
### Pattern is not exhaustive.
### ML warning (line 139 of "~~/src/HOL/Tools/BNF/bnf_lfp_countable.ML"):
### Pattern is not exhaustive.
### ML warning (line 143 of "~~/src/HOL/Tools/BNF/bnf_lfp_countable.ML"):
### Matches are not exhaustive.
### ML warning (line 145 of "~~/src/HOL/Tools/BNF/bnf_lfp_countable.ML"):
### Matches are not exhaustive.
### ML warning (line 156 of "~~/src/HOL/Tools/BNF/bnf_lfp_countable.ML"):
### Pattern is not exhaustive.
signature BNF_LFP_COUNTABLE =
  sig
    val countable_datatype_tac: Proof.context -> tactic
    val derive_encode_injectives_thms:
       Proof.context -> string list -> thm list
  end
structure BNF_LFP_Countable: BNF_LFP_COUNTABLE
val countable_datatype_tac = fn: Proof.context -> thm -> thm Seq.seq
val countable_tac = fn: Proof.context -> int -> tactic
Found termination order: "size <*mlex*> {}"
### theory "HOL-Library.Countable"
### 1.224s elapsed time, 4.854s cpu time, 0.664s GC time
Loading theory "HOL-Library.Countable_Set" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Complex_Bounded_Operators.Complex_L2" via "Complex_Bounded_Operators.Complex_Bounded_Linear_Function" via "Complex_Bounded_Operators.Complex_Inner_Product" via "Complex_Bounded_Operators.Complex_Inner_Product0" via "Complex_Bounded_Operators.Complex_Vector_Spaces" via "HOL-Analysis.Elementary_Topology" via "HOL-Library.Set_Idioms")
### theory "HOL-Library.Tree"
### 2.171s elapsed time, 8.613s cpu time, 1.223s GC time
Loading theory "Draft.Templates" (required by "Draft.TeleportMoreTemplates" via "Draft.ExtrEqs")
datatype template_term
=
     t_empty
   | template_app of template_term * template_term
   | template_hole of int
   | template_var of int
datatype sign
= equals | greater_equals | greater_than | less_equals | less_than
datatype template
=
     template_bimplication of template * template
   | template_dunno
   | template_equation of template_term * template_term
   | template_implication of template list * template
   | template_inequation of sign * template_term * template_term
   | template_negation of template
   | template_predicate of template_term
constructor t_empty: template_term
constructor template_app: template_term * template_term -> template_term
constructor template_hole: int -> template_term
constructor template_var: int -> template_term
constructor equals: sign
constructor greater_equals: sign
constructor greater_than: sign
constructor less_equals: sign
constructor less_than: sign
constructor template_bimplication: template * template -> template
constructor template_dunno: template
constructor template_equation: template_term * template_term -> template
constructor template_implication: template list * template -> template
constructor template_inequation:
   sign * template_term * template_term -> template
constructor template_negation: template -> template
constructor template_predicate: template_term -> template
val vfs = fn: term -> (indexname * typ) list * (string * typ) list
val indexOf = fn: ''a list -> ''a -> int -> int
val has_eq = fn: term -> bool
val term2template = fn:
   (indexname * typ) list -> (string * typ) list -> term -> template_term
val lemma2predicate = fn: term -> term -> template
val makeTemplatewithContext = fn: term -> term -> template
val lemma2template = fn: term -> template
val thm2template = fn: thm -> template
val tterm2string = fn: template_term -> string
val template2string = fn: template -> string
val t = "height ?t <= size ?t": thm
val th =
   Const ("HOL.Trueprop", "bool => prop") $
     (Const ("Orderings.ord_class.less_eq", "nat => nat => bool") $
       (Const ("Tree.height_class.height", "?'a tree => nat") $
         Var (("t", 0), "?'a tree")) $
       (Const ("Nat.size_class.size", "?'a tree => nat") $
         Var (("t", 0), "?'a tree"))):
   term
### theory "Draft.Templates"
### 0.066s elapsed time, 0.258s cpu time, 0.000s GC time
Loading theory "HOL-Analysis.Metric_Arith" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Complex_Bounded_Operators.Complex_L2" via "Complex_Bounded_Operators.Complex_Bounded_Linear_Function" via "Complex_Bounded_Operators.Complex_Inner_Product" via "Complex_Bounded_Operators.Complex_Inner_Product0" via "Complex_Bounded_Operators.Complex_Vector_Spaces" via "HOL-Analysis.Elementary_Normed_Spaces" via "HOL-Analysis.Elementary_Metric_Spaces")
locale comm_monoid_set
  fixes f :: "'a => 'a => 'a"  (infixl \<open>\<^bold>*\<close> 70)
    and z :: "'a"  (\<open>\<^bold>1\<close>)
  assumes "comm_monoid_set (\<^bold>*) \<^bold>1"
### theory "HOL-Library.Countable_Set"
### 0.481s elapsed time, 1.910s cpu time, 0.238s GC time
Loading theory "HOL-Library.Countable_Complete_Lattices" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Complex_Bounded_Operators.Complex_L2" via "Complex_Bounded_Operators.Complex_Bounded_Linear_Function" via "Complex_Bounded_Operators.Complex_Inner_Product" via "Complex_Bounded_Operators.Complex_Inner_Product0" via "Complex_Bounded_Operators.Complex_Vector_Spaces" via "Complex_Bounded_Operators.Extra_Vector_Spaces" via "Complex_Bounded_Operators.Extra_General" via "HOL-Analysis.Uniform_Limit" via "HOL-Analysis.Summation_Tests" via "HOL-Library.Extended_Real" via "HOL-Library.Extended_Nat" via "HOL-Library.Order_Continuity")
signature METRIC_ARITH =
  sig
    val argo_timeout: real Config.T
    val metric_arith_tac: Proof.context -> int -> tactic
    val trace: bool Config.T
  end
structure Metric_Arith: METRIC_ARITH
### theory "HOL-Analysis.Metric_Arith"
### 0.654s elapsed time, 2.586s cpu time, 0.327s GC time
Loading theory "HOL-Library.Set_Idioms" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Complex_Bounded_Operators.Complex_L2" via "Complex_Bounded_Operators.Complex_Bounded_Linear_Function" via "Complex_Bounded_Operators.Complex_Inner_Product" via "Complex_Bounded_Operators.Complex_Inner_Product0" via "Complex_Bounded_Operators.Complex_Vector_Spaces" via "HOL-Analysis.Elementary_Topology")
class countable_complete_lattice = Inf + Sup + lattice + bot + top +
  assumes "ccInf_lower": "!!A x. [| countable A; x : A |] ==> Inf A <= x"
  assumes
    "ccInf_greatest":
      "!!A z. [| countable A; !!x. x : A ==> z <= x |] ==> z <= Inf A"
  assumes "ccSup_upper": "!!A x. [| countable A; x : A |] ==> x <= Sup A"
  assumes
    "ccSup_least":
      "!!A z. [| countable A; !!x. x : A ==> x <= z |] ==> Sup A <= z"
  assumes "ccInf_empty": "Inf {} = top"
  assumes "ccSup_empty": "Sup {} = bot"
### theory "HOL-Library.Set_Idioms"
### 1.323s elapsed time, 4.899s cpu time, 4.042s GC time
Loading theory "Polynomial_Interpolation.Missing_Unsorted" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl")
### Missing patterns in function definition:
### max_list_non_empty [] = undefined
Found termination order: "length <*mlex*> {}"
class comm_monoid_mult = ab_semigroup_mult + monoid_mult + dvd +
  assumes "mult_1": "!!a. (1::'a) * a = a"
class countable_complete_distrib_lattice = countable_complete_lattice +
  assumes
    "sup_ccInf": "!!B a. countable B ==> sup a (Inf B) = Inf (sup a ` B)"
  assumes
    "inf_ccSup": "!!B a. countable B ==> inf a (Sup B) = Sup (inf a ` B)"
### theory "Polynomial_Interpolation.Missing_Unsorted"
### 1.243s elapsed time, 4.892s cpu time, 0.296s GC time
Loading theory "Cauchy.CauchysMeanTheorem" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Quantum" via "Real_Impl.Real_Impl" via "Sqrt_Babylonian.Sqrt_Babylonian" via "Sqrt_Babylonian.NthRoot_Impl")
### theory "Cauchy.CauchysMeanTheorem"
### 0.265s elapsed time, 1.045s cpu time, 0.141s GC time
Loading theory "HOL-Analysis.Abstract_Topology" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Complex_Bounded_Operators.Complex_L2" via "Complex_Bounded_Operators.Complex_Bounded_Linear_Function" via "Complex_Bounded_Operators.Complex_Inner_Product" via "Complex_Bounded_Operators.Complex_Inner_Product0" via "Complex_Bounded_Operators.Complex_Vector_Spaces" via "HOL-Analysis.Elementary_Normed_Spaces" via "HOL-Analysis.Elementary_Metric_Spaces" via "HOL-Analysis.Abstract_Topology_2")
### theory "HOL-Library.Countable_Complete_Lattices"
### 3.292s elapsed time, 12.658s cpu time, 4.636s GC time
Loading theory "HOL-Analysis.Inner_Product" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Complex_Bounded_Operators.Complex_L2" via "Complex_Bounded_Operators.Complex_Bounded_Linear_Function" via "Complex_Bounded_Operators.Complex_Inner_Product" via "Complex_Bounded_Operators.Complex_Inner_Product0" via "Complex_Bounded_Operators.Complex_Vector_Spaces" via "HOL-Analysis.Elementary_Normed_Spaces" via "HOL-Analysis.Cartesian_Space" via "HOL-Analysis.Finite_Cartesian_Product" via "HOL-Analysis.Euclidean_Space")
class real_inner = dist_norm + real_vector + sgn_div_norm +
  uniformity_dist + open_uniformity +
  fixes inner :: "'a => 'a => real"
  assumes "inner_commute": "!!x y. inner x y = inner y x"
    and "inner_add_left": "!!x y z. inner (x + y) z = inner x z + inner y z"
    and
    "inner_scaleR_left": "!!r x y. inner (r *\<^sub>R x) y = r * inner x y"
    and "inner_ge_zero": "!!x. 0 <= inner x x"
    and "inner_eq_zero_iff": "!!x. (inner x x = 0) = (x = (0::'a))"
    and "norm_eq_sqrt_inner": "!!x. norm x = sqrt (inner x x)"
instantiation
  real :: real_inner
  inner_real == inner :: real => real => real
instantiation
  complex :: real_inner
  inner_complex == inner :: complex => complex => real
bundle inner_syntax
bundle no_inner_syntax
### theory "HOL-Analysis.Inner_Product"
### 1.031s elapsed time, 4.062s cpu time, 0.260s GC time
Loading theory "HOL-Analysis.L2_Norm" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Complex_Bounded_Operators.Complex_L2" via "Complex_Bounded_Operators.Complex_Bounded_Linear_Function" via "Complex_Bounded_Operators.Complex_Inner_Product" via "Complex_Bounded_Operators.Complex_Inner_Product0" via "Complex_Bounded_Operators.Complex_Vector_Spaces" via "HOL-Analysis.Elementary_Normed_Spaces" via "HOL-Analysis.Cartesian_Space" via "HOL-Analysis.Finite_Cartesian_Product" via "HOL-Analysis.Euclidean_Space")
### theory "HOL-Analysis.L2_Norm"
### 0.112s elapsed time, 0.431s cpu time, 0.061s GC time
Loading theory "HOL-Analysis.Operator_Norm" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Complex_Bounded_Operators.Complex_L2" via "Complex_Bounded_Operators.Complex_Bounded_Linear_Function" via "Complex_Bounded_Operators.Complex_Inner_Product" via "Complex_Bounded_Operators.Complex_Inner_Product0" via "Complex_Bounded_Operators.Complex_Vector_Spaces")
### theory "HOL-Analysis.Operator_Norm"
### 0.118s elapsed time, 0.454s cpu time, 0.063s GC time
Loading theory "HOL-Analysis.Product_Vector" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Complex_Bounded_Operators.Complex_L2" via "Complex_Bounded_Operators.Complex_Bounded_Linear_Function" via "Complex_Bounded_Operators.Complex_Inner_Product" via "Complex_Bounded_Operators.Complex_Inner_Product0" via "Complex_Bounded_Operators.Complex_Vector_Spaces" via "HOL-Analysis.Elementary_Topology")
### theory "HOL-Computational_Algebra.Euclidean_Algorithm"
### 10.960s elapsed time, 43.026s cpu time, 8.020s GC time
Loading theory "HOL-Computational_Algebra.Normalized_Fraction" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Determinant_Impl" via "Polynomial_Interpolation.Missing_Polynomial" via "HOL-Computational_Algebra.Polynomial_Factorial")
locale module_prod
  fixes s1 :: "'a => 'b => 'b"
    and s2 :: "'a => 'c => 'c"
  assumes "module_prod s1 s2"
locale vector_space_prod
  fixes s1 :: "'a => 'b => 'b"  (infixr \<open>*a\<close> 75)
    and s2 :: "'a => 'c => 'c"  (infixr \<open>*b\<close> 75)
  assumes "vector_space_prod (*a) (*b)"
### Cannot skip proof of schematic goal statement
instantiation
  prod :: (real_vector, real_vector) real_vector
  scaleR_prod == scaleR :: real => 'a * 'b => 'a * 'b
### Cannot skip proof of schematic goal statement
instantiation
  prod :: (metric_space, metric_space) dist
  dist_prod == dist :: 'a * 'b => 'a * 'b => real
instantiation
  prod :: (uniformity, uniformity) uniformity
  uniformity_prod == uniformity :: (('a * 'b) * 'a * 'b) filter
instantiation
  prod :: (uniform_space, uniform_space) uniform_space
instantiation
  prod :: (metric_space, metric_space) uniformity_dist
instantiation
  prod :: (metric_space, metric_space) metric_space
locale fract_as_normalized_quot
instantiation
  prod :: (real_normed_vector, real_normed_vector) real_normed_vector
  sgn_prod == sgn :: 'a * 'b => 'a * 'b
  norm_prod == norm :: 'a * 'b => real
### theory "HOL-Computational_Algebra.Normalized_Fraction"
### 0.540s elapsed time, 2.105s cpu time, 0.276s GC time
Loading theory "HOL-Computational_Algebra.Polynomial" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Determinant_Impl" via "Polynomial_Interpolation.Missing_Polynomial" via "HOL-Computational_Algebra.Polynomial_Factorial")
locale finite_dimensional_vector_space_prod
  fixes s1 :: "'a => 'b => 'b"  (infixr \<open>*a\<close> 75)
    and s2 :: "'a => 'c => 'c"  (infixr \<open>*b\<close> 75)
    and B1 :: "'b set"
    and B2 :: "'c set"
  assumes "finite_dimensional_vector_space_prod (*a) (*b) B1 B2"
### theory "HOL-Analysis.Product_Vector"
### 2.234s elapsed time, 8.423s cpu time, 4.858s GC time
Loading theory "HOL-Analysis.Elementary_Topology" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Complex_Bounded_Operators.Complex_L2" via "Complex_Bounded_Operators.Complex_Bounded_Linear_Function" via "Complex_Bounded_Operators.Complex_Inner_Product" via "Complex_Bounded_Operators.Complex_Inner_Product0" via "Complex_Bounded_Operators.Complex_Vector_Spaces")
Proofs for inductive predicate(s) "generate_topology_on"
  Proving monotonicity ...
### theory "HOL-Analysis.Abstract_Topology"
### 3.918s elapsed time, 15.056s cpu time, 5.420s GC time
Loading theory "HOL-Analysis.Abstract_Limits" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Complex_Bounded_Operators.Complex_L2" via "Complex_Bounded_Operators.Complex_Bounded_Linear_Function" via "Complex_Bounded_Operators.One_Dimensional_Spaces" via "Complex_Bounded_Operators.Extra_Operator_Norm" via "HOL-Analysis.Bounded_Linear_Function" via "HOL-Analysis.Function_Topology")
### theory "HOL-Analysis.Abstract_Limits"
### 0.241s elapsed time, 0.951s cpu time, 0.093s GC time
Loading theory "HOL-Analysis.Euclidean_Space" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Complex_Bounded_Operators.Complex_L2" via "Complex_Bounded_Operators.Complex_Bounded_Linear_Function" via "Complex_Bounded_Operators.Complex_Inner_Product" via "Complex_Bounded_Operators.Complex_Inner_Product0" via "Complex_Bounded_Operators.Complex_Vector_Spaces" via "HOL-Analysis.Elementary_Normed_Spaces" via "HOL-Analysis.Cartesian_Space" via "HOL-Analysis.Finite_Cartesian_Product")
class topological_space = open +
  assumes "open_UNIV": "open UNIV"
  assumes "open_Int": "!!S T. [| open S; open T |] ==> open (S Int T)"
  assumes "open_Union": "!!K. Ball K open ==> open (\<Union> K)"
instantiation
  poly :: (zero) zero
  zero_poly == zero_class.zero :: 'a poly
locale countable_basis
  fixes p :: "'a set => bool"
    and B :: "'a set set"
  assumes "countable_basis p B"
class second_countable_topology = topological_space +
  assumes
    "ex_countable_subbasis":
      "EX B. countable B & open = generate_topology B"
consts
  Poly :: "'a list => 'a poly"
instantiation
  poly :: ({zero,equal}) equal
  equal_poly == equal_class.equal :: 'a poly => 'a poly => bool
instantiation
  poly :: (comm_monoid_add) comm_monoid_add
  plus_poly == plus :: 'a poly => 'a poly => 'a poly
instantiation
  poly :: (cancel_comm_monoid_add) cancel_comm_monoid_add
  minus_poly == minus :: 'a poly => 'a poly => 'a poly
instantiation
  poly :: (ab_group_add) ab_group_add
  uminus_poly == uminus :: 'a poly => 'a poly
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
class euclidean_space = real_inner +
  fixes Basis :: "'a set"
  assumes "nonempty_Basis": "Basis ~= {}"
  assumes "finite_Basis": "finite Basis"
  assumes
    "inner_Basis":
      "!!u v.
          [| u : Basis; v : Basis |]
          ==> inner u v = (if u = v then 1 else 0)"
  assumes
    "euclidean_all_zero_iff":
      "!!x. (ALL u:Basis. inner x u = 0) = (x = (0::'a))"
instantiation
  poly :: (comm_semiring_0) comm_semiring_0
  times_poly == times :: 'a poly => 'a poly => 'a poly
instantiation
  poly :: (comm_semiring_1) comm_semiring_1
  one_poly == one_class.one :: 'a poly
instantiation
  poly :: (linordered_idom) linordered_idom
  sgn_poly == sgn :: 'a poly => 'a poly
  abs_poly == abs :: 'a poly => 'a poly
  less_eq_poly == less_eq :: 'a poly => 'a poly => bool
  less_poly == less :: 'a poly => 'a poly => bool
### theory "HOL-Analysis.Elementary_Topology"
### 2.057s elapsed time, 8.107s cpu time, 0.930s GC time
Loading theory "HOL-Library.BigO" (required by "Draft.TeleportMoreTemplates" via "Draft.ExtrEqs")
Found termination order: "{}"
### Ignoring duplicate rewrite rule:
### balance Empty ?s1 ?t1 Empty == Branch B Empty ?s1 ?t1 Empty
### Ignoring duplicate rewrite rule:
### balance (Branch B ?va1 ?vb1 ?vc1 ?vd1) ?s1 ?t1 Empty ==
### Branch B (Branch B ?va1 ?vb1 ?vc1 ?vd1) ?s1 ?t1 Empty
### Ignoring duplicate rewrite rule:
### balance Empty ?s1 ?t1 (Branch B ?va1 ?vb1 ?vc1 ?vd1) ==
### Branch B Empty ?s1 ?t1 (Branch B ?va1 ?vb1 ?vc1 ?vd1)
instantiation
  real :: euclidean_space
  Basis_real == Basis :: real set
instantiation
  complex :: euclidean_space
  Basis_complex == Basis :: complex set
instantiation
  prod :: (real_inner, real_inner) real_inner
  inner_prod == inner :: 'a * 'b => 'a * 'b => real
instantiation
  prod :: (euclidean_space, euclidean_space) euclidean_space
  Basis_prod == Basis :: ('a * 'b) set
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
### Cannot skip proof of schematic goal statement
### Cannot skip proof of schematic goal statement
### theory "HOL-Analysis.Euclidean_Space"
### 1.793s elapsed time, 7.060s cpu time, 0.874s GC time
Loading theory "HOL-Analysis.Finite_Cartesian_Product" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Complex_Bounded_Operators.Complex_L2" via "Complex_Bounded_Operators.Complex_Bounded_Linear_Function" via "Complex_Bounded_Operators.Complex_Inner_Product" via "Complex_Bounded_Operators.Complex_Inner_Product0" via "Complex_Bounded_Operators.Complex_Vector_Spaces" via "HOL-Analysis.Elementary_Normed_Spaces" via "HOL-Analysis.Cartesian_Space")
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
Proofs for inductive predicate(s) "algebraic_int"
  Proving monotonicity ...
instantiation
  poly :: (idom_divide) idom_divide
  divide_poly == divide :: 'a poly => 'a poly => 'a poly
consts
  paint :: "color => ('a, 'b) rbt => ('a, 'b) rbt"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
Found termination order:
  "(%p. size (snd (snd (snd (snd (snd p)))))) <*mlex*> {}"
### theory "HOL-Library.BigO"
### 0.872s elapsed time, 3.424s cpu time, 0.481s GC time
Loading theory "HOL-Analysis.Linear_Algebra" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Complex_Bounded_Operators.Complex_L2" via "Complex_Bounded_Operators.Complex_Bounded_Linear_Function" via "Complex_Bounded_Operators.Complex_Inner_Product" via "Complex_Bounded_Operators.Complex_Inner_Product0" via "Complex_Bounded_Operators.Complex_Vector_Spaces" via "HOL-Analysis.Elementary_Normed_Spaces" via "HOL-Analysis.Cartesian_Space")
Found termination order:
  "(%p. size (snd (snd (snd (snd (snd p)))))) <*mlex*> {}"
instantiation
  poly :: ({idom_divide,semidom_divide_unit_factor}) normalization_semidom
  normalize_poly == normalize :: 'a poly => 'a poly
  unit_factor_poly == unit_factor :: 'a poly => 'a poly
Found termination order: "(%p. size (snd (snd (snd p)))) <*mlex*> {}"
bundle vec_syntax
bundle no_vec_syntax
instantiation
  vec :: (zero, finite) zero
  zero_vec == zero_class.zero :: ('a, 'b) vec
instantiation
  vec :: (plus, finite) plus
  plus_vec == plus :: ('a, 'b) vec => ('a, 'b) vec => ('a, 'b) vec
instantiation
  vec :: (minus, finite) minus
  minus_vec == minus :: ('a, 'b) vec => ('a, 'b) vec => ('a, 'b) vec
instantiation
  vec :: (uminus, finite) uminus
  uminus_vec == uminus :: ('a, 'b) vec => ('a, 'b) vec
instantiation
  vec :: (times, finite) times
  times_vec == times :: ('a, 'b) vec => ('a, 'b) vec => ('a, 'b) vec
class real_inner = real_normed_vector +
  fixes inner :: "'a => 'a => real"
  assumes "inner_commute": "!!x y. x \<bullet> y = y \<bullet> x"
    and
    "inner_add_left":
      "!!x y z. (x + y) \<bullet> z = x \<bullet> z + y \<bullet> z"
    and
    "inner_scaleR_left":
      "!!r x y. r *\<^sub>R x \<bullet> y = r * (x \<bullet> y)"
    and "inner_ge_zero": "!!x. 0 <= x \<bullet> x"
    and "inner_eq_zero_iff": "!!x. (x \<bullet> x = 0) = (x = (0::'a))"
    and "norm_eq_sqrt_inner": "!!x. norm x = sqrt (x \<bullet> x)"
instantiation
  vec :: (one, finite) one
  one_vec == one_class.one :: ('a, 'b) vec
instantiation
  vec :: (ord, finite) ord
  less_eq_vec == less_eq :: ('a, 'b) vec => ('a, 'b) vec => bool
  less_vec == less :: ('a, 'b) vec => ('a, 'b) vec => bool
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
instantiation
  vec :: (real_vector, finite) real_vector
  scaleR_vec == scaleR :: real => ('a, 'b) vec => ('a, 'b) vec
instantiation
  vec :: (topological_space, finite) topological_space
  open_vec == open :: ('a, 'b) vec set => bool
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
instantiation
  vec :: (metric_space, finite) dist
  dist_vec == dist :: ('a, 'b) vec => ('a, 'b) vec => real
instantiation
  vec :: (metric_space, finite) uniformity_dist
  uniformity_vec == uniformity :: (('a, 'b) vec * ('a, 'b) vec) filter
instantiation
  vec :: (metric_space, finite) metric_space
instantiation
  vec :: (real_normed_vector, finite) real_normed_vector
  sgn_vec == sgn :: ('a, 'b) vec => ('a, 'b) vec
  norm_vec == norm :: ('a, 'b) vec => real
instantiation
  vec :: (real_inner, finite) real_inner
  inner_vec == inner :: ('a, 'b) vec => ('a, 'b) vec => real
instantiation
  vec :: (euclidean_space, finite) euclidean_space
  Basis_vec == Basis :: ('a, 'b) vec set
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
### theory "HOL-Analysis.Linear_Algebra"
### 1.074s elapsed time, 4.185s cpu time, 0.560s GC time
Loading theory "HOL-Analysis.Affine" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Complex_Bounded_Operators.Complex_L2" via "Complex_Bounded_Operators.Complex_Bounded_Linear_Function" via "Complex_Bounded_Operators.Complex_Inner_Product" via "Complex_Bounded_Operators.Complex_Inner_Product0" via "Complex_Bounded_Operators.Complex_Vector_Spaces" via "HOL-Analysis.Starlike" via "HOL-Analysis.Convex_Euclidean_Space" via "HOL-Analysis.Convex")
### theory "HOL-Analysis.Finite_Cartesian_Product"
### 1.803s elapsed time, 7.042s cpu time, 0.980s GC time
Loading theory "HOL-Analysis.Cartesian_Space" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Complex_Bounded_Operators.Complex_L2" via "Complex_Bounded_Operators.Complex_Bounded_Linear_Function" via "Complex_Bounded_Operators.Complex_Inner_Product" via "Complex_Bounded_Operators.Complex_Inner_Product0" via "Complex_Bounded_Operators.Complex_Vector_Spaces" via "HOL-Analysis.Elementary_Normed_Spaces")
class field_unit_factor = field + unit_factor +
  assumes "unit_factor_field": "unit_factor = id"
Found termination order: "{}"
Proofs for inductive predicate(s) "eucl_rel_poly"
  Proving monotonicity ...
### theory "HOL-Analysis.Affine"
### 0.511s elapsed time, 1.965s cpu time, 0.294s GC time
Loading theory "HOL-Analysis.Convex" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Complex_Bounded_Operators.Complex_L2" via "Complex_Bounded_Operators.Complex_Bounded_Linear_Function" via "Complex_Bounded_Operators.Complex_Inner_Product" via "Complex_Bounded_Operators.Complex_Inner_Product0" via "Complex_Bounded_Operators.Complex_Vector_Spaces" via "HOL-Analysis.Starlike" via "HOL-Analysis.Convex_Euclidean_Space")
instantiation
  poly :: (field) semidom_modulo
  modulo_poly == modulo :: 'a poly => 'a poly => 'a poly
class order = preorder +
  assumes "order_antisym": "!!x y. [| x <= y; y <= x |] ==> x = y"
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
Found termination order: "(%p. size (snd (snd (snd (snd p))))) <*mlex*> {}"
Found termination order: "{}"
Found termination order: "(%p. size (snd (snd (snd p)))) <*mlex*> {}"
class order = preorder +
  assumes "order_antisym": "!!x y. [| x <= y; y <= x |] ==> x = y"
locale linear_first_finite_dimensional_vector_space
  fixes scaleB :: "'a => 'b => 'b"  (infixr \<open>*b\<close> 75)
    and scaleC :: "'a => 'c => 'c"  (infixr \<open>*c\<close> 75)
    and BasisB :: "'b set"
    and f :: "'b => 'c"
  assumes "linear_first_finite_dimensional_vector_space (*b) (*c) BasisB f"
Found termination order: "(%p. size (snd (snd (snd p)))) <*mlex*> {}"
Found termination order: "(%p. size (snd (snd p))) <*mlex*> {}"
### theory "HOL-Analysis.Convex"
### 2.611s elapsed time, 9.867s cpu time, 6.121s GC time
Loading theory "Draft.ExtrEqs" (required by "Draft.TeleportMoreTemplates")
Found termination order:
  "(%p. size (snd p)) <*mlex*> (%p. size (fst p)) <*mlex*> {}"
### theory "HOL-Analysis.Cartesian_Space"
### 3.257s elapsed time, 12.384s cpu time, 6.476s GC time
Loading theory "HOL-Library.Complex_Order" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Jordan_Normal_Form.Matrix" via "Jordan_Normal_Form.Conjugate")
instantiation
  complex :: order
  less_eq_complex == less_eq :: complex => complex => bool
  less_complex == less :: complex => complex => bool
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
Found termination order: "(%p. size (snd (snd (snd (snd p))))) <*mlex*> {}"
### theory "HOL-Library.Complex_Order"
### 0.062s elapsed time, 0.254s cpu time, 0.000s GC time
Loading theory "Complex_Bounded_Operators.Complex_Vector_Spaces0" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Complex_Bounded_Operators.Complex_L2" via "Complex_Bounded_Operators.Complex_Bounded_Linear_Function" via "Complex_Bounded_Operators.Complex_Inner_Product" via "Complex_Bounded_Operators.Complex_Inner_Product0" via "Complex_Bounded_Operators.Complex_Vector_Spaces")
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
class scaleC = scaleR +
  fixes scaleC :: "complex => 'a => 'a"
  assumes
    "scaleR_scaleC": "!!r. (*\<^sub>R) r = (*\<^sub>C) (complex_of_real r)"
### theory "HOL-Computational_Algebra.Polynomial"
### 9.294s elapsed time, 35.751s cpu time, 13.275s GC time
Loading theory "HOL-Computational_Algebra.Fundamental_Theorem_Algebra" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Jordan_Normal_Form_Existence" via "Jordan_Normal_Form.Jordan_Normal_Form" via "Jordan_Normal_Form.Char_Poly" via "Polynomial_Factorization.Fundamental_Theorem_Algebra_Factorized")
class complex_vector = scaleC + ab_group_add +
  assumes
    "scaleC_add_right":
      "!!a x y. a *\<^sub>C (x + y) = a *\<^sub>C x + a *\<^sub>C y"
    and
    "scaleC_add_left":
      "!!a b x. (a + b) *\<^sub>C x = a *\<^sub>C x + b *\<^sub>C x"
    and
    "scaleC_scaleC":
      "!!a b x. a *\<^sub>C b *\<^sub>C x = (a * b) *\<^sub>C x"
    and "scaleC_one": "!!x. 1 *\<^sub>C x = x"
val eqpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Var (("_dummy_", 2), "?'a"))
       ):
   term Find_Theorems.criterion
val badeqpattern = Pattern (Const ("Pure.eq", "?'a => ?'a => prop")):
   term Find_Theorems.criterion
val undefpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Const ("HOL.undefined", "?'a"))
       ):
   term Find_Theorems.criterion
val thmpattern =
   Pattern
    (Const ("HOL.Trueprop", "bool => prop") $ Var (("_dummy_", 1), "bool")):
   term Find_Theorems.criterion
val badnames =
   ["*nitpick*", "*Nitpick*", "*full_exhaustive*", "*_def*", "Enum.finite*",
    "*Quickcheck*", "ATP*", "*Nunchaku*", "*Code*", "*BNF*", "*SMT*",
    "*.*.*"]:
   string list
val unwanted_names =
   [(false, Name "*nitpick*"), (false, Name "*Nitpick*"),
    (false, Name "*full_exhaustive*"), (false, Name "*_def*"),
    (false, Name "Enum.finite*"), (false, Name "*Quickcheck*"),
    (false, Name "ATP*"), (false, Name "*Nunchaku*"),
    (false, Name "*Code*"), (false, Name "*BNF*"), (false, Name "*SMT*"),
    (false, Name "*.*.*")]:
   (bool * term Find_Theorems.criterion) list
val has_vars = fn: term -> bool
val get_all_eqs = fn: string -> Proof.context -> (string * thm) list
val get_all_thms = fn: string -> Proof.context -> (string * thm) list
val get_noneq_thms = fn: string -> Proof.context -> (string * thm) list
val template_eqs = fn:
   string -> Proof.context -> (string * thm * template) list
val template_thms = fn:
   string -> Proof.context -> (string * thm * template) list
### theory "Draft.ExtrEqs"
### 0.762s elapsed time, 2.989s cpu time, 0.444s GC time
Loading theory "HOL-Computational_Algebra.Polynomial_Factorial" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Determinant_Impl" via "Polynomial_Interpolation.Missing_Polynomial")
### theory "HOL-Computational_Algebra.Fundamental_Theorem_Algebra"
### 0.296s elapsed time, 1.161s cpu time, 0.167s GC time
Loading theory "Complex_Bounded_Operators.Extra_Ordered_Fields" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Complex_Bounded_Operators.Complex_L2" via "Complex_Bounded_Operators.Complex_Bounded_Linear_Function" via "Complex_Bounded_Operators.Complex_Inner_Product" via "Complex_Bounded_Operators.Complex_Inner_Product0" via "Complex_Bounded_Operators.Complex_Vector_Spaces")
class complex_algebra = complex_vector + ring +
  assumes
    "mult_scaleC_left": "!!a x y. a *\<^sub>C x * y = a *\<^sub>C (x * y)"
    and
    "mult_scaleC_right": "!!x a y. x * a *\<^sub>C y = a *\<^sub>C (x * y)"
### Cannot skip proof of schematic goal statement
instantiation
  poly :: ({factorial_ring_gcd,semiring_gcd_mult_normalize})
    factorial_ring_gcd
  Gcd_poly == Gcd :: 'a poly set => 'a poly
  Lcm_poly == Lcm :: 'a poly set => 'a poly
  gcd_poly == gcd :: 'a poly => 'a poly => 'a poly
  lcm_poly == lcm :: 'a poly => 'a poly => 'a poly
instantiation
  poly :: ({factorial_ring_gcd,field,semiring_gcd_mult_normalize})
    {normalization_euclidean_semiring,unique_euclidean_ring}
  division_segment_poly == division_segment :: 'a poly => 'a poly
  euclidean_size_poly == euclidean_size :: 'a poly => nat
class partial_abs_if = abs + minus + uminus + zero + ord +
  assumes "abs_neg": "!!a. a <= (0::'a) ==> \<bar>a\<bar> = - a"
  assumes "abs_pos": "!!a. (0::'a) <= a ==> \<bar>a\<bar> = a"
### theory "HOL-Computational_Algebra.Polynomial_Factorial"
### 1.127s elapsed time, 4.420s cpu time, 0.505s GC time
Loading theory "Polynomial_Interpolation.Missing_Polynomial" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Determinant_Impl")
class mult_zero = times + zero +
  assumes "mult_zero_left": "!!a. (0::'a) * a = (0::'a)"
  assumes "mult_zero_right": "!!a. a * (0::'a) = (0::'a)"
Found termination order: "size_list (%p. size (fst p)) <*mlex*> {}"
### theory "Polynomial_Interpolation.Missing_Polynomial"
### 0.957s elapsed time, 3.747s cpu time, 0.351s GC time
Loading theory "Polynomial_Factorization.Order_Polynomial" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Jordan_Normal_Form_Existence" via "Jordan_Normal_Form.Jordan_Normal_Form" via "Jordan_Normal_Form.Char_Poly" via "Polynomial_Factorization.Fundamental_Theorem_Algebra_Factorized")
### theory "Polynomial_Factorization.Order_Polynomial"
### 0.102s elapsed time, 0.391s cpu time, 0.047s GC time
Loading theory "Polynomial_Factorization.Fundamental_Theorem_Algebra_Factorized" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Jordan_Normal_Form_Existence" via "Jordan_Normal_Form.Jordan_Normal_Form" via "Jordan_Normal_Form.Char_Poly")
class ordered_semiring_strict = comm_monoid_add +
  ordered_cancel_ab_semigroup_add + semiring +
  assumes
    "mult_strict_left_mono":
      "!!a b c. [| a < b; (0::'a) < c |] ==> c * a < c * b"
  assumes
    "mult_strict_right_mono":
      "!!a b c. [| a < b; (0::'a) < c |] ==> a * c < b * c"
### theory "Polynomial_Factorization.Fundamental_Theorem_Algebra_Factorized"
### 0.316s elapsed time, 1.245s cpu time, 0.075s GC time
Loading theory "Jordan_Normal_Form.Conjugate" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Jordan_Normal_Form.Matrix")
class conjugate = type +
  fixes conjugate :: "'a => 'a"
  assumes "conjugate_id": "!!a. conjugate (conjugate a) = a"
    and
    "conjugate_cancel_iff": "!!a b. (conjugate a = conjugate b) = (a = b)"
class conjugatable_ring = conjugate + ring +
  assumes
    "conjugate_dist_mul":
      "!!a b. conjugate (a * b) = conjugate a * conjugate b"
    and
    "conjugate_dist_add":
      "!!a b. conjugate (a + b) = conjugate a + conjugate b"
    and "conjugate_neg": "!!a. conjugate (- a) = - conjugate a"
    and "conjugate_zero": "conjugate (0::'a) = (0::'a)"
Found termination order:
  "case_sum (%p. size (fst (snd p)))
    (case_sum (%p. size (snd (snd (snd (snd p)))))
      (%p. size (snd p))) <*mlex*>
   case_sum (%x. Suc 0) (%x. 0) <*mlex*>
   case_sum (%x. 0) (case_sum (%x. Suc 0) (%x. 0)) <*mlex*> {}"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
instantiation
  complex :: complex_field
  scaleC_complex == scaleC :: complex => complex => complex
locale clinear
  fixes f :: "'a => 'b"
  assumes "clinear f"
### Cannot skip proof of schematic goal statement
### Cannot skip proof of schematic goal statement
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
consts
  rbt_map_entry :: "'a => ('b => 'b) => ('a, 'b) rbt => ('a, 'b) rbt"
class conjugatable_ordered_ring = conjugatable_ring +
  ordered_comm_monoid_add +
  assumes "conjugate_square_positive": "!!a. (0::'a) <= a * conjugate a"
consts
  map :: "('a => 'b => 'c) => ('a, 'b) rbt => ('a, 'c) rbt"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
class ordered_complex_vector = complex_vector + ordered_ab_group_add +
  assumes
    "scaleC_left_mono":
      "!!x y a. [| x <= y; 0 <= a |] ==> a *\<^sub>C x <= a *\<^sub>C y"
    and
    "scaleC_right_mono":
      "!!a b x.
          [| a <= b; (0::'a) <= x |] ==> a *\<^sub>C x <= b *\<^sub>C x"
class ordered_comm_semiring_strict = ordered_cancel_ab_semigroup_add +
  comm_semiring_0 +
  assumes
    "comm_mult_strict_left_mono":
      "!!a b c. [| a < b; (0::'a) < c |] ==> c * a < c * b"
Found termination order: "(%p. size (fst (snd (snd p)))) <*mlex*> {}"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
class complex_normed_vector = complex_vector + real_normed_vector +
  assumes "norm_scaleC": "!!a x. norm (a *\<^sub>C x) = cmod a * norm x"
instantiation
  complex :: conjugatable_ordered_field
  conjugate_complex == conjugate :: complex => complex
instantiation
  real :: conjugatable_ordered_field
  conjugate_real == conjugate :: real => real
instantiation
  rat :: conjugatable_ordered_field
  conjugate_rat == conjugate :: rat => rat
instantiation
  int :: conjugatable_ordered_ring
  conjugate_int == conjugate :: int => int
### theory "Jordan_Normal_Form.Conjugate"
### 3.229s elapsed time, 12.448s cpu time, 1.633s GC time
Loading theory "HOL-Library.Discrete" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Complex_Bounded_Operators.Complex_L2" via "Complex_Bounded_Operators.Complex_Bounded_Linear_Function" via "Complex_Bounded_Operators.Complex_Inner_Product" via "Complex_Bounded_Operators.Complex_Inner_Product0" via "Complex_Bounded_Operators.Complex_Vector_Spaces" via "Complex_Bounded_Operators.Extra_Vector_Spaces" via "Complex_Bounded_Operators.Extra_General" via "HOL-Analysis.Uniform_Limit" via "HOL-Analysis.Summation_Tests")
### Rewrite rule not in simpset:
### Wellfounded.accp log_rel ?n1 ==>
### log ?n1 == if ?n1 < 2 then 0 else Suc (log (?n1 div 2))
Found termination order: "size <*mlex*> {}"
### theory "HOL-Library.Discrete"
### 0.190s elapsed time, 0.726s cpu time, 0.125s GC time
Loading theory "HOL-Library.Indicator_Function" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Complex_Bounded_Operators.Complex_L2" via "Complex_Bounded_Operators.Complex_Bounded_Linear_Function" via "Complex_Bounded_Operators.Complex_Inner_Product" via "Complex_Bounded_Operators.Complex_Inner_Product0" via "Complex_Bounded_Operators.Complex_Vector_Spaces" via "HOL-Analysis.Elementary_Normed_Spaces" via "HOL-Analysis.Elementary_Metric_Spaces" via "HOL-Analysis.Abstract_Topology_2")
### theory "HOL-Library.Indicator_Function"
### 0.453s elapsed time, 1.709s cpu time, 0.273s GC time
Loading theory "HOL-Analysis.Abstract_Topology_2" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Complex_Bounded_Operators.Complex_L2" via "Complex_Bounded_Operators.Complex_Bounded_Linear_Function" via "Complex_Bounded_Operators.Complex_Inner_Product" via "Complex_Bounded_Operators.Complex_Inner_Product0" via "Complex_Bounded_Operators.Complex_Vector_Spaces" via "HOL-Analysis.Elementary_Normed_Spaces" via "HOL-Analysis.Elementary_Metric_Spaces")
### theory "HOL-Analysis.Abstract_Topology_2"
### 24.833s elapsed time, 84.622s cpu time, 79.732s GC time
Loading theory "HOL-Analysis.Connected" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Complex_Bounded_Operators.Complex_L2" via "Complex_Bounded_Operators.Complex_Bounded_Linear_Function" via "Complex_Bounded_Operators.Complex_Inner_Product" via "Complex_Bounded_Operators.Complex_Inner_Product0" via "Complex_Bounded_Operators.Complex_Vector_Spaces" via "HOL-Analysis.Elementary_Normed_Spaces")
### theory "HOL-Analysis.Connected"
### 0.312s elapsed time, 1.234s cpu time, 0.096s GC time
Loading theory "HOL-Analysis.Function_Topology" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Complex_Bounded_Operators.Complex_L2" via "Complex_Bounded_Operators.Complex_Bounded_Linear_Function" via "Complex_Bounded_Operators.One_Dimensional_Spaces" via "Complex_Bounded_Operators.Extra_Operator_Norm" via "HOL-Analysis.Bounded_Linear_Function")
Found termination order:
  "case_sum (%p. size (fst p)) (%p. size (fst p)) <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
instantiation
  fun :: (type, topological_space) topological_space
  open_fun == open :: ('a => 'b) set => bool
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
### theory "HOL-Analysis.Function_Topology"
### 0.745s elapsed time, 2.930s cpu time, 0.426s GC time
Loading theory "HOL-Analysis.Elementary_Metric_Spaces" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Complex_Bounded_Operators.Complex_L2" via "Complex_Bounded_Operators.Complex_Bounded_Linear_Function" via "Complex_Bounded_Operators.Complex_Inner_Product" via "Complex_Bounded_Operators.Complex_Inner_Product0" via "Complex_Bounded_Operators.Complex_Vector_Spaces" via "HOL-Analysis.Elementary_Normed_Spaces")
Found termination order: "{}"
class complex_normed_vector = complex_vector + real_normed_vector +
  assumes "norm_scaleC": "!!a x. norm (a *\<^sub>C x) = cmod a * norm x"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
instantiation
  complex :: complex_normed_field
### Code generator: dropping subsumed code equation
### uniformity ==
### Filter.abstract_filter
###  (%u. Code.abort STR ''uniformity is not executable'' (%u. uniformity))
class nice_ordered_field = ordered_field + idom_abs_sgn + zero_less_one +
  assumes
    "positive_imp_inverse_positive":
      "!!a. (0::'a) < a ==> (0::'a) < inverse a"
    and
    "inverse_le_imp_le":
      "!!a b. [| inverse a <= inverse b; (0::'a) < a |] ==> b <= a"
    and "dense_le": "!!y z. (!!x. x < y ==> x <= z) ==> y <= z"
    and
    "nn_comparable":
      "!!a b. [| (0::'a) <= a; (0::'a) <= b |] ==> a <= b | b <= a"
    and "abs_nn": "!!x. (0::'a) <= \<bar>x\<bar>"
locale bounded_clinear
  fixes f :: "'a => 'b"
  assumes "bounded_clinear f"
locale bounded_cbilinear
  fixes prod :: "'a => 'b => 'c"  (infixl \<open>**\<close> 70)
  assumes "bounded_cbilinear (**)"
class heine_borel = metric_space +
  assumes
    "bounded_imp_convergent_subsequence":
      "!!f. bounded (range f) ==>
            EX l r. strict_mono r & (f o r) \<longlonglongrightarrow> l"
### theory "Complex_Bounded_Operators.Complex_Vector_Spaces0"
### 34.405s elapsed time, 121.927s cpu time, 84.167s GC time
Loading theory "HOL-Library.Liminf_Limsup" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Complex_Bounded_Operators.Complex_L2" via "Complex_Bounded_Operators.Complex_Bounded_Linear_Function" via "Complex_Bounded_Operators.Complex_Inner_Product" via "Complex_Bounded_Operators.Complex_Inner_Product0" via "Complex_Bounded_Operators.Complex_Vector_Spaces" via "Complex_Bounded_Operators.Extra_Vector_Spaces" via "Complex_Bounded_Operators.Extra_General" via "HOL-Analysis.Uniform_Limit" via "HOL-Analysis.Summation_Tests" via "HOL-Library.Extended_Real")
### theory "HOL-Analysis.Elementary_Metric_Spaces"
### 1.883s elapsed time, 7.451s cpu time, 0.809s GC time
Loading theory "HOL-Analysis.Elementary_Normed_Spaces" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Complex_Bounded_Operators.Complex_L2" via "Complex_Bounded_Operators.Complex_Bounded_Linear_Function" via "Complex_Bounded_Operators.Complex_Inner_Product" via "Complex_Bounded_Operators.Complex_Inner_Product0" via "Complex_Bounded_Operators.Complex_Vector_Spaces")
### theory "HOL-Library.Liminf_Limsup"
### 0.538s elapsed time, 2.120s cpu time, 0.295s GC time
Loading theory "HOL-Library.Order_Continuity" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Complex_Bounded_Operators.Complex_L2" via "Complex_Bounded_Operators.Complex_Bounded_Linear_Function" via "Complex_Bounded_Operators.Complex_Inner_Product" via "Complex_Bounded_Operators.Complex_Inner_Product0" via "Complex_Bounded_Operators.Complex_Vector_Spaces" via "Complex_Bounded_Operators.Extra_Vector_Spaces" via "Complex_Bounded_Operators.Extra_General" via "HOL-Analysis.Uniform_Limit" via "HOL-Analysis.Summation_Tests" via "HOL-Library.Extended_Real" via "HOL-Library.Extended_Nat")
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
### Ambiguous input (line 1808 of "~~/src/HOL/Library/RBT_Impl.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("_applC" ("_position" sorted)
###         ("_applC" ("_position" map)
###           ("_cargs" ("_position" fst) ("_position" xs)))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("_applC" ("_position" sorted)
###           ("_applC" ("_position" map)
###             ("_cargs" ("_position" fst) ("_position" ys)))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("_applC" ("_position" map_of)
###         ("_cargs"
###           ("_applC" ("_position" sunion_with)
###             ("_cargs" ("_position" f)
###               ("_cargs" ("_position" xs) ("_position" ys))))
###           ("_position" k)))
###       ("_case_syntax"
###         ("_applC" ("_position" map_of)
###           ("_cargs" ("_position" xs) ("_position" k)))
###         ("_case2"
###           ("_case1" ("_position" None)
###             ("_applC" ("_position" map_of)
###               ("_cargs" ("_position" ys) ("_position" k))))
###           ("_case1" ("_applC" ("_position" Some) ("_position" v))
###             ("_case_syntax"
###               ("_applC" ("_position" map_of)
###                 ("_cargs" ("_position" ys) ("_position" k)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Some) ("_position" v)))
###                 ("_case1" ("_applC" ("_position" Some) ("_position" w))
###                   ("_applC" ("_position" Some)
###                     ("_applC" ("_position" f)
###                       ("_cargs" ("_position" k)
###                         ("_cargs" ("_position" v)
###                           ("_position" w))))))))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("_applC" ("_position" sorted)
###         ("_applC" ("_position" map)
###           ("_cargs" ("_position" fst) ("_position" xs)))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("_applC" ("_position" sorted)
###           ("_applC" ("_position" map)
###             ("_cargs" ("_position" fst) ("_position" ys)))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("_applC" ("_position" map_of)
###         ("_cargs"
###           ("_applC" ("_position" sunion_with)
###             ("_cargs" ("_position" f)
###               ("_cargs" ("_position" xs) ("_position" ys))))
###           ("_position" k)))
###       ("_case_syntax"
###         ("_applC" ("_position" map_of)
###           ("_cargs" ("_position" xs) ("_position" k)))
###         ("_case2"
###           ("_case1" ("_position" None)
###             ("_applC" ("_position" map_of)
###               ("_cargs" ("_position" ys) ("_position" k))))
###           ("_case2"
###             ("_case1" ("_applC" ("_position" Some) ("_position" v))
###               ("_case_syntax"
###                 ("_applC" ("_position" map_of)
###                   ("_cargs" ("_position" ys) ("_position" k)))
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Some) ("_position" v)))))
###             ("_case1" ("_applC" ("_position" Some) ("_position" w))
###               ("_applC" ("_position" Some)
###                 ("_applC" ("_position" f)
###                   ("_cargs" ("_position" k)
###                     ("_cargs" ("_position" v) ("_position" w))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "HOL-Library.Order_Continuity"
### 0.598s elapsed time, 2.366s cpu time, 0.194s GC time
Loading theory "HOL-Library.Extended_Nat" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Complex_Bounded_Operators.Complex_L2" via "Complex_Bounded_Operators.Complex_Bounded_Linear_Function" via "Complex_Bounded_Operators.Complex_Inner_Product" via "Complex_Bounded_Operators.Complex_Inner_Product0" via "Complex_Bounded_Operators.Complex_Vector_Spaces" via "Complex_Bounded_Operators.Extra_Vector_Spaces" via "Complex_Bounded_Operators.Extra_General" via "HOL-Analysis.Uniform_Limit" via "HOL-Analysis.Summation_Tests" via "HOL-Library.Extended_Real")
class infinity = type +
  fixes infinity :: "'a"
instantiation
  enat :: infinity
  infinity_enat == infinity :: enat
Proofs for inductive predicate(s) "rec_set_enat"
Found termination order: "{}"
### No equation for constructor "Extended_Nat.infinity_class.infinity"
### in definition of function "the_enat"
consts
  the_enat :: "enat => nat"
instantiation
  enat :: zero_neq_one
  one_enat == one_class.one :: enat
  zero_enat == zero_class.zero :: enat
instantiation
  enat :: comm_monoid_add
  plus_enat == plus :: enat => enat => enat
instantiation
  enat :: {comm_semiring_1,semiring_no_zero_divisors}
  times_enat == times :: enat => enat => enat
instantiation
  enat :: minus
  minus_enat == minus :: enat => enat => enat
instantiation
  enat :: linordered_ab_semigroup_add
  less_eq_enat == less_eq :: enat => enat => bool
  less_enat == less :: enat => enat => bool
### theory "HOL-Analysis.Elementary_Normed_Spaces"
### 1.359s elapsed time, 5.365s cpu time, 0.535s GC time
Loading theory "HOL-Library.Sum_of_Squares" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Complex_Bounded_Operators.Complex_L2" via "Complex_Bounded_Operators.Complex_Bounded_Linear_Function" via "Complex_Bounded_Operators.Complex_Inner_Product" via "Complex_Bounded_Operators.Complex_Inner_Product0" via "Complex_Bounded_Operators.Complex_Vector_Spaces" via "HOL-Analysis.Starlike" via "HOL-Analysis.Convex_Euclidean_Space" via "HOL-Analysis.Topology_Euclidean_Space" via "HOL-Analysis.Norm_Arith")
instantiation
  enat :: {order_bot,order_top}
  top_enat == top :: enat
  bot_enat == bot :: enat
structure Cancel_Enat_Common:
  sig
    val dest_sum: term -> term list
    val dest_summing: term * term list -> term list
    val find_first: term -> term list -> term list
    val find_first_t: term list -> term -> term list -> term list
    val mk_eq: term * term -> term
    val mk_sum: typ -> term list -> term
    val norm_ss: simpset
    val norm_tac: Proof.context -> tactic
    val simplify_meta_eq: Proof.context -> thm -> thm -> thm
    val trans_tac: Proof.context -> thm option -> tactic
  end
structure Eq_Enat_Cancel:
  sig val proc: Proof.context -> term -> thm option end
structure Le_Enat_Cancel:
  sig val proc: Proof.context -> term -> thm option end
structure Less_Enat_Cancel:
  sig val proc: Proof.context -> term -> thm option end
instantiation
  enat :: complete_lattice
  Inf_enat == Inf :: enat set => enat
  Sup_enat == Sup :: enat set => enat
  sup_enat == sup :: enat => enat => enat
  inf_enat == inf :: enat => enat => enat
### theory "HOL-Library.Extended_Nat"
### 0.775s elapsed time, 3.044s cpu time, 0.464s GC time
Loading theory "HOL-Library.Extended_Real" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Complex_Bounded_Operators.Complex_L2" via "Complex_Bounded_Operators.Complex_Bounded_Linear_Function" via "Complex_Bounded_Operators.Complex_Inner_Product" via "Complex_Bounded_Operators.Complex_Inner_Product0" via "Complex_Bounded_Operators.Complex_Vector_Spaces" via "Complex_Bounded_Operators.Extra_Vector_Spaces" via "Complex_Bounded_Operators.Extra_General" via "HOL-Analysis.Uniform_Limit" via "HOL-Analysis.Summation_Tests")
Found termination order: "{}"
instantiation
  enat :: linorder_topology
  open_enat == open :: enat set => bool
instantiation
  complex :: nice_ordered_field
### theory "Complex_Bounded_Operators.Extra_Ordered_Fields"
### 36.270s elapsed time, 129.272s cpu time, 85.012s GC time
Loading theory "Sqrt_Babylonian.Sqrt_Babylonian_Auxiliary" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Quantum" via "Real_Impl.Real_Impl" via "Sqrt_Babylonian.Sqrt_Babylonian")
### ML warning (line 261 of "~~/src/HOL/Library/Sum_of_Squares/positivstellensatz.ML"):
### Value identifier (pth_abs) has not been referenced.
### ML warning (line 265 of "~~/src/HOL/Library/Sum_of_Squares/positivstellensatz.ML"):
### Value identifier (pth_max) has not been referenced.
### ML warning (line 269 of "~~/src/HOL/Library/Sum_of_Squares/positivstellensatz.ML"):
### Value identifier (pth_min) has not been referenced.
### ML warning (line 379 of "~~/src/HOL/Library/Sum_of_Squares/positivstellensatz.ML"):
### Pattern is not exhaustive.
signature FUNC =
  sig
    exception DUP of key
    exception SAME
    exception UNDEF of key
    val apply: 'a table -> key -> 'a
    val applyd: 'a table -> (key -> 'a) -> key -> 'a
    val build: ('a table -> 'a table) -> 'a table
    val choose: 'a table -> key * 'a
    val combine:
       ('a -> 'a -> 'a) -> ('a -> bool) -> 'a table -> 'a table -> 'a table
    val cons_list: key * 'a -> 'a list table -> 'a list table
    val default: key * 'a -> 'a table -> 'a table
    val defined: 'a table -> key -> bool
    val delete: key -> 'a table -> 'a table
    val delete_safe: key -> 'a table -> 'a table
    val dest: 'a table -> (key * 'a) list
    val dest_list: 'a list table -> (key * 'a) list
    val dom: 'a table -> key list
    val empty: 'a table
    val exists: (key * 'a -> bool) -> 'a table -> bool
    val fold: (key * 'a -> 'b -> 'b) -> 'a table -> 'b -> 'b
    val fold_rev: (key * 'a -> 'b -> 'b) -> 'a table -> 'b -> 'b
    val forall: (key * 'a -> bool) -> 'a table -> bool
    val get_first: (key * 'a -> 'b option) -> 'a table -> 'b option
    val insert: ('a * 'a -> bool) -> key * 'a -> 'a table -> 'a table
    val insert_list:
       ('a * 'a -> bool) -> key * 'a -> 'a list table -> 'a list table
    val insert_set: key -> set -> set
    val is_empty: 'a table -> bool
    val is_single: 'a table -> bool
    val join: (key -> 'a * 'a -> 'a) -> 'a table * 'a table -> 'a table
    type key
    val keys: 'a table -> key list
    val lookup: 'a table -> key -> 'a option
    val lookup_key: 'a table -> key -> (key * 'a) option
    val lookup_list: 'a list table -> key -> 'a list
    val make: (key * 'a) list -> 'a table
    val make_list: (key * 'a) list -> 'a list table
    val make_set: key list -> set
    val map: (key -> 'a -> 'b) -> 'a table -> 'b table
    val map_default: key * 'a -> ('a -> 'a) -> 'a table -> 'a table
    val map_entry: key -> ('a -> 'a) -> 'a table -> 'a table
    val max: 'a table -> (key * 'a) option
    val member: ('a * 'b -> bool) -> 'b table -> key * 'a -> bool
    val merge: ('a * 'a -> bool) -> 'a table * 'a table -> 'a table
    val merge_list:
       ('a * 'a -> bool) -> 'a list table * 'a list table -> 'a list table
    val min: 'a table -> (key * 'a) option
    val onefunc: key * 'a -> 'a table
    val remove: ('a * 'b -> bool) -> key * 'a -> 'b table -> 'b table
    val remove_list:
       ('a * 'b -> bool) -> key * 'a -> 'b list table -> 'b list table
    val remove_set: key -> set -> set
    type set = unit table
    type 'a table
    val tryapplyd: 'a table -> key -> 'a -> 'a
    val update: key * 'a -> 'a table -> 'a table
    val update_list:
       ('a * 'a -> bool) -> key * 'a -> 'a list table -> 'a list table
    val update_new: key * 'a -> 'a table -> 'a table
    val updatep: (key * 'a -> bool) -> key * 'a -> 'a table -> 'a table
  end
functor FuncFun (Key: KEY): FUNC
signature REAL_ARITH =
  sig
    type cert_conv = cterm -> thm * pss_tree
    val cterm_of_rat: Rat.rat -> cterm
    val dest_ratconst: cterm -> Rat.rat
    val gen_gen_real_arith:
       Proof.context ->
         (Rat.rat -> cterm) * conv * conv * conv * conv * conv * conv *
         conv * conv * conv * prover
           -> cert_conv
    val gen_prover_real_arith: Proof.context -> prover -> cert_conv
    val gen_real_arith:
       Proof.context ->
         (Rat.rat -> cterm) * conv * conv * conv * conv * conv * conv *
         conv * prover
           -> cert_conv
    val is_ratconst: cterm -> bool
    datatype positivstellensatz
    =
         Axiom_eq of int
       | Axiom_le of int
       | Axiom_lt of int
       | Eqmul of FuncUtil.poly * positivstellensatz
       | Product of positivstellensatz * positivstellensatz
       | Rational_eq of Rat.rat
       | Rational_le of Rat.rat
       | Rational_lt of Rat.rat
       | Square of FuncUtil.poly
       | Sum of positivstellensatz * positivstellensatz
    type prover =
       tree_choice list ->
         (thm list * thm list * thm list -> positivstellensatz -> thm) ->
           thm list * thm list * thm list -> thm * pss_tree
    datatype pss_tree
    = Branch of pss_tree * pss_tree | Cert of positivstellensatz | Trivial
    val real_linear_prover:
       (thm list * thm list * thm list -> positivstellensatz -> thm) ->
         thm list * thm list * thm list -> thm * pss_tree
    datatype tree_choice = Left | Right
  end
structure FuncUtil:
  sig
    structure Ctermfunc: FUNC
    structure Intfunc: FUNC
    structure Intpairfunc: FUNC
    structure Monomialfunc: FUNC
    structure Ratfunc: FUNC
    structure Symfunc: FUNC
    structure Termfunc: FUNC
    val dest_monomial: 'a Ctermfunc.table -> (cterm * 'a) list
    type monomial = int Ctermfunc.table
    val monomial_ord: int Ctermfunc.table * int Ctermfunc.table -> order
    val monomial_order: int Ctermfunc.table * int Ctermfunc.table -> order
    type poly = Rat.rat Monomialfunc.table
  end
structure RealArith: REAL_ARITH
signature POSITIVSTELLENSATZ_TOOLS =
  sig
    val print_cert: RealArith.pss_tree -> string
    val read_cert: Proof.context -> string -> RealArith.pss_tree
  end
structure Positivstellensatz_Tools: POSITIVSTELLENSATZ_TOOLS
instantiation
  ereal :: uminus
  uminus_ereal == uminus :: ereal => ereal
Found termination order: "{}"
instantiation
  ereal :: infinity
  infinity_ereal == infinity :: ereal
Found termination order: "{}"
class linordered_idom = ring_char_0 + idom_abs_sgn +
  linordered_ring_strict + linordered_semidom +
  linordered_semiring_1_strict + ordered_comm_ring + ordered_ring_abs +
  assumes
    "sgn_if":
      "!!x. sgn x =
            (if x = (0::'a) then 0::'a
             else if (0::'a) < x then 1::'a else - (1::'a))"
instantiation
  ereal :: abs
  abs_ereal == abs :: ereal => ereal
### theory "Sqrt_Babylonian.Sqrt_Babylonian_Auxiliary"
### 0.486s elapsed time, 1.897s cpu time, 0.206s GC time
Loading theory "Sqrt_Babylonian.Log_Impl" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Quantum" via "Real_Impl.Real_Impl" via "Sqrt_Babylonian.Sqrt_Babylonian" via "Sqrt_Babylonian.NthRoot_Impl")
instantiation
  ereal :: {comm_monoid_add,zero_neq_one}
  one_ereal == one_class.one :: ereal
  zero_ereal == zero_class.zero :: ereal
  plus_ereal == plus :: ereal => ereal => ereal
signature SUM_OF_SQUARES =
  sig
    exception Failure of string
    val debug: bool Config.T
    val debug_message: Proof.context -> (unit -> string) -> unit
    datatype proof_method
    = Certificate of RealArith.pss_tree | Prover of string -> string
    val sos_tac:
       (RealArith.pss_tree -> unit) ->
         proof_method -> Proof.context -> int -> tactic
    val trace: bool Config.T
    val trace_message: Proof.context -> (unit -> string) -> unit
  end
structure Sum_of_Squares: SUM_OF_SQUARES
signature SOS_WRAPPER =
  sig val sos_tac: Proof.context -> string option -> int -> tactic end
structure SOS_Wrapper: SOS_WRAPPER
### theory "HOL-Library.Sum_of_Squares"
### 1.433s elapsed time, 5.599s cpu time, 0.766s GC time
Loading theory "HOL-Analysis.Norm_Arith" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Complex_Bounded_Operators.Complex_L2" via "Complex_Bounded_Operators.Complex_Bounded_Linear_Function" via "Complex_Bounded_Operators.Complex_Inner_Product" via "Complex_Bounded_Operators.Complex_Inner_Product0" via "Complex_Bounded_Operators.Complex_Vector_Spaces" via "HOL-Analysis.Starlike" via "HOL-Analysis.Convex_Euclidean_Space" via "HOL-Analysis.Topology_Euclidean_Space")
instantiation
  ereal :: linorder
  less_eq_ereal == less_eq :: ereal => ereal => bool
  less_ereal == less :: ereal => ereal => bool
### theory "Sqrt_Babylonian.Log_Impl"
### 0.282s elapsed time, 1.095s cpu time, 0.177s GC time
Loading theory "Sqrt_Babylonian.NthRoot_Impl" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Quantum" via "Real_Impl.Real_Impl" via "Sqrt_Babylonian.Sqrt_Babylonian")
instantiation
  ereal :: {comm_monoid_mult,sgn}
  sgn_ereal == sgn :: ereal => ereal
  times_ereal == times :: ereal => ereal => ereal
### ML warning (line 103 of "~~/src/HOL/Analysis/normarith.ML"):
### Matches are not exhaustive.
signature NORM_ARITH =
  sig
    val norm_arith: Proof.context -> conv
    val norm_arith_tac: Proof.context -> int -> tactic
  end
structure NormArith: NORM_ARITH
### theory "HOL-Analysis.Norm_Arith"
### 0.321s elapsed time, 1.254s cpu time, 0.175s GC time
Loading theory "HOL-Analysis.Topology_Euclidean_Space" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Complex_Bounded_Operators.Complex_L2" via "Complex_Bounded_Operators.Complex_Bounded_Linear_Function" via "Complex_Bounded_Operators.Complex_Inner_Product" via "Complex_Bounded_Operators.Complex_Inner_Product0" via "Complex_Bounded_Operators.Complex_Vector_Spaces" via "HOL-Analysis.Starlike" via "HOL-Analysis.Convex_Euclidean_Space")
locale fixed_root
  fixes p :: "nat"
    and pm :: "nat"
  assumes "fixed_root p pm"
Found termination order: "{}"
locale fixed_root
  fixes p :: "nat"
    and pm :: "nat"
  assumes "fixed_root p pm"
instantiation
  ereal :: minus
  minus_ereal == minus :: ereal => ereal => ereal
instantiation
  ereal :: inverse
  inverse_ereal == inverse :: ereal => ereal
  divide_ereal == divide :: ereal => ereal => ereal
### theory "Sqrt_Babylonian.NthRoot_Impl"
### 0.594s elapsed time, 2.336s cpu time, 0.322s GC time
Loading theory "Sqrt_Babylonian.Sqrt_Babylonian" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Quantum" via "Real_Impl.Real_Impl")
instantiation
  ereal :: lattice
  inf_ereal == inf :: ereal => ereal => ereal
  sup_ereal == sup :: ereal => ereal => ereal
instantiation
  ereal :: complete_lattice
  Inf_ereal == Inf :: ereal set => ereal
  Sup_ereal == Sup :: ereal set => ereal
  bot_ereal == bot :: ereal
  top_ereal == top :: ereal
Found termination order:
  "(%p. size (snd p)) <*mlex*> (%p. size (fst p)) <*mlex*> {}"
locale sqrt_approximation
  fixes \<epsilon> :: "'a"
    and n :: "'a"
  assumes "sqrt_approximation \<epsilon> n"
instantiation
  ereal :: linear_continuum_topology
  open_ereal == open :: ereal set => bool
### theory "Sqrt_Babylonian.Sqrt_Babylonian"
### 0.344s elapsed time, 1.353s cpu time, 0.186s GC time
Loading theory "Real_Impl.Real_Impl" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Quantum")
Found termination order: "(%p. size (snd (snd (snd p)))) <*mlex*> {}"
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
### Code generator: dropping subsumed code equation
### 0 == Ratreal 0
### Code generator: dropping subsumed code equation
### 1 == Ratreal 1
### Code generator: dropping subsumed code equation
### Ratreal ?x <= Ratreal ?y == ?x <= ?y
### Code generator: dropping subsumed code equation
### Ratreal ?x < Ratreal ?y == ?x < ?y
### Code generator: dropping subsumed code equation
### Ratreal ?x / Ratreal ?y == Ratreal (?x / ?y)
### Code generator: dropping subsumed code equation
### Ratreal ?x - Ratreal ?y == Ratreal (?x - ?y)
### theory "Real_Impl.Real_Impl"
### 0.561s elapsed time, 2.199s cpu time, 0.266s GC time
Loading theory "Polynomial_Interpolation.Ring_Hom" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Jordan_Normal_Form.Matrix")
Found termination order: "{}"
Found termination order: "size <*mlex*> {}"
### theory "HOL-Library.Extended_Real"
### 2.995s elapsed time, 11.750s cpu time, 1.527s GC time
Loading theory "HOL-Library.Extended_Nonnegative_Real" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Complex_Bounded_Operators.Complex_L2" via "Complex_Bounded_Operators.Complex_Bounded_Linear_Function" via "Complex_Bounded_Operators.Complex_Inner_Product" via "Complex_Bounded_Operators.Complex_Inner_Product0" via "Complex_Bounded_Operators.Complex_Vector_Spaces" via "Complex_Bounded_Operators.Extra_Vector_Spaces" via "Complex_Bounded_Operators.Extra_General" via "HOL-Analysis.Uniform_Limit" via "HOL-Analysis.Summation_Tests" via "HOL-Analysis.Extended_Real_Limits")
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
locale zero_hom
  fixes hom :: "'a => 'b"
  assumes "zero_hom hom"
locale one_hom
  fixes hom :: "'a => 'b"
  assumes "one_hom hom"
locale times_hom
  fixes hom :: "'a => 'b"
  assumes "times_hom hom"
locale plus_hom
  fixes hom :: "'a => 'b"
  assumes "plus_hom hom"
locale semigroup_mult_hom
  fixes hom :: "'a => 'b"
  assumes "semigroup_mult_hom hom"
locale semigroup_add_hom
  fixes hom :: "'a => 'b"
  assumes "semigroup_add_hom hom"
locale monoid_mult_hom
  fixes hom :: "'a => 'b"
  assumes "monoid_mult_hom hom"
locale monoid_add_hom
  fixes hom :: "'a => 'b"
  assumes "monoid_add_hom hom"
locale group_add_hom
  fixes hom :: "'a => 'b"
  assumes "group_add_hom hom"
locale ab_semigroup_mult_hom
  fixes hom :: "'a => 'b"
  assumes "ab_semigroup_mult_hom hom"
locale ab_semigroup_add_hom
  fixes hom :: "'a => 'b"
  assumes "ab_semigroup_add_hom hom"
locale comm_monoid_mult_hom
  fixes hom :: "'a => 'b"
  assumes "comm_monoid_mult_hom hom"
locale comm_monoid_add_hom
  fixes hom :: "'a => 'b"
  assumes "comm_monoid_add_hom hom"
locale ab_group_add_hom
  fixes hom :: "'a => 'b"
  assumes "ab_group_add_hom hom"
locale semiring_hom
  fixes hom :: "'a => 'b"
  assumes "semiring_hom hom"
locale ring_hom
  fixes hom :: "'a => 'b"
  assumes "ring_hom hom"
locale comm_semiring_hom
  fixes hom :: "'a => 'b"
  assumes "comm_semiring_hom hom"
locale comm_ring_hom
  fixes hom :: "'a => 'b"
  assumes "comm_ring_hom hom"
locale idom_hom
  fixes hom :: "'a => 'b"
  assumes "idom_hom hom"
locale idom_divide_hom
  fixes hom :: "'a => 'b"
  assumes "idom_divide_hom hom"
locale field_hom
  fixes hom :: "'a => 'b"
  assumes "field_hom hom"
instantiation
  ennreal :: complete_linorder
  Inf_ennreal == Inf :: ennreal set => ennreal
  Sup_ennreal == Sup :: ennreal set => ennreal
  bot_ennreal == bot :: ennreal
  sup_ennreal == sup :: ennreal => ennreal => ennreal
  top_ennreal == top :: ennreal
  inf_ennreal == inf :: ennreal => ennreal => ennreal
  less_eq_ennreal == less_eq :: ennreal => ennreal => bool
  less_ennreal == less :: ennreal => ennreal => bool
locale field_char_0_hom
  fixes hom :: "'a => 'b"
  assumes "field_char_0_hom hom"
locale zero_hom_0
  fixes hom :: "'a => 'b"
  assumes "zero_hom_0 hom"
locale one_hom_1
  fixes hom :: "'a => 'b"
  assumes "one_hom_1 hom"
locale monoid_mult_hom_1
  fixes hom :: "'a => 'b"
  assumes "monoid_mult_hom_1 hom"
locale monoid_add_hom_0
  fixes hom :: "'a => 'b"
  assumes "monoid_add_hom_0 hom"
locale comm_monoid_mult_hom_1
  fixes hom :: "'a => 'b"
  assumes "comm_monoid_mult_hom_1 hom"
locale comm_monoid_add_hom_0
  fixes hom :: "'a => 'b"
  assumes "comm_monoid_add_hom_0 hom"
locale injective
  fixes f :: "'a => 'b"
  assumes "injective f"
locale inj_zero_hom
  fixes hom :: "'a => 'b"
  assumes "inj_zero_hom hom"
locale inj_one_hom
  fixes hom :: "'a => 'b"
  assumes "inj_one_hom hom"
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
locale inj_semigroup_mult_hom
  fixes hom :: "'a => 'b"
  assumes "inj_semigroup_mult_hom hom"
locale inj_semigroup_add_hom
  fixes hom :: "'a => 'b"
  assumes "inj_semigroup_add_hom hom"
locale inj_monoid_mult_hom
  fixes hom :: "'a => 'b"
  assumes "inj_monoid_mult_hom hom"
instantiation
  ennreal :: infinity
  infinity_ennreal == infinity :: ennreal
locale inj_monoid_add_hom
  fixes hom :: "'a => 'b"
  assumes "inj_monoid_add_hom hom"
instantiation
  ennreal :: {comm_semiring_1,semiring_1_no_zero_divisors}
  zero_ennreal == zero_class.zero :: ennreal
  plus_ennreal == plus :: ennreal => ennreal => ennreal
  one_ennreal == one_class.one :: ennreal
  times_ennreal == times :: ennreal => ennreal => ennreal
locale inj_comm_monoid_mult_hom
  fixes hom :: "'a => 'b"
  assumes "inj_comm_monoid_mult_hom hom"
locale inj_comm_monoid_add_hom
  fixes hom :: "'a => 'b"
  assumes "inj_comm_monoid_add_hom hom"
locale inj_semiring_hom
  fixes hom :: "'a => 'b"
  assumes "inj_semiring_hom hom"
instantiation
  ennreal :: minus
  minus_ennreal == minus :: ennreal => ennreal => ennreal
### theory "HOL-Analysis.Topology_Euclidean_Space"
### 2.377s elapsed time, 9.325s cpu time, 1.218s GC time
Loading theory "HOL-Analysis.Convex_Euclidean_Space" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Complex_Bounded_Operators.Complex_L2" via "Complex_Bounded_Operators.Complex_Bounded_Linear_Function" via "Complex_Bounded_Operators.Complex_Inner_Product" via "Complex_Bounded_Operators.Complex_Inner_Product0" via "Complex_Bounded_Operators.Complex_Vector_Spaces" via "HOL-Analysis.Starlike")
locale inj_comm_semiring_hom
  fixes hom :: "'a => 'b"
  assumes "inj_comm_semiring_hom hom"
instantiation
  ennreal :: inverse
  inverse_ennreal == inverse :: ennreal => ennreal
  divide_ennreal == divide :: ennreal => ennreal => ennreal
locale inj_group_add_hom
  fixes hom :: "'a => 'b"
  assumes "inj_group_add_hom hom"
locale inj_ab_group_add_hom
  fixes hom :: "'a => 'b"
  assumes "inj_ab_group_add_hom hom"
locale inj_ring_hom
  fixes hom :: "'a => 'b"
  assumes "inj_ring_hom hom"
locale inj_comm_ring_hom
  fixes hom :: "'a => 'b"
  assumes "inj_comm_ring_hom hom"
structure Cancel_Ennreal_Common:
  sig
    val dest_sum: term -> term list
    val dest_summing: term * term list -> term list
    val find_first: term -> term list -> term list
    val find_first_t: term list -> term -> term list -> term list
    val mk_eq: term * term -> term
    val mk_sum: typ -> term list -> term
    val norm_ss: simpset
    val norm_tac: Proof.context -> tactic
    val simplify_meta_eq: Proof.context -> thm -> thm -> thm
    val trans_tac: Proof.context -> thm option -> tactic
  end
structure Eq_Ennreal_Cancel:
  sig val proc: Proof.context -> term -> thm option end
structure Le_Ennreal_Cancel:
  sig val proc: Proof.context -> term -> thm option end
structure Less_Ennreal_Cancel:
  sig val proc: Proof.context -> term -> thm option end
locale inj_idom_hom
  fixes hom :: "'a => 'b"
  assumes "inj_idom_hom hom"
locale field_hom
  fixes hom :: "'a => 'b"
  assumes "field_hom hom"
locale surjective
  fixes f :: "'a => 'b"
  assumes "surjective f"
locale bijective
  fixes f :: "'a => 'b"
  assumes "bijective f"
locale bijective
  fixes f :: "'a => 'b"
  assumes "bijective f"
locale monoid_mult_isom
  fixes hom :: "'a => 'b"
  assumes "monoid_mult_isom hom"
locale monoid_add_isom
  fixes hom :: "'a => 'b"
  assumes "monoid_add_isom hom"
locale comm_monoid_mult_isom
  fixes hom :: "'a => 'b"
  assumes "comm_monoid_mult_isom hom"
locale comm_monoid_add_isom
  fixes hom :: "'a => 'b"
  assumes "comm_monoid_add_isom hom"
locale semiring_isom
  fixes hom :: "'a => 'b"
  assumes "semiring_isom hom"
instantiation
  ennreal :: linear_continuum_topology
  open_ennreal == open :: ennreal set => bool
locale comm_semiring_isom
  fixes hom :: "'a => 'b"
  assumes "comm_semiring_isom hom"
locale ring_isom
  fixes hom :: "'a => 'b"
  assumes "ring_isom hom"
locale comm_ring_isom
  fixes hom :: "'a => 'b"
  assumes "comm_ring_isom hom"
### theory "HOL-Library.Extended_Nonnegative_Real"
### 1.811s elapsed time, 7.061s cpu time, 1.003s GC time
Loading theory "HOL-Analysis.Infinite_Sum" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Complex_Bounded_Operators.Complex_L2" via "Complex_Bounded_Operators.Complex_Bounded_Linear_Function" via "Complex_Bounded_Operators.Complex_Inner_Product" via "Complex_Bounded_Operators.Complex_Inner_Product0" via "Complex_Bounded_Operators.Complex_Vector_Spaces" via "Complex_Bounded_Operators.Extra_Vector_Spaces" via "Complex_Bounded_Operators.Extra_General")
### theory "HOL-Analysis.Convex_Euclidean_Space"
### 3.074s elapsed time, 11.693s cpu time, 7.621s GC time
Loading theory "HOL-Analysis.Extended_Real_Limits" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Complex_Bounded_Operators.Complex_L2" via "Complex_Bounded_Operators.Complex_Bounded_Linear_Function" via "Complex_Bounded_Operators.Complex_Inner_Product" via "Complex_Bounded_Operators.Complex_Inner_Product0" via "Complex_Bounded_Operators.Complex_Vector_Spaces" via "Complex_Bounded_Operators.Extra_Vector_Spaces" via "Complex_Bounded_Operators.Extra_General" via "HOL-Analysis.Uniform_Limit" via "HOL-Analysis.Summation_Tests")
locale idom_isom
  fixes hom :: "'a => 'b"
  assumes "idom_isom hom"
locale field_isom
  fixes hom :: "'a => 'b"
  assumes "field_isom hom"
locale inj_idom_divide_hom
  fixes hom :: "'a => 'b"
  assumes "inj_idom_divide_hom hom"
locale field_hom
  fixes hom :: "'a => 'b"
  assumes "field_hom hom"
### theory "Polynomial_Interpolation.Ring_Hom"
### 5.275s elapsed time, 20.336s cpu time, 8.634s GC time
Loading theory "HOL-Analysis.Line_Segment" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Complex_Bounded_Operators.Complex_L2" via "Complex_Bounded_Operators.Complex_Bounded_Linear_Function" via "Complex_Bounded_Operators.Complex_Inner_Product" via "Complex_Bounded_Operators.Complex_Inner_Product0" via "Complex_Bounded_Operators.Complex_Vector_Spaces" via "HOL-Analysis.Starlike")
### theory "HOL-Analysis.Extended_Real_Limits"
### 1.118s elapsed time, 4.402s cpu time, 0.495s GC time
Loading theory "HOL-Analysis.Summation_Tests" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Complex_Bounded_Operators.Complex_L2" via "Complex_Bounded_Operators.Complex_Bounded_Linear_Function" via "Complex_Bounded_Operators.Complex_Inner_Product" via "Complex_Bounded_Operators.Complex_Inner_Product0" via "Complex_Bounded_Operators.Complex_Vector_Spaces" via "Complex_Bounded_Operators.Extra_Vector_Spaces" via "Complex_Bounded_Operators.Extra_General" via "HOL-Analysis.Uniform_Limit")
### theory "HOL-Analysis.Infinite_Sum"
### 1.659s elapsed time, 6.505s cpu time, 0.886s GC time
Loading theory "Jordan_Normal_Form.Matrix" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl")
### theory "HOL-Analysis.Summation_Tests"
### 0.963s elapsed time, 3.778s cpu time, 0.643s GC time
Loading theory "HOL-Analysis.Uniform_Limit" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Complex_Bounded_Operators.Complex_L2" via "Complex_Bounded_Operators.Complex_Bounded_Linear_Function" via "Complex_Bounded_Operators.Complex_Inner_Product" via "Complex_Bounded_Operators.Complex_Inner_Product0" via "Complex_Bounded_Operators.Complex_Vector_Spaces" via "Complex_Bounded_Operators.Extra_Vector_Spaces" via "Complex_Bounded_Operators.Extra_General")
### theory "HOL-Analysis.Line_Segment"
### 1.023s elapsed time, 4.018s cpu time, 0.643s GC time
Loading theory "HOL-Analysis.Starlike" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Complex_Bounded_Operators.Complex_L2" via "Complex_Bounded_Operators.Complex_Bounded_Linear_Function" via "Complex_Bounded_Operators.Complex_Inner_Product" via "Complex_Bounded_Operators.Complex_Inner_Product0" via "Complex_Bounded_Operators.Complex_Vector_Spaces")
instantiation
  vec :: (plus) plus
  plus_vec == plus :: 'a vec => 'a vec => 'a vec
instantiation
  vec :: (minus) minus
  minus_vec == minus :: 'a vec => 'a vec => 'a vec
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
### theory "HOL-Analysis.Uniform_Limit"
### 0.691s elapsed time, 2.698s cpu time, 0.477s GC time
Loading theory "Complex_Bounded_Operators.Extra_General" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Complex_Bounded_Operators.Complex_L2" via "Complex_Bounded_Operators.Complex_Bounded_Linear_Function" via "Complex_Bounded_Operators.Complex_Inner_Product" via "Complex_Bounded_Operators.Complex_Inner_Product0" via "Complex_Bounded_Operators.Complex_Vector_Spaces" via "Complex_Bounded_Operators.Extra_Vector_Spaces")
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
instantiation
  vec :: (uminus) uminus
  uminus_vec == uminus :: 'a vec => 'a vec
instantiation
  vec :: (ord) ord
  less_eq_vec == less_eq :: 'a vec => 'a vec => bool
  less_vec == less :: 'a vec => 'a vec => bool
instantiation
  vec :: (preorder) preorder
instantiation
  vec :: (order) order
Found termination order: "{}"
instantiation
  mat :: (ord) ord
  less_eq_mat == less_eq :: 'a mat => 'a mat => bool
  less_mat == less :: 'a mat => 'a mat => bool
instantiation
  mat :: (preorder) preorder
instantiation
  mat :: (order) order
instantiation
  mat :: (plus) plus
  plus_mat == plus :: 'a mat => 'a mat => 'a mat
instantiation
  mat :: (uminus) uminus
  uminus_mat == uminus :: 'a mat => 'a mat
instantiation
  mat :: (minus) minus
  minus_mat == minus :: 'a mat => 'a mat => 'a mat
instantiation
  mat :: (semiring_0) times
  times_mat == times :: 'a mat => 'a mat => 'a mat
overloading
  heterogenous_identity_id \<equiv> heterogenous_identity :: 'a => 'a
### Additional type variable(s) in locale specification "not_singleton": 'a
class not_singleton = type +
  assumes "not_singleton_card": "EX x y. x ~= y"
### theory "HOL-Analysis.Starlike"
### 2.015s elapsed time, 7.831s cpu time, 1.228s GC time
Loading theory "HOL-Analysis.Bounded_Linear_Function" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Complex_Bounded_Operators.Complex_L2" via "Complex_Bounded_Operators.Complex_Bounded_Linear_Function" via "Complex_Bounded_Operators.One_Dimensional_Spaces" via "Complex_Bounded_Operators.Extra_Operator_Norm")
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
class CARD_1 = finite +
  assumes "CARD_1": "CARD('a) = 1"
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
Found termination order: "length <*mlex*> {}"
### theory "Complex_Bounded_Operators.Extra_General"
### 2.030s elapsed time, 7.847s cpu time, 1.212s GC time
Loading theory "Complex_Bounded_Operators.Extra_Vector_Spaces" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Complex_Bounded_Operators.Complex_L2" via "Complex_Bounded_Operators.Complex_Bounded_Linear_Function" via "Complex_Bounded_Operators.Complex_Inner_Product" via "Complex_Bounded_Operators.Complex_Inner_Product0" via "Complex_Bounded_Operators.Complex_Vector_Spaces")
locale semiring_hom
  fixes hom :: "'a => 'b"
  assumes "semiring_hom hom"
instantiation
  euclidean_space :: (type) real_vector
  uminus_euclidean_space == uminus ::
    'a euclidean_space => 'a euclidean_space
  zero_euclidean_space == zero_class.zero :: 'a euclidean_space
  minus_euclidean_space == minus ::
    'a euclidean_space => 'a euclidean_space => 'a euclidean_space
  plus_euclidean_space == plus ::
    'a euclidean_space => 'a euclidean_space => 'a euclidean_space
  scaleR_euclidean_space == scaleR ::
    real => 'a euclidean_space => 'a euclidean_space
instantiation
  vec :: (conjugate) conjugate
  conjugate_vec == conjugate :: 'a vec => 'a vec
instantiation
  blinfun :: (real_normed_vector, real_normed_vector) real_normed_vector
  uminus_blinfun == uminus ::
    'a \<Rightarrow>\<^sub>L 'b => 'a \<Rightarrow>\<^sub>L 'b
  zero_blinfun == zero_class.zero :: 'a \<Rightarrow>\<^sub>L 'b
  minus_blinfun == minus ::
    'a \<Rightarrow>\<^sub>L 'b
    => 'a \<Rightarrow>\<^sub>L 'b => 'a \<Rightarrow>\<^sub>L 'b
  plus_blinfun == plus ::
    'a \<Rightarrow>\<^sub>L 'b
    => 'a \<Rightarrow>\<^sub>L 'b => 'a \<Rightarrow>\<^sub>L 'b
  sgn_blinfun == sgn ::
    'a \<Rightarrow>\<^sub>L 'b => 'a \<Rightarrow>\<^sub>L 'b
  norm_blinfun == norm :: 'a \<Rightarrow>\<^sub>L 'b => real
  scaleR_blinfun == scaleR ::
    real => 'a \<Rightarrow>\<^sub>L 'b => 'a \<Rightarrow>\<^sub>L 'b
  dist_blinfun == dist ::
    'a \<Rightarrow>\<^sub>L 'b => 'a \<Rightarrow>\<^sub>L 'b => real
  uniformity_blinfun == uniformity ::
    ('a \<Rightarrow>\<^sub>L 'b * 'a \<Rightarrow>\<^sub>L 'b) filter
  open_blinfun == open :: ('a \<Rightarrow>\<^sub>L 'b) set => bool
instantiation
  euclidean_space :: (finite) real_inner
  inner_euclidean_space == inner ::
    'a euclidean_space => 'a euclidean_space => real
  sgn_euclidean_space == sgn :: 'a euclidean_space => 'a euclidean_space
  norm_euclidean_space == norm :: 'a euclidean_space => real
  dist_euclidean_space == dist ::
    'a euclidean_space => 'a euclidean_space => real
  uniformity_euclidean_space == uniformity ::
    ('a euclidean_space * 'a euclidean_space) filter
  open_euclidean_space == open :: 'a euclidean_space set => bool
### theory "Jordan_Normal_Form.Matrix"
### 4.133s elapsed time, 16.042s cpu time, 2.435s GC time
Loading theory "Jordan_Normal_Form.Gauss_Jordan_Elimination" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl")
instantiation
  euclidean_space :: (finite) euclidean_space
  Basis_euclidean_space == Basis :: 'a euclidean_space set
### theory "Complex_Bounded_Operators.Extra_Vector_Spaces"
### 0.858s elapsed time, 3.295s cpu time, 0.453s GC time
Loading theory "Complex_Bounded_Operators.Complex_Vector_Spaces" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Complex_Bounded_Operators.Complex_L2" via "Complex_Bounded_Operators.Complex_Bounded_Linear_Function" via "Complex_Bounded_Operators.Complex_Inner_Product" via "Complex_Bounded_Operators.Complex_Inner_Product0")
locale bounded_bilinear
  fixes prod :: "'a => 'b => 'c"  (infixl \<open>**\<close> 70)
  assumes "bounded_bilinear (**)"
Found termination order:
  "(%p. size_list (%p. size (snd p)) (snd (snd p))) <*mlex*> {}"
locale bounded_bilinear
  fixes prod :: "'a => 'b => 'c"  (infixl \<open>**\<close> 70)
  assumes "bounded_bilinear (**)"
### theory "HOL-Analysis.Bounded_Linear_Function"
### 2.178s elapsed time, 8.340s cpu time, 1.285s GC time
Loading theory "Complex_Bounded_Operators.Extra_Operator_Norm" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Complex_Bounded_Operators.Complex_L2" via "Complex_Bounded_Operators.Complex_Bounded_Linear_Function" via "Complex_Bounded_Operators.One_Dimensional_Spaces")
### theory "Complex_Bounded_Operators.Extra_Operator_Norm"
### 2.720s elapsed time, 10.307s cpu time, 8.588s GC time
Loading theory "Banach_Steinhaus.Banach_Steinhaus_Missing" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Complex_Bounded_Operators.Complex_L2" via "Complex_Bounded_Operators.Complex_Bounded_Linear_Function" via "Banach_Steinhaus.Banach_Steinhaus")
### theory "Jordan_Normal_Form.Gauss_Jordan_Elimination"
### 3.602s elapsed time, 13.649s cpu time, 9.160s GC time
Loading theory "Jordan_Normal_Form.Column_Operations" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Determinant_Impl" via "Jordan_Normal_Form.Determinant")
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
bundle notation_norm
bundle no_notation_norm
bundle notation_blinfun_apply
bundle no_notation_blinfun_apply
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
### theory "Jordan_Normal_Form.Column_Operations"
### 0.460s elapsed time, 1.808s cpu time, 0.180s GC time
Loading theory "Jordan_Normal_Form.Determinant" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Determinant_Impl")
### theory "Banach_Steinhaus.Banach_Steinhaus_Missing"
### 0.695s elapsed time, 2.736s cpu time, 0.305s GC time
Loading theory "Banach_Steinhaus.Banach_Steinhaus" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Complex_Bounded_Operators.Complex_L2" via "Complex_Bounded_Operators.Complex_Bounded_Linear_Function")
bundle notation_norm
### theory "Banach_Steinhaus.Banach_Steinhaus"
### 0.096s elapsed time, 0.383s cpu time, 0.000s GC time
Loading theory "Polynomial_Interpolation.Ring_Hom_Poly" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Jordan_Normal_Form_Existence" via "Jordan_Normal_Form.Jordan_Normal_Form" via "Jordan_Normal_Form.Char_Poly")
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
locale antilinear
  fixes f :: "'a => 'b"
  assumes "antilinear f"
locale bounded_antilinear
  fixes f :: "'a => 'b"
  assumes "bounded_antilinear f"
locale bounded_sesquilinear
  fixes prod :: "'a => 'b => 'c"  (infixl \<open>**\<close> 70)
  assumes "bounded_sesquilinear (**)"
locale zero_hom
  fixes hom :: "'a => 'b"
  assumes "zero_hom hom"
locale map_poly_zero_hom
  fixes hom :: "'a => 'b"
  assumes "map_poly_zero_hom hom"
locale comm_monoid_add_hom
  fixes hom :: "'a => 'b"
  assumes "comm_monoid_add_hom hom"
locale map_poly_comm_monoid_add_hom
  fixes hom :: "'a => 'b"
  assumes "map_poly_comm_monoid_add_hom hom"
locale comm_semiring_hom
  fixes hom :: "'a => 'b"
  assumes "comm_semiring_hom hom"
locale map_poly_comm_semiring_hom
  fixes hom :: "'a => 'b"
  assumes "map_poly_comm_semiring_hom hom"
locale map_poly_comm_ring_hom
  fixes hom :: "'a => 'b"
  assumes "map_poly_comm_ring_hom hom"
locale map_poly_idom_hom
  fixes hom :: "'a => 'b"
  assumes "map_poly_idom_hom hom"
locale map_poly_inj_zero_hom
  fixes hom :: "'a => 'b"
  assumes "map_poly_inj_zero_hom hom"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
class cfinite_dim = complex_vector +
  assumes "cfinitely_spanned": "EX S. finite S & cspan S = UNIV"
locale map_poly_inj_comm_monoid_add_hom
  fixes hom :: "'a => 'b"
  assumes "map_poly_inj_comm_monoid_add_hom hom"
locale map_poly_inj_comm_semiring_hom
  fixes hom :: "'a => 'b"
  assumes "map_poly_inj_comm_semiring_hom hom"
locale map_poly_inj_comm_ring_hom
  fixes hom :: "'a => 'b"
  assumes "map_poly_inj_comm_ring_hom hom"
locale map_poly_inj_idom_hom
  fixes hom :: "'a => 'b"
  assumes "map_poly_inj_idom_hom hom"
class basis_enum = complex_vector +
  fixes canonical_basis :: "'a list"
  assumes "distinct_canonical_basis": "distinct canonical_basis"
    and "is_cindependent_set": "~ cdependent (set canonical_basis)"
    and "is_generator_set": "cspan (set canonical_basis) = UNIV"
locale zero_hom_0
  fixes hom :: "'a => 'b"
  assumes "zero_hom_0 hom"
locale comm_semiring_hom
  fixes hom :: "'a => 'b"
  assumes "comm_semiring_hom hom"
locale comm_semiring_hom
  fixes hom :: "'a => 'b"
  assumes "comm_semiring_hom hom"
locale comm_ring_hom
  fixes hom :: "'a => 'b"
  assumes "comm_ring_hom hom"
### theory "Jordan_Normal_Form.Determinant"
### 1.752s elapsed time, 6.877s cpu time, 0.980s GC time
Loading theory "Jordan_Normal_Form.Determinant_Impl" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl")
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
locale field_hom
  fixes hom :: "'a => 'b"
  assumes "field_hom hom"
locale closed_csubspace
  fixes A :: "'a set"
  assumes "closed_csubspace A"
locale field_hom'
  fixes hom :: "'a => 'b"
  assumes "field_hom' hom"
locale map_poly_inj_idom_divide_hom
  fixes hom :: "'a => 'b"
  assumes "map_poly_inj_idom_divide_hom hom"
instantiation
  ccsubspace :: (complex_normed_vector) scaleC
  scaleC_ccsubspace == scaleC :: complex => 'a ccsubspace => 'a ccsubspace
  scaleR_ccsubspace == scaleR :: real => 'a ccsubspace => 'a ccsubspace
### Ambiguous input (line 2563 of "~~/src/HOL/Library/RBT_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" rbt_lookup)
###       ("_cargs"
###         ("_applC" ("_position" fold)
###           ("_cargs"
###             ("_applC" ("_position" rbt_insert_with_key) ("_position" f))
###             ("_cargs" ("_position" t1) ("_position" t2))))
###         ("_position" k)))
###     ("_case_syntax"
###       ("_applC" ("_position" rbt_lookup)
###         ("_cargs" ("_position" t1) ("_position" k)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" rbt_lookup)
###             ("_cargs" ("_position" t2) ("_position" k))))
###         ("_case1" ("_applC" ("_position" Some) ("_position" v))
###           ("_case_syntax"
###             ("_applC" ("_position" rbt_lookup)
###               ("_cargs" ("_position" t2) ("_position" k)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Some) ("_position" v)))
###               ("_case1" ("_applC" ("_position" Some) ("_position" w))
###                 ("_applC" ("_position" Some)
###                   ("_applC" ("_position" f)
###                     ("_cargs" ("_position" k)
###                       ("_cargs" ("_position" w) ("_position" v)))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" rbt_lookup)
###       ("_cargs"
###         ("_applC" ("_position" fold)
###           ("_cargs"
###             ("_applC" ("_position" rbt_insert_with_key) ("_position" f))
###             ("_cargs" ("_position" t1) ("_position" t2))))
###         ("_position" k)))
###     ("_case_syntax"
###       ("_applC" ("_position" rbt_lookup)
###         ("_cargs" ("_position" t1) ("_position" k)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" rbt_lookup)
###             ("_cargs" ("_position" t2) ("_position" k))))
###         ("_case2"
###           ("_case1" ("_applC" ("_position" Some) ("_position" v))
###             ("_case_syntax"
###               ("_applC" ("_position" rbt_lookup)
###                 ("_cargs" ("_position" t2) ("_position" k)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Some) ("_position" v)))))
###           ("_case1" ("_applC" ("_position" Some) ("_position" w))
###             ("_applC" ("_position" Some)
###               ("_applC" ("_position" f)
###                 ("_cargs" ("_position" k)
###                   ("_cargs" ("_position" w) ("_position" v)))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
instantiation
  ccsubspace :: ({complex_vector,t1_space}) bot
  bot_ccsubspace == bot :: 'a ccsubspace
instantiation
  ccsubspace :: ({complex_vector,topological_space}) top
  top_ccsubspace == top :: 'a ccsubspace
instantiation
  ccsubspace :: ({complex_vector,topological_space}) Inf
  Inf_ccsubspace == Inf :: 'a ccsubspace set => 'a ccsubspace
instantiation
  ccsubspace :: ({complex_vector,topological_space}) order
  less_eq_ccsubspace == less_eq :: 'a ccsubspace => 'a ccsubspace => bool
  less_ccsubspace == less :: 'a ccsubspace => 'a ccsubspace => bool
instantiation
  ccsubspace :: ({complex_vector,topological_space}) inf
  inf_ccsubspace == inf :: 'a ccsubspace => 'a ccsubspace => 'a ccsubspace
instantiation
  ccsubspace :: ({complex_vector,topological_space}) order_top
instantiation
  ccsubspace :: ({complex_vector,t1_space}) order_bot
instantiation
  ccsubspace :: ({complex_vector,topological_space}) semilattice_inf
instantiation
  ccsubspace :: ({complex_vector,t1_space}) zero
  zero_ccsubspace == zero_class.zero :: 'a ccsubspace
### theory "Polynomial_Interpolation.Ring_Hom_Poly"
### 2.010s elapsed time, 7.887s cpu time, 1.216s GC time
Loading theory "Jordan_Normal_Form.Char_Poly" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Jordan_Normal_Form_Existence" via "Jordan_Normal_Form.Jordan_Normal_Form")
instantiation
  ccsubspace :: (complex_normed_vector) sup
  sup_ccsubspace == sup :: 'a ccsubspace => 'a ccsubspace => 'a ccsubspace
instantiation
  ccsubspace :: (complex_normed_vector) Sup
  Sup_ccsubspace == Sup :: 'a ccsubspace set => 'a ccsubspace
instantiation
  ccsubspace :: (complex_normed_vector) comm_monoid_add
  plus_ccsubspace == plus :: 'a ccsubspace => 'a ccsubspace => 'a ccsubspace
Found termination order: "{}"
instantiation
  conjugate_space :: (complex_vector) complex_vector
  scaleC_conjugate_space == scaleC ::
    complex => 'a conjugate_space => 'a conjugate_space
  uminus_conjugate_space == uminus ::
    'a conjugate_space => 'a conjugate_space
  zero_conjugate_space == zero_class.zero :: 'a conjugate_space
  minus_conjugate_space == minus ::
    'a conjugate_space => 'a conjugate_space => 'a conjugate_space
  plus_conjugate_space == plus ::
    'a conjugate_space => 'a conjugate_space => 'a conjugate_space
  scaleR_conjugate_space == scaleR ::
    real => 'a conjugate_space => 'a conjugate_space
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
instantiation
  conjugate_space :: (complex_normed_vector) complex_normed_vector
  sgn_conjugate_space == sgn :: 'a conjugate_space => 'a conjugate_space
  norm_conjugate_space == norm :: 'a conjugate_space => real
  dist_conjugate_space == dist ::
    'a conjugate_space => 'a conjugate_space => real
  uniformity_conjugate_space == uniformity ::
    ('a conjugate_space * 'a conjugate_space) filter
  open_conjugate_space == open :: 'a conjugate_space set => bool
Found termination order: "(%p. size (fst (snd p))) <*mlex*> {}"
instantiation
  conjugate_space :: (cbanach) cbanach
instantiation
  complex :: basis_enum
  canonical_basis_complex == canonical_basis :: complex list
instantiation
  prod :: (complex_vector, complex_vector) complex_vector
  scaleC_prod == scaleC :: complex => 'a * 'b => 'a * 'b
### Cannot skip proof of schematic goal statement
Found termination order: "{}"
locale bounded_clinear
  fixes f :: "'a => 'b"
  assumes "bounded_clinear f"
locale bounded_antilinear
  fixes f :: "'a => 'b"
  assumes "bounded_antilinear f"
locale bounded_cbilinear
  fixes prod :: "'a => 'b => 'c"  (infixl \<open>**\<close> 70)
  assumes "bounded_cbilinear (**)"
locale bounded_sesquilinear
  fixes prod :: "'a => 'b => 'c"  (infixl \<open>**\<close> 70)
  assumes "bounded_sesquilinear (**)"
### theory "Complex_Bounded_Operators.Complex_Vector_Spaces"
### 7.104s elapsed time, 27.396s cpu time, 11.032s GC time
Loading theory "Complex_Bounded_Operators.Complex_Inner_Product0" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Complex_Bounded_Operators.Complex_L2" via "Complex_Bounded_Operators.Complex_Bounded_Linear_Function" via "Complex_Bounded_Operators.Complex_Inner_Product")
Found termination order: "(%p. size (fst (snd p))) <*mlex*> {}"
locale inj_comm_ring_hom
  fixes hom :: "'a => 'b"
  assumes "inj_comm_ring_hom hom"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
### Ambiguous input (line 2939 of "~~/src/HOL/Library/RBT_Impl.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("_applC" ("_position" rbt_sorted) ("_position" t1)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("_applC" ("_position" rbt_sorted) ("_position" t2)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("_applC" ("_position" rbt_lookup)
###         ("_cargs"
###           ("_applC" ("_position" rbt_union_with_key)
###             ("_cargs" ("_position" f)
###               ("_cargs" ("_position" t1) ("_position" t2))))
###           ("_position" k)))
###       ("_case_syntax"
###         ("_applC" ("_position" rbt_lookup)
###           ("_cargs" ("_position" t1) ("_position" k)))
###         ("_case2"
###           ("_case1" ("_position" None)
###             ("_applC" ("_position" rbt_lookup)
###               ("_cargs" ("_position" t2) ("_position" k))))
###           ("_case1" ("_applC" ("_position" Some) ("_position" v))
###             ("_case_syntax"
###               ("_applC" ("_position" rbt_lookup)
###                 ("_cargs" ("_position" t2) ("_position" k)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Some) ("_position" v)))
###                 ("_case1" ("_applC" ("_position" Some) ("_position" w))
###                   ("_applC" ("_position" Some)
###                     ("_applC" ("_position" f)
###                       ("_cargs" ("_position" k)
###                         ("_cargs" ("_position" v)
###                           ("_position" w))))))))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("_applC" ("_position" rbt_sorted) ("_position" t1)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("_applC" ("_position" rbt_sorted) ("_position" t2)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("_applC" ("_position" rbt_lookup)
###         ("_cargs"
###           ("_applC" ("_position" rbt_union_with_key)
###             ("_cargs" ("_position" f)
###               ("_cargs" ("_position" t1) ("_position" t2))))
###           ("_position" k)))
###       ("_case_syntax"
###         ("_applC" ("_position" rbt_lookup)
###           ("_cargs" ("_position" t1) ("_position" k)))
###         ("_case2"
###           ("_case1" ("_position" None)
###             ("_applC" ("_position" rbt_lookup)
###               ("_cargs" ("_position" t2) ("_position" k))))
###           ("_case2"
###             ("_case1" ("_applC" ("_position" Some) ("_position" v))
###               ("_case_syntax"
###                 ("_applC" ("_position" rbt_lookup)
###                   ("_cargs" ("_position" t2) ("_position" k)))
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Some) ("_position" v)))))
###             ("_case1" ("_applC" ("_position" Some) ("_position" w))
###               ("_applC" ("_position" Some)
###                 ("_applC" ("_position" f)
###                   ("_cargs" ("_position" k)
###                     ("_cargs" ("_position" v) ("_position" w))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2972 of "~~/src/HOL/Library/RBT_Impl.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("_applC" ("_position" rbt_sorted) ("_position" t1)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("_applC" ("_position" rbt_sorted) ("_position" t2)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("_applC" ("_position" rbt_lookup)
###         ("_cargs"
###           ("_applC" ("_position" rbt_inter_with_key)
###             ("_cargs" ("_position" f)
###               ("_cargs" ("_position" t1) ("_position" t2))))
###           ("_position" k)))
###       ("_case_syntax"
###         ("_applC" ("_position" rbt_lookup)
###           ("_cargs" ("_position" t1) ("_position" k)))
###         ("_case2" ("_case1" ("_position" None) ("_position" None))
###           ("_case1" ("_applC" ("_position" Some) ("_position" v))
###             ("_case_syntax"
###               ("_applC" ("_position" rbt_lookup)
###                 ("_cargs" ("_position" t2) ("_position" k)))
###               ("_case2" ("_case1" ("_position" None) ("_position" None))
###                 ("_case1" ("_applC" ("_position" Some) ("_position" w))
###                   ("_applC" ("_position" Some)
###                     ("_applC" ("_position" f)
###                       ("_cargs" ("_position" k)
###                         ("_cargs" ("_position" v)
###                           ("_position" w))))))))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("_applC" ("_position" rbt_sorted) ("_position" t1)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("_applC" ("_position" rbt_sorted) ("_position" t2)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("_applC" ("_position" rbt_lookup)
###         ("_cargs"
###           ("_applC" ("_position" rbt_inter_with_key)
###             ("_cargs" ("_position" f)
###               ("_cargs" ("_position" t1) ("_position" t2))))
###           ("_position" k)))
###       ("_case_syntax"
###         ("_applC" ("_position" rbt_lookup)
###           ("_cargs" ("_position" t1) ("_position" k)))
###         ("_case2" ("_case1" ("_position" None) ("_position" None))
###           ("_case2"
###             ("_case1" ("_applC" ("_position" Some) ("_position" v))
###               ("_case_syntax"
###                 ("_applC" ("_position" rbt_lookup)
###                   ("_cargs" ("_position" t2) ("_position" k)))
###                 ("_case1" ("_position" None) ("_position" None))))
###             ("_case1" ("_applC" ("_position" Some) ("_position" w))
###               ("_applC" ("_position" Some)
###                 ("_applC" ("_position" f)
###                   ("_cargs" ("_position" k)
###                     ("_cargs" ("_position" v) ("_position" w))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "Jordan_Normal_Form.Char_Poly"
### 1.177s elapsed time, 4.600s cpu time, 0.632s GC time
Loading theory "Jordan_Normal_Form.Jordan_Normal_Form" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Jordan_Normal_Form_Existence")
Found termination order: "(%p. size_list size (snd (snd p))) <*mlex*> {}"
### Code generator: dropping subsumed code equation
### keys (Branch ?c ?l ?k ?v ?r) == keys ?l @ ?k # keys ?r
### Code generator: dropping subsumed code equation
### keys Empty == []
### theory "Jordan_Normal_Form.Determinant_Impl"
### 1.873s elapsed time, 7.325s cpu time, 1.085s GC time
Loading theory "Show.Show" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Show_Matrix")
### theory "HOL-Library.RBT_Impl"
### 74.778s elapsed time, 278.494s cpu time, 129.932s GC time
Loading theory "Containers.RBT_ext" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl" via "Containers.RBT_Set2" via "Containers.RBT_Mapping2")
### theory "Jordan_Normal_Form.Jordan_Normal_Form"
### 0.333s elapsed time, 1.303s cpu time, 0.162s GC time
Loading theory "Deriving.RBT_Comparator_Impl" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl" via "Containers.RBT_Set2" via "Containers.RBT_Mapping2")
class show = type +
  fixes shows_prec :: "nat => 'a => char list => char list"
    and shows_list :: "'a list => char list => char list"
  assumes
    "shows_prec_append":
      "!!p x r s. shows_prec p x (r @ s) = shows_prec p x r @ s"
    and
    "shows_list_append":
      "!!xs r s. shows_list xs (r @ s) = shows_list xs r @ s"
class complex_inner = complex_vector + dist_norm + sgn_div_norm +
  uniformity_dist + open_uniformity +
  fixes cinner :: "'a => 'a => complex"
  assumes "cinner_commute": "!!x y. cinner x y = cnj (cinner y x)"
    and
    "cinner_add_left": "!!x y z. cinner (x + y) z = cinner x z + cinner y z"
    and
    "cinner_scaleC_left":
      "!!r x y. cinner (r *\<^sub>C x) y = cnj r * cinner x y"
    and "cinner_ge_zero": "!!x. 0 <= cinner x x"
    and "cinner_eq_zero_iff": "!!x. (cinner x x = 0) = (x = (0::'a))"
    and "norm_eq_sqrt_cinner": "!!x. norm x = sqrt (cmod (cinner x x))"
consts
  rbt_comp_lookup :: "('a, 'b) rbt => 'a => 'b option"
Found termination order: "(%p. length (snd (snd p))) <*mlex*> {}"
instantiation
  char :: show
  shows_prec_char == shows_prec :: nat => char => char list => char list
  shows_list_char == shows_list :: char list => char list => char list
Found termination order: "(%p. size (snd (snd (snd p)))) <*mlex*> {}"
signature SHOW_GENERATOR =
  sig
    val generate_showsp: string -> local_theory -> local_theory
    val register_foreign_partial_and_full_showsp:
       string ->
         int ->
           term ->
             term ->
               thm option ->
                 term ->
                   thm option ->
                     bool list -> thm -> local_theory -> local_theory
    val register_foreign_showsp:
       typ -> term -> thm -> local_theory -> local_theory
    val show_instance: string -> theory -> theory
  end
structure Show_Generator: SHOW_GENERATOR
instantiation
  list :: (show) show
  shows_prec_list == shows_prec :: nat => 'a list => char list => char list
  shows_list_list == shows_list :: 'a list list => char list => char list
instantiation
  String.literal :: show
  shows_prec_literal == shows_prec ::
    nat => String.literal => char list => char list
  shows_list_literal == shows_list ::
    String.literal list => char list => char list
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
### theory "Show.Show"
### 0.904s elapsed time, 3.515s cpu time, 0.547s GC time
Loading theory "Jordan_Normal_Form.Show_Matrix" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl")
instantiation
  complex :: complex_inner
  cinner_complex == cinner :: complex => complex => complex
### Dropping global mixfix syntax: "less_eq_prod'" (infix \<open>\<sqsubseteq>\<close> 50)
### Dropping global mixfix syntax: "less_prod'" (infix \<open>\<sqsubset>\<close> 50)
consts
  RBT_Impl_diag :: "('a, 'b) rbt => ('a * 'a, 'b) rbt"
bundle cinner_syntax
bundle no_cinner_syntax
### theory "Complex_Bounded_Operators.Complex_Inner_Product0"
### 1.615s elapsed time, 6.269s cpu time, 1.020s GC time
Loading theory "Complex_Bounded_Operators.Complex_Inner_Product" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Complex_Bounded_Operators.Complex_L2" via "Complex_Bounded_Operators.Complex_Bounded_Linear_Function")
bundle cinner_bracket_notation
bundle no_cinner_bracket_notation
Found termination order: "{}"
### Missing patterns in function definition:
### rbt_keys_next ([], rbt.Empty) = undefined
instantiation
  vec :: (show) show
  shows_prec_vec == shows_prec :: nat => 'a vec => char list => char list
  shows_list_vec == shows_list :: 'a vec list => char list => char list
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
instantiation
  mat :: (show) show
  shows_prec_mat == shows_prec :: nat => 'a mat => char list => char list
  shows_list_mat == shows_list :: 'a mat list => char list => char list
### theory "Jordan_Normal_Form.Show_Matrix"
### 0.901s elapsed time, 3.452s cpu time, 0.830s GC time
Loading theory "Show.Show_Instances" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl")
### Missing patterns in function definition:
### rbt_entries_next ([], rbt.Empty) = undefined
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
### theory "Containers.RBT_ext"
### 2.032s elapsed time, 7.851s cpu time, 1.553s GC time
Loading theory "VectorSpace.FunctionLemmas" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Jordan_Normal_Form_Existence" via "Jordan_Normal_Form.Schur_Decomposition" via "Jordan_Normal_Form.Gram_Schmidt" via "Jordan_Normal_Form.VS_Connect" via "Jordan_Normal_Form.Missing_VectorSpace" via "VectorSpace.VectorSpace" via "VectorSpace.MonoidSums")
### theory "VectorSpace.FunctionLemmas"
### 0.044s elapsed time, 0.174s cpu time, 0.046s GC time
Loading theory "VectorSpace.RingModuleFacts" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Jordan_Normal_Form_Existence" via "Jordan_Normal_Form.Schur_Decomposition" via "Jordan_Normal_Form.Gram_Schmidt" via "Jordan_Normal_Form.VS_Connect" via "Jordan_Normal_Form.Missing_VectorSpace" via "VectorSpace.VectorSpace")
consts
  showsp_bool :: "nat => bool => char list => char list"
consts
  pshowsp_prod ::
    "nat
     => (char list => char list) * (char list => char list)
        => char list => char list"
Found termination order: "{}"
instantiation
  complex :: chilbert_space
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
bundle orthogonal_notation
bundle no_orthogonal_notation
instantiation
  ccsubspace :: (complex_inner) uminus
  uminus_ccsubspace == uminus :: 'a ccsubspace => 'a ccsubspace
instantiation
  ccsubspace :: (complex_inner) minus
  minus_ccsubspace == minus ::
    'a ccsubspace => 'a ccsubspace => 'a ccsubspace
deriving "show" instance for type "Option.option"
generating show function for type "Option.option"
deriving "show" instance for type "Sum_Type.sum"
generating show function for type "Sum_Type.sum"
deriving "show" instance for type "Product_Type.prod"
deriving "show" instance for type "Product_Type.unit"
deriving "show" instance for type "HOL.bool"
deriving "show" instance for type "Nat.nat"
### theory "VectorSpace.RingModuleFacts"
### 0.789s elapsed time, 2.981s cpu time, 0.575s GC time
Loading theory "VectorSpace.MonoidSums" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Jordan_Normal_Form_Existence" via "Jordan_Normal_Form.Schur_Decomposition" via "Jordan_Normal_Form.Gram_Schmidt" via "Jordan_Normal_Form.VS_Connect" via "Jordan_Normal_Form.Missing_VectorSpace" via "VectorSpace.VectorSpace")
deriving "show" instance for type "Int.int"
deriving "show" instance for type "Rat.rat"
### theory "Show.Show_Instances"
### 1.338s elapsed time, 5.064s cpu time, 1.046s GC time
(if ?x <= ?y then if ?x = ?y then ?P else ?Q else ?R) =
(case compare ?x ?y of Eq => ?P | Lt => ?Q | Gt => ?R)
(if ?x <= ?y then if ?y = ?x then ?P else ?Q else ?R) =
(case compare ?x ?y of Eq => ?P | Lt => ?Q | Gt => ?R)
(if ?x <= ?y then if ?y <= ?x then ?P else ?Q else ?R) =
(case compare ?x ?y of Eq => ?P | Lt => ?Q | Gt => ?R)
(if ?x <= ?y then if ?x < ?y then ?Q else ?P else ?R) =
(case compare ?x ?y of Eq => ?P | Lt => ?Q | Gt => ?R)
(if ?x < ?y then ?Q else if ?x <= ?y then ?P else ?R) =
(case compare ?x ?y of Eq => ?P | Lt => ?Q | Gt => ?R)
(if ?x < ?y then ?Q else if ?y < ?x then ?R else ?P) =
(case compare ?x ?y of Eq => ?P | Lt => ?Q | Gt => ?R)
(if ?x < ?y then ?Q else if ?x = ?y then ?P else ?R) =
(case compare ?x ?y of Eq => ?P | Lt => ?Q | Gt => ?R)
(if ?x < ?y then ?Q else if ?y = ?x then ?P else ?R) =
(case compare ?x ?y of Eq => ?P | Lt => ?Q | Gt => ?R)
(if ?x = ?y then ?P else if ?y < ?x then ?R else ?Q) =
(case compare ?x ?y of Eq => ?P | Lt => ?Q | Gt => ?R)
(if ?x = ?y then ?P else if ?x < ?y then ?Q else ?R) =
(case compare ?x ?y of Eq => ?P | Lt => ?Q | Gt => ?R)
(if ?x = ?y then ?P else if ?y <= ?x then ?R else ?Q) =
(case compare ?x ?y of Eq => ?P | Lt => ?Q | Gt => ?R)
(if ?x = ?y then ?P else if ?x <= ?y then ?Q else ?R) =
(case compare ?x ?y of Eq => ?P | Lt => ?Q | Gt => ?R)
"(bij, bij_betw, permutation)"
  :: "(('a => 'b) => bool) *
      (('c => 'd) => 'c set => 'd set => bool) * (('e => 'e) => bool)"
carrier (| carrier = ?carrier, ... = ?more |) = ?carrier
partial_object.more (| carrier = ?carrier, ... = ?more |) = ?more
carrier_update ?carrier' (| carrier = ?carrier, ... = ?more |) =
(| carrier = ?carrier' ?carrier, ... = ?more |)
partial_object.more_update ?more' (| carrier = ?carrier, ... = ?more |) =
(| carrier = ?carrier, ... = ?more' ?more |)
(\<otimes>\<^bsub>(| carrier = ?carrier, mult = ?mult, one = ?one, ... = ?more |)\<^esub>) =
?mult
\<one>\<^bsub>(| carrier = ?carrier, mult = ?mult, one = ?one, ... = ?more |)\<^esub> =
?one
monoid.more
 (| carrier = ?carrier, mult = ?mult, one = ?one, ... = ?more |) =
?more
mult_update ?mult'
 (| carrier = ?carrier, mult = ?mult, one = ?one, ... = ?more |) =
(| carrier = ?carrier, mult = ?mult' ?mult, one = ?one, ... = ?more |)
one_update ?one'
 (| carrier = ?carrier, mult = ?mult, one = ?one, ... = ?more |) =
(| carrier = ?carrier, mult = ?mult, one = ?one' ?one, ... = ?more |)
monoid.more_update ?more'
 (| carrier = ?carrier, mult = ?mult, one = ?one, ... = ?more |) =
(| carrier = ?carrier, mult = ?mult, one = ?one, ... = ?more' ?more |)
locale abelian_monoid
  fixes G :: "('a, 'b) ring_scheme"  (structure)
  assumes "abelian_monoid G"
### theory "VectorSpace.MonoidSums"
### 0.431s elapsed time, 1.600s cpu time, 0.417s GC time
Loading theory "VectorSpace.LinearCombinations" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Jordan_Normal_Form_Existence" via "Jordan_Normal_Form.Schur_Decomposition" via "Jordan_Normal_Form.Gram_Schmidt" via "Jordan_Normal_Form.VS_Connect" via "Jordan_Normal_Form.Missing_VectorSpace" via "VectorSpace.VectorSpace")
class onb_enum = complex_inner + basis_enum +
  assumes "is_orthonormal": "is_ortho_set (set canonical_basis)"
    and "is_normal": "!!x. x : set canonical_basis ==> norm x = 1"
Found termination order:
  "case_sum (%p. size (fst (snd p)))
    (case_sum (%p. size (snd (snd (snd (snd p)))))
      (%p. size (snd p))) <*mlex*>
   case_sum (%x. Suc 0) (%x. 0) <*mlex*>
   case_sum (%x. 0) (case_sum (%x. Suc 0) (%x. 0)) <*mlex*> {}"
instantiation
  conjugate_space :: (complex_inner) complex_inner
  cinner_conjugate_space == cinner ::
    'a conjugate_space => 'a conjugate_space => complex
consts
  rbt_comp_map_entry :: "'a => ('b => 'b) => ('a, 'b) rbt => ('a, 'b) rbt"
### theory "Complex_Bounded_Operators.Complex_Inner_Product"
### 5.845s elapsed time, 22.002s cpu time, 12.985s GC time
Loading theory "Complex_Bounded_Operators.Complex_Euclidean_Space0" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Complex_Bounded_Operators.Complex_L2" via "Complex_Bounded_Operators.Complex_Bounded_Linear_Function" via "Complex_Bounded_Operators.Complex_Bounded_Linear_Function0")
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
class ceuclidean_space = complex_inner +
  fixes CBasis :: "'a set"
  assumes "nonempty_CBasis": "CBasis ~= {}"
  assumes "finite_CBasis": "finite CBasis"
  assumes
    "cinner_CBasis":
      "!!u v.
          [| u : CBasis; v : CBasis |]
          ==> \<langle>u, v\<rangle> = (if u = v then 1 else 0)"
  assumes
    "ceuclidean_all_zero_iff":
      "!!x. (ALL u:CBasis. \<langle>x, u\<rangle> = 0) = (x = (0::'a))"
locale LinearCombinations.submodule
  fixes R :: "('a, 'b) ring_scheme"
    and N :: "'c set"
    and M :: "('a, 'c, 'd) module_scheme"  (structure)
  assumes "LinearCombinations.submodule R N M"
locale mod_hom
  fixes R :: "('a, 'b) ring_scheme"
    and M :: "('a, 'c, 'd) module_scheme"
    and N :: "('a, 'e, 'f) module_scheme"
    and f :: "'c => 'e"
  assumes "mod_hom R M N f"
instantiation
  complex :: ceuclidean_space
  CBasis_complex == CBasis :: complex set
instantiation
  prod :: (complex_inner, complex_inner) complex_inner
  cinner_prod == cinner :: 'a * 'b => 'a * 'b => complex
instantiation
  prod :: (ceuclidean_space, ceuclidean_space) ceuclidean_space
  CBasis_prod == CBasis :: ('a * 'b) set
### Cannot skip proof of schematic goal statement
### Cannot skip proof of schematic goal statement
### theory "Complex_Bounded_Operators.Complex_Euclidean_Space0"
### 1.802s elapsed time, 7.045s cpu time, 0.953s GC time
Loading theory "Complex_Bounded_Operators.Complex_Bounded_Linear_Function0" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Complex_Bounded_Operators.Complex_L2" via "Complex_Bounded_Operators.Complex_Bounded_Linear_Function")
locale mod_hom
  fixes R :: "('a, 'b) ring_scheme"
    and M :: "('a, 'c, 'd) module_scheme"
    and N :: "('a, 'e, 'f) module_scheme"
    and f :: "'c => 'e"
  assumes "mod_hom R M N f"
instantiation
  cblinfun :: (complex_normed_vector, complex_normed_vector)
    complex_normed_vector
  scaleC_cblinfun == scaleC ::
    complex
    => 'a \<Rightarrow>\<^sub>C\<^sub>L 'b
       => 'a \<Rightarrow>\<^sub>C\<^sub>L 'b
  uminus_cblinfun == uminus ::
    'a \<Rightarrow>\<^sub>C\<^sub>L 'b
    => 'a \<Rightarrow>\<^sub>C\<^sub>L 'b
  zero_cblinfun == zero_class.zero :: 'a \<Rightarrow>\<^sub>C\<^sub>L 'b
  minus_cblinfun == minus ::
    'a \<Rightarrow>\<^sub>C\<^sub>L 'b
    => 'a \<Rightarrow>\<^sub>C\<^sub>L 'b
       => 'a \<Rightarrow>\<^sub>C\<^sub>L 'b
  plus_cblinfun == plus ::
    'a \<Rightarrow>\<^sub>C\<^sub>L 'b
    => 'a \<Rightarrow>\<^sub>C\<^sub>L 'b
       => 'a \<Rightarrow>\<^sub>C\<^sub>L 'b
  sgn_cblinfun == sgn ::
    'a \<Rightarrow>\<^sub>C\<^sub>L 'b
    => 'a \<Rightarrow>\<^sub>C\<^sub>L 'b
  norm_cblinfun == norm :: 'a \<Rightarrow>\<^sub>C\<^sub>L 'b => real
  scaleR_cblinfun == scaleR ::
    real
    => 'a \<Rightarrow>\<^sub>C\<^sub>L 'b
       => 'a \<Rightarrow>\<^sub>C\<^sub>L 'b
  dist_cblinfun == dist ::
    'a \<Rightarrow>\<^sub>C\<^sub>L 'b
    => 'a \<Rightarrow>\<^sub>C\<^sub>L 'b => real
  uniformity_cblinfun == uniformity ::
    ('a \<Rightarrow>\<^sub>C\<^sub>L 'b *
     'a \<Rightarrow>\<^sub>C\<^sub>L 'b) filter
  open_cblinfun == open :: ('a \<Rightarrow>\<^sub>C\<^sub>L 'b) set => bool
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
### theory "Deriving.RBT_Comparator_Impl"
### 9.654s elapsed time, 36.803s cpu time, 15.325s GC time
Loading theory "Containers.RBT_Mapping2" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl" via "Containers.RBT_Set2")
locale bounded_cbilinear
  fixes prod :: "'a => 'b => 'c"  (infixl \<open>**\<close> 70)
  assumes "bounded_cbilinear (**)"
### theory "VectorSpace.LinearCombinations"
### 6.977s elapsed time, 26.636s cpu time, 13.004s GC time
Loading theory "Complex_Bounded_Operators.One_Dimensional_Spaces" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Complex_Bounded_Operators.Complex_L2" via "Complex_Bounded_Operators.Complex_Bounded_Linear_Function")
locale bounded_cbilinear
  fixes prod :: "'a => 'b => 'c"  (infixl \<open>**\<close> 70)
  assumes "bounded_cbilinear (**)"
### Ignoring duplicate rewrite rule:
### (o\<^sub>L) 0 == %_. 0
### Ignoring duplicate rewrite rule:
### ?x1 o\<^sub>L 0 == 0
"(215912063945802350977 / 152672884556058511392,
  1104427674243920646305299201 / 23309009678667569523128057147486993777664,
  True)"
  :: "rat * rat * bool"
Loading theory "VectorSpace.SumSpaces" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Jordan_Normal_Form_Existence" via "Jordan_Normal_Form.Schur_Decomposition" via "Jordan_Normal_Form.Gram_Schmidt" via "Jordan_Normal_Form.VS_Connect" via "Jordan_Normal_Form.Missing_VectorSpace" via "VectorSpace.VectorSpace")
### theory "Complex_Bounded_Operators.Complex_Bounded_Linear_Function0"
### 1.847s elapsed time, 7.161s cpu time, 1.092s GC time
### theory "VectorSpace.SumSpaces"
### 0.473s elapsed time, 1.836s cpu time, 0.260s GC time
Loading theory "VectorSpace.VectorSpace" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Jordan_Normal_Form_Existence" via "Jordan_Normal_Form.Schur_Decomposition" via "Jordan_Normal_Form.Gram_Schmidt" via "Jordan_Normal_Form.VS_Connect" via "Jordan_Normal_Form.Missing_VectorSpace")
### Ambiguous input (line 247 of "$AFP/Containers/RBT_Mapping2.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" lookup)
###       ("_applC" ("_position" meet)
###         ("_cargs" ("_position" f)
###           ("_cargs"
###             ("_constrain" ("_position" t1)
###               ("_tappl" ("_position_sort" 'a) ("_position_sort" 'b)
###                 ("_type_name" mapping_rbt)))
###             ("_position" t2)))))
###     ("_lambda" ("_position" k)
###       ("_case_syntax"
###         ("_applC" ("_position" lookup)
###           ("_cargs" ("_position" t1) ("_position" k)))
###         ("_case2" ("_case1" ("_position" None) ("_position" None))
###           ("_case1" ("_applC" ("_position" Some) ("_position" v1))
###             ("_case_syntax"
###               ("_applC" ("_position" lookup)
###                 ("_cargs" ("_position" t2) ("_position" k)))
###               ("_case2" ("_case1" ("_position" None) ("_position" None))
###                 ("_case1" ("_applC" ("_position" Some) ("_position" v2))
###                   ("_applC" ("_position" Some)
###                     ("_applC" ("_position" f)
###                       ("_cargs" ("_position" k)
###                         ("_cargs" ("_position" v1)
###                           ("_position" v2))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" lookup)
###       ("_applC" ("_position" meet)
###         ("_cargs" ("_position" f)
###           ("_cargs"
###             ("_constrain" ("_position" t1)
###               ("_tappl" ("_position_sort" 'a) ("_position_sort" 'b)
###                 ("_type_name" mapping_rbt)))
###             ("_position" t2)))))
###     ("_lambda" ("_position" k)
###       ("_case_syntax"
###         ("_applC" ("_position" lookup)
###           ("_cargs" ("_position" t1) ("_position" k)))
###         ("_case2" ("_case1" ("_position" None) ("_position" None))
###           ("_case2"
###             ("_case1" ("_applC" ("_position" Some) ("_position" v1))
###               ("_case_syntax"
###                 ("_applC" ("_position" lookup)
###                   ("_cargs" ("_position" t2) ("_position" k)))
###                 ("_case1" ("_position" None) ("_position" None))))
###             ("_case1" ("_applC" ("_position" Some) ("_position" v2))
###               ("_applC" ("_position" Some)
###                 ("_applC" ("_position" f)
###                   ("_cargs" ("_position" k)
###                     ("_cargs" ("_position" v1) ("_position" v2))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "Containers.RBT_Mapping2"
### 1.333s elapsed time, 5.169s cpu time, 0.761s GC time
Loading theory "Containers.RBT_Set2" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl")
locale vectorspace
  fixes K :: "('a, 'b) ring_scheme"
    and V :: "('a, 'c, 'd) module_scheme"
  assumes "vectorspace K V"
locale subspace
  fixes K :: "('a, 'b) ring_scheme"
    and W :: "'c set"
    and V :: "('a, 'c, 'd) module_scheme"  (structure)
  assumes "subspace K W V"
### Ignoring duplicate rewrite rule:
### carrier (vs ?y) == ?y
class one_dim = onb_enum + inverse + one + times +
  assumes "one_dim_canonical_basis": "canonical_basis = [1::'a]"
  assumes
    "one_dim_prod_scale1":
      "!!a b.
          a *\<^sub>C (1::'a) * b *\<^sub>C (1::'a) =
          (a * b) *\<^sub>C (1::'a)"
  assumes "divide_inverse": "!!x y. x / y = x * inverse y"
  assumes
    "one_dim_inverse":
      "!!a. inverse (a *\<^sub>C (1::'a)) = (1::'a) /\<^sub>C a"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
locale linear_map
  fixes K :: "('a, 'b) ring_scheme"
    and V :: "('a, 'c, 'd) module_scheme"
    and W :: "('a, 'e, 'f) module_scheme"
    and T :: "'c => 'e"
  assumes "linear_map K V W T"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
locale linear_map
  fixes K :: "('a, 'b) ring_scheme"
    and V :: "('a, 'c, 'd) module_scheme"
    and W :: "('a, 'e, 'f) module_scheme"
    and T :: "'c => 'e"
  assumes "linear_map K V W T"
### Ignoring duplicate rewrite rule:
### T \<zero>\<^bsub>V\<^esub> == \<zero>\<^bsub>W\<^esub>
### theory "Containers.RBT_Set2"
### 1.712s elapsed time, 6.593s cpu time, 1.377s GC time
Loading theory "Containers.Set_Impl" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl")
"857"
  :: "int"
### theory "Complex_Bounded_Operators.One_Dimensional_Spaces"
### 6.736s elapsed time, 25.791s cpu time, 13.502s GC time
Loading theory "Complex_Bounded_Operators.Complex_Bounded_Linear_Function" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Complex_Bounded_Operators.Complex_L2")
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
instantiation
  blinfun :: (real_normed_vector, complex_normed_vector)
    complex_normed_vector
  scaleC_blinfun == scaleC ::
    complex => 'a \<Rightarrow>\<^sub>L 'b => 'a \<Rightarrow>\<^sub>L 'b
"857"
  :: "int"
instantiation
  blinfun :: (real_normed_vector, cbanach) cbanach
### theory "VectorSpace.VectorSpace"
### 7.184s elapsed time, 27.597s cpu time, 13.642s GC time
Loading theory "Jordan_Normal_Form.Missing_VectorSpace" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Jordan_Normal_Form_Existence" via "Jordan_Normal_Form.Schur_Decomposition" via "Jordan_Normal_Form.Gram_Schmidt" via "Jordan_Normal_Form.VS_Connect")
locale Missing_VectorSpace.comp_fun_commute_on
  fixes f :: "'a => 'a => 'a"
    and A :: "'a set"
  assumes "Missing_VectorSpace.comp_fun_commute_on f A"
locale Missing_VectorSpace.comp_fun_commute_on
  fixes f :: "'a => 'a => 'a"
    and A :: "'a set"
  assumes "Missing_VectorSpace.comp_fun_commute_on f A"
locale abelian_group
  fixes G :: "('a, 'b) ring_scheme"  (structure)
  assumes "abelian_group G"
locale vectorspace
  fixes K :: "('a, 'b) ring_scheme"
    and V :: "('a, 'c, 'd) module_scheme"
  assumes "vectorspace K V"
instantiation
  cblinfun :: (one_dim, one_dim) complex_inner
  cinner_cblinfun == cinner ::
    'a \<Rightarrow>\<^sub>C\<^sub>L 'b
    => 'a \<Rightarrow>\<^sub>C\<^sub>L 'b => complex
instantiation
  cblinfun :: (one_dim, one_dim) one_dim
  one_cblinfun == one_class.one :: 'a \<Rightarrow>\<^sub>C\<^sub>L 'b
  times_cblinfun == times ::
    'a \<Rightarrow>\<^sub>C\<^sub>L 'b
    => 'a \<Rightarrow>\<^sub>C\<^sub>L 'b
       => 'a \<Rightarrow>\<^sub>C\<^sub>L 'b
  inverse_cblinfun == inverse ::
    'a \<Rightarrow>\<^sub>C\<^sub>L 'b
    => 'a \<Rightarrow>\<^sub>C\<^sub>L 'b
  divide_cblinfun == divide ::
    'a \<Rightarrow>\<^sub>C\<^sub>L 'b
    => 'a \<Rightarrow>\<^sub>C\<^sub>L 'b
       => 'a \<Rightarrow>\<^sub>C\<^sub>L 'b
  canonical_basis_cblinfun == canonical_basis ::
    ('a \<Rightarrow>\<^sub>C\<^sub>L 'b) list
"False"
  :: "bool"
instantiation
  cblinfun :: (chilbert_space, chilbert_space) ord
  less_eq_cblinfun == less_eq ::
    'a \<Rightarrow>\<^sub>C\<^sub>L 'b
    => 'a \<Rightarrow>\<^sub>C\<^sub>L 'b => bool
  less_cblinfun == less ::
    'a \<Rightarrow>\<^sub>C\<^sub>L 'b
    => 'a \<Rightarrow>\<^sub>C\<^sub>L 'b => bool
instantiation
  cblinfun :: (chilbert_space, chilbert_space) ordered_complex_vector
locale module
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and M :: "('a, 'c, 'd) module_scheme"  (structure)
  assumes "module R M"
bundle cblinfun_notation
bundle no_cblinfun_notation
locale linear_map
  fixes K :: "('a, 'b) ring_scheme"
    and V :: "('a, 'c, 'd) module_scheme"
    and W :: "('a, 'e, 'f) module_scheme"
    and T :: "'c => 'e"
  assumes "linear_map K V W T"
"True"
  :: "bool"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
locale abelian_monoid
  fixes G :: "('a, 'b) ring_scheme"  (structure)
  assumes "abelian_monoid G"
bundle blinfun_notation
bundle no_blinfun_notation
locale module
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and M :: "('a, 'c, 'd) module_scheme"  (structure)
  assumes "module R M"
### theory "Jordan_Normal_Form.Missing_VectorSpace"
### 2.619s elapsed time, 10.255s cpu time, 1.569s GC time
Loading theory "Jordan_Normal_Form.VS_Connect" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Jordan_Normal_Form_Existence" via "Jordan_Normal_Form.Schur_Decomposition" via "Jordan_Normal_Form.Gram_Schmidt")
### theory "Complex_Bounded_Operators.Complex_Bounded_Linear_Function"
### 4.331s elapsed time, 16.966s cpu time, 2.563s GC time
Loading theory "Complex_Bounded_Operators.Complex_L2" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum")
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
"(False, True)"
  :: "bool * bool"
"- \<infinity>"
  :: "ereal"
instantiation
  ell2 :: (type) complex_vector
  scaleC_ell2 == scaleC :: complex => 'a ell2 => 'a ell2
  uminus_ell2 == uminus :: 'a ell2 => 'a ell2
  zero_ell2 == zero_class.zero :: 'a ell2
  minus_ell2 == minus :: 'a ell2 => 'a ell2 => 'a ell2
  plus_ell2 == plus :: 'a ell2 => 'a ell2 => 'a ell2
  scaleR_ell2 == scaleR :: real => 'a ell2 => 'a ell2
"\<infinity>"
  :: "ereal"
Found termination order: "length <*mlex*> {}"
instantiation
  ell2 :: (type) complex_normed_vector
  sgn_ell2 == sgn :: 'a ell2 => 'a ell2
  norm_ell2 == norm :: 'a ell2 => real
  dist_ell2 == dist :: 'a ell2 => 'a ell2 => real
  uniformity_ell2 == uniformity :: ('a ell2 * 'a ell2) filter
  open_ell2 == open :: 'a ell2 set => bool
### Cannot skip proof of schematic goal statement
instantiation
  ell2 :: (type) complex_inner
  cinner_ell2 == cinner :: 'a ell2 => 'a ell2 => complex
instantiation
  ell2 :: (CARD_1) complex_algebra_1
  one_ell2 == one_class.one :: 'a ell2
  times_ell2 == times :: 'a ell2 => 'a ell2 => 'a ell2
"ereal (13 / 4)"
  :: "ereal"
"True"
  :: "bool"
instantiation
  ell2 :: (CARD_1) field
  inverse_ell2 == inverse :: 'a ell2 => 'a ell2
  divide_ell2 == divide :: 'a ell2 => 'a ell2 => 'a ell2
"True"
  :: "bool"
inj_on ?h ?A ==> (?g summable_on ?h ` ?A) = (?g o ?h summable_on ?A)
uniformity =
filtermap (%((x1, x2), y1, y2). ((x1, y1), x2, y2))
 (uniformity \<times>\<^sub>F uniformity)
?a : affine hull ?S ==> aff_dim ?S = int (dim ((+) (- ?a) ` ?S))
?x ~= (0::?'a) ==>
(norm has_derivative (%h. Re (cinner (sgn ?x) h))) (at ?x)
0 = \<bottom>
### Cannot skip proof of schematic goal statement
*** Undefined fact: "False" (line 2479 of "$AFP/Complex_Bounded_Operators/Complex_Bounded_Linear_Function.thy")12FalseEfactHOL.FalseEFalse_deffactHOL.False_defFalse_imp_not_eventuallyfactFilter.False_imp_not_eventuallyFalse_implies_equalsfactHOL.False_implies_equalsFalse_neq_TruefactHOL.False_neq_TrueFalse_not_TruefactHOL.False_not_TrueFilter.False_imp_not_eventuallyfactFilter.False_imp_not_eventuallyHOL.FalseEfactHOL.FalseEHOL.False_deffactHOL.False_defHOL.False_implies_equalsfactHOL.False_implies_equalsHOL.False_neq_TruefactHOL.False_neq_TrueHOL.False_not_TruefactHOL.False_not_True
*** At command "thm" (line 2479 of "$AFP/Complex_Bounded_Operators/Complex_Bounded_Linear_Function.thy")
instantiation
  ell2 :: (enum) onb_enum
  canonical_basis_ell2 == canonical_basis :: 'a ell2 list
instantiation
  ell2 :: ({CARD_1,enum}) one_dim
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
### Cannot skip proof of schematic goal statement
structure Set_Complement_Eqs: NAMED_THMS
### Cannot skip proof of schematic goal statement
locale matrix_ring
  fixes n :: "nat"
    and field_type :: "'a itself"
### theory "Complex_Bounded_Operators.Complex_L2"
### 1.958s elapsed time, 7.659s cpu time, 1.168s GC time
locale vec_module
  fixes f_ty :: "'a itself"
    and n :: "nat"
### Code generator: dropping subsumed code equation
### Collect ?P == set (filter ?P enum_class.enum)
### Cannot skip proof of schematic goal statement
### Ambiguous input (line 739 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Set.union" ("_applC" ("_position" RBT_set) ("_position" rbt))
###       ("_applC" ("_position" DList_set) ("_position" dxs)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''union RBT_set DList_set: ccompare = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Set.union"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt))
###                   ("_applC" ("_position" DList_set) ("_position" dxs)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'b)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position" ''union RBT_set DList_set: ceq = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Set.union"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs)))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_applC" ("_position" RBT_set)
###                   ("_applC" ("_position" DList_Set.fold)
###                     ("_cargs" ("_position" RBT_Set2.insert)
###                       ("_cargs" ("_position" dxs)
###                         ("_position" rbt)))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Set.union" ("_applC" ("_position" RBT_set) ("_position" rbt))
###       ("_applC" ("_position" DList_set) ("_position" dxs)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''union RBT_set DList_set: ccompare = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Set.union"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt))
###                   ("_applC" ("_position" DList_set) ("_position" dxs)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'b)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position" ''union RBT_set DList_set: ceq = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Set.union"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs)))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_applC" ("_position" RBT_set)
###               ("_applC" ("_position" DList_Set.fold)
###                 ("_cargs" ("_position" RBT_Set2.insert)
###                   ("_cargs" ("_position" dxs) ("_position" rbt)))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 744 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Set.union"
###       ("_applC" ("_position" DList_set) ("_position" dxs))
###       ("_applC" ("_position" RBT_set) ("_position" rbt)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''union DList_set RBT_set: ccompare = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Set.union"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt))
###                   ("_applC" ("_position" DList_set) ("_position" dxs)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'b)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position" ''union DList_set RBT_set: ceq = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Set.union"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs)))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_applC" ("_position" RBT_set)
###                   ("_applC" ("_position" DList_Set.fold)
###                     ("_cargs" ("_position" RBT_Set2.insert)
###                       ("_cargs" ("_position" dxs)
###                         ("_position" rbt)))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Set.union"
###       ("_applC" ("_position" DList_set) ("_position" dxs))
###       ("_applC" ("_position" RBT_set) ("_position" rbt)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''union DList_set RBT_set: ccompare = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Set.union"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt))
###                   ("_applC" ("_position" DList_set) ("_position" dxs)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'b)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position" ''union DList_set RBT_set: ceq = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Set.union"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs)))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_applC" ("_position" RBT_set)
###               ("_applC" ("_position" DList_Set.fold)
###                 ("_cargs" ("_position" RBT_Set2.insert)
###                   ("_cargs" ("_position" dxs) ("_position" rbt)))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
locale matrix_vs
  fixes nr :: "nat"
    and nc :: "nat"
    and field_type :: "'a itself"
### Cannot skip proof of schematic goal statement
### Ambiguous input (line 823 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Set.inter"
###       ("_applC" ("_position" DList_set) ("_position" dxs))
###       ("_applC" ("_position" RBT_set) ("_position" rbt)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''inter DList_set RBT_set: ccompare = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Set.inter"
###                   ("_applC" ("_position" DList_set) ("_position" dxs))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'b)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position" ''inter DList_set RBT_set: ceq = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Set.inter"
###                         ("_applC" ("_position" DList_set) ("_position" dxs))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt)))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_applC" ("_position" RBT_set)
###                   ("_applC" ("_position" RBT_Set2.inter_list)
###                     ("_cargs" ("_position" rbt)
###                       ("_applC" ("_position" list_of_dlist)
###                         ("_position" dxs)))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Set.inter"
###       ("_applC" ("_position" DList_set) ("_position" dxs))
###       ("_applC" ("_position" RBT_set) ("_position" rbt)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''inter DList_set RBT_set: ccompare = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Set.inter"
###                   ("_applC" ("_position" DList_set) ("_position" dxs))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'b)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position" ''inter DList_set RBT_set: ceq = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Set.inter"
###                         ("_applC" ("_position" DList_set) ("_position" dxs))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt)))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_applC" ("_position" RBT_set)
###               ("_applC" ("_position" RBT_Set2.inter_list)
###                 ("_cargs" ("_position" rbt)
###                   ("_applC" ("_position" list_of_dlist)
###                     ("_position" dxs)))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 838 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Set.inter" ("_applC" ("_position" RBT_set) ("_position" rbt))
###       ("_applC" ("_position" DList_set) ("_position" dxs)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''inter RBT_set DList_set: ccompare = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Set.inter"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt))
###                   ("_applC" ("_position" DList_set) ("_position" dxs)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'b)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position" ''inter RBT_set DList_set: ceq = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Set.inter"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs)))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_applC" ("_position" RBT_set)
###                   ("_applC" ("_position" RBT_Set2.inter_list)
###                     ("_cargs" ("_position" rbt)
###                       ("_applC" ("_position" list_of_dlist)
###                         ("_position" dxs)))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Set.inter" ("_applC" ("_position" RBT_set) ("_position" rbt))
###       ("_applC" ("_position" DList_set) ("_position" dxs)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''inter RBT_set DList_set: ccompare = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Set.inter"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt))
###                   ("_applC" ("_position" DList_set) ("_position" dxs)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'b)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position" ''inter RBT_set DList_set: ceq = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Set.inter"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs)))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_applC" ("_position" RBT_set)
###               ("_applC" ("_position" RBT_Set2.inter_list)
###                 ("_cargs" ("_position" rbt)
###                   ("_applC" ("_position" list_of_dlist)
###                     ("_position" dxs)))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Code generator: dropping subsumed code equation
### Inf ?A ?x == INF f\<in>?A. f ?x
### Code generator: dropping subsumed code equation
### Sup ?A ?x == SUP f\<in>?A. f ?x
### Ambiguous input (line 951 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" csorted_list_of_set)
###       ("_applC" ("_position" DList_set) ("_position" dxs)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'b)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''csorted_list_of_set DList_set: ceq = None''))
###               ("_lambda" ("_idtdummy")
###                 ("_applC" ("_position" csorted_list_of_set)
###                   ("_applC" ("_position" DList_set) ("_position" dxs)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''csorted_list_of_set DList_set: ccompare = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("_applC" ("_position" csorted_list_of_set)
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs)))))))
###               ("_case1" ("_applC" ("_position" Some) ("_position" c))
###                 ("_applC" ("_position" ord.quicksort)
###                   ("_cargs"
###                     ("_applC" ("_position" lt_of_comp) ("_position" c))
###                     ("_applC" ("_position" list_of_dlist)
###                       ("_position" dxs))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" csorted_list_of_set)
###       ("_applC" ("_position" DList_set) ("_position" dxs)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'b)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''csorted_list_of_set DList_set: ceq = None''))
###               ("_lambda" ("_idtdummy")
###                 ("_applC" ("_position" csorted_list_of_set)
###                   ("_applC" ("_position" DList_set) ("_position" dxs)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'b)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''csorted_list_of_set DList_set: ccompare = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("_applC" ("_position" csorted_list_of_set)
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs)))))))))
###           ("_case1" ("_applC" ("_position" Some) ("_position" c))
###             ("_applC" ("_position" ord.quicksort)
###               ("_cargs" ("_applC" ("_position" lt_of_comp) ("_position" c))
###                 ("_applC" ("_position" list_of_dlist)
###                   ("_position" dxs))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
locale vec_space
  fixes f_ty :: "'a itself"
    and n :: "nat"
### Cannot skip proof of schematic goal statement
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
locale mat_space
  fixes f_ty :: "'a itself"
    and nc :: "nat"
    and nr :: "nat"
Found termination order: "(%p. length (snd (snd p))) <*mlex*> {}"
locale vec_space
  fixes f_ty :: "'a itself"
    and n :: "nat"
locale vec_module
  fixes f_ty :: "'a itself"
    and n :: "nat"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
locale idom_vec
  fixes n :: "nat"
    and f_ty :: "'a itself"
### Code generator: dropping subsumed code equation
### set_eq ?A ?B == ?A <= ?B & ?B <= ?A
### Ambiguous input (line 1326 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" the_elem)
###       ("_applC" ("_position" DList_set) ("_position" dxs)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal" ("_position" ''the_elem DList_set: ceq = None''))
###               ("_lambda" ("_idtdummy")
###                 ("_applC" ("_position" the_elem)
###                   ("_applC" ("_position" DList_set) ("_position" dxs)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" list_of_dlist) ("_position" dxs))
###             ("_case2" ("_case1" ("_list" ("_position" x)) ("_position" x))
###               ("_case1" ("\<^const>Pure.dummy_pattern")
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position" ''the_elem DList_set: not unique''))
###                     ("_lambda" ("_idtdummy")
###                       ("_applC" ("_position" the_elem)
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" the_elem)
###       ("_applC" ("_position" DList_set) ("_position" dxs)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal" ("_position" ''the_elem DList_set: ceq = None''))
###               ("_lambda" ("_idtdummy")
###                 ("_applC" ("_position" the_elem)
###                   ("_applC" ("_position" DList_set) ("_position" dxs)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" list_of_dlist) ("_position" dxs))
###               ("_case1" ("_list" ("_position" x)) ("_position" x))))
###           ("_case1" ("\<^const>Pure.dummy_pattern")
###             ("_applC" ("_position" Code.abort)
###               ("_cargs"
###                 ("_Literal"
###                   ("_position" ''the_elem DList_set: not unique''))
###                 ("_lambda" ("_idtdummy")
###                   ("_applC" ("_position" the_elem)
###                     ("_applC" ("_position" DList_set)
###                       ("_position" dxs))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1331 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" the_elem)
###       ("_applC" ("_position" RBT_set) ("_position" rbt)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''the_elem RBT_set: ccompare = None''))
###               ("_lambda" ("_idtdummy")
###                 ("_applC" ("_position" the_elem)
###                   ("_applC" ("_position" RBT_set) ("_position" rbt)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" RBT_Mapping2.impl_of) ("_position" rbt))
###             ("_case2"
###               ("_case1"
###                 ("_applC" ("_position" RBT_Impl.Branch)
###                   ("_cargs" ("\<^const>Pure.dummy_pattern")
###                     ("_cargs" ("_position" RBT_Impl.Empty)
###                       ("_cargs" ("_position" x)
###                         ("_cargs" ("\<^const>Pure.dummy_pattern")
###                           ("_position" RBT_Impl.Empty))))))
###                 ("_position" x))
###               ("_case1" ("\<^const>Pure.dummy_pattern")
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position" ''the_elem RBT_set: not unique''))
###                     ("_lambda" ("_idtdummy")
###                       ("_applC" ("_position" the_elem)
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" the_elem)
###       ("_applC" ("_position" RBT_set) ("_position" rbt)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''the_elem RBT_set: ccompare = None''))
###               ("_lambda" ("_idtdummy")
###                 ("_applC" ("_position" the_elem)
###                   ("_applC" ("_position" RBT_set) ("_position" rbt)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" RBT_Mapping2.impl_of)
###                 ("_position" rbt))
###               ("_case1"
###                 ("_applC" ("_position" RBT_Impl.Branch)
###                   ("_cargs" ("\<^const>Pure.dummy_pattern")
###                     ("_cargs" ("_position" RBT_Impl.Empty)
###                       ("_cargs" ("_position" x)
###                         ("_cargs" ("\<^const>Pure.dummy_pattern")
###                           ("_position" RBT_Impl.Empty))))))
###                 ("_position" x))))
###           ("_case1" ("\<^const>Pure.dummy_pattern")
###             ("_applC" ("_position" Code.abort)
###               ("_cargs"
###                 ("_Literal" ("_position" ''the_elem RBT_set: not unique''))
###                 ("_lambda" ("_idtdummy")
###                   ("_applC" ("_position" the_elem)
###                     ("_applC" ("_position" RBT_set)
###                       ("_position" rbt))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1387 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" Product_Type.product)
###       ("_cargs" ("_applC" ("_position" DList_set) ("_position" dxs))
###         ("_applC" ("_position" DList_set) ("_position" dys))))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''product DList_set DList_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("_applC" ("_position" Product_Type.product)
###                   ("_cargs"
###                     ("_applC" ("_position" DList_set) ("_position" dxs))
###                     ("_applC" ("_position" DList_set)
###                       ("_position" dys))))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'b)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''product DList_set DList_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("_applC" ("_position" Product_Type.product)
###                         ("_cargs"
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs))
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dys))))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_applC" ("_position" DList_set)
###                   ("_applC" ("_position" DList_Set.product)
###                     ("_cargs" ("_position" dxs) ("_position" dys))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" Product_Type.product)
###       ("_cargs" ("_applC" ("_position" DList_set) ("_position" dxs))
###         ("_applC" ("_position" DList_set) ("_position" dys))))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''product DList_set DList_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("_applC" ("_position" Product_Type.product)
###                   ("_cargs"
###                     ("_applC" ("_position" DList_set) ("_position" dxs))
###                     ("_applC" ("_position" DList_set)
###                       ("_position" dys))))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'b)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''product DList_set DList_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("_applC" ("_position" Product_Type.product)
###                         ("_cargs"
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs))
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dys))))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_applC" ("_position" DList_set)
###               ("_applC" ("_position" DList_Set.product)
###                 ("_cargs" ("_position" dxs) ("_position" dys))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1403 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" Product_Type.product)
###       ("_cargs" ("_applC" ("_position" RBT_set) ("_position" rbt1))
###         ("_applC" ("_position" RBT_set) ("_position" rbt2))))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'c)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''product RBT_set RBT_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("_applC" ("_position" Product_Type.product)
###                   ("_cargs"
###                     ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                     ("_applC" ("_position" RBT_set)
###                       ("_position" rbt2))))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'd)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''product RBT_set RBT_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("_applC" ("_position" Product_Type.product)
###                         ("_cargs"
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt1))
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt2))))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_applC" ("_position" RBT_set)
###                   ("_applC" ("_position" RBT_Set2.product)
###                     ("_cargs" ("_position" rbt1)
###                       ("_position" rbt2))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" Product_Type.product)
###       ("_cargs" ("_applC" ("_position" RBT_set) ("_position" rbt1))
###         ("_applC" ("_position" RBT_set) ("_position" rbt2))))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'c)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''product RBT_set RBT_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("_applC" ("_position" Product_Type.product)
###                   ("_cargs"
###                     ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                     ("_applC" ("_position" RBT_set)
###                       ("_position" rbt2))))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'd)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''product RBT_set RBT_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("_applC" ("_position" Product_Type.product)
###                         ("_cargs"
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt1))
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt2))))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_applC" ("_position" RBT_set)
###               ("_applC" ("_position" RBT_Set2.product)
###                 ("_cargs" ("_position" rbt1) ("_position" rbt2))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1470 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.Image"
###       ("_applC" ("_position" DList_set) ("_position" dxs)) ("_position" B))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal" ("_position" ''Image DList_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.Image"
###                   ("_applC" ("_position" DList_set) ("_position" dxs))
###                   ("_position" B))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'b)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position" ''Image DList_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.Image"
###                         ("_applC" ("_position" DList_set) ("_position" dxs))
###                         ("_position" B))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_applC" ("_position" DList_Set.fold)
###                   ("_cargs"
###                     ("_lambda"
###                       ("_pttrns"
###                         ("_pattern" ("_position" x) ("_position" y))
###                         ("_position" acc))
###                       ("\<^const>HOL.If"
###                         ("\<^const>Set.member" ("_position" x)
###                           ("_position" B))
###                         ("_applC" ("_position" insert)
###                           ("_cargs" ("_position" y) ("_position" acc)))
###                         ("_position" acc)))
###                     ("_cargs" ("_position" dxs)
###                       ("\<^const>Set.empty"))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.Image"
###       ("_applC" ("_position" DList_set) ("_position" dxs)) ("_position" B))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal" ("_position" ''Image DList_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.Image"
###                   ("_applC" ("_position" DList_set) ("_position" dxs))
###                   ("_position" B))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'b)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position" ''Image DList_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.Image"
###                         ("_applC" ("_position" DList_set) ("_position" dxs))
###                         ("_position" B))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_applC" ("_position" DList_Set.fold)
###               ("_cargs"
###                 ("_lambda"
###                   ("_pttrns" ("_pattern" ("_position" x) ("_position" y))
###                     ("_position" acc))
###                   ("\<^const>HOL.If"
###                     ("\<^const>Set.member" ("_position" x) ("_position" B))
###                     ("_applC" ("_position" insert)
###                       ("_cargs" ("_position" y) ("_position" acc)))
###                     ("_position" acc)))
###                 ("_cargs" ("_position" dxs) ("\<^const>Set.empty"))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1477 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.Image"
###       ("_applC" ("_position" RBT_set) ("_position" rbt)) ("_position" C))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'c)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal" ("_position" ''Image RBT_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.Image"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt))
###                   ("_position" C))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'd)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position" ''Image RBT_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.Image"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt))
###                         ("_position" C))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_applC" ("_position" RBT_Set2.fold)
###                   ("_cargs"
###                     ("_lambda"
###                       ("_pttrns"
###                         ("_pattern" ("_position" x) ("_position" y))
###                         ("_position" acc))
###                       ("\<^const>HOL.If"
###                         ("\<^const>Set.member" ("_position" x)
###                           ("_position" C))
###                         ("_applC" ("_position" insert)
###                           ("_cargs" ("_position" y) ("_position" acc)))
###                         ("_position" acc)))
###                     ("_cargs" ("_position" rbt)
###                       ("\<^const>Set.empty"))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.Image"
###       ("_applC" ("_position" RBT_set) ("_position" rbt)) ("_position" C))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'c)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal" ("_position" ''Image RBT_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.Image"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt))
###                   ("_position" C))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'd)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position" ''Image RBT_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.Image"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt))
###                         ("_position" C))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_applC" ("_position" RBT_Set2.fold)
###               ("_cargs"
###                 ("_lambda"
###                   ("_pttrns" ("_pattern" ("_position" x) ("_position" y))
###                     ("_position" acc))
###                   ("\<^const>HOL.If"
###                     ("\<^const>Set.member" ("_position" x) ("_position" C))
###                     ("_applC" ("_position" insert)
###                       ("_cargs" ("_position" y) ("_position" acc)))
###                     ("_position" acc)))
###                 ("_cargs" ("_position" rbt) ("\<^const>Set.empty"))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
locale vec_space
  fixes f_ty :: "'a itself"
    and n :: "nat"
### Ambiguous input (line 1546 of "$AFP/Containers/Set_Impl.thy") produces 5 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt1))
###       ("_applC" ("_position" RBT_set) ("_position" rbt2)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp RBT_set RBT_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt2)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp RBT_set RBT_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt2)))))))
###               ("_case1" ("_applC" ("_position" Some) ("_position" c_b))
###                 ("_case_syntax"
###                   ("_applC" ("_position" ID)
###                     ("_CCOMPARE" ("_position_sort" 'c)))
###                   ("_case2"
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp RBT_set RBT_set: ccompare3 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt1))
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt2)))))))
###                     ("_case1"
###                       ("_applC" ("_position" Some)
###                         ("\<^const>Pure.dummy_pattern"))
###                       ("_applC" ("_position" RBT_Set2.fold)
###                         ("_cargs"
###                           ("_lambda"
###                             ("_pattern" ("_position" x) ("_position" y))
###                             ("_applC" ("_position" RBT_Set2.fold)
###                               ("_cargs"
###                                 ("_lambda"
###                                   ("_pttrns"
###                                     ("_pattern" ("_position" y')
### ("_position" z))
###                                     ("_position" A))
###                                   ("\<^const>HOL.If"
###                                     ("\<^const>HOL.not_equal"
### ("_applC" ("_position" c_b) ("_cargs" ("_position" y) ("_position" y')))
### ("_position" Eq))
###                                     ("_position" A)
###                                     ("_applC" ("_position" insert)
### ("_cargs" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z)))
###   ("_position" A)))))
###                                 ("_position" rbt2))))
###                           ("_cargs" ("_position" rbt1)
###                             ("\<^const>Set.empty")))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt1))
###       ("_applC" ("_position" RBT_set) ("_position" rbt2)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp RBT_set RBT_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt2)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'b)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp RBT_set RBT_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt2)))))))))
###           ("_case1" ("_applC" ("_position" Some) ("_position" c_b))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'c)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp RBT_set RBT_set: ccompare3 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt1))
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt2)))))))
###                 ("_case1"
###                   ("_applC" ("_position" Some)
###                     ("\<^const>Pure.dummy_pattern"))
###                   ("_applC" ("_position" RBT_Set2.fold)
###                     ("_cargs"
###                       ("_lambda"
###                         ("_pattern" ("_position" x) ("_position" y))
###                         ("_applC" ("_position" RBT_Set2.fold)
###                           ("_cargs"
###                             ("_lambda"
###                               ("_pttrns"
###                                 ("_pattern" ("_position" y')
###                                   ("_position" z))
###                                 ("_position" A))
###                               ("\<^const>HOL.If"
###                                 ("\<^const>HOL.not_equal"
###                                   ("_applC" ("_position" c_b)
###                                     ("_cargs" ("_position" y)
### ("_position" y')))
###                                   ("_position" Eq))
###                                 ("_position" A)
###                                 ("_applC" ("_position" insert)
###                                   ("_cargs"
###                                     ("_tuple" ("_position" x)
### ("_tuple_arg" ("_position" z)))
###                                     ("_position" A)))))
###                             ("_position" rbt2))))
###                       ("_cargs" ("_position" rbt1)
###                         ("\<^const>Set.empty")))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt1))
###       ("_applC" ("_position" RBT_set) ("_position" rbt2)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp RBT_set RBT_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt2)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp RBT_set RBT_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt2)))))))
###               ("_case2"
###                 ("_case1" ("_applC" ("_position" Some) ("_position" c_b))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CCOMPARE" ("_position_sort" 'c)))
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp RBT_set RBT_set: ccompare3 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt1))
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt2)))))))))
###                 ("_case1"
###                   ("_applC" ("_position" Some)
###                     ("\<^const>Pure.dummy_pattern"))
###                   ("_applC" ("_position" RBT_Set2.fold)
###                     ("_cargs"
###                       ("_lambda"
###                         ("_pattern" ("_position" x) ("_position" y))
###                         ("_applC" ("_position" RBT_Set2.fold)
###                           ("_cargs"
###                             ("_lambda"
###                               ("_pttrns"
###                                 ("_pattern" ("_position" y')
###                                   ("_position" z))
###                                 ("_position" A))
###                               ("\<^const>HOL.If"
###                                 ("\<^const>HOL.not_equal"
###                                   ("_applC" ("_position" c_b)
###                                     ("_cargs" ("_position" y)
### ("_position" y')))
###                                   ("_position" Eq))
###                                 ("_position" A)
###                                 ("_applC" ("_position" insert)
###                                   ("_cargs"
###                                     ("_tuple" ("_position" x)
### ("_tuple_arg" ("_position" z)))
###                                     ("_position" A)))))
###                             ("_position" rbt2))))
###                       ("_cargs" ("_position" rbt1)
###                         ("\<^const>Set.empty")))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt1))
###       ("_applC" ("_position" RBT_set) ("_position" rbt2)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp RBT_set RBT_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt2)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'b)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp RBT_set RBT_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt2)))))))))
###           ("_case2"
###             ("_case1" ("_applC" ("_position" Some) ("_position" c_b))
###               ("_case_syntax"
###                 ("_applC" ("_position" ID)
###                   ("_CCOMPARE" ("_position_sort" 'c)))
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp RBT_set RBT_set: ccompare3 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt1))
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt2)))))))))
###             ("_case1"
###               ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###               ("_applC" ("_position" RBT_Set2.fold)
###                 ("_cargs"
###                   ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                     ("_applC" ("_position" RBT_Set2.fold)
###                       ("_cargs"
###                         ("_lambda"
###                           ("_pttrns"
###                             ("_pattern" ("_position" y') ("_position" z))
###                             ("_position" A))
###                           ("\<^const>HOL.If"
###                             ("\<^const>HOL.not_equal"
###                               ("_applC" ("_position" c_b)
###                                 ("_cargs" ("_position" y) ("_position" y')))
###                               ("_position" Eq))
###                             ("_position" A)
###                             ("_applC" ("_position" insert)
###                               ("_cargs"
###                                 ("_tuple" ("_position" x)
###                                   ("_tuple_arg" ("_position" z)))
###                                 ("_position" A)))))
###                         ("_position" rbt2))))
###                   ("_cargs" ("_position" rbt1)
###                     ("\<^const>Set.empty")))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt1))
###       ("_applC" ("_position" RBT_set) ("_position" rbt2)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp RBT_set RBT_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt2)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'b)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp RBT_set RBT_set: ccompare2 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt1))
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt2)))))))
###                 ("_case1" ("_applC" ("_position" Some) ("_position" c_b))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CCOMPARE" ("_position_sort" 'c)))
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp RBT_set RBT_set: ccompare3 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt1))
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt2))))))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_applC" ("_position" RBT_Set2.fold)
###               ("_cargs"
###                 ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                   ("_applC" ("_position" RBT_Set2.fold)
###                     ("_cargs"
###                       ("_lambda"
###                         ("_pttrns"
###                           ("_pattern" ("_position" y') ("_position" z))
###                           ("_position" A))
###                         ("\<^const>HOL.If"
###                           ("\<^const>HOL.not_equal"
###                             ("_applC" ("_position" c_b)
###                               ("_cargs" ("_position" y) ("_position" y')))
###                             ("_position" Eq))
###                           ("_position" A)
###                           ("_applC" ("_position" insert)
###                             ("_cargs"
###                               ("_tuple" ("_position" x)
###                                 ("_tuple_arg" ("_position" z)))
###                               ("_position" A)))))
###                       ("_position" rbt2))))
###                 ("_cargs" ("_position" rbt1) ("\<^const>Set.empty"))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1555 of "$AFP/Containers/Set_Impl.thy") produces 14 parse trees (10 displayed):
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt3))
###       ("_applC" ("_position" DList_set) ("_position" dxs1)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position"
###                   ''relcomp RBT_set DList_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs1)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'd)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp RBT_set DList_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs1)))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_case_syntax"
###                   ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'd)))
###                   ("_case2"
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp RBT_set DList_set: ceq2 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt3))
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs1)))))))
###                     ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                       ("_case_syntax"
###                         ("_applC" ("_position" ID)
###                           ("_CEQ" ("_position_sort" 'e)))
###                         ("_case2"
###                           ("_case1" ("_position" None)
###                             ("_applC" ("_position" Code.abort)
###                               ("_cargs"
###                                 ("_Literal"
###                                   ("_position"
###                                     ''relcomp RBT_set DList_set: ceq3 = None''))
###                                 ("_lambda" ("_idtdummy")
###                                   ("\<^const>Relation.relcomp"
###                                     ("_applC" ("_position" RBT_set)
### ("_position" rbt3))
###                                     ("_applC" ("_position" DList_set)
### ("_position" dxs1)))))))
###                           ("_case1"
###                             ("_applC" ("_position" Some)
###                               ("\<^const>Pure.dummy_pattern"))
###                             ("_applC" ("_position" RBT_Set2.fold)
###                               ("_cargs"
###                                 ("_lambda"
###                                   ("_pattern" ("_position" x)
###                                     ("_position" y))
###                                   ("_applC" ("_position" DList_Set.fold)
###                                     ("_cargs"
### ("_lambda"
###   ("_pttrns" ("_pattern" ("_position" y') ("_position" z)) ("_position" A))
###   ("\<^const>HOL.If"
###     ("_applC" ("_position" eq) ("_cargs" ("_position" y) ("_position" y')))
###     ("_applC" ("_position" insert)
###       ("_cargs" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z)))
###         ("_position" A)))
###     ("_position" A)))
### ("_position" dxs1))))
###                                 ("_cargs" ("_position" rbt3)
###                                   ("\<^const>Set.empty"))))))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt3))
###       ("_applC" ("_position" DList_set) ("_position" dxs1)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position"
###                   ''relcomp RBT_set DList_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs1)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'd)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp RBT_set DList_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs1)))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'd)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp RBT_set DList_set: ceq2 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt3))
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs1)))))))
###                 ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CEQ" ("_position_sort" 'e)))
###                     ("_case2"
###                       ("_case1" ("_position" None)
###                         ("_applC" ("_position" Code.abort)
###                           ("_cargs"
###                             ("_Literal"
###                               ("_position"
###                                 ''relcomp RBT_set DList_set: ceq3 = None''))
###                             ("_lambda" ("_idtdummy")
###                               ("\<^const>Relation.relcomp"
###                                 ("_applC" ("_position" RBT_set)
###                                   ("_position" rbt3))
###                                 ("_applC" ("_position" DList_set)
###                                   ("_position" dxs1)))))))
###                       ("_case1"
###                         ("_applC" ("_position" Some)
###                           ("\<^const>Pure.dummy_pattern"))
###                         ("_applC" ("_position" RBT_Set2.fold)
###                           ("_cargs"
###                             ("_lambda"
###                               ("_pattern" ("_position" x) ("_position" y))
###                               ("_applC" ("_position" DList_Set.fold)
###                                 ("_cargs"
###                                   ("_lambda"
###                                     ("_pttrns"
### ("_pattern" ("_position" y') ("_position" z)) ("_position" A))
###                                     ("\<^const>HOL.If"
### ("_applC" ("_position" eq) ("_cargs" ("_position" y) ("_position" y')))
### ("_applC" ("_position" insert)
###   ("_cargs" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z)))
###     ("_position" A)))
### ("_position" A)))
###                                   ("_position" dxs1))))
###                             ("_cargs" ("_position" rbt3)
###                               ("\<^const>Set.empty"))))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt3))
###       ("_applC" ("_position" DList_set) ("_position" dxs1)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position"
###                   ''relcomp RBT_set DList_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs1)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'd)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp RBT_set DList_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs1)))))))
###               ("_case2"
###                 ("_case1"
###                   ("_applC" ("_position" Some)
###                     ("\<^const>Pure.dummy_pattern"))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CEQ" ("_position_sort" 'd)))
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp RBT_set DList_set: ceq2 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt3))
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs1)))))))))
###                 ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CEQ" ("_position_sort" 'e)))
###                     ("_case2"
###                       ("_case1" ("_position" None)
###                         ("_applC" ("_position" Code.abort)
###                           ("_cargs"
###                             ("_Literal"
###                               ("_position"
###                                 ''relcomp RBT_set DList_set: ceq3 = None''))
###                             ("_lambda" ("_idtdummy")
###                               ("\<^const>Relation.relcomp"
###                                 ("_applC" ("_position" RBT_set)
###                                   ("_position" rbt3))
###                                 ("_applC" ("_position" DList_set)
###                                   ("_position" dxs1)))))))
###                       ("_case1"
###                         ("_applC" ("_position" Some)
###                           ("\<^const>Pure.dummy_pattern"))
###                         ("_applC" ("_position" RBT_Set2.fold)
###                           ("_cargs"
###                             ("_lambda"
###                               ("_pattern" ("_position" x) ("_position" y))
###                               ("_applC" ("_position" DList_Set.fold)
###                                 ("_cargs"
###                                   ("_lambda"
###                                     ("_pttrns"
### ("_pattern" ("_position" y') ("_position" z)) ("_position" A))
###                                     ("\<^const>HOL.If"
### ("_applC" ("_position" eq) ("_cargs" ("_position" y) ("_position" y')))
### ("_applC" ("_position" insert)
###   ("_cargs" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z)))
###     ("_position" A)))
### ("_position" A)))
###                                   ("_position" dxs1))))
###                             ("_cargs" ("_position" rbt3)
###                               ("\<^const>Set.empty"))))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt3))
###       ("_applC" ("_position" DList_set) ("_position" dxs1)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position"
###                   ''relcomp RBT_set DList_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs1)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'd)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp RBT_set DList_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs1)))))))))
###           ("_case2"
###             ("_case1"
###               ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###               ("_case_syntax"
###                 ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'd)))
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp RBT_set DList_set: ceq2 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt3))
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs1)))))))))
###             ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###               ("_case_syntax"
###                 ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###                 ("_case2"
###                   ("_case1" ("_position" None)
###                     ("_applC" ("_position" Code.abort)
###                       ("_cargs"
###                         ("_Literal"
###                           ("_position"
###                             ''relcomp RBT_set DList_set: ceq3 = None''))
###                         ("_lambda" ("_idtdummy")
###                           ("\<^const>Relation.relcomp"
###                             ("_applC" ("_position" RBT_set)
###                               ("_position" rbt3))
###                             ("_applC" ("_position" DList_set)
###                               ("_position" dxs1)))))))
###                   ("_case1"
###                     ("_applC" ("_position" Some)
###                       ("\<^const>Pure.dummy_pattern"))
###                     ("_applC" ("_position" RBT_Set2.fold)
###                       ("_cargs"
###                         ("_lambda"
###                           ("_pattern" ("_position" x) ("_position" y))
###                           ("_applC" ("_position" DList_Set.fold)
###                             ("_cargs"
###                               ("_lambda"
###                                 ("_pttrns"
###                                   ("_pattern" ("_position" y')
###                                     ("_position" z))
###                                   ("_position" A))
###                                 ("\<^const>HOL.If"
###                                   ("_applC" ("_position" eq)
###                                     ("_cargs" ("_position" y)
### ("_position" y')))
###                                   ("_applC" ("_position" insert)
###                                     ("_cargs"
### ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z))) ("_position" A)))
###                                   ("_position" A)))
###                               ("_position" dxs1))))
###                         ("_cargs" ("_position" rbt3)
###                           ("\<^const>Set.empty"))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt3))
###       ("_applC" ("_position" DList_set) ("_position" dxs1)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position"
###                   ''relcomp RBT_set DList_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs1)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'd)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp RBT_set DList_set: ccompare2 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt3))
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs1)))))))
###                 ("_case1"
###                   ("_applC" ("_position" Some)
###                     ("\<^const>Pure.dummy_pattern"))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CEQ" ("_position_sort" 'd)))
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp RBT_set DList_set: ceq2 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt3))
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs1))))))))))))
###           ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp RBT_set DList_set: ceq3 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt3))
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs1)))))))
###                 ("_case1"
###                   ("_applC" ("_position" Some)
###                     ("\<^const>Pure.dummy_pattern"))
###                   ("_applC" ("_position" RBT_Set2.fold)
###                     ("_cargs"
###                       ("_lambda"
###                         ("_pattern" ("_position" x) ("_position" y))
###                         ("_applC" ("_position" DList_Set.fold)
###                           ("_cargs"
###                             ("_lambda"
###                               ("_pttrns"
###                                 ("_pattern" ("_position" y')
###                                   ("_position" z))
###                                 ("_position" A))
###                               ("\<^const>HOL.If"
###                                 ("_applC" ("_position" eq)
###                                   ("_cargs" ("_position" y)
###                                     ("_position" y')))
###                                 ("_applC" ("_position" insert)
###                                   ("_cargs"
###                                     ("_tuple" ("_position" x)
### ("_tuple_arg" ("_position" z)))
###                                     ("_position" A)))
###                                 ("_position" A)))
###                             ("_position" dxs1))))
###                       ("_cargs" ("_position" rbt3)
###                         ("\<^const>Set.empty")))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt3))
###       ("_applC" ("_position" DList_set) ("_position" dxs1)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position"
###                   ''relcomp RBT_set DList_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs1)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'd)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp RBT_set DList_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs1)))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_case_syntax"
###                   ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'd)))
###                   ("_case2"
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp RBT_set DList_set: ceq2 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt3))
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs1)))))))
###                     ("_case2"
###                       ("_case1"
###                         ("_applC" ("_position" Some) ("_position" eq))
###                         ("_case_syntax"
###                           ("_applC" ("_position" ID)
###                             ("_CEQ" ("_position_sort" 'e)))
###                           ("_case1" ("_position" None)
###                             ("_applC" ("_position" Code.abort)
###                               ("_cargs"
###                                 ("_Literal"
###                                   ("_position"
###                                     ''relcomp RBT_set DList_set: ceq3 = None''))
###                                 ("_lambda" ("_idtdummy")
###                                   ("\<^const>Relation.relcomp"
###                                     ("_applC" ("_position" RBT_set)
### ("_position" rbt3))
###                                     ("_applC" ("_position" DList_set)
### ("_position" dxs1)))))))))
###                       ("_case1"
###                         ("_applC" ("_position" Some)
###                           ("\<^const>Pure.dummy_pattern"))
###                         ("_applC" ("_position" RBT_Set2.fold)
###                           ("_cargs"
###                             ("_lambda"
###                               ("_pattern" ("_position" x) ("_position" y))
###                               ("_applC" ("_position" DList_Set.fold)
###                                 ("_cargs"
###                                   ("_lambda"
###                                     ("_pttrns"
### ("_pattern" ("_position" y') ("_position" z)) ("_position" A))
###                                     ("\<^const>HOL.If"
### ("_applC" ("_position" eq) ("_cargs" ("_position" y) ("_position" y')))
### ("_applC" ("_position" insert)
###   ("_cargs" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z)))
###     ("_position" A)))
### ("_position" A)))
###                                   ("_position" dxs1))))
###                             ("_cargs" ("_position" rbt3)
###                               ("\<^const>Set.empty"))))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt3))
###       ("_applC" ("_position" DList_set) ("_position" dxs1)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position"
###                   ''relcomp RBT_set DList_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs1)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'd)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp RBT_set DList_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs1)))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'd)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp RBT_set DList_set: ceq2 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt3))
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs1)))))))
###                 ("_case2"
###                   ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                     ("_case_syntax"
###                       ("_applC" ("_position" ID)
###                         ("_CEQ" ("_position_sort" 'e)))
###                       ("_case1" ("_position" None)
###                         ("_applC" ("_position" Code.abort)
###                           ("_cargs"
###                             ("_Literal"
###                               ("_position"
###                                 ''relcomp RBT_set DList_set: ceq3 = None''))
###                             ("_lambda" ("_idtdummy")
###                               ("\<^const>Relation.relcomp"
###                                 ("_applC" ("_position" RBT_set)
###                                   ("_position" rbt3))
###                                 ("_applC" ("_position" DList_set)
###                                   ("_position" dxs1)))))))))
###                   ("_case1"
###                     ("_applC" ("_position" Some)
###                       ("\<^const>Pure.dummy_pattern"))
###                     ("_applC" ("_position" RBT_Set2.fold)
###                       ("_cargs"
###                         ("_lambda"
###                           ("_pattern" ("_position" x) ("_position" y))
###                           ("_applC" ("_position" DList_Set.fold)
###                             ("_cargs"
###                               ("_lambda"
###                                 ("_pttrns"
###                                   ("_pattern" ("_position" y')
###                                     ("_position" z))
###                                   ("_position" A))
###                                 ("\<^const>HOL.If"
###                                   ("_applC" ("_position" eq)
###                                     ("_cargs" ("_position" y)
### ("_position" y')))
###                                   ("_applC" ("_position" insert)
###                                     ("_cargs"
### ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z))) ("_position" A)))
###                                   ("_position" A)))
###                               ("_position" dxs1))))
###                         ("_cargs" ("_position" rbt3)
###                           ("\<^const>Set.empty"))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt3))
###       ("_applC" ("_position" DList_set) ("_position" dxs1)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position"
###                   ''relcomp RBT_set DList_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs1)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'd)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp RBT_set DList_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs1)))))))
###               ("_case2"
###                 ("_case1"
###                   ("_applC" ("_position" Some)
###                     ("\<^const>Pure.dummy_pattern"))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CEQ" ("_position_sort" 'd)))
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp RBT_set DList_set: ceq2 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt3))
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs1)))))))))
###                 ("_case2"
###                   ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                     ("_case_syntax"
###                       ("_applC" ("_position" ID)
###                         ("_CEQ" ("_position_sort" 'e)))
###                       ("_case1" ("_position" None)
###                         ("_applC" ("_position" Code.abort)
###                           ("_cargs"
###                             ("_Literal"
###                               ("_position"
###                                 ''relcomp RBT_set DList_set: ceq3 = None''))
###                             ("_lambda" ("_idtdummy")
###                               ("\<^const>Relation.relcomp"
###                                 ("_applC" ("_position" RBT_set)
###                                   ("_position" rbt3))
###                                 ("_applC" ("_position" DList_set)
###                                   ("_position" dxs1)))))))))
###                   ("_case1"
###                     ("_applC" ("_position" Some)
###                       ("\<^const>Pure.dummy_pattern"))
###                     ("_applC" ("_position" RBT_Set2.fold)
###                       ("_cargs"
###                         ("_lambda"
###                           ("_pattern" ("_position" x) ("_position" y))
###                           ("_applC" ("_position" DList_Set.fold)
###                             ("_cargs"
###                               ("_lambda"
###                                 ("_pttrns"
###                                   ("_pattern" ("_position" y')
###                                     ("_position" z))
###                                   ("_position" A))
###                                 ("\<^const>HOL.If"
###                                   ("_applC" ("_position" eq)
###                                     ("_cargs" ("_position" y)
### ("_position" y')))
###                                   ("_applC" ("_position" insert)
###                                     ("_cargs"
### ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z))) ("_position" A)))
###                                   ("_position" A)))
###                               ("_position" dxs1))))
###                         ("_cargs" ("_position" rbt3)
###                           ("\<^const>Set.empty"))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt3))
###       ("_applC" ("_position" DList_set) ("_position" dxs1)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position"
###                   ''relcomp RBT_set DList_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs1)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'd)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp RBT_set DList_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs1)))))))))
###           ("_case2"
###             ("_case1"
###               ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###               ("_case_syntax"
###                 ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'd)))
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp RBT_set DList_set: ceq2 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt3))
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs1)))))))))
###             ("_case2"
###               ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                 ("_case_syntax"
###                   ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###                   ("_case1" ("_position" None)
###                     ("_applC" ("_position" Code.abort)
###                       ("_cargs"
###                         ("_Literal"
###                           ("_position"
###                             ''relcomp RBT_set DList_set: ceq3 = None''))
###                         ("_lambda" ("_idtdummy")
###                           ("\<^const>Relation.relcomp"
###                             ("_applC" ("_position" RBT_set)
###                               ("_position" rbt3))
###                             ("_applC" ("_position" DList_set)
###                               ("_position" dxs1)))))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_applC" ("_position" RBT_Set2.fold)
###                   ("_cargs"
###                     ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                       ("_applC" ("_position" DList_Set.fold)
###                         ("_cargs"
###                           ("_lambda"
###                             ("_pttrns"
###                               ("_pattern" ("_position" y') ("_position" z))
###                               ("_position" A))
###                             ("\<^const>HOL.If"
###                               ("_applC" ("_position" eq)
###                                 ("_cargs" ("_position" y) ("_position" y')))
###                               ("_applC" ("_position" insert)
###                                 ("_cargs"
###                                   ("_tuple" ("_position" x)
###                                     ("_tuple_arg" ("_position" z)))
###                                   ("_position" A)))
###                               ("_position" A)))
###                           ("_position" dxs1))))
###                     ("_cargs" ("_position" rbt3)
###                       ("\<^const>Set.empty"))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt3))
###       ("_applC" ("_position" DList_set) ("_position" dxs1)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position"
###                   ''relcomp RBT_set DList_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs1)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'd)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp RBT_set DList_set: ccompare2 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt3))
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs1)))))))
###                 ("_case1"
###                   ("_applC" ("_position" Some)
###                     ("\<^const>Pure.dummy_pattern"))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CEQ" ("_position_sort" 'd)))
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp RBT_set DList_set: ceq2 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt3))
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs1))))))))))))
###           ("_case2"
###             ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###               ("_case_syntax"
###                 ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp RBT_set DList_set: ceq3 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt3))
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs1)))))))))
###             ("_case1"
###               ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###               ("_applC" ("_position" RBT_Set2.fold)
###                 ("_cargs"
###                   ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                     ("_applC" ("_position" DList_Set.fold)
###                       ("_cargs"
###                         ("_lambda"
###                           ("_pttrns"
###                             ("_pattern" ("_position" y') ("_position" z))
###                             ("_position" A))
###                           ("\<^const>HOL.If"
###                             ("_applC" ("_position" eq)
###                               ("_cargs" ("_position" y) ("_position" y')))
###                             ("_applC" ("_position" insert)
###                               ("_cargs"
###                                 ("_tuple" ("_position" x)
###                                   ("_tuple_arg" ("_position" z)))
###                                 ("_position" A)))
###                             ("_position" A)))
###                         ("_position" dxs1))))
###                   ("_cargs" ("_position" rbt3)
###                     ("\<^const>Set.empty")))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
locale vec_module
  fixes f_ty :: "'a itself"
    and n :: "nat"
### Ambiguous input (line 1566 of "$AFP/Containers/Set_Impl.thy") produces 14 parse trees (10 displayed):
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs2))
###       ("_applC" ("_position" RBT_set) ("_position" rbt4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set RBT_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs2))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt4)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'd)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp DList_set RBT_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs2))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt4)))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_case_syntax"
###                   ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'd)))
###                   ("_case2"
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp DList_set RBT_set: ccompare2 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs2))
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt4)))))))
###                     ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                       ("_case_syntax"
###                         ("_applC" ("_position" ID)
###                           ("_CCOMPARE" ("_position_sort" 'a)))
###                         ("_case2"
###                           ("_case1" ("_position" None)
###                             ("_applC" ("_position" Code.abort)
###                               ("_cargs"
###                                 ("_Literal"
###                                   ("_position"
###                                     ''relcomp DList_set RBT_set: ccompare3 = None''))
###                                 ("_lambda" ("_idtdummy")
###                                   ("\<^const>Relation.relcomp"
###                                     ("_applC" ("_position" DList_set)
### ("_position" dxs2))
###                                     ("_applC" ("_position" RBT_set)
### ("_position" rbt4)))))))
###                           ("_case1"
###                             ("_applC" ("_position" Some)
###                               ("\<^const>Pure.dummy_pattern"))
###                             ("_applC" ("_position" DList_Set.fold)
###                               ("_cargs"
###                                 ("_lambda"
###                                   ("_pattern" ("_position" x)
###                                     ("_position" y))
###                                   ("_applC" ("_position" RBT_Set2.fold)
###                                     ("_cargs"
### ("_lambda"
###   ("_pttrns" ("_pattern" ("_position" y') ("_position" z)) ("_position" A))
###   ("\<^const>HOL.If"
###     ("_applC" ("_position" eq) ("_cargs" ("_position" y) ("_position" y')))
###     ("_applC" ("_position" insert)
###       ("_cargs" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z)))
###         ("_position" A)))
###     ("_position" A)))
### ("_position" rbt4))))
###                                 ("_cargs" ("_position" dxs2)
###                                   ("\<^const>Set.empty"))))))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs2))
###       ("_applC" ("_position" RBT_set) ("_position" rbt4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set RBT_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs2))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt4)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'd)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp DList_set RBT_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs2))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt4)))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'd)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp DList_set RBT_set: ccompare2 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs2))
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt4)))))))
###                 ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CCOMPARE" ("_position_sort" 'a)))
###                     ("_case2"
###                       ("_case1" ("_position" None)
###                         ("_applC" ("_position" Code.abort)
###                           ("_cargs"
###                             ("_Literal"
###                               ("_position"
###                                 ''relcomp DList_set RBT_set: ccompare3 = None''))
###                             ("_lambda" ("_idtdummy")
###                               ("\<^const>Relation.relcomp"
###                                 ("_applC" ("_position" DList_set)
###                                   ("_position" dxs2))
###                                 ("_applC" ("_position" RBT_set)
###                                   ("_position" rbt4)))))))
###                       ("_case1"
###                         ("_applC" ("_position" Some)
###                           ("\<^const>Pure.dummy_pattern"))
###                         ("_applC" ("_position" DList_Set.fold)
###                           ("_cargs"
###                             ("_lambda"
###                               ("_pattern" ("_position" x) ("_position" y))
###                               ("_applC" ("_position" RBT_Set2.fold)
###                                 ("_cargs"
###                                   ("_lambda"
###                                     ("_pttrns"
### ("_pattern" ("_position" y') ("_position" z)) ("_position" A))
###                                     ("\<^const>HOL.If"
### ("_applC" ("_position" eq) ("_cargs" ("_position" y) ("_position" y')))
### ("_applC" ("_position" insert)
###   ("_cargs" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z)))
###     ("_position" A)))
### ("_position" A)))
###                                   ("_position" rbt4))))
###                             ("_cargs" ("_position" dxs2)
###                               ("\<^const>Set.empty"))))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs2))
###       ("_applC" ("_position" RBT_set) ("_position" rbt4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set RBT_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs2))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt4)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'd)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp DList_set RBT_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs2))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt4)))))))
###               ("_case2"
###                 ("_case1"
###                   ("_applC" ("_position" Some)
###                     ("\<^const>Pure.dummy_pattern"))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CEQ" ("_position_sort" 'd)))
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp DList_set RBT_set: ccompare2 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs2))
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt4)))))))))
###                 ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CCOMPARE" ("_position_sort" 'a)))
###                     ("_case2"
###                       ("_case1" ("_position" None)
###                         ("_applC" ("_position" Code.abort)
###                           ("_cargs"
###                             ("_Literal"
###                               ("_position"
###                                 ''relcomp DList_set RBT_set: ccompare3 = None''))
###                             ("_lambda" ("_idtdummy")
###                               ("\<^const>Relation.relcomp"
###                                 ("_applC" ("_position" DList_set)
###                                   ("_position" dxs2))
###                                 ("_applC" ("_position" RBT_set)
###                                   ("_position" rbt4)))))))
###                       ("_case1"
###                         ("_applC" ("_position" Some)
###                           ("\<^const>Pure.dummy_pattern"))
###                         ("_applC" ("_position" DList_Set.fold)
###                           ("_cargs"
###                             ("_lambda"
###                               ("_pattern" ("_position" x) ("_position" y))
###                               ("_applC" ("_position" RBT_Set2.fold)
###                                 ("_cargs"
###                                   ("_lambda"
###                                     ("_pttrns"
### ("_pattern" ("_position" y') ("_position" z)) ("_position" A))
###                                     ("\<^const>HOL.If"
### ("_applC" ("_position" eq) ("_cargs" ("_position" y) ("_position" y')))
### ("_applC" ("_position" insert)
###   ("_cargs" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z)))
###     ("_position" A)))
### ("_position" A)))
###                                   ("_position" rbt4))))
###                             ("_cargs" ("_position" dxs2)
###                               ("\<^const>Set.empty"))))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs2))
###       ("_applC" ("_position" RBT_set) ("_position" rbt4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set RBT_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs2))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt4)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'd)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp DList_set RBT_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs2))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt4)))))))))
###           ("_case2"
###             ("_case1"
###               ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###               ("_case_syntax"
###                 ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'd)))
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp DList_set RBT_set: ccompare2 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs2))
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt4)))))))))
###             ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###               ("_case_syntax"
###                 ("_applC" ("_position" ID)
###                   ("_CCOMPARE" ("_position_sort" 'a)))
###                 ("_case2"
###                   ("_case1" ("_position" None)
###                     ("_applC" ("_position" Code.abort)
###                       ("_cargs"
###                         ("_Literal"
###                           ("_position"
###                             ''relcomp DList_set RBT_set: ccompare3 = None''))
###                         ("_lambda" ("_idtdummy")
###                           ("\<^const>Relation.relcomp"
###                             ("_applC" ("_position" DList_set)
###                               ("_position" dxs2))
###                             ("_applC" ("_position" RBT_set)
###                               ("_position" rbt4)))))))
###                   ("_case1"
###                     ("_applC" ("_position" Some)
###                       ("\<^const>Pure.dummy_pattern"))
###                     ("_applC" ("_position" DList_Set.fold)
###                       ("_cargs"
###                         ("_lambda"
###                           ("_pattern" ("_position" x) ("_position" y))
###                           ("_applC" ("_position" RBT_Set2.fold)
###                             ("_cargs"
###                               ("_lambda"
###                                 ("_pttrns"
###                                   ("_pattern" ("_position" y')
###                                     ("_position" z))
###                                   ("_position" A))
###                                 ("\<^const>HOL.If"
###                                   ("_applC" ("_position" eq)
###                                     ("_cargs" ("_position" y)
### ("_position" y')))
###                                   ("_applC" ("_position" insert)
###                                     ("_cargs"
### ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z))) ("_position" A)))
###                                   ("_position" A)))
###                               ("_position" rbt4))))
###                         ("_cargs" ("_position" dxs2)
###                           ("\<^const>Set.empty"))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs2))
###       ("_applC" ("_position" RBT_set) ("_position" rbt4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set RBT_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs2))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt4)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'd)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp DList_set RBT_set: ceq2 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs2))
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt4)))))))
###                 ("_case1"
###                   ("_applC" ("_position" Some)
###                     ("\<^const>Pure.dummy_pattern"))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CEQ" ("_position_sort" 'd)))
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp DList_set RBT_set: ccompare2 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs2))
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt4))))))))))))
###           ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'a)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp DList_set RBT_set: ccompare3 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs2))
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt4)))))))
###                 ("_case1"
###                   ("_applC" ("_position" Some)
###                     ("\<^const>Pure.dummy_pattern"))
###                   ("_applC" ("_position" DList_Set.fold)
###                     ("_cargs"
###                       ("_lambda"
###                         ("_pattern" ("_position" x) ("_position" y))
###                         ("_applC" ("_position" RBT_Set2.fold)
###                           ("_cargs"
###                             ("_lambda"
###                               ("_pttrns"
###                                 ("_pattern" ("_position" y')
###                                   ("_position" z))
###                                 ("_position" A))
###                               ("\<^const>HOL.If"
###                                 ("_applC" ("_position" eq)
###                                   ("_cargs" ("_position" y)
###                                     ("_position" y')))
###                                 ("_applC" ("_position" insert)
###                                   ("_cargs"
###                                     ("_tuple" ("_position" x)
### ("_tuple_arg" ("_position" z)))
###                                     ("_position" A)))
###                                 ("_position" A)))
###                             ("_position" rbt4))))
###                       ("_cargs" ("_position" dxs2)
###                         ("\<^const>Set.empty")))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs2))
###       ("_applC" ("_position" RBT_set) ("_position" rbt4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set RBT_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs2))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt4)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'd)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp DList_set RBT_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs2))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt4)))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_case_syntax"
###                   ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'd)))
###                   ("_case2"
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp DList_set RBT_set: ccompare2 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs2))
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt4)))))))
###                     ("_case2"
###                       ("_case1"
###                         ("_applC" ("_position" Some) ("_position" eq))
###                         ("_case_syntax"
###                           ("_applC" ("_position" ID)
###                             ("_CCOMPARE" ("_position_sort" 'a)))
###                           ("_case1" ("_position" None)
###                             ("_applC" ("_position" Code.abort)
###                               ("_cargs"
###                                 ("_Literal"
###                                   ("_position"
###                                     ''relcomp DList_set RBT_set: ccompare3 = None''))
###                                 ("_lambda" ("_idtdummy")
###                                   ("\<^const>Relation.relcomp"
###                                     ("_applC" ("_position" DList_set)
### ("_position" dxs2))
###                                     ("_applC" ("_position" RBT_set)
### ("_position" rbt4)))))))))
###                       ("_case1"
###                         ("_applC" ("_position" Some)
###                           ("\<^const>Pure.dummy_pattern"))
###                         ("_applC" ("_position" DList_Set.fold)
###                           ("_cargs"
###                             ("_lambda"
###                               ("_pattern" ("_position" x) ("_position" y))
###                               ("_applC" ("_position" RBT_Set2.fold)
###                                 ("_cargs"
###                                   ("_lambda"
###                                     ("_pttrns"
### ("_pattern" ("_position" y') ("_position" z)) ("_position" A))
###                                     ("\<^const>HOL.If"
### ("_applC" ("_position" eq) ("_cargs" ("_position" y) ("_position" y')))
### ("_applC" ("_position" insert)
###   ("_cargs" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z)))
###     ("_position" A)))
### ("_position" A)))
###                                   ("_position" rbt4))))
###                             ("_cargs" ("_position" dxs2)
###                               ("\<^const>Set.empty"))))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs2))
###       ("_applC" ("_position" RBT_set) ("_position" rbt4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set RBT_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs2))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt4)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'd)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp DList_set RBT_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs2))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt4)))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'd)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp DList_set RBT_set: ccompare2 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs2))
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt4)))))))
###                 ("_case2"
###                   ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                     ("_case_syntax"
###                       ("_applC" ("_position" ID)
###                         ("_CCOMPARE" ("_position_sort" 'a)))
###                       ("_case1" ("_position" None)
###                         ("_applC" ("_position" Code.abort)
###                           ("_cargs"
###                             ("_Literal"
###                               ("_position"
###                                 ''relcomp DList_set RBT_set: ccompare3 = None''))
###                             ("_lambda" ("_idtdummy")
###                               ("\<^const>Relation.relcomp"
###                                 ("_applC" ("_position" DList_set)
###                                   ("_position" dxs2))
###                                 ("_applC" ("_position" RBT_set)
###                                   ("_position" rbt4)))))))))
###                   ("_case1"
###                     ("_applC" ("_position" Some)
###                       ("\<^const>Pure.dummy_pattern"))
###                     ("_applC" ("_position" DList_Set.fold)
###                       ("_cargs"
###                         ("_lambda"
###                           ("_pattern" ("_position" x) ("_position" y))
###                           ("_applC" ("_position" RBT_Set2.fold)
###                             ("_cargs"
###                               ("_lambda"
###                                 ("_pttrns"
###                                   ("_pattern" ("_position" y')
###                                     ("_position" z))
###                                   ("_position" A))
###                                 ("\<^const>HOL.If"
###                                   ("_applC" ("_position" eq)
###                                     ("_cargs" ("_position" y)
### ("_position" y')))
###                                   ("_applC" ("_position" insert)
###                                     ("_cargs"
### ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z))) ("_position" A)))
###                                   ("_position" A)))
###                               ("_position" rbt4))))
###                         ("_cargs" ("_position" dxs2)
###                           ("\<^const>Set.empty"))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs2))
###       ("_applC" ("_position" RBT_set) ("_position" rbt4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set RBT_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs2))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt4)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'd)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp DList_set RBT_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs2))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt4)))))))
###               ("_case2"
###                 ("_case1"
###                   ("_applC" ("_position" Some)
###                     ("\<^const>Pure.dummy_pattern"))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CEQ" ("_position_sort" 'd)))
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp DList_set RBT_set: ccompare2 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs2))
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt4)))))))))
###                 ("_case2"
###                   ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                     ("_case_syntax"
###                       ("_applC" ("_position" ID)
###                         ("_CCOMPARE" ("_position_sort" 'a)))
###                       ("_case1" ("_position" None)
###                         ("_applC" ("_position" Code.abort)
###                           ("_cargs"
###                             ("_Literal"
###                               ("_position"
###                                 ''relcomp DList_set RBT_set: ccompare3 = None''))
###                             ("_lambda" ("_idtdummy")
###                               ("\<^const>Relation.relcomp"
###                                 ("_applC" ("_position" DList_set)
###                                   ("_position" dxs2))
###                                 ("_applC" ("_position" RBT_set)
###                                   ("_position" rbt4)))))))))
###                   ("_case1"
###                     ("_applC" ("_position" Some)
###                       ("\<^const>Pure.dummy_pattern"))
###                     ("_applC" ("_position" DList_Set.fold)
###                       ("_cargs"
###                         ("_lambda"
###                           ("_pattern" ("_position" x) ("_position" y))
###                           ("_applC" ("_position" RBT_Set2.fold)
###                             ("_cargs"
###                               ("_lambda"
###                                 ("_pttrns"
###                                   ("_pattern" ("_position" y')
###                                     ("_position" z))
###                                   ("_position" A))
###                                 ("\<^const>HOL.If"
###                                   ("_applC" ("_position" eq)
###                                     ("_cargs" ("_position" y)
### ("_position" y')))
###                                   ("_applC" ("_position" insert)
###                                     ("_cargs"
### ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z))) ("_position" A)))
###                                   ("_position" A)))
###                               ("_position" rbt4))))
###                         ("_cargs" ("_position" dxs2)
###                           ("\<^const>Set.empty"))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs2))
###       ("_applC" ("_position" RBT_set) ("_position" rbt4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set RBT_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs2))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt4)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'd)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp DList_set RBT_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs2))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt4)))))))))
###           ("_case2"
###             ("_case1"
###               ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###               ("_case_syntax"
###                 ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'd)))
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp DList_set RBT_set: ccompare2 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs2))
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt4)))))))))
###             ("_case2"
###               ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                 ("_case_syntax"
###                   ("_applC" ("_position" ID)
###                     ("_CCOMPARE" ("_position_sort" 'a)))
###                   ("_case1" ("_position" None)
###                     ("_applC" ("_position" Code.abort)
###                       ("_cargs"
###                         ("_Literal"
###                           ("_position"
###                             ''relcomp DList_set RBT_set: ccompare3 = None''))
###                         ("_lambda" ("_idtdummy")
###                           ("\<^const>Relation.relcomp"
###                             ("_applC" ("_position" DList_set)
###                               ("_position" dxs2))
###                             ("_applC" ("_position" RBT_set)
###                               ("_position" rbt4)))))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_applC" ("_position" DList_Set.fold)
###                   ("_cargs"
###                     ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                       ("_applC" ("_position" RBT_Set2.fold)
###                         ("_cargs"
###                           ("_lambda"
###                             ("_pttrns"
###                               ("_pattern" ("_position" y') ("_position" z))
###                               ("_position" A))
###                             ("\<^const>HOL.If"
###                               ("_applC" ("_position" eq)
###                                 ("_cargs" ("_position" y) ("_position" y')))
###                               ("_applC" ("_position" insert)
###                                 ("_cargs"
###                                   ("_tuple" ("_position" x)
###                                     ("_tuple_arg" ("_position" z)))
###                                   ("_position" A)))
###                               ("_position" A)))
###                           ("_position" rbt4))))
###                     ("_cargs" ("_position" dxs2)
###                       ("\<^const>Set.empty"))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs2))
###       ("_applC" ("_position" RBT_set) ("_position" rbt4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set RBT_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs2))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt4)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'd)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp DList_set RBT_set: ceq2 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs2))
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt4)))))))
###                 ("_case1"
###                   ("_applC" ("_position" Some)
###                     ("\<^const>Pure.dummy_pattern"))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CEQ" ("_position_sort" 'd)))
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp DList_set RBT_set: ccompare2 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs2))
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt4))))))))))))
###           ("_case2"
###             ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###               ("_case_syntax"
###                 ("_applC" ("_position" ID)
###                   ("_CCOMPARE" ("_position_sort" 'a)))
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp DList_set RBT_set: ccompare3 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs2))
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt4)))))))))
###             ("_case1"
###               ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###               ("_applC" ("_position" DList_Set.fold)
###                 ("_cargs"
###                   ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                     ("_applC" ("_position" RBT_Set2.fold)
###                       ("_cargs"
###                         ("_lambda"
###                           ("_pttrns"
###                             ("_pattern" ("_position" y') ("_position" z))
###                             ("_position" A))
###                           ("\<^const>HOL.If"
###                             ("_applC" ("_position" eq)
###                               ("_cargs" ("_position" y) ("_position" y')))
###                             ("_applC" ("_position" insert)
###                               ("_cargs"
###                                 ("_tuple" ("_position" x)
###                                   ("_tuple_arg" ("_position" z)))
###                                 ("_position" A)))
###                             ("_position" A)))
###                         ("_position" rbt4))))
###                   ("_cargs" ("_position" dxs2)
###                     ("\<^const>Set.empty")))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1577 of "$AFP/Containers/Set_Impl.thy") produces 5 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs3))
###       ("_applC" ("_position" DList_set) ("_position" dxs4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set DList_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs4)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'f)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp DList_set DList_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs3))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs4)))))))
###               ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                 ("_case_syntax"
###                   ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'g)))
###                   ("_case2"
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp DList_set DList_set: ceq3 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs3))
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs4)))))))
###                     ("_case1"
###                       ("_applC" ("_position" Some)
###                         ("\<^const>Pure.dummy_pattern"))
###                       ("_applC" ("_position" DList_Set.fold)
###                         ("_cargs"
###                           ("_lambda"
###                             ("_pattern" ("_position" x) ("_position" y))
###                             ("_applC" ("_position" DList_Set.fold)
###                               ("_cargs"
###                                 ("_lambda"
###                                   ("_pttrns"
###                                     ("_pattern" ("_position" y')
### ("_position" z))
###                                     ("_position" A))
###                                   ("\<^const>HOL.If"
###                                     ("_applC" ("_position" eq)
### ("_cargs" ("_position" y) ("_position" y')))
###                                     ("_applC" ("_position" insert)
### ("_cargs" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z)))
###   ("_position" A)))
###                                     ("_position" A)))
###                                 ("_position" dxs4))))
###                           ("_cargs" ("_position" dxs3)
###                             ("\<^const>Set.empty")))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs3))
###       ("_applC" ("_position" DList_set) ("_position" dxs4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set DList_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs4)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'f)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp DList_set DList_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs3))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs4)))))))))
###           ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'g)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp DList_set DList_set: ceq3 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs3))
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs4)))))))
###                 ("_case1"
###                   ("_applC" ("_position" Some)
###                     ("\<^const>Pure.dummy_pattern"))
###                   ("_applC" ("_position" DList_Set.fold)
###                     ("_cargs"
###                       ("_lambda"
###                         ("_pattern" ("_position" x) ("_position" y))
###                         ("_applC" ("_position" DList_Set.fold)
###                           ("_cargs"
###                             ("_lambda"
###                               ("_pttrns"
###                                 ("_pattern" ("_position" y')
###                                   ("_position" z))
###                                 ("_position" A))
###                               ("\<^const>HOL.If"
###                                 ("_applC" ("_position" eq)
###                                   ("_cargs" ("_position" y)
###                                     ("_position" y')))
###                                 ("_applC" ("_position" insert)
###                                   ("_cargs"
###                                     ("_tuple" ("_position" x)
### ("_tuple_arg" ("_position" z)))
###                                     ("_position" A)))
###                                 ("_position" A)))
###                             ("_position" dxs4))))
###                       ("_cargs" ("_position" dxs3)
###                         ("\<^const>Set.empty")))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs3))
###       ("_applC" ("_position" DList_set) ("_position" dxs4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set DList_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs4)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'f)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp DList_set DList_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs3))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs4)))))))
###               ("_case2"
###                 ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CEQ" ("_position_sort" 'g)))
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp DList_set DList_set: ceq3 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs3))
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs4)))))))))
###                 ("_case1"
###                   ("_applC" ("_position" Some)
###                     ("\<^const>Pure.dummy_pattern"))
###                   ("_applC" ("_position" DList_Set.fold)
###                     ("_cargs"
###                       ("_lambda"
###                         ("_pattern" ("_position" x) ("_position" y))
###                         ("_applC" ("_position" DList_Set.fold)
###                           ("_cargs"
###                             ("_lambda"
###                               ("_pttrns"
###                                 ("_pattern" ("_position" y')
###                                   ("_position" z))
###                                 ("_position" A))
###                               ("\<^const>HOL.If"
###                                 ("_applC" ("_position" eq)
###                                   ("_cargs" ("_position" y)
###                                     ("_position" y')))
###                                 ("_applC" ("_position" insert)
###                                   ("_cargs"
###                                     ("_tuple" ("_position" x)
### ("_tuple_arg" ("_position" z)))
###                                     ("_position" A)))
###                                 ("_position" A)))
###                             ("_position" dxs4))))
###                       ("_cargs" ("_position" dxs3)
###                         ("\<^const>Set.empty")))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs3))
###       ("_applC" ("_position" DList_set) ("_position" dxs4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set DList_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs4)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'f)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp DList_set DList_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs3))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs4)))))))))
###           ("_case2"
###             ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###               ("_case_syntax"
###                 ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'g)))
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp DList_set DList_set: ceq3 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs3))
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs4)))))))))
###             ("_case1"
###               ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###               ("_applC" ("_position" DList_Set.fold)
###                 ("_cargs"
###                   ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                     ("_applC" ("_position" DList_Set.fold)
###                       ("_cargs"
###                         ("_lambda"
###                           ("_pttrns"
###                             ("_pattern" ("_position" y') ("_position" z))
###                             ("_position" A))
###                           ("\<^const>HOL.If"
###                             ("_applC" ("_position" eq)
###                               ("_cargs" ("_position" y) ("_position" y')))
###                             ("_applC" ("_position" insert)
###                               ("_cargs"
###                                 ("_tuple" ("_position" x)
###                                   ("_tuple_arg" ("_position" z)))
###                                 ("_position" A)))
###                             ("_position" A)))
###                         ("_position" dxs4))))
###                   ("_cargs" ("_position" dxs3)
###                     ("\<^const>Set.empty")))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs3))
###       ("_applC" ("_position" DList_set) ("_position" dxs4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set DList_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs4)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'f)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp DList_set DList_set: ceq2 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs3))
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs4)))))))
###                 ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CEQ" ("_position_sort" 'g)))
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp DList_set DList_set: ceq3 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs3))
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs4))))))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_applC" ("_position" DList_Set.fold)
###               ("_cargs"
###                 ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                   ("_applC" ("_position" DList_Set.fold)
###                     ("_cargs"
###                       ("_lambda"
###                         ("_pttrns"
###                           ("_pattern" ("_position" y') ("_position" z))
###                           ("_position" A))
###                         ("\<^const>HOL.If"
###                           ("_applC" ("_position" eq)
###                             ("_cargs" ("_position" y) ("_position" y')))
###                           ("_applC" ("_position" insert)
###                             ("_cargs"
###                               ("_tuple" ("_position" x)
###                                 ("_tuple_arg" ("_position" z)))
###                               ("_position" A)))
###                           ("_position" A)))
###                       ("_position" dxs4))))
###                 ("_cargs" ("_position" dxs3) ("\<^const>Set.empty"))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1591 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt1))
###       ("_applC" ("_position" Set_Monad) ("_position" xs3)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position"
###                   ''relcomp RBT_set Set_Monad: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                   ("_applC" ("_position" Set_Monad) ("_position" xs3)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp RBT_set Set_Monad: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                         ("_applC" ("_position" Set_Monad)
###                           ("_position" xs3)))))))
###               ("_case1" ("_applC" ("_position" Some) ("_position" c_b))
###                 ("_applC" ("_position" RBT_Set2.fold)
###                   ("_cargs"
###                     ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                       ("_applC" ("_position" fold)
###                         ("_cargs"
###                           ("_lambda"
###                             ("_pttrns"
###                               ("_pattern" ("_position" y') ("_position" z))
###                               ("_position" A))
###                             ("\<^const>HOL.If"
###                               ("\<^const>HOL.not_equal"
###                                 ("_applC" ("_position" c_b)
###                                   ("_cargs" ("_position" y)
###                                     ("_position" y')))
###                                 ("_position" Eq))
###                               ("_position" A)
###                               ("_applC" ("_position" insert)
###                                 ("_cargs"
###                                   ("_tuple" ("_position" x)
###                                     ("_tuple_arg" ("_position" z)))
###                                   ("_position" A)))))
###                           ("_position" xs3))))
###                     ("_cargs" ("_position" rbt1)
###                       ("\<^const>Set.empty"))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt1))
###       ("_applC" ("_position" Set_Monad) ("_position" xs3)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position"
###                   ''relcomp RBT_set Set_Monad: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                   ("_applC" ("_position" Set_Monad) ("_position" xs3)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'b)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp RBT_set Set_Monad: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                         ("_applC" ("_position" Set_Monad)
###                           ("_position" xs3)))))))))
###           ("_case1" ("_applC" ("_position" Some) ("_position" c_b))
###             ("_applC" ("_position" RBT_Set2.fold)
###               ("_cargs"
###                 ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                   ("_applC" ("_position" fold)
###                     ("_cargs"
###                       ("_lambda"
###                         ("_pttrns"
###                           ("_pattern" ("_position" y') ("_position" z))
###                           ("_position" A))
###                         ("\<^const>HOL.If"
###                           ("\<^const>HOL.not_equal"
###                             ("_applC" ("_position" c_b)
###                               ("_cargs" ("_position" y) ("_position" y')))
###                             ("_position" Eq))
###                           ("_position" A)
###                           ("_applC" ("_position" insert)
###                             ("_cargs"
###                               ("_tuple" ("_position" x)
###                                 ("_tuple_arg" ("_position" z)))
###                               ("_position" A)))))
###                       ("_position" xs3))))
###                 ("_cargs" ("_position" rbt1) ("\<^const>Set.empty"))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1598 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" Set_Monad) ("_position" xs4))
###       ("_applC" ("_position" RBT_set) ("_position" rbt5)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position"
###                   ''relcomp Set_Monad RBT_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" Set_Monad) ("_position" xs4))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt5)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp Set_Monad RBT_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" Set_Monad) ("_position" xs4))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt5)))))))
###               ("_case1" ("_applC" ("_position" Some) ("_position" c_b))
###                 ("_applC" ("_position" fold)
###                   ("_cargs"
###                     ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                       ("_applC" ("_position" RBT_Set2.fold)
###                         ("_cargs"
###                           ("_lambda"
###                             ("_pttrns"
###                               ("_pattern" ("_position" y') ("_position" z))
###                               ("_position" A))
###                             ("\<^const>HOL.If"
###                               ("\<^const>HOL.not_equal"
###                                 ("_applC" ("_position" c_b)
###                                   ("_cargs" ("_position" y)
###                                     ("_position" y')))
###                                 ("_position" Eq))
###                               ("_position" A)
###                               ("_applC" ("_position" insert)
###                                 ("_cargs"
###                                   ("_tuple" ("_position" x)
###                                     ("_tuple_arg" ("_position" z)))
###                                   ("_position" A)))))
###                           ("_position" rbt5))))
###                     ("_cargs" ("_position" xs4)
###                       ("\<^const>Set.empty"))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" Set_Monad) ("_position" xs4))
###       ("_applC" ("_position" RBT_set) ("_position" rbt5)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position"
###                   ''relcomp Set_Monad RBT_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" Set_Monad) ("_position" xs4))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt5)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'b)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp Set_Monad RBT_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" Set_Monad) ("_position" xs4))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt5)))))))))
###           ("_case1" ("_applC" ("_position" Some) ("_position" c_b))
###             ("_applC" ("_position" fold)
###               ("_cargs"
###                 ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                   ("_applC" ("_position" RBT_Set2.fold)
###                     ("_cargs"
###                       ("_lambda"
###                         ("_pttrns"
###                           ("_pattern" ("_position" y') ("_position" z))
###                           ("_position" A))
###                         ("\<^const>HOL.If"
###                           ("\<^const>HOL.not_equal"
###                             ("_applC" ("_position" c_b)
###                               ("_cargs" ("_position" y) ("_position" y')))
###                             ("_position" Eq))
###                           ("_position" A)
###                           ("_applC" ("_position" insert)
###                             ("_cargs"
###                               ("_tuple" ("_position" x)
###                                 ("_tuple_arg" ("_position" z)))
###                               ("_position" A)))))
###                       ("_position" rbt5))))
###                 ("_cargs" ("_position" xs4) ("\<^const>Set.empty"))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1605 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs3))
###       ("_applC" ("_position" Set_Monad) ("_position" xs5)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set Set_Monad: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs3))
###                   ("_applC" ("_position" Set_Monad) ("_position" xs5)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'f)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp DList_set Set_Monad: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs3))
###                         ("_applC" ("_position" Set_Monad)
###                           ("_position" xs5)))))))
###               ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                 ("_applC" ("_position" DList_Set.fold)
###                   ("_cargs"
###                     ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                       ("_applC" ("_position" fold)
###                         ("_cargs"
###                           ("_lambda"
###                             ("_pttrns"
###                               ("_pattern" ("_position" y') ("_position" z))
###                               ("_position" A))
###                             ("\<^const>HOL.If"
###                               ("_applC" ("_position" eq)
###                                 ("_cargs" ("_position" y) ("_position" y')))
###                               ("_applC" ("_position" insert)
###                                 ("_cargs"
###                                   ("_tuple" ("_position" x)
###                                     ("_tuple_arg" ("_position" z)))
###                                   ("_position" A)))
###                               ("_position" A)))
###                           ("_position" xs5))))
###                     ("_cargs" ("_position" dxs3)
###                       ("\<^const>Set.empty"))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs3))
###       ("_applC" ("_position" Set_Monad) ("_position" xs5)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set Set_Monad: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs3))
###                   ("_applC" ("_position" Set_Monad) ("_position" xs5)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'f)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp DList_set Set_Monad: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs3))
###                         ("_applC" ("_position" Set_Monad)
###                           ("_position" xs5)))))))))
###           ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###             ("_applC" ("_position" DList_Set.fold)
###               ("_cargs"
###                 ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                   ("_applC" ("_position" fold)
###                     ("_cargs"
###                       ("_lambda"
###                         ("_pttrns"
###                           ("_pattern" ("_position" y') ("_position" z))
###                           ("_position" A))
###                         ("\<^const>HOL.If"
###                           ("_applC" ("_position" eq)
###                             ("_cargs" ("_position" y) ("_position" y')))
###                           ("_applC" ("_position" insert)
###                             ("_cargs"
###                               ("_tuple" ("_position" x)
###                                 ("_tuple_arg" ("_position" z)))
###                               ("_position" A)))
###                           ("_position" A)))
###                       ("_position" xs5))))
###                 ("_cargs" ("_position" dxs3) ("\<^const>Set.empty"))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1612 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" Set_Monad) ("_position" xs6))
###       ("_applC" ("_position" DList_set) ("_position" dxs4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'f)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp Set_Monad DList_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" Set_Monad) ("_position" xs6))
###                   ("_applC" ("_position" DList_set) ("_position" dxs4)))))))
###         ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'g)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp Set_Monad DList_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" Set_Monad) ("_position" xs6))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs4)))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_applC" ("_position" fold)
###                   ("_cargs"
###                     ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                       ("_applC" ("_position" DList_Set.fold)
###                         ("_cargs"
###                           ("_lambda"
###                             ("_pttrns"
###                               ("_pattern" ("_position" y') ("_position" z))
###                               ("_position" A))
###                             ("\<^const>HOL.If"
###                               ("_applC" ("_position" eq)
###                                 ("_cargs" ("_position" y) ("_position" y')))
###                               ("_applC" ("_position" insert)
###                                 ("_cargs"
###                                   ("_tuple" ("_position" x)
###                                     ("_tuple_arg" ("_position" z)))
###                                   ("_position" A)))
###                               ("_position" A)))
###                           ("_position" dxs4))))
###                     ("_cargs" ("_position" xs6)
###                       ("\<^const>Set.empty"))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" Set_Monad) ("_position" xs6))
###       ("_applC" ("_position" DList_set) ("_position" dxs4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'f)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp Set_Monad DList_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" Set_Monad) ("_position" xs6))
###                   ("_applC" ("_position" DList_set) ("_position" dxs4)))))))
###         ("_case2"
###           ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'g)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp Set_Monad DList_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" Set_Monad) ("_position" xs6))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs4)))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_applC" ("_position" fold)
###               ("_cargs"
###                 ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                   ("_applC" ("_position" DList_Set.fold)
###                     ("_cargs"
###                       ("_lambda"
###                         ("_pttrns"
###                           ("_pattern" ("_position" y') ("_position" z))
###                           ("_position" A))
###                         ("\<^const>HOL.If"
###                           ("_applC" ("_position" eq)
###                             ("_cargs" ("_position" y) ("_position" y')))
###                           ("_applC" ("_position" insert)
###                             ("_cargs"
###                               ("_tuple" ("_position" x)
###                                 ("_tuple_arg" ("_position" z)))
###                               ("_position" A)))
###                           ("_position" A)))
###                       ("_position" dxs4))))
###                 ("_cargs" ("_position" xs6) ("\<^const>Set.empty"))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
locale vec_space
  fixes f_ty :: "'a itself"
    and n :: "nat"
### theory "Jordan_Normal_Form.VS_Connect"
### 8.129s elapsed time, 22.834s cpu time, 4.014s GC time
Loading theory "Jordan_Normal_Form.Gram_Schmidt" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Jordan_Normal_Form_Existence" via "Jordan_Normal_Form.Schur_Decomposition")
Loading theory "Jordan_Normal_Form.Matrix_Kernel" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Draft.Finite_Tensor_Product" via "Draft.Misc" via "Complex_Bounded_Operators.Cblinfun_Code")
locale kernel
  fixes nr :: "nat"
    and nc :: "nat"
    and A :: "'a mat"
  assumes "Matrix_Kernel.kernel nr nc A"
Found termination order: "(%p. length (snd (snd p))) <*mlex*> {}"
Found termination order: "(%p. length (snd (snd p))) <*mlex*> {}"
### Ambiguous input (line 1629 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.iff" ("_applC" ("_position" irrefl) ("_position" r))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###           ("_Ball" ("_pattern" ("_position" x) ("_position" y))
###             ("_position" r)
###             ("\<^const>HOL.Not"
###               ("_applC" ("_position" eq)
###                 ("_cargs" ("_position" x) ("_position" y))))))
###         ("_case1" ("_position" None)
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''irrefl: ceq = None & ccompare = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("_applC" ("_position" irrefl) ("_position" r))))))
###               ("_case1" ("_applC" ("_position" Some) ("_position" c))
###                 ("_Ball" ("_pattern" ("_position" x) ("_position" y))
###                   ("_position" r)
###                   ("\<^const>HOL.not_equal"
###                     ("_applC" ("_position" c)
###                       ("_cargs" ("_position" x) ("_position" y)))
###                     ("_position" Eq)))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.iff" ("_applC" ("_position" irrefl) ("_position" r))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###           ("_Ball" ("_pattern" ("_position" x) ("_position" y))
###             ("_position" r)
###             ("\<^const>HOL.Not"
###               ("_applC" ("_position" eq)
###                 ("_cargs" ("_position" x) ("_position" y))))))
###         ("_case2"
###           ("_case1" ("_position" None)
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'a)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''irrefl: ceq = None & ccompare = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("_applC" ("_position" irrefl) ("_position" r))))))))
###           ("_case1" ("_applC" ("_position" Some) ("_position" c))
###             ("_Ball" ("_pattern" ("_position" x) ("_position" y))
###               ("_position" r)
###               ("\<^const>HOL.not_equal"
###                 ("_applC" ("_position" c)
###                   ("_cargs" ("_position" x) ("_position" y)))
###                 ("_position" Eq)))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Found termination order: "(%p. length (snd (snd p))) <*mlex*> {}"
### Ambiguous input (line 1722 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" can_select)
###       ("_cargs" ("_position" P)
###         ("_applC" ("_position" Set_Monad) ("_position" xs))))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''can_select Set_Monad: ceq = None''))
###               ("_lambda" ("_idtdummy")
###                 ("_applC" ("_position" can_select)
###                   ("_cargs" ("_position" P)
###                     ("_applC" ("_position" Set_Monad)
###                       ("_position" xs))))))))
###         ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###           ("_case_syntax"
###             ("_applC" ("_position" filter)
###               ("_cargs" ("_position" P) ("_position" xs)))
###             ("_case2" ("_case1" ("_position" Nil) ("_position" False))
###               ("_case1"
###                 ("\<^const>List.list.Cons" ("_position" x) ("_position" xs))
###                 ("_applC" ("_position" list_all)
###                   ("_cargs" ("_applC" ("_position" eq) ("_position" x))
###                     ("_position" xs)))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" can_select)
###       ("_cargs" ("_position" P)
###         ("_applC" ("_position" Set_Monad) ("_position" xs))))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''can_select Set_Monad: ceq = None''))
###               ("_lambda" ("_idtdummy")
###                 ("_applC" ("_position" can_select)
###                   ("_cargs" ("_position" P)
###                     ("_applC" ("_position" Set_Monad)
###                       ("_position" xs))))))))
###         ("_case2"
###           ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###             ("_case_syntax"
###               ("_applC" ("_position" filter)
###                 ("_cargs" ("_position" P) ("_position" xs)))
###               ("_case1" ("_position" Nil) ("_position" False))))
###           ("_case1"
###             ("\<^const>List.list.Cons" ("_position" x) ("_position" xs))
###             ("_applC" ("_position" list_all)
###               ("_cargs" ("_applC" ("_position" eq) ("_position" x))
###                 ("_position" xs)))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Cannot skip proof of schematic goal statement
### Ambiguous input (line 1833 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_constrain" ("_position" set_empty_choose)
###       ("_tapp"
###         ("_ofsort" ("_position_sort" 'a)
###           ("_sort"
###             ("_classes" ("_class_name" ceq) ("_class_name" ccompare))))
###         ("_type_name" set)))
###     ("_case_syntax" ("_CCOMPARE" ("_position_sort" 'a))
###       ("_case2"
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_applC" ("_position" RBT_set) ("_position" RBT_Set2.empty)))
###         ("_case1" ("_position" None)
###           ("_case_syntax" ("_CEQ" ("_position_sort" 'a))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Set_Monad)
###                   ("\<^const>List.list.Nil")))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_applC" ("_position" DList_set)
###                   ("_position" DList_Set.empty))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_constrain" ("_position" set_empty_choose)
###       ("_tapp"
###         ("_ofsort" ("_position_sort" 'a)
###           ("_sort"
###             ("_classes" ("_class_name" ceq) ("_class_name" ccompare))))
###         ("_type_name" set)))
###     ("_case_syntax" ("_CCOMPARE" ("_position_sort" 'a))
###       ("_case2"
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_applC" ("_position" RBT_set) ("_position" RBT_Set2.empty)))
###         ("_case2"
###           ("_case1" ("_position" None)
###             ("_case_syntax" ("_CEQ" ("_position_sort" 'a))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Set_Monad)
###                   ("\<^const>List.list.Nil")))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_applC" ("_position" DList_set)
###               ("_position" DList_Set.empty))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
class set_impl = type +
  fixes set_impl :: "('a, set_impl) phantom"
signature SET_IMPL_GENERATOR =
  sig val derive_set_impl: string -> string -> theory -> theory end
structure Set_Impl_Generator: SET_IMPL_GENERATOR
use dlist as set_impl for type unit
registered unit in class set_impl
use dlist as set_impl for type bool
registered bool in class set_impl
use rbt as set_impl for type nat
registered nat in class set_impl
use set_RBT as set_impl for type int
locale cof_vec_space
  fixes n :: "nat"
    and f_ty :: "'a itself"
registered int in class set_impl
use dlist as set_impl for type finite_1
registered finite_1 in class set_impl
use dlist as set_impl for type finite_2
registered finite_2 in class set_impl
use dlist as set_impl for type finite_3
registered finite_3 in class set_impl
use rbt as set_impl for type integer
registered integer in class set_impl
use rbt as set_impl for type natural
registered natural in class set_impl
use rbt as set_impl for type char
registered char in class set_impl
instantiation
  sum :: (set_impl, set_impl) set_impl
  set_impl_sum == set_impl :: ('a + 'b, set_impl) phantom
instantiation
  prod :: (set_impl, set_impl) set_impl
  set_impl_prod == set_impl :: ('a * 'b, set_impl) phantom
use choose as set_impl for type list
registered list in class set_impl
use rbt as set_impl for type literal
registered literal in class set_impl
instantiation
  option :: (set_impl) set_impl
  set_impl_option == set_impl :: ('a option, set_impl) phantom
### theory "Jordan_Normal_Form.Gram_Schmidt"
### 1.427s elapsed time, 4.324s cpu time, 0.907s GC time
Loading theory "Jordan_Normal_Form.Schur_Decomposition" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl" via "Jordan_Normal_Form.Jordan_Normal_Form_Existence")
use monad as set_impl for type fun
registered fun in class set_impl
use choose as set_impl for type set
registered set in class set_impl
instantiation
  phantom :: (type, set_impl) set_impl
  set_impl_phantom == set_impl :: (('a, 'b) phantom, set_impl) phantom
### Ambiguous input (line 1952 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" set_aux) ("_position" set_Choose))
###     ("_case_syntax"
###       ("_CCOMPARE"
###         ("_ofsort" ("_position_sort" 'a)
###           ("_sort"
###             ("_classes" ("_class_name" ccompare) ("_class_name" ceq)))))
###       ("_case2"
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_applC" ("_position" conv)
###             ("_applC" ("_position" RBT_set) ("_position" RBT_Set2.empty))))
###         ("_case1" ("_position" None)
###           ("_case_syntax" ("_CEQ" ("_position_sort" 'a))
###             ("_case2" ("_case1" ("_position" None) ("_position" Set_Monad))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_applC" ("_position" conv)
###                   ("_applC" ("_position" DList_set)
###                     ("_position" DList_Set.empty)))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" set_aux) ("_position" set_Choose))
###     ("_case_syntax"
###       ("_CCOMPARE"
###         ("_ofsort" ("_position_sort" 'a)
###           ("_sort"
###             ("_classes" ("_class_name" ccompare) ("_class_name" ceq)))))
###       ("_case2"
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_applC" ("_position" conv)
###             ("_applC" ("_position" RBT_set) ("_position" RBT_Set2.empty))))
###         ("_case2"
###           ("_case1" ("_position" None)
###             ("_case_syntax" ("_CEQ" ("_position_sort" 'a))
###               ("_case1" ("_position" None) ("_position" Set_Monad))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_applC" ("_position" conv)
###               ("_applC" ("_position" DList_set)
###                 ("_position" DList_Set.empty)))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "Containers.Set_Impl"
### 17.749s elapsed time, 58.673s cpu time, 18.870s GC time
Loading theory "Jordan_Normal_Form.Matrix_IArray_Impl" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl")
locale vardim
  fixes f_ty :: "'a itself"
### theory "Jordan_Normal_Form.Matrix_Kernel"
### 57.241s elapsed time, 199.588s cpu time, 192.801s GC time
instantiation
  vec :: (type) equal
  equal_vec == equal_class.equal :: 'a vec => 'a vec => bool
instantiation
  mat :: (type) equal
  equal_mat == equal_class.equal :: 'a mat => 'a mat => bool
deriving "ceq" instance for type "Matrix.mat" via "="
derived is_ceq_mat-lemma
deriving "ceq" instance for type "Matrix.vec" via "="
derived is_ceq_vec-lemma
use None as trivial implementation of ccompare for type mat
registered mat in class ccompare
use None as trivial implementation of ccompare for type vec
registered vec in class ccompare
use dlist as set_impl for type mat
registered mat in class set_impl
use dlist as set_impl for type vec
registered vec in class set_impl
use None as trivial implementation of cenum for type mat
registered mat in class cenum
use None as trivial implementation of cenum for type vec
registered vec in class cenum
### theory "Jordan_Normal_Form.Matrix_IArray_Impl"
### 56.789s elapsed time, 197.505s cpu time, 192.003s GC time
Loading theory "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl")
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
### theory "Jordan_Normal_Form.Schur_Decomposition"
### 57.124s elapsed time, 198.313s cpu time, 192.077s GC time
Loading theory "Complex_Bounded_Operators.Extra_Jordan_Normal_Form" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Draft.Finite_Tensor_Product" via "Draft.Misc" via "Complex_Bounded_Operators.Cblinfun_Code" via "Complex_Bounded_Operators.Cblinfun_Matrix")
Loading theory "Jordan_Normal_Form.Jordan_Normal_Form_Existence" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Jordan_Normal_Form.Matrix_Impl")
bundle jnf_notation
bundle no_jnf_notation
Found termination order: "(%p. size (fst (snd p))) <*mlex*> {}"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
Found termination order:
  "(%p. size_list (%p. size (snd p)) (snd p)) <*mlex*> {}"
Found termination order: "(%p. size (fst (snd p))) <*mlex*> {}"
### theory "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl"
### 1.285s elapsed time, 3.735s cpu time, 0.365s GC time
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
Found termination order: "(%p. size (fst (snd (snd (snd p))))) <*mlex*> {}"
Found termination order:
  "(%p. size_list (%p. size (snd p)) (fst (snd (snd (snd p))))) <*mlex*> {}"
### theory "Jordan_Normal_Form.Jordan_Normal_Form_Existence"
### 2.765s elapsed time, 7.108s cpu time, 0.851s GC time
Loading theory "Jordan_Normal_Form.Matrix_Impl" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum")
Found termination order: "(%p. length (snd (snd p))) <*mlex*> {}"
*** Undefined fact: "lin_dep_iff_in_span" (line 181 of "$AFP/Complex_Bounded_Operators/extra/Extra_Jordan_Normal_Form.thy")2vectorspace.lin_dep_iff_in_spanfactVectorSpace.vectorspace.lin_dep_iff_in_spanVectorSpace.vectorspace.lin_dep_iff_in_spanfactVectorSpace.vectorspace.lin_dep_iff_in_span
*** At command "thm" (line 181 of "$AFP/Complex_Bounded_Operators/extra/Extra_Jordan_Normal_Form.thy")
locale complex_vec_space
  fixes n :: "nat"
[| M : carrier_mat ?m ?n; ?i < ?m; ?j < ?n |]
==> (M *\<^sub>v unit_vec ?n ?j) $ ?i = M $$ (?i, ?j)
### theory "Jordan_Normal_Form.Matrix_Impl"
### 1.394s elapsed time, 2.948s cpu time, 0.185s GC time
### theory "Complex_Bounded_Operators.Extra_Jordan_Normal_Form"
### 6.077s elapsed time, 17.628s cpu time, 1.474s GC time
Loading theory "Complex_Bounded_Operators.Cblinfun_Matrix" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Draft.Finite_Tensor_Product" via "Draft.Misc" via "Complex_Bounded_Operators.Cblinfun_Code")
"- 3208"
  :: "int"
"- 3208"
  :: "rat"
"''[[14, 34, 54, 74], [22, 56, 90, 124]]''"
  :: "char list"
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
"[:- 3208, - 10, - 1, - 7, 1:]"
  :: "real poly"
"[(3, 3), (1, 3), (2, 5)]"
  :: "(nat * rat) list"
"''Some [[55/1604, -169/1604, 241/3208, 35/802], [25/1604, 69/1604, 547/3208, -57/802], [73/802, 9/802, -103/1604, 10/401], [-135/1604, 269/1604, 575/3208, -13/802]]''"
  :: "char list"
"''None''"
  :: "char list"
### theory "Complex_Bounded_Operators.Cblinfun_Matrix"
### 6.265s elapsed time, 22.101s cpu time, 1.412s GC time
Loading theory "Complex_Bounded_Operators.Cblinfun_Code" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Draft.Finite_Tensor_Product" via "Draft.Misc")
instantiation
  cblinfun :: (onb_enum, onb_enum) equal
  equal_cblinfun == equal_class.equal ::
    'a \<Rightarrow>\<^sub>C\<^sub>L 'b
    => 'a \<Rightarrow>\<^sub>C\<^sub>L 'b => bool
instantiation
  ell2 :: (enum) equal
  equal_ell2 == equal_class.equal :: 'a ell2 => 'a ell2 => bool
instantiation
  ccsubspace :: (onb_enum) equal
  equal_ccsubspace == equal_class.equal ::
    'a ccsubspace => 'a ccsubspace => bool
deriving "ceq" instance for type "Complex_Vector_Spaces.ccsubspace" via "="
derived is_ceq_ccsubspace-lemma
use None as trivial implementation of ccompare for type ccsubspace
registered ccsubspace in class ccompare
use monad as set_impl for type ccsubspace
registered ccsubspace in class set_impl
deriving "ceq" instance for type "Complex_L2.ell2" via "="
derived is_ceq_ell2-lemma
use None as trivial implementation of ccompare for type ell2
registered ell2 in class ccompare
use monad as set_impl for type ell2
registered ell2 in class set_impl
### theory "Complex_Bounded_Operators.Cblinfun_Code"
### 5.052s elapsed time, 5.541s cpu time, 0.671s GC time
Loading theory "Draft.Misc" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum" via "Draft.Finite_Tensor_Product")
instantiation
  bit :: enum
  enum_bit == enum_class.enum :: bit list
  enum_all_bit == enum_class.enum_all :: (bit => bool) => bool
  enum_ex_bit == enum_class.enum_ex :: (bit => bool) => bool
instantiation
  bit :: card_UNIV
  card_UNIV_bit == card_UNIV_class.card_UNIV :: (bit, nat) phantom
  finite_UNIV_bit == finite_UNIV :: (bit, bool) phantom
instantiation
  prod :: (default, default) default
  default_prod == default :: 'a * 'b
### theory "Draft.Misc"
### 1.412s elapsed time, 1.523s cpu time, 0.152s GC time
Loading theory "Draft.Finite_Tensor_Product" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum" via "Draft.Axioms_Quantum")
[| cindependent ?S; cspan ?S = UNIV |]
==> cblinfun_extension_exists ?S \<phi>
### theory "Draft.Finite_Tensor_Product"
### 0.435s elapsed time, 0.509s cpu time, 0.100s GC time
Loading theory "Draft.Axioms_Quantum" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra" via "Draft.Laws_Quantum")
Loading theory "Draft.Finite_Tensor_Product_Matrices" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport")
Loading theory "Draft.Quantum" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra")
### theory "Draft.Finite_Tensor_Product_Matrices"
### 0.167s elapsed time, 0.494s cpu time, 0.000s GC time
deriving "ceq" instance for type "Z2.bit" via "="
derived is_ceq_bit-lemma
instantiation
  bit :: ccompare
  ccompare_bit == ccompare :: (bit => bit => order) option
use dlist as set_impl for type bit
registered bit in class set_impl
### theory "Draft.Quantum"
### 1.677s elapsed time, 3.646s cpu time, 0.267s GC time
### theory "Draft.Axioms_Quantum"
### 1.966s elapsed time, 3.937s cpu time, 0.267s GC time
Loading theory "Draft.Laws_Quantum" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare" via "Draft.Quantum_Extra")
### Ignoring duplicate rewrite rule:
### id_cblinfun *\<^sub>u ?y == ?y
### Ignoring duplicate rewrite rule:
### ?y *\<^sub>u id_cblinfun == ?y
bundle register_notation
bundle no_register_notation
### theory "Draft.Laws_Quantum"
### 2.153s elapsed time, 2.373s cpu time, 0.304s GC time
Loading theory "Draft.Quantum_Extra" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport" via "Draft.QHoare")
### theory "Draft.Quantum_Extra"
### 1.397s elapsed time, 1.505s cpu time, 0.146s GC time
Loading theory "Draft.QHoare" (required by "Draft.TeleportMoreTemplates" via "Draft.Teleport")
locale qhoare
  fixes memory_type :: "'mem itself"
### theory "Draft.QHoare"
### 0.153s elapsed time, 0.153s cpu time, 0.000s GC time
Loading theory "Draft.Teleport" (required by "Draft.TeleportMoreTemplates")
locale teleport_locale
  fixes
    X :: "bit ell2 \<Rightarrow>\<^sub>C\<^sub>L bit ell2
          => 'mem ell2 \<Rightarrow>\<^sub>C\<^sub>L 'mem ell2"
    and
    \<Phi> ::
      "(bit * bit) ell2 \<Rightarrow>\<^sub>C\<^sub>L (bit * bit) ell2
       => 'mem ell2 \<Rightarrow>\<^sub>C\<^sub>L 'mem ell2"
    and
    A :: "'atype ell2 \<Rightarrow>\<^sub>C\<^sub>L 'atype ell2
          => 'mem ell2 \<Rightarrow>\<^sub>C\<^sub>L 'mem ell2"
    and
    B :: "'btype ell2 \<Rightarrow>\<^sub>C\<^sub>L 'btype ell2
          => 'mem ell2 \<Rightarrow>\<^sub>C\<^sub>L 'mem ell2"
  assumes "teleport_locale X \<Phi> A B"
### Cannot skip proof of schematic goal statement
locale concrete_teleport_vars
### theory "Draft.Teleport"
### 1.887s elapsed time, 2.011s cpu time, 0.165s GC time
Loading theory "Draft.TeleportMoreTemplates"
norm ?\<psi> = 1 ==>
hoare
 (XAB =\<^sub>q ?\<psi> \<sqinter>
  (teleport_concrete.\<Phi>1;teleport_concrete.\<Phi>2) =\<^sub>q \<beta>00)
 (teleport ?a ?b) (\<Phi>2AB =\<^sub>q ?\<psi>)
teleport ?a ?b =
[apply CNOT X\<Phi>1, apply hadamard teleport_concrete.X, ifthen \<Phi>1 ?a,
 ifthen teleport_concrete.X ?b,
 apply (if ?a = 1 then pauliX else id_cblinfun) \<Phi>2,
 apply (if ?b = 1 then pauliZ else id_cblinfun) \<Phi>2]
val templateLemmas =
   [("Teleport.hoare_skip", "?C <= ?D ==> hoare ?C [] ?D",
     template_implication
      ([template_inequation (less_equals, template_var 1, template_var 0)],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 1, template_var 1),
               template_hole 0),
             template_var 0)
           ))),
    ("Teleport.program_seq",
     "program (?p1.0 @ ?p2.0) =
      program ?p2.0 o\<^sub>C\<^sub>L program ?p1.0",
     template_equation
      (template_app
        (template_hole 2,
         template_app
          (template_app (template_hole 1, template_var 1), template_var 0)),
       template_app
        (template_app
          (template_hole 0, template_app (template_hole 2, template_var 0)),
         template_app (template_hole 2, template_var 1)))),
    ("Teleport.X_X\<Phi>",
     "teleport_concrete.X ?a = X\<Phi> (?a \<otimes>\<^sub>o id_cblinfun)",
     template_equation
      (template_app (template_hole 6, template_var 0),
       template_app
        (template_app
          (template_app (template_hole 5, template_hole 6),
           template_app
            (template_app (template_hole 4, template_hole 3),
             template_hole 2)),
         template_app
          (template_app (template_hole 1, template_var 0),
           template_hole 0)))),
    ("Teleport.X_X\<Phi>1",
     "teleport_concrete.X ?a = X\<Phi>1 (?a \<otimes>\<^sub>o id_cblinfun)",
     template_equation
      (template_app (template_hole 7, template_var 0),
       template_app
        (template_app
          (template_app (template_hole 6, template_hole 7),
           template_app
            (template_app
              (template_hole 5,
               template_app
                (template_app (template_hole 6, template_hole 4),
                 template_hole 3)),
             template_hole 2)),
         template_app
          (template_app (template_hole 1, template_var 0),
           template_hole 0)))),
    ("Teleport.\<Phi>_X\<Phi>",
     "(teleport_concrete.\<Phi>1;teleport_concrete.\<Phi>2) ?a =
      X\<Phi> (id_cblinfun \<otimes>\<^sub>o ?a)",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 6, template_hole 5),
           template_hole 4),
         template_var 0),
       template_app
        (template_app
          (template_app (template_hole 3, template_hole 2),
           template_app
            (template_app (template_hole 6, template_hole 5),
             template_hole 4)),
         template_app
          (template_app (template_hole 1, template_hole 0),
           template_var 0)))),
    ("Teleport.to_X\<Phi>",
     "(teleport_concrete.\<Phi>1;teleport_concrete.\<Phi>2) ?aa =
      X\<Phi> (id_cblinfun \<otimes>\<^sub>o ?aa)",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 6, template_hole 5),
           template_hole 4),
         template_var 0),
       template_app
        (template_app
          (template_app (template_hole 3, template_hole 2),
           template_app
            (template_app (template_hole 6, template_hole 5),
             template_hole 4)),
         template_app
          (template_app (template_hole 1, template_hole 0),
           template_var 0)))),
    ("Teleport.hoare_weaken_left",
     "[| ?A <= ?B; hoare ?B ?p ?C |] ==> hoare ?A ?p ?C",
     template_implication
      ([template_inequation (less_equals, template_var 3, template_var 2),
        template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 0, template_var 2),
                template_var 1),
              template_var 0)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 0, template_var 3),
               template_var 1),
             template_var 0)
           ))),
    ("Teleport.hoare_weaken_right",
     "[| hoare ?A ?p ?B; ?B <= ?C |] ==> hoare ?A ?p ?C",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 1, template_var 3),
                template_var 2),
              template_var 1)
            ),
        template_inequation (less_equals, template_var 1, template_var 0)],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 1, template_var 3),
               template_var 2),
             template_var 0)
           ))),
    ("Teleport.hoare_apply",
     "?R ?U *\<^sub>S ?pre <= ?post ==> hoare ?pre [apply ?U ?R] ?post",
     template_implication
      ([template_inequation
         (less_equals,
          template_app
           (template_app
             (template_hole 4,
              template_app (template_var 3, template_var 2)),
            template_var 1),
          template_var 0)],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 3, template_var 1),
               template_app
                (template_app
                  (template_hole 2,
                   template_app
                    (template_app (template_hole 1, template_var 2),
                     template_var 3)),
                 template_hole 0)),
             template_var 0)
           ))),
    ("Teleport.\<Phi>1_X\<Phi>",
     "\<Phi>1 ?a =
      X\<Phi>
       (id_cblinfun \<otimes>\<^sub>o ?a \<otimes>\<^sub>o id_cblinfun)",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_hole 9,
             template_app
              (template_app (template_hole 8, template_hole 7),
               template_hole 6)),
           template_hole 5),
         template_var 0),
       template_app
        (template_app
          (template_app (template_hole 4, template_hole 3),
           template_app
            (template_app (template_hole 8, template_hole 7),
             template_hole 6)),
         template_app
          (template_app (template_hole 2, template_hole 1),
           template_app
            (template_app (template_hole 0, template_var 0),
             template_hole 1))))),
    ("Teleport.\<Phi>2_X\<Phi>",
     "\<Phi>2 ?a =
      X\<Phi>
       (id_cblinfun \<otimes>\<^sub>o id_cblinfun \<otimes>\<^sub>o ?a)",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_hole 9,
             template_app
              (template_app (template_hole 8, template_hole 7),
               template_hole 6)),
           template_hole 5),
         template_var 0),
       template_app
        (template_app
          (template_app (template_hole 4, template_hole 3),
           template_app
            (template_app (template_hole 8, template_hole 7),
             template_hole 6)),
         template_app
          (template_app (template_hole 2, template_hole 1),
           template_app
            (template_app (template_hole 0, template_hole 1),
             template_var 0))))),
    ("Teleport.X\<Phi>1_X\<Phi>",
     "X\<Phi>1 ?a = X\<Phi> (assoc (?a \<otimes>\<^sub>o id_cblinfun))",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 9, template_hole 8),
           template_app
            (template_app
              (template_hole 7,
               template_app
                (template_app (template_hole 9, template_hole 6),
                 template_hole 5)),
             template_hole 4)),
         template_var 0),
       template_app
        (template_app
          (template_app (template_hole 3, template_hole 8),
           template_app
            (template_app (template_hole 9, template_hole 6),
             template_hole 5)),
         template_app
          (template_hole 2,
           template_app
            (template_app (template_hole 1, template_var 0),
             template_hole 0))))),
    ("Teleport.to_X\<Phi>",
     "X\<Phi>1 ?aa = X\<Phi> (assoc (?aa \<otimes>\<^sub>o id_cblinfun))",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 9, template_hole 8),
           template_app
            (template_app
              (template_hole 7,
               template_app
                (template_app (template_hole 9, template_hole 6),
                 template_hole 5)),
             template_hole 4)),
         template_var 0),
       template_app
        (template_app
          (template_app (template_hole 3, template_hole 8),
           template_app
            (template_app (template_hole 9, template_hole 6),
             template_hole 5)),
         template_app
          (template_hole 2,
           template_app
            (template_app (template_hole 1, template_var 0),
             template_hole 0))))),
    ("Teleport.hoare_seq",
     "[| hoare ?C ?p1.0 ?D; hoare ?D ?p2.0 ?E |]
      ==> hoare ?C (?p1.0 @ ?p2.0) ?E",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 1, template_var 4),
                template_var 3),
              template_var 2)
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 1, template_var 2),
                template_var 1),
              template_var 0)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 1, template_var 4),
               template_app
                (template_app (template_hole 0, template_var 3),
                 template_var 1)),
             template_var 0)
           ))),
    ("Teleport.hoare_ifthen",
     "?R (selfbutterket ?x) *\<^sub>S ?pre <= ?post ==>
      hoare ?pre [ifthen ?R ?x] ?post",
     template_implication
      ([template_inequation
         (less_equals,
          template_app
           (template_app
             (template_hole 6,
              template_app
               (template_var 3,
                template_app
                 (template_app
                   (template_hole 5,
                    template_app (template_hole 4, template_var 2)),
                  template_app (template_hole 4, template_var 2)))),
            template_var 1),
          template_var 0)],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 3, template_var 1),
               template_app
                (template_app
                  (template_hole 2,
                   template_app
                    (template_app (template_hole 1, template_var 3),
                     template_var 2)),
                 template_hole 0)),
             template_var 0)
           ))),
    ("Teleport.X\<Phi>2_X\<Phi>",
     "X\<Phi>2 ?a =
      X\<Phi>
       ((id \<otimes>\<^sub>r swap)
         (assoc (?a \<otimes>\<^sub>o id_cblinfun)))",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 12, template_hole 11),
           template_app
            (template_app
              (template_hole 10,
               template_app
                (template_app (template_hole 12, template_hole 9),
                 template_hole 8)),
             template_hole 7)),
         template_var 0),
       template_app
        (template_app
          (template_app (template_hole 6, template_hole 11),
           template_app
            (template_app (template_hole 12, template_hole 9),
             template_hole 8)),
         template_app
          (template_app
            (template_app (template_hole 5, template_hole 4),
             template_hole 3),
           template_app
            (template_hole 2,
             template_app
              (template_app (template_hole 1, template_var 0),
               template_hole 0)))))),
    ("Teleport.to_X\<Phi>",
     "X\<Phi>2 ?aa =
      X\<Phi>
       ((id \<otimes>\<^sub>r swap)
         (assoc (?aa \<otimes>\<^sub>o id_cblinfun)))",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 12, template_hole 11),
           template_app
            (template_app
              (template_hole 10,
               template_app
                (template_app (template_hole 12, template_hole 9),
                 template_hole 8)),
             template_hole 7)),
         template_var 0),
       template_app
        (template_app
          (template_app (template_hole 6, template_hole 11),
           template_app
            (template_app (template_hole 12, template_hole 9),
             template_hole 8)),
         template_app
          (template_app
            (template_app (template_hole 5, template_hole 4),
             template_hole 3),
           template_app
            (template_hole 2,
             template_app
              (template_app (template_hole 1, template_var 0),
               template_hole 0)))))),
    ("Teleport.X\<Phi>2_to_X\<Phi>2_AB",
     "X\<Phi>2 ?a = (X\<Phi>2;AB) (?a \<otimes>\<^sub>o id_cblinfun)",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 11, template_hole 10),
           template_app
            (template_app
              (template_hole 9,
               template_app
                (template_app (template_hole 11, template_hole 8),
                 template_hole 7)),
             template_hole 6)),
         template_var 0),
       template_app
        (template_app
          (template_app
            (template_hole 5,
             template_app
              (template_app (template_hole 11, template_hole 10),
               template_app
                (template_app
                  (template_hole 9,
                   template_app
                    (template_app (template_hole 11, template_hole 8),
                     template_hole 7)),
                 template_hole 6))),
           template_app
            (template_app (template_hole 4, template_hole 3),
             template_hole 2)),
         template_app
          (template_app (template_hole 1, template_var 0),
           template_hole 0)))),
    ("Teleport.XAB_to_X\<Phi>2_AB",
     "XAB ?a =
      (X\<Phi>2;AB)
       ((swap \<otimes>\<^sub>r id)
         (assoc' (id_cblinfun \<otimes>\<^sub>o assoc ?a)))",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_hole 18,
             template_app
              (template_app (template_hole 17, template_hole 16),
               template_hole 15)),
           template_hole 14),
         template_var 0),
       template_app
        (template_app
          (template_app
            (template_hole 13,
             template_app
              (template_app (template_hole 12, template_hole 16),
               template_app
                (template_app
                  (template_hole 11,
                   template_app
                    (template_app (template_hole 12, template_hole 10),
                     template_hole 9)),
                 template_hole 8))),
           template_app
            (template_app (template_hole 7, template_hole 15),
             template_hole 14)),
         template_app
          (template_app
            (template_app (template_hole 6, template_hole 5),
             template_hole 4),
           template_app
            (template_hole 3,
             template_app
              (template_app (template_hole 2, template_hole 1),
               template_app (template_hole 0, template_var 0))))))),
    ("Teleport.to_X\<Phi>2_AB",
     "XAB ?aa =
      (X\<Phi>2;AB)
       ((swap \<otimes>\<^sub>r id)
         (assoc' (id_cblinfun \<otimes>\<^sub>o assoc ?aa)))",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_hole 18,
             template_app
              (template_app (template_hole 17, template_hole 16),
               template_hole 15)),
           template_hole 14),
         template_var 0),
       template_app
        (template_app
          (template_app
            (template_hole 13,
             template_app
              (template_app (template_hole 12, template_hole 16),
               template_app
                (template_app
                  (template_hole 11,
                   template_app
                    (template_app (template_hole 12, template_hole 10),
                     template_hole 9)),
                 template_hole 8))),
           template_app
            (template_app (template_hole 7, template_hole 15),
             template_hole 14)),
         template_app
          (template_app
            (template_app (template_hole 6, template_hole 5),
             template_hole 4),
           template_app
            (template_hole 3,
             template_app
              (template_app (template_hole 2, template_hole 1),
               template_app (template_hole 0, template_var 0))))))),
    ("Teleport.\<Phi>2AB_to_X\<Phi>2_AB",
     "\<Phi>2AB ?a =
      (X\<Phi>2;AB) (assoc' (id_cblinfun \<otimes>\<^sub>o assoc ?a))",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_hole 15,
             template_app
              (template_app
                (template_hole 14,
                 template_app
                  (template_app
                    (template_hole 13,
                     template_app
                      (template_app (template_hole 12, template_hole 11),
                       template_hole 10)),
                   template_hole 9)),
               template_hole 8)),
           template_hole 7),
         template_var 0),
       template_app
        (template_app
          (template_app
            (template_hole 6,
             template_app
              (template_app (template_hole 12, template_hole 5),
               template_app
                (template_app
                  (template_hole 13,
                   template_app
                    (template_app (template_hole 12, template_hole 11),
                     template_hole 10)),
                 template_hole 9))),
           template_app
            (template_app (template_hole 4, template_hole 8),
             template_hole 7)),
         template_app
          (template_hole 3,
           template_app
            (template_app (template_hole 2, template_hole 1),
             template_app (template_hole 0, template_var 0)))))),
    ("Teleport.to_X\<Phi>2_AB",
     "\<Phi>2AB ?aa =
      (X\<Phi>2;AB) (assoc' (id_cblinfun \<otimes>\<^sub>o assoc ?aa))",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_hole 15,
             template_app
              (template_app
                (template_hole 14,
                 template_app
                  (template_app
                    (template_hole 13,
                     template_app
                      (template_app (template_hole 12, template_hole 11),
                       template_hole 10)),
                   template_hole 9)),
               template_hole 8)),
           template_hole 7),
         template_var 0),
       template_app
        (template_app
          (template_app
            (template_hole 6,
             template_app
              (template_app (template_hole 12, template_hole 5),
               template_app
                (template_app
                  (template_hole 13,
                   template_app
                    (template_app (template_hole 12, template_hole 11),
                     template_hole 10)),
                 template_hole 9))),
           template_app
            (template_app (template_hole 4, template_hole 8),
             template_hole 7)),
         template_app
          (template_hole 3,
           template_app
            (template_app (template_hole 2, template_hole 1),
             template_app (template_hole 0, template_var 0)))))),
    ("Teleport.teleport",
     "norm ?\<psi> = 1 ==>
      hoare
       (XAB =\<^sub>q ?\<psi> \<sqinter>
        (teleport_concrete.\<Phi>1;teleport_concrete.\<Phi>2) =\<^sub>q
        \<beta>00)
       (teleport ?a ?b) (\<Phi>2AB =\<^sub>q ?\<psi>)",
     template_implication
      ([template_equation
         (template_app (template_hole 17, template_var 2),
          template_hole 16)],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_hole 15,
                 template_app
                  (template_app
                    (template_hole 14,
                     template_app
                      (template_app
                        (template_hole 13,
                         template_app
                          (template_app
                            (template_hole 12,
                             template_app
                              (template_app
                                (template_hole 11, template_hole 10),
                               template_hole 9)),
                           template_hole 8)),
                       template_var 2)),
                   template_app
                    (template_app
                      (template_hole 7,
                       template_app
                        (template_app (template_hole 6, template_hole 5),
                         template_hole 4)),
                     template_hole 3))),
               template_app
                (template_app
                  (template_app
                    (template_app (template_hole 2, template_hole 10),
                     template_app
                      (template_app (template_hole 6, template_hole 5),
                       template_hole 4)),
                   template_var 1),
                 template_var 0)),
             template_app
              (template_app
                (template_hole 13,
                 template_app
                  (template_app
                    (template_hole 12,
                     template_app
                      (template_app
                        (template_hole 11,
                         template_app
                          (template_app
                            (template_hole 1,
                             template_app
                              (template_app
                                (template_hole 6, template_hole 5),
                               template_hole 4)),
                           template_hole 0)),
                       template_hole 9)),
                   template_hole 8)),
               template_var 2))
           )))]:
   (string * thm * template) list
### theory "Draft.TeleportMoreTemplates"
### 2.662s elapsed time, 3.295s cpu time, 0.279s GC time
*** Undefined fact: "lin_dep_iff_in_span" (line 181 of "$AFP/Complex_Bounded_Operators/extra/Extra_Jordan_Normal_Form.thy")2vectorspace.lin_dep_iff_in_spanfactVectorSpace.vectorspace.lin_dep_iff_in_spanVectorSpace.vectorspace.lin_dep_iff_in_spanfactVectorSpace.vectorspace.lin_dep_iff_in_span
*** At command "thm" (line 181 of "$AFP/Complex_Bounded_Operators/extra/Extra_Jordan_Normal_Form.thy")
*** Undefined fact: "False" (line 2479 of "$AFP/Complex_Bounded_Operators/Complex_Bounded_Linear_Function.thy")12FalseEfactHOL.FalseEFalse_deffactHOL.False_defFalse_imp_not_eventuallyfactFilter.False_imp_not_eventuallyFalse_implies_equalsfactHOL.False_implies_equalsFalse_neq_TruefactHOL.False_neq_TrueFalse_not_TruefactHOL.False_not_TrueFilter.False_imp_not_eventuallyfactFilter.False_imp_not_eventuallyHOL.FalseEfactHOL.FalseEHOL.False_deffactHOL.False_defHOL.False_implies_equalsfactHOL.False_implies_equalsHOL.False_neq_TruefactHOL.False_neq_TrueHOL.False_not_TruefactHOL.False_not_True
*** At command "thm" (line 2479 of "$AFP/Complex_Bounded_Operators/Complex_Bounded_Linear_Function.thy")
Exception- TOPLEVEL_ERROR raised
