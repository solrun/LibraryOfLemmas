Loading theory "Draft.Preliminaries" (required by "Draft.Binding_SyntaxTemplates" via "Draft.Binding_Syntax" via "Draft.Semantic_Domains" via "Draft.Iteration" via "Draft.Well_Sorted_Terms" via "Draft.Terms" via "Draft.Transition_QuasiTerms_Terms" via "Draft.QuasiTerms_Environments_Substitution" via "Draft.QuasiTerms_PickFresh_Alpha" via "Draft.QuasiTerms_Swap_Fresh")
Loading theory "HOL-Library.Function_Algebras" (required by "Draft.Binding_SyntaxTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
Loading theory "Draft.Pick" (required by "Draft.Binding_SyntaxTemplates" via "Draft.Binding_Syntax" via "Draft.Semantic_Domains" via "Draft.Iteration" via "Draft.Well_Sorted_Terms" via "Draft.Terms" via "Draft.Transition_QuasiTerms_Terms" via "Draft.Equiv_Relation2")
Loading theory "HOL-Library.Nat_Bijection" (required by "Draft.Binding_SyntaxTemplates" via "Draft.ExtrEqs" via "HOL-Library.Stream")
instantiation
  fun :: (type, plus) plus
  plus_fun == plus :: ('a => 'b) => ('a => 'b) => 'a => 'b
### theory "Draft.Pick"
### 0.035s elapsed time, 0.169s cpu time, 0.000s GC time
Loading theory "HOL-Library.Set_Algebras" (required by "Draft.Binding_SyntaxTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
instantiation
  fun :: (type, zero) zero
  zero_fun == zero_class.zero :: 'a => 'b
instantiation
  fun :: (type, times) times
  times_fun == times :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  fun :: (type, one) one
  one_fun == one_class.one :: 'a => 'b
instantiation
  set :: (plus) plus
  plus_set == plus :: 'a set => 'a set => 'a set
instantiation
  set :: (times) times
  times_set == times :: 'a set => 'a set => 'a set
instantiation
  set :: (zero) zero
  zero_set == zero_class.zero :: 'a set
instantiation
  set :: (one) one
  one_set == one_class.one :: 'a set
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
### theory "HOL-Library.Function_Algebras"
### 0.145s elapsed time, 0.601s cpu time, 0.040s GC time
Loading theory "HOL-Library.Tree" (required by "Draft.Binding_SyntaxTemplates" via "Draft.ExtrEqs" via "Draft.Templates")
### theory "HOL-Library.Set_Algebras"
### 0.208s elapsed time, 0.817s cpu time, 0.040s GC time
Loading theory "HOL-Library.BigO" (required by "Draft.Binding_SyntaxTemplates" via "Draft.ExtrEqs")
Found termination order: "size_list size <*mlex*> {}"
### theory "HOL-Library.Nat_Bijection"
### 0.362s elapsed time, 1.449s cpu time, 0.119s GC time
Loading theory "HOL-Library.Stream" (required by "Draft.Binding_SyntaxTemplates" via "Draft.ExtrEqs")
### theory "Draft.Preliminaries"
### 0.617s elapsed time, 2.448s cpu time, 0.198s GC time
Loading theory "Draft.Equiv_Relation2" (required by "Draft.Binding_SyntaxTemplates" via "Draft.Binding_Syntax" via "Draft.Semantic_Domains" via "Draft.Iteration" via "Draft.Well_Sorted_Terms" via "Draft.Terms" via "Draft.Transition_QuasiTerms_Terms")
consts
  left :: "'a tree => 'a tree"
consts
  right :: "'a tree => 'a tree"
Found termination order: "size <*mlex*> {}"
consts
  shift :: "'a list => 'a stream => 'a stream"
Proofs for coinductive predicate(s) "streamsp"
  Proving monotonicity ...
Found termination order: "size <*mlex*> {}"
consts
  snth :: "'a stream => nat => 'a"
Found termination order: "size <*mlex*> {}"
consts
  stake :: "nat => 'a stream => 'a list"
consts
  sdrop :: "nat => 'a stream => 'a stream"
### theory "Draft.Equiv_Relation2"
### 0.310s elapsed time, 1.212s cpu time, 0.150s GC time
Loading theory "Draft.QuasiTerms_Swap_Fresh" (required by "Draft.Binding_SyntaxTemplates" via "Draft.Binding_Syntax" via "Draft.Semantic_Domains" via "Draft.Iteration" via "Draft.Well_Sorted_Terms" via "Draft.Terms" via "Draft.Transition_QuasiTerms_Terms" via "Draft.QuasiTerms_Environments_Substitution" via "Draft.QuasiTerms_PickFresh_Alpha")
class height = type +
  fixes height :: "'a => nat"
instantiation
  tree :: (type) height
  height_tree == height :: 'a tree => nat
consts
  sfilter :: "('a => bool) => 'a stream => 'a stream"
consts
  cycle :: "'a list => 'a stream"
Found termination order: "size <*mlex*> {}"
consts
  siterate :: "('a => 'a) => 'a => 'a stream"
Found termination order: "size <*mlex*> {}"
### theory "HOL-Library.BigO"
### 1.030s elapsed time, 3.862s cpu time, 0.960s GC time
consts
  flat :: "'a list stream => 'a stream"
Found termination order: "size <*mlex*> {}"
consts
  sinterleave :: "'a stream => 'a stream => 'a stream"
consts
  szip :: "'a stream => 'b stream => ('a * 'b) stream"
Found termination order: "size <*mlex*> {}"
consts
  smap2 :: "('a => 'b => 'c) => 'a stream => 'b stream => 'c stream"
### theory "HOL-Library.Stream"
### 1.119s elapsed time, 4.042s cpu time, 0.971s GC time
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
### theory "HOL-Library.Tree"
### 2.033s elapsed time, 6.370s cpu time, 1.196s GC time
Loading theory "Draft.Templates" (required by "Draft.Binding_SyntaxTemplates" via "Draft.ExtrEqs")
datatype template_term
=
     t_empty
   | template_app of template_term * template_term
   | template_hole of int
   | template_var of int
datatype sign
= equals | greater_equals | greater_than | less_equals | less_than
datatype template
=
     template_bimplication of template * template
   | template_dunno
   | template_equation of template_term * template_term
   | template_implication of template list * template
   | template_inequation of sign * template_term * template_term
   | template_negation of template
   | template_predicate of template_term
constructor t_empty: template_term
constructor template_app: template_term * template_term -> template_term
constructor template_hole: int -> template_term
constructor template_var: int -> template_term
constructor equals: sign
constructor greater_equals: sign
constructor greater_than: sign
constructor less_equals: sign
constructor less_than: sign
constructor template_bimplication: template * template -> template
constructor template_dunno: template
constructor template_equation: template_term * template_term -> template
constructor template_implication: template list * template -> template
constructor template_inequation:
   sign * template_term * template_term -> template
constructor template_negation: template -> template
constructor template_predicate: template_term -> template
val vfs = fn: term -> (indexname * typ) list * (string * typ) list
val indexOf = fn: ''a list -> ''a -> int -> int
val has_eq = fn: term -> bool
val term2template = fn:
   (indexname * typ) list -> (string * typ) list -> term -> template_term
val lemma2predicate = fn: term -> term -> template
val makeTemplatewithContext = fn: term -> term -> template
val lemma2template = fn: term -> template
val thm2template = fn: thm -> template
val tterm2string = fn: template_term -> string
val template2string = fn: template -> string
val t = "height ?t <= size ?t": thm
val th =
   Const ("HOL.Trueprop", "bool => prop") $
     (Const ("Orderings.ord_class.less_eq", "nat => nat => bool") $
       (Const ("Tree.height_class.height", "?'a tree => nat") $
         Var (("t", 0), "?'a tree")) $
       (Const ("Nat.size_class.size", "?'a tree => nat") $
         Var (("t", 0), "?'a tree"))):
   term
### theory "Draft.Templates"
### 0.074s elapsed time, 0.178s cpu time, 0.067s GC time
Loading theory "Draft.ExtrEqs" (required by "Draft.Binding_SyntaxTemplates")
val eqpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Var (("_dummy_", 2), "?'a"))
       ):
   term Find_Theorems.criterion
val badeqpattern = Pattern (Const ("Pure.eq", "?'a => ?'a => prop")):
   term Find_Theorems.criterion
val undefpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Const ("HOL.undefined", "?'a"))
       ):
   term Find_Theorems.criterion
val thmpattern =
   Pattern
    (Const ("HOL.Trueprop", "bool => prop") $ Var (("_dummy_", 1), "bool")):
   term Find_Theorems.criterion
val badnames =
   ["*nitpick*", "*Nitpick*", "*full_exhaustive*", "*_def*", "Enum.finite*",
    "*Quickcheck*", "ATP*", "*Nunchaku*", "*Code*", "*BNF*", "*SMT*",
    "*.*.*"]:
   string list
val unwanted_names =
   [(false, Name "*nitpick*"), (false, Name "*Nitpick*"),
    (false, Name "*full_exhaustive*"), (false, Name "*_def*"),
    (false, Name "Enum.finite*"), (false, Name "*Quickcheck*"),
    (false, Name "ATP*"), (false, Name "*Nunchaku*"),
    (false, Name "*Code*"), (false, Name "*BNF*"), (false, Name "*SMT*"),
    (false, Name "*.*.*")]:
   (bool * term Find_Theorems.criterion) list
val has_vars = fn: term -> bool
val get_all_eqs = fn: string -> Proof.context -> (string * thm) list
val get_all_thms = fn: string -> Proof.context -> (string * thm) list
val get_noneq_thms = fn: string -> Proof.context -> (string * thm) list
val template_eqs = fn:
   string -> Proof.context -> (string * thm * template) list
val template_thms = fn:
   string -> Proof.context -> (string * thm * template) list
### theory "Draft.ExtrEqs"
### 0.543s elapsed time, 1.138s cpu time, 0.125s GC time
Proofs for inductive predicate(s) "qSwappedp"
  Proving monotonicity ...
### theory "Draft.QuasiTerms_Swap_Fresh"
### 2.869s elapsed time, 5.684s cpu time, 1.206s GC time
Loading theory "Draft.QuasiTerms_PickFresh_Alpha" (required by "Draft.Binding_SyntaxTemplates" via "Draft.Binding_Syntax" via "Draft.Semantic_Domains" via "Draft.Iteration" via "Draft.Well_Sorted_Terms" via "Draft.Terms" via "Draft.Transition_QuasiTerms_Terms" via "Draft.QuasiTerms_Environments_Substitution")
locale FixVars
  fixes dummyV :: "'var"
    and dummyVS :: "'varSort"
  assumes "FixVars TYPE('var) TYPE('varSort)"
locale FixVars
  fixes dummyV :: "'var"
    and dummyVS :: "'varSort"
  assumes "FixVars TYPE('var) TYPE('varSort)"
Found termination order: "{}"
locale FixVars
  fixes dummyV :: "'var"
    and dummyVS :: "'varSort"
  assumes "FixVars TYPE('var) TYPE('varSort)"
"X'"
  :: "'a"
"binp"
  :: "'a"
### theory "Draft.QuasiTerms_PickFresh_Alpha"
### 1.583s elapsed time, 2.236s cpu time, 0.915s GC time
Loading theory "Draft.QuasiTerms_Environments_Substitution" (required by "Draft.Binding_SyntaxTemplates" via "Draft.Binding_Syntax" via "Draft.Semantic_Domains" via "Draft.Iteration" via "Draft.Well_Sorted_Terms" via "Draft.Terms" via "Draft.Transition_QuasiTerms_Terms")
locale FixVars
  fixes dummyV :: "'var"
    and dummyVS :: "'varSort"
  assumes "FixVars TYPE('var) TYPE('varSort)"
### theory "Draft.QuasiTerms_Environments_Substitution"
### 0.531s elapsed time, 0.598s cpu time, 0.096s GC time
Loading theory "Draft.Transition_QuasiTerms_Terms" (required by "Draft.Binding_SyntaxTemplates" via "Draft.Binding_Syntax" via "Draft.Semantic_Domains" via "Draft.Iteration" via "Draft.Well_Sorted_Terms" via "Draft.Terms")
locale FixVars
  fixes dummyV :: "'var"
    and dummyVS :: "'varSort"
  assumes "FixVars TYPE('var) TYPE('varSort)"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
locale FixVars
  fixes dummyV :: "'var"
    and dummyVS :: "'varSort"
  assumes "FixVars TYPE('var) TYPE('varSort)"
Proofs for inductive predicate(s) "swappedp"
  Proving monotonicity ...
### theory "Draft.Transition_QuasiTerms_Terms"
### 3.132s elapsed time, 4.074s cpu time, 1.325s GC time
Loading theory "Draft.Terms" (required by "Draft.Binding_SyntaxTemplates" via "Draft.Binding_Syntax" via "Draft.Semantic_Domains" via "Draft.Iteration" via "Draft.Well_Sorted_Terms")
locale FixVars
  fixes dummyV :: "'var"
    and dummyVS :: "'varSort"
  assumes "FixVars TYPE('var) TYPE('varSort)"
### theory "Draft.Terms"
### 0.942s elapsed time, 1.008s cpu time, 0.093s GC time
Loading theory "Draft.Well_Sorted_Terms" (required by "Draft.Binding_SyntaxTemplates" via "Draft.Binding_Syntax" via "Draft.Semantic_Domains" via "Draft.Iteration")
locale FixSyn
  fixes dummyV :: "'var"
    and Delta :: "('index, 'bindex, 'varSort, 'sort, 'opSym) signature"
  assumes "FixSyn TYPE('var) Delta"
locale FixSyn
  fixes dummyV :: "'var"
    and Delta :: "('index, 'bindex, 'varSort, 'sort, 'opSym) signature"
  assumes "FixSyn TYPE('var) Delta"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
locale FixSyn
  fixes dummyV :: "'var"
    and Delta :: "('index, 'bindex, 'varSort, 'sort, 'opSym) signature"
  assumes "FixSyn TYPE('var) Delta"
Proofs for inductive predicate(s) "wls", "wlsAbs", "wlsInp", "wlsBinp"
  Proving monotonicity ...
### Ignoring duplicate rewrite rule:
### [| wlsOpS ?delta1; barOf ?delta1 ?i1 = Some (?us1, ?s1) |]
### ==> isInBar (?us1, ?s1) == True
### Rewrite rule not in simpset:
### [| good ?y; goodEnv ?rhoa1; !!zs z. freshEnv zs z ?rhoa1 | fresh zs z ?y |]
### ==> ?y #[?rhoa1] == ?y
### Rewrite rule not in simpset:
### [| goodAbs ?y; goodEnv ?rhoa1;
###    !!zs z. freshEnv zs z ?rhoa1 | freshAbs zs z ?y |]
### ==> ?y $[?rhoa1] == ?y
### Rewrite rule not in simpset:
### termsOf (Par ?uu1 ?XLa1 ?uv1 ?uw1) == set ?XLa1
### Rewrite rule not in simpset:
### absOf (Par ?uu1 ?uva1 ?ALa1 ?uw1) == set ?ALa1
### Rewrite rule not in simpset:
### envsOf (Par ?uu1 ?uva1 ?uwa1 ?rhoL1) == set ?rhoL1
### Rewrite rule not in simpset:
### [| !!X. X : set ?XL1 ==> good X; !!A. A : set ?AL1 ==> goodAbs A;
###    !!rho. rho : set ?rhoLa1 ==> goodEnv rho |]
### ==> goodPar (Par ?xL1 ?XL1 ?AL1 ?rhoLa1) == True
### Rewrite rule not in simpset:
### good (Var ?xsa1 ?xa1) == True
### Rewrite rule not in simpset:
### [| goodInp ?inp1; goodBinp ?binpa1 |]
### ==> good (Op ?delta1 ?inp1 ?binpa1) == True
### Rewrite rule not in simpset:
### good ?X1 ==> goodAbs (Abs ?xsa1 ?xa1 ?X1) == True
### Rewrite rule not in simpset:
### good ?X1 ==> good (?X1 #[?xa1 \<and> ?y1]_?xsa1) == True
### Rewrite rule not in simpset:
### goodAbs ?A1 ==> goodAbs (?A1 $[?xa1 \<and> ?y1]_?xsa1) == True
### Rewrite rule not in simpset:
### goodInp ?inpa1 ==> goodInp (?inpa1 %[?xa1 \<and> ?y1]_?xsa1) == True
### Rewrite rule not in simpset:
### goodBinp ?binp1 ==> goodBinp (?binp1 %%[?xa1 \<and> ?y1]_?xsa1) == True
### Rewrite rule not in simpset:
### goodEnv ?rhoa1 ==> goodEnv (?rhoa1 &[?xa1 \<and> ?y1]_?xsa1) == True
### Rewrite rule not in simpset:
### [| goodEnv ?rhoa1; good ?X1 |] ==> good ?X1 #[?rhoa1] == True
### Rewrite rule not in simpset:
### [| goodEnv ?rhoa1; goodAbs ?A1 |] ==> goodAbs ?A1 $[?rhoa1] == True
### Rewrite rule not in simpset:
### [| goodEnv ?rhoa1; goodInp ?inpb1 |] ==> goodInp ?inpb1 %[?rhoa1] == True
### Rewrite rule not in simpset:
### [| goodEnv ?rhoa1; goodBinp ?binpb1 |]
### ==> goodBinp ?binpb1 %%[?rhoa1] == True
### Rewrite rule not in simpset:
### [| goodEnv ?rhoa1; goodEnv ?rho'1 |] ==> goodEnv ?rhoa1 &[?rho'1] == True
### Rewrite rule not in simpset:
### [| good ?X1; goodEnv ?rhoa1 |]
### ==> goodEnv (?rhoa1 [?xa1 \<leftarrow> ?X1]_?xsa1) == True
### Rewrite rule not in simpset:
### [| goodEnv ?rho1; ?rho1 ?xs1 ?x1 = Some ?Xa1 |] ==> good ?Xa1 == True
### Rewrite rule not in simpset:
### [| good ?X1; good ?Y1 |] ==> good (?Y1 #[?X1 / ?xa1]_?xsa1) == True
### Rewrite rule not in simpset:
### [| good ?X1; goodAbs ?A1 |] ==> goodAbs (?A1 $[?X1 / ?xa1]_?xsa1) == True
### Rewrite rule not in simpset:
### [| good ?X1; goodInp ?inpb1 |]
### ==> goodInp (?inpb1 %[?X1 / ?xa1]_?xsa1) == True
### Rewrite rule not in simpset:
### [| good ?X1; goodBinp ?binpb1 |]
### ==> goodBinp (?binpb1 %%[?X1 / ?xa1]_?xsa1) == True
### Rewrite rule not in simpset:
### [| good ?X1; goodEnv ?rhoa1 |]
### ==> goodEnv (?rhoa1 &[?X1 / ?xa1]_?xsa1) == True
### Rewrite rule not in simpset:
### good ?Y1 ==> good (?Y1 #[?x1.1 // ?xa1]_?xsa1) == True
### Rewrite rule not in simpset:
### goodAbs ?A1 ==> goodAbs (?A1 $[?x1.1 // ?xa1]_?xsa1) == True
### Rewrite rule not in simpset:
### goodInp ?inpa1 ==> goodInp (?inpa1 %[?x1.1 // ?xa1]_?xsa1) == True
### Rewrite rule not in simpset:
### goodBinp ?binp1 ==> goodBinp (?binp1 %%[?x1.1 // ?xa1]_?xsa1) == True
### Rewrite rule not in simpset:
### goodEnv ?rhoa1 ==> goodEnv (?rhoa1 &[?x1.1 // ?xa1]_?xsa1) == True
### Rewrite rule not in simpset:
### qSkel (qVar ?xsa1 ?xa1) == Branch Map.empty Map.empty
### Rewrite rule not in simpset:
### qSkel (qOp ?deltaa1 ?qinp1 ?qbinp1) ==
### Branch (qSkelInp ?qinp1) (qSkelBinp ?qbinp1)
### Rewrite rule not in simpset:
### qFresh ?xs1 ?x1 (qVar ?ys1 ?y1) == ?xs1 ~= ?ys1 | ?x1 ~= ?y1
### Rewrite rule not in simpset:
### qFresh ?xsb1 ?xb1 (qOp ?delta1 ?qinpa1 ?qbinpa1) ==
### qFreshInp ?xsb1 ?xb1 ?qinpa1 & qFreshBinp ?xsb1 ?xb1 ?qbinpa1
### Rewrite rule not in simpset:
### qVar ?zs'1 ?z1 #[[?x1 \<and> ?y1]]_?zs1 ==
### qVar ?zs'1 (?z1 @?zs'1[?x1 \<and> ?y1]_?zs1)
### Rewrite rule not in simpset:
### qOp ?deltaa1 ?qinp1 ?qbinp1 #[[?xa1 \<and> ?ya1]]_?xsa1 ==
### qOp ?deltaa1 (qSwapInp ?xsa1 ?xa1 ?ya1 ?qinp1)
###  (qSwapBinp ?xsa1 ?xa1 ?ya1 ?qbinp1)
### Rewrite rule not in simpset:
### qVar ?xsb1 ?xb1 #[[?rhoa1]] ==
### case ?rhoa1 ?xsb1 ?xb1 of None => qVar ?xsb1 ?xb1 | Some X => X
### Rewrite rule not in simpset:
### qOp ?delta1 ?qinpa1 ?qbinpa1 #[[?rho1]] ==
### qOp ?delta1 (?qinpa1 %[[?rho1]]) (?qbinpa1 %%[[?rho1]])
### Rewrite rule not in simpset:
### qGood (qVar ?xsb1 ?xb1) == True
### Rewrite rule not in simpset:
### qGood (qOp ?delta1 ?qinpa1 ?qbinpa1) ==
### qGoodInp ?qinpa1 & qGoodBinp ?qbinpa1
### Rewrite rule not in simpset:
### qVar ?xsa1 ?xa1 #= qVar ?xs'1 ?x'1 == ?xsa1 = ?xs'1 & ?xa1 = ?x'1
### Rewrite rule not in simpset:
### qOp ?deltaa1 ?qinp1 ?qbinp1 #= qOp ?delta'1 ?qinp'1 ?qbinp'1 ==
### ?deltaa1 = ?delta'1 &
### (?qinp1, ?qinp'1) : alphaInp & (?qbinp1, ?qbinp'1) : alphaBinp
### Rewrite rule not in simpset:
### qAbs ?xsa1 ?xa1 ?X1 $= qAbs ?xs'1 ?x'1 ?X'1 ==
### ?xsa1 = ?xs'1 &
### (EX y. y ~: {?xa1, ?x'1} &
###        qAFresh ?xsa1 y ?X1 &
###        qAFresh ?xs'1 y ?X'1 &
###        ?X1 #[[y \<and> ?xa1]]_?xsa1 #= ?X'1 #[[y \<and> ?x'1]]_?xs'1)
### Rewrite rule not in simpset:
### ?y #[[?xa1 \<and> ?xa1]]_?zsa1 == ?y
### Rewrite rule not in simpset:
### ?y #[[?xa1 \<and> ?ya1]]_?zsa1 #[[?xa1 \<and> ?ya1]]_?zsa1 == ?y
### Rewrite rule not in simpset:
### [| qAFresh ?zs1 ?z1.1 ?y; qAFresh ?zs1 ?z2.1 ?y |]
### ==> ?y #[[?z1.1 \<and> ?z2.1]]_?zs1 == ?y
### Rewrite rule not in simpset:
### qAFresh ?ys1 (?y1 @?ys1[?z1.1 \<and> ?z2.1]_?zs1)
###  (?Xa1 #[[?z1.1 \<and> ?z2.1]]_?zs1) ==
### qAFresh ?ys1 ?y1 ?Xa1
### Rewrite rule not in simpset:
### qAFresh ?xs1 ?x1 (qVar ?ys1 ?y1) == ?xs1 ~= ?ys1 | ?x1 ~= ?y1
### Rewrite rule not in simpset:
### qAFresh ?xs1 ?x1 (qOp ?deltaa1 ?inp1 ?binp1) ==
### liftAll (qAFresh ?xs1 ?x1) ?inp1 & liftAll (qAFreshAbs ?xs1 ?x1) ?binp1
### Rewrite rule not in simpset:
### qGoodItem (termIn ?qX1) == qGood ?qX1
### Rewrite rule not in simpset:
### qGoodItem (absIn ?qA1) == qGoodAbs ?qA1
### Rewrite rule not in simpset:
### [| ?f1 respectsP alphaGood; qGood ?Xa1 |]
### ==> Equiv_Relation2.univ ?f1 (asTerm ?Xa1) == ?f1 ?Xa1
### Rewrite rule not in simpset:
### [| ?fAbs1 respectsP alphaAbsGood; qGoodAbs ?Aa1 |]
### ==> Equiv_Relation2.univ ?fAbs1 (asAbs ?Aa1) == ?fAbs1 ?Aa1
### Rewrite rule not in simpset:
### [| ?f1 respectsP (#=); qGood ?Xa1 |]
### ==> Equiv_Relation2.univ ?f1 (asTerm ?Xa1) == ?f1 ?Xa1
### Rewrite rule not in simpset:
### [| ?fAbs1 respectsP ($=); qGoodAbs ?Aa1 |]
### ==> Equiv_Relation2.univ ?fAbs1 (asAbs ?Aa1) == ?fAbs1 ?Aa1
### Rewrite rule not in simpset:
### [| good ?X1; good ?Y1 |] ==> pick ?X1 = pick ?Y1 == ?X1 = ?Y1
### Rewrite rule not in simpset:
### [| goodAbs ?A1; goodAbs ?B1 |] ==> pick ?A1 = pick ?B1 == ?A1 = ?B1
### theory "Draft.Well_Sorted_Terms"
### 3.677s elapsed time, 4.048s cpu time, 0.524s GC time
Loading theory "Draft.Iteration" (required by "Draft.Binding_SyntaxTemplates" via "Draft.Binding_Syntax" via "Draft.Semantic_Domains")
locale FixSyn
  fixes dummyV :: "'var"
    and Delta :: "('index, 'bindex, 'varSort, 'sort, 'opSym) signature"
  assumes "FixSyn TYPE('var) Delta"
locale FixSyn
  fixes dummyV :: "'var"
    and Delta :: "('index, 'bindex, 'varSort, 'sort, 'opSym) signature"
  assumes "FixSyn TYPE('var) Delta"
### theory "Draft.Iteration"
### 6.263s elapsed time, 6.990s cpu time, 1.032s GC time
Loading theory "Draft.Recursion" (required by "Draft.Binding_SyntaxTemplates" via "Draft.Binding_Syntax")
Loading theory "Draft.Semantic_Domains" (required by "Draft.Binding_SyntaxTemplates" via "Draft.Binding_Syntax")
locale FixSyn
  fixes dummyV :: "'var"
    and Delta :: "('index, 'bindex, 'varSort, 'sort, 'opSym) signature"
  assumes "FixSyn TYPE('var) Delta"
Found termination order: "{}"
locale FixSyn
  fixes dummyV :: "'var"
    and Delta :: "('index, 'bindex, 'varSort, 'sort, 'opSym) signature"
  assumes "FixSyn TYPE('var) Delta"
locale FixSyn
  fixes dummyV :: "'var"
    and Delta :: "('index, 'bindex, 'varSort, 'sort, 'opSym) signature"
  assumes "FixSyn TYPE('var) Delta"
### theory "Draft.Semantic_Domains"
### 3.538s elapsed time, 7.594s cpu time, 1.523s GC time
### theory "Draft.Recursion"
### 5.727s elapsed time, 11.650s cpu time, 4.113s GC time
Loading theory "Draft.Binding_Syntax" (required by "Draft.Binding_SyntaxTemplates")
locale FixVars
  fixes dummyV :: "'var"
    and dummyVS :: "'varSort"
  assumes "FixVars TYPE('var) TYPE('varSort)"
[| FixVars TYPE(?'var) TYPE(?'varSort); !!p xs. |?varsOf xs p| <o |UNIV|;
   !!xs x p. ?phi (FixVars.Var xs x) p;
   !!delta inp binp p.
      [| |{i. inp i ~= None}| <o |UNIV|; |{i. binp i ~= None}| <o |UNIV|;
         liftAll (%X. FixVars.good X & (ALL q. ?phi X p)) inp;
         liftAll (%A. FixVars.goodAbs A & (ALL q. ?phiAbs A p)) binp |]
      ==> ?phi (FixVars.Op delta inp binp) p;
   !!xs x X p.
      [| FixVars.good X; x ~: ?varsOf p xs; ?phi X p |]
      ==> ?phiAbs (FixVars.Abs xs x X) p |]
==> (FixVars.good ?X --> (ALL p. ?phi ?X p)) &
    (FixVars.goodAbs ?A --> (ALL p. ?phiAbs ?A p))
find_theorems
  name: "local."
  -name: "q"
  -name: "alpha"
found 382 theorem(s):
local.var_infinite: var_infinite undefined
local.var_regular: var_regular undefined
local.idEnv_preserves_good: goodEnv idEnv
local.var_regular_INNER: regular |UNIV|
local.var_infinite_INNER: infinite UNIV
local.FixVars_axioms: FixVars TYPE('var) TYPE('varSort)
local.varSort_lt_var: varSort_lt_var undefined undefined
local.swappedp.Refl: swappedp ?X ?X
local.pickBinp_inj_on_goodBinp: inj_on pickBinp (Collect goodBinp)
local.pickInp_inj_on_goodInp: inj_on pickInp (Collect goodInp)
local.pick_inj_on_goodAbs: inj_on pick (Collect goodAbs)
local.pick_inj_on_good: inj_on pick (Collect good)
local.freshEnv_idEnv: freshEnv ?xs ?x idEnv
local.Var_preserves_good: good (Var ?xs ?x)
local.idEnv_def: idEnv == %xs. Map.empty
local.goodAbs_def: goodAbs == qGoodAbs /// alphaAbsGood
local.good_def: good == qGood /// alphaGood
local.psubstEnv_idEnv: idEnv &[?rho] = ?rho
local.getEnv_idEnv: idEnv ?xs ?x = None
local.swapped.Refl: (?X, ?X) : swapped
local.pickBinp_def: pickBinp ?binp == lift pick ?binp
local.pickInp_def: pickInp ?inp == lift pick ?inp
local.asBinp_def: asBinp ?qbinp == lift asAbs ?qbinp
local.asInp_def: asInp ?qinp == lift asTerm ?qinp
local.asAbs_def: asAbs ?qA == proj alphaAbsGood ?qA
local.asTerm_def: asTerm ?qX == proj alphaGood ?qX
local.skel_def: skel ?X == qSkel (pick ?X)
local.skelAbs_def: skelAbs ?A == qSkelAbs (pick ?A)
local.skelBinp_def: skelBinp ?binp = qSkelBinp (pickBinp ?binp)
local.skelInp_def: skelInp ?inp = qSkelInp (pickInp ?inp)
local.infinite_var_regular_INNER: infinite UNIV & regular |UNIV|
local.swapEnv_idEnv: idEnv &[?x \<and> ?y]_?xs = idEnv
local.varSort_le_Var: |UNIV| \<le>o |UNIV|
local.varSort_lt_var_INNER: |UNIV| <o |UNIV|
local.pickE_def: pickE ?rho == %xs. lift pick (?rho xs)
local.asEnv_def: asEnv ?qrho == %xs. lift asTerm (?qrho xs)
local.psubstBinp_def: ?binp %%[?rho] == lift (psubstAbs ?rho) ?binp
local.psubstInp_def: ?inp %[?rho] == lift (psubst ?rho) ?inp
local.Var_def: Var ?xs ?x == asTerm (qVar ?xs ?x)
local.swapEnv_defs(2): ?f o ?g = (%x. ?f (?g x))
local.swapped_def: swapped == {(x, y). swappedp x y}
local.Var_diff_Op: Var ?xs ?x ~= Op ?delta ?inp ?binp
local.Op_diff_Var: Op ?delta ?inp ?binp ~= Var ?xs ?x
local.param_simps(3): envsOf (Par ?uu ?uv ?uw ?rhoL) = set ?rhoL
local.param_simps(2): absOf (Par ?uu ?uv ?AL ?uw) = set ?AL
local.param_simps(1): termsOf (Par ?uu ?XL ?uv ?uw) = set ?XL
local.swap_swapped: (?X, ?X #[?x \<and> ?y]_?zs) : swapped
local.psubstAbs_def: ?A $[?rho] == asAbs pick ?A $[[pickE ?rho]]
local.psubst_def: ?X #[?rho] == asTerm pick ?X #[[pickE ?rho]]
local.fresh_def: fresh ?xs ?x ?X == qFresh ?xs ?x (pick ?X)
local.freshAbs_def: freshAbs ?xs ?x ?A == qFreshAbs ?xs ?x (pick ?A)
local.freshBinp_def:
  freshBinp ?xs ?x ?binp == liftAll (freshAbs ?xs ?x) ?binp
local.freshInp_def: freshInp ?xs ?x ?inp == liftAll (fresh ?xs ?x) ?inp
local.pick_asTerm: qGood ?qX ==> pick (asTerm ?qX) #= ?qX
local.pick_asAbs: qGoodAbs ?qA ==> pick (asAbs ?qA) $= ?qA
local.asTerm_pick: good ?X ==> asTerm (pick ?X) = ?X
local.psubst_idEnv: good ?X ==> ?X #[idEnv] = ?X
local.Abs_preserves_good: good ?X ==> goodAbs (Abs ?xs ?x ?X)
local.asAbs_pick: goodAbs ?A ==> asAbs (pick ?A) = ?A
local.psubstAbs_idEnv: goodAbs ?A ==> ?A $[idEnv] = ?A
local.asBinp_pickBinp: goodBinp ?binp ==> asBinp (pickBinp ?binp) = ?binp
local.psubstEnv_idEnv_id: goodEnv ?rho ==> ?rho &[idEnv] = ?rho
local.asInp_pickInp: goodInp ?inp ==> asInp (pickInp ?inp) = ?inp
local.substBinp_def2: substBinp ?ys ?Y ?y = lift (substAbs ?ys ?Y ?y)
local.substInp_def2: substInp ?ys ?Y ?y = lift (subst ?ys ?Y ?y)
local.freshBinp_def2:
  freshBinp ?xs ?x ?binp = qFreshBinp ?xs ?x (pickBinp ?binp)
local.freshEnv_def2: freshEnv ?xs ?x ?rho = qFreshEnv ?xs ?x (pickE ?rho)
local.freshInp_def2: freshInp ?xs ?x ?inp = qFreshInp ?xs ?x (pickInp ?inp)
local.getEnv_updEnv2: (?rho [?x \<leftarrow> ?X]_?xs) ?xs ?x = Some ?X
local.skel_Var_simp: skel (Var ?xs ?x) = Branch Map.empty Map.empty
local.substBinp_def:
  substBinp ?xs ?X ?x == psubstBinp (idEnv [?x \<leftarrow> ?X]_?xs)
local.vsubstBinp_def:
  vsubstBinp ?ys ?y1.0 ?y2.0 == substBinp ?ys (Var ?ys ?y1.0) ?y2.0
local.substInp_def:
  substInp ?xs ?X ?x == psubstInp (idEnv [?x \<leftarrow> ?X]_?xs)
local.vsubstInp_def:
  vsubstInp ?ys ?y1.0 ?y2.0 == substInp ?ys (Var ?ys ?y1.0) ?y2.0
local.substEnv_def:
  substEnv ?xs ?X ?x == psubstEnv (idEnv [?x \<leftarrow> ?X]_?xs)
local.vsubstEnv_def:
  vsubstEnv ?ys ?y1.0 ?y2.0 == substEnv ?ys (Var ?ys ?y1.0) ?y2.0
local.substAbs_def:
  substAbs ?xs ?X ?x == psubstAbs (idEnv [?x \<leftarrow> ?X]_?xs)
local.vsubstAbs_def:
  vsubstAbs ?ys ?y1.0 ?y2.0 == substAbs ?ys (Var ?ys ?y1.0) ?y2.0
local.subst_def: subst ?xs ?X ?x == psubst (idEnv [?x \<leftarrow> ?X]_?xs)
local.vsubst_def: vsubst ?ys ?y1.0 ?y2.0 == subst ?ys (Var ?ys ?y1.0) ?y2.0
local.Abs_def: Abs ?xs ?x ?X == asAbs (qAbs ?xs ?x (pick ?X))
local.swap_preserves_good: good ?X ==> good (?X #[?x \<and> ?y]_?xs)
local.vsubst_preserves_good: good ?Y ==> good (?Y #[?x1.0 // ?x]_?xs)
local.swapAbs_preserves_good:
  goodAbs ?A ==> goodAbs (?A $[?x \<and> ?y]_?xs)
local.vsubstAbs_preserves_good:
  goodAbs ?A ==> goodAbs (?A $[?x1.0 // ?x]_?xs)
local.skelBinp_def2: goodBinp ?binp ==> skelBinp ?binp = lift skelAbs ?binp
local.swapBinp_preserves_good:
  goodBinp ?binp ==> goodBinp (?binp %%[?x \<and> ?y]_?xs)
local.vsubstBinp_preserves_good:
  goodBinp ?binp ==> goodBinp (?binp %%[?x1.0 // ?x]_?xs)
local.swapEnvDom_preserves_good:
  goodEnv ?rho ==> goodEnv (swapEnvDom ?xs ?x ?y ?rho)
local.swapEnvIm_preserves_good:
  goodEnv ?rho ==> goodEnv (swapEnvIm ?xs ?x ?y ?rho)
local.swapEnv_preserves_good:
  goodEnv ?rho ==> goodEnv (?rho &[?x \<and> ?y]_?xs)
local.vsubstEnv_preserves_good:
  goodEnv ?rho ==> goodEnv (?rho &[?x1.0 // ?x]_?xs)
local.skelInp_def2: goodInp ?inp ==> skelInp ?inp = lift skel ?inp
local.swapInp_preserves_good:
  goodInp ?inp ==> goodInp (?inp %[?x \<and> ?y]_?xs)
local.vsubstInp_preserves_good:
  goodInp ?inp ==> goodInp (?inp %[?x1.0 // ?x]_?xs)
local.substEnv_idEnv: idEnv &[?X / ?x]_?xs = idEnv [?x \<leftarrow> ?X]_?xs
local.swapEnv_sym: ?rho &[?x \<and> ?y]_?zs = ?rho &[?y \<and> ?x]_?zs
local.swap_sym: ?X #[?x \<and> ?y]_?zs = ?X #[?y \<and> ?x]_?zs
local.swapBinp_def:
  ?binp %%[?x \<and> ?y]_?xs == lift (swapAbs ?xs ?x ?y) ?binp
local.swapInp_def: ?inp %[?x \<and> ?y]_?xs == lift (swap ?xs ?x ?y) ?inp
local.Op_def:
  Op ?delta ?inp ?binp ==
  asTerm (qOp ?delta (pickInp ?inp) (pickBinp ?binp))
local.pickE_asEnv: qGoodEnv ?qrho ==> pickE (asEnv ?qrho) &= ?qrho
local.swap_ident: good ?X ==> ?X #[?x \<and> ?x]_?xs = ?X
local.vsubst_ident: good ?X ==> ?X #[?z // ?z]_?zs = ?X
local.vsubstAbs_ident: goodAbs ?A ==> ?A $[?z // ?z]_?zs = ?A
local.swapEnv_ident: goodEnv ?rho ==> ?rho &[?x \<and> ?x]_?xs = ?rho
local.pickBinp_asBinp:
  qGoodBinp ?qbinp ==> (pickBinp (asBinp ?qbinp), ?qbinp) : alphaBinp
local.pickInp_asInp:
  qGoodInp ?qinp ==> (pickInp (asInp ?qinp), ?qinp) : alphaInp
local.freshEnv_getEnv: freshEnv ?ys ?y ?rho ==> ?rho ?ys ?y = None
local.vsubstBinp_def2:
  ?binp %%[?y1.0 // ?y2.0]_?ys = lift (vsubstAbs ?ys ?y1.0 ?y2.0) ?binp
local.vsubstInp_def2:
  ?inp %[?y1.0 // ?y2.0]_?ys = lift (vsubst ?ys ?y1.0 ?y2.0) ?inp
local.psubst_preserves_good: [| goodEnv ?rho; good ?X |] ==> good ?X #[?rho]
local.psubstAbs_preserves_good:
  [| goodEnv ?rho; goodAbs ?A |] ==> goodAbs ?A $[?rho]
local.psubstBinp_preserves_good:
  [| goodEnv ?rho; goodBinp ?binp |] ==> goodBinp ?binp %%[?rho]
local.psubstEnv_preserves_good:
  [| goodEnv ?rho; goodEnv ?rho' |] ==> goodEnv ?rho &[?rho']
local.psubstInp_preserves_good:
  [| goodEnv ?rho; goodInp ?inp |] ==> goodInp ?inp %[?rho]
local.envsOf_preserves_good:
  [| goodPar ?P; ?rho : envsOf ?P |] ==> goodEnv ?rho
local.absOf_preserves_good: [| goodPar ?P; ?A : absOf ?P |] ==> goodAbs ?A
local.termsOf_preserves_good: [| goodPar ?P; ?X : termsOf ?P |] ==> good ?X
local.swappedp.Swap: swappedp ?X ?Y ==> swappedp ?X (?Y #[?x \<and> ?y]_?zs)
local.swapBinp_def2:
  ?binp %%[?x1.0 \<and> ?x2.0]_?xs =
  asBinp (qSwapBinp ?xs ?x1.0 ?x2.0 (pickBinp ?binp))
local.swapInp_def2:
  ?inp %[?x1.0 \<and> ?x2.0]_?xs =
  asInp (qSwapInp ?xs ?x1.0 ?x2.0 (pickInp ?inp))
local.substEnv_psubstEnv_idEnv:
  ?rho &[?Y / ?y]_?ys = ?rho &[idEnv [?y \<leftarrow> ?Y]_?ys]
local.vsubstEnv_idEnv:
  idEnv &[?y // ?x]_?xs = idEnv [?x \<leftarrow> Var ?xs ?y]_?xs
local.swapAbs_def:
  ?A $[?x \<and> ?y]_?xs = asAbs (pick ?A $[[?x \<and> ?y]]_?xs)
local.subst_psubst_idEnv:
  ?X #[?Y / ?y]_?ys = ?X #[idEnv [?y \<leftarrow> ?Y]_?ys]
local.swap_def:
  ?X #[?x \<and> ?y]_?xs = asTerm (pick ?X #[[?x \<and> ?y]]_?xs)
local.swapEnvIm_def:
  swapEnvIm ?xs ?x ?y ?rho == %zs. lift (swap ?xs ?x ?y) (?rho zs)
local.swapEnv_def:
  swapEnv ?xs ?x ?y == swapEnvIm ?xs ?x ?y o swapEnvDom ?xs ?x ?y
local.subst_ident: good ?X ==> ?X #[Var ?zs ?z / ?z]_?zs = ?X
local.skel_swap: good ?X ==> skel (?X #[?x1.0 \<and> ?x2.0]_?xs) = skel ?X
local.skel_vsubst: good ?X ==> skel (?X #[?y1.0 // ?y2.0]_?ys) = skel ?X
local.swapped_preserves_good: [| good ?X; (?X, ?Y) : swapped |] ==> good ?Y
local.subst_Var_simp2: good ?Y ==> Var ?xs ?x #[?Y / ?x]_?xs = ?Y
local.substAbs_ident: goodAbs ?A ==> ?A $[Var ?zs ?z / ?z]_?zs = ?A
local.skelAbs_vsubstAbs:
  goodAbs ?A ==> skelAbs (?A $[?y1.0 // ?y2.0]_?ys) = skelAbs ?A
local.asEnv_pickE: goodEnv ?rho ==> asEnv (pickE ?rho) ?xs ?x = ?rho ?xs ?x
local.Op_preserves_good:
  [| goodInp ?inp; goodBinp ?binp |] ==> good (Op ?delta ?inp ?binp)
local.swappedp.Trans:
  [| swappedp ?X ?Y; swappedp ?Y ?Z |] ==> swappedp ?X ?Z
local.subst_preserves_good:
  [| good ?X; good ?Y |] ==> good (?Y #[?X / ?x]_?xs)
local.substAbs_preserves_good:
  [| good ?X; goodAbs ?A |] ==> goodAbs (?A $[?X / ?x]_?xs)
local.substBinp_preserves_good:
  [| good ?X; goodBinp ?binp |] ==> goodBinp (?binp %%[?X / ?x]_?xs)
local.substEnv_preserves_good:
  [| good ?X; goodEnv ?rho |] ==> goodEnv (?rho &[?X / ?x]_?xs)
local.updEnv_preserves_good:
  [| good ?X; goodEnv ?rho |] ==> goodEnv (?rho [?x \<leftarrow> ?X]_?xs)
local.substInp_preserves_good:
  [| good ?X; goodInp ?inp |] ==> goodInp (?inp %[?X / ?x]_?xs)
local.getEnv_preserves_good:
  [| goodEnv ?rho; ?rho ?xs ?x = Some ?X |] ==> good ?X
local.freshEnv_updEnv_E1:
  freshEnv ?xs ?y (?rho [?x \<leftarrow> ?X]_?xs) ==> ?y ~= ?x
local.freshEnv_updEnv_E2:
  freshEnv ?ys ?y (?rho [?x \<leftarrow> ?X]_?xs) ==> fresh ?ys ?y ?X
local.vsubstEnv_psubstEnv_idEnv:
  ?rho &[?z // ?y]_?ys = ?rho &[idEnv [?y \<leftarrow> Var ?ys ?z]_?ys]
local.psubstEnv_updEnv_idEnv:
  idEnv [?x \<leftarrow> ?X]_?xs &[?rho] =
  ?rho [?x \<leftarrow> ?X #[?rho]]_?xs
local.updEnv_overwrite:
  ?rho [?x \<leftarrow> ?X]_?xs [?x \<leftarrow> ?X']_?xs =
  ?rho [?x \<leftarrow> ?X']_?xs
local.vsubst_psubst_idEnv:
  ?X #[?z // ?y]_?ys = ?X #[idEnv [?y \<leftarrow> Var ?ys ?z]_?ys]
local.Var_inj: (Var ?xs ?x = Var ?ys ?y) = (?xs = ?ys & ?x = ?y)
local.swapEnvDom_def:
  swapEnvDom ?xs ?x ?y ?rho == %zs z. ?rho zs (z @zs[?x \<and> ?y]_?xs)
local.swap_involutive:
  good ?X ==> ?X #[?x \<and> ?y]_?zs #[?x \<and> ?y]_?zs = ?X
local.swap_involutive2:
  good ?X ==> ?X #[?x \<and> ?y]_?zs #[?y \<and> ?x]_?zs = ?X
local.swapEnv_involutive:
  goodEnv ?rho ==> ?rho &[?x \<and> ?y]_?zs &[?x \<and> ?y]_?zs = ?rho
local.swapEnv_involutive2:
  goodEnv ?rho ==> ?rho &[?x \<and> ?y]_?zs &[?y \<and> ?x]_?zs = ?rho
local.freshEnv_updEnv_E3:
  freshEnv ?ys ?y (?rho [?x \<leftarrow> ?X]_?xs) ==> ?rho ?ys ?y = None
local.swap_Var_simp:
  Var ?xs ?x #[?y1.0 \<and> ?y2.0]_?ys =
  Var ?xs (?x @?xs[?y1.0 \<and> ?y2.0]_?ys)
local.vsubst_Var_simp:
  Var ?xs ?x #[?y1.0 // ?y]_?ys = Var ?xs (?x @?xs[?y1.0 / ?y]_?ys)
local.fresh_Var_simp: fresh ?ys ?y (Var ?xs ?x) = (?ys ~= ?xs | ?y ~= ?x)
local.swapped_skel: [| good ?X; (?X, ?Y) : swapped |] ==> skel ?Y = skel ?X
local.getEnv_substEnv4:
  freshEnv ?ys ?y ?rho ==> (?rho &[?Y / ?y]_?ys) ?ys ?y = Some ?Y
local.getEnv_psubstEnv_None:
  ?rho ?xs ?x = None ==> ?rho &[?rho'] ?xs ?x = ?rho' ?xs ?x
local.swapped.Swap:
  (?X, ?Y) : swapped ==> (?X, ?Y #[?x \<and> ?y]_?zs) : swapped
local.getEnv_ext: (!!xs x. ?rho xs x = ?rho' xs x) ==> ?rho = ?rho'
local.psubstAll_idEnv:
  (good ?X --> ?X #[idEnv] = ?X) & (goodAbs ?A --> ?A $[idEnv] = ?A)
local.psubstEnv_updEnv:
  ?rho [?x \<leftarrow> ?X]_?xs &[?rho'] =
  ?rho &[?rho'] [?x \<leftarrow> ?X #[?rho']]_?xs
local.psubstEnv_def:
  ?rho' &[?rho] ==
  %xs x. case ?rho' xs x of None => ?rho xs x | Some X => Some X #[?rho]
local.fresh_swap_exchange1:
  good ?X ==>
  fresh ?xs ?x2.0 (?X #[?x1.0 \<and> ?x2.0]_?xs) = fresh ?xs ?x1.0 ?X
local.skelAbs_simp:
  good ?X ==>
  skelAbs (Abs ?xs ?x ?X) = Branch (%i. Some (skel ?X)) Map.empty
local.single_non_fresh_ordLess_var:
  good ?X ==> |{x. ~ fresh ?xs x ?X}| <o |UNIV|
local.pick_injective_good:
  [| good ?X; good ?Y |] ==> (pick ?X = pick ?Y) = (?X = ?Y)
local.fresh_vsubst_ident:
  [| good ?Y; fresh ?xs ?x ?Y |] ==> ?Y #[?x1.0 // ?x]_?xs = ?Y
local.single_non_freshAbs_ordLess_var:
  goodAbs ?A ==> |{x. ~ freshAbs ?xs x ?A}| <o |UNIV|
local.pick_injective_goodAbs:
  [| goodAbs ?A; goodAbs ?B |] ==> (pick ?A = pick ?B) = (?A = ?B)
local.freshAbs_vsubstAbs_ident:
  [| goodAbs ?A; freshAbs ?xs ?x ?A |] ==> ?A $[?x1.0 // ?x]_?xs = ?A
local.freshEnv_swapEnv_exchange1:
  goodEnv ?rho ==>
  freshEnv ?xs ?x2.0 (?rho &[?x1.0 \<and> ?x2.0]_?xs) =
  freshEnv ?xs ?x1.0 ?rho
local.freshEnv_swapEnv_exchange2:
  goodEnv ?rho ==>
  freshEnv ?xs ?x2.0 (?rho &[?x2.0 \<and> ?x1.0]_?xs) =
  freshEnv ?xs ?x1.0 ?rho
local.finite_ordLess_var: (|?S| <o |UNIV| | finite ?S) = (|?S| <o |UNIV|)
local.freshEnv_def:
  freshEnv ?xs ?x ?rho ==
  ?rho ?xs ?x = None & (ALL ys. liftAll (fresh ?xs ?x) (?rho ys))
local.diff_fresh_vsubst:
  [| good ?X; ?y ~= ?y1.0 |] ==> fresh ?ys ?y (?X #[?y1.0 // ?y]_?ys)
local.diff_freshAbs_vsubstAbs:
  [| goodAbs ?A; ?y ~= ?y1.0 |] ==> freshAbs ?ys ?y (?A $[?y1.0 // ?y]_?ys)
local.freshEnv_getEnv2:
  [| freshEnv ?ys ?y ?rho; ?rho ?xs ?x = Some ?X |] ==> fresh ?ys ?y ?X
local.getEnv_vsubstEnv4:
  freshEnv ?ys ?y ?rho ==> (?rho &[?z // ?y]_?ys) ?ys ?y = Some (Var ?ys ?z)
local.getEnv_psubstEnv_Some:
  ?rho ?xs ?x = Some ?X ==> ?rho &[?rho'] ?xs ?x = Some ?X #[?rho']
local.getEnv_updEnv_idEnv:
  (idEnv [?x \<leftarrow> ?X]_?xs) ?ys ?y =
  (if ?ys = ?xs & ?y = ?x then Some ?X else None)
local.goodBinp_def:
  goodBinp ?binp == liftAll goodAbs ?binp & |{i. ?binp i ~= None}| <o |UNIV|
local.goodInp_def:
  goodInp ?inp == liftAll good ?inp & |{i. ?inp i ~= None}| <o |UNIV|
local.abs_nchotomy: goodAbs ?A ==> EX xs x X. good X & ?A = Abs xs x X
local.psubst_Var:
  goodEnv ?rho ==>
  Var ?xs ?x #[?rho] =
  (case ?rho ?xs ?x of None => Var ?xs ?x | Some X => X)
local.psubst_Var_simp2:
  [| goodEnv ?rho; ?rho ?xs ?x = Some ?X |] ==> Var ?xs ?x #[?rho] = ?X
local.skel_Op_simp:
  [| goodInp ?inp; goodBinp ?binp |]
  ==> skel (Op ?delta ?inp ?binp) = Branch (skelInp ?inp) (skelBinp ?binp)
local.swapped.Trans:
  [| (?X, ?Y) : swapped; (?Y, ?Z) : swapped |] ==> (?X, ?Z) : swapped
local.updEnv_def:
  ?rho [?x \<leftarrow> ?X]_?xs ==
  %ys y. if ys = ?xs & y = ?x then Some ?X else ?rho ys y
local.psubst_Var_simp1:
  [| goodEnv ?rho; ?rho ?xs ?x = None |] ==> Var ?xs ?x #[?rho] = Var ?xs ?x
local.getEnv_updEnv:
  (?rho [?x \<leftarrow> ?X]_?xs) ?ys ?y =
  (if ?ys = ?xs & ?y = ?x then Some ?X else ?rho ?ys ?y)
local.substAbs_Abs:
  [| good ?X; good ?Y |] ==> Abs ?xs ?x ?X $[?Y / ?x]_?xs = Abs ?xs ?x ?X
local.fresh_subst_ident:
  [| good ?X; good ?Y; fresh ?xs ?x ?Y |] ==> ?Y #[?X / ?x]_?xs = ?Y
local.freshAbs_substAbs_ident:
  [| good ?X; goodAbs ?A; freshAbs ?xs ?x ?A |] ==> ?A $[?X / ?x]_?xs = ?A
local.getEnv_swapEnv1:
  ?rho ?xs (?x @?xs[?z1.0 \<and> ?z2.0]_?zs) = None ==>
  (?rho &[?z1.0 \<and> ?z2.0]_?zs) ?xs ?x = None
local.goodPar_def:
  goodPar ?P ==
  Ball (termsOf ?P) good &
  Ball (absOf ?P) goodAbs & Ball (envsOf ?P) goodEnv
local.swap_preserves_fresh:
  good ?X ==>
  fresh ?xs (?x @?xs[?y1.0 \<and> ?y2.0]_?ys)
   (?X #[?y1.0 \<and> ?y2.0]_?ys) =
  fresh ?xs ?x ?X
local.fresh_fresh_subst:
  [| good ?Y; good ?X; fresh ?ys ?y ?Y |]
  ==> fresh ?ys ?y (?X #[?Y / ?y]_?ys)
local.fresh_freshAbs_substAbs:
  [| good ?Y; goodAbs ?A; fresh ?ys ?y ?Y |]
  ==> freshAbs ?ys ?y (?A $[?Y / ?y]_?ys)
local.swapEnv_preserves_freshEnv:
  goodEnv ?rho ==>
  freshEnv ?xs (?x @?xs[?y1.0 \<and> ?y2.0]_?ys)
   (?rho &[?y1.0 \<and> ?y2.0]_?ys) =
  freshEnv ?xs ?x ?rho
local.getEnv_updEnv1:
  ?ys ~= ?xs | ?y ~= ?x ==>
  (?rho [?x \<leftarrow> ?X]_?xs) ?ys ?y = ?rho ?ys ?y
local.substEnv_updEnv:
  ?rho [?x \<leftarrow> ?X]_?xs &[?Y / ?y]_?ys =
  ?rho &[?Y / ?y]_?ys [?x \<leftarrow> ?X #[?Y / ?y]_?ys]_?xs
local.vsubstEnv_updEnv:
  ?rho [?x \<leftarrow> ?X]_?xs &[?y1.0 // ?y]_?ys =
  ?rho &[?y1.0 // ?y]_?ys [?x \<leftarrow> ?X #[?y1.0 // ?y]_?ys]_?xs
local.pickQFresh_def:
  pickQFresh ?xs ?V ?XS ==
  SOME x. x ~: ?V & (ALL X:?XS. qAFresh ?xs x X & qFresh ?xs x X)
local.vsubst_psubst_compose:
  [| good ?X; goodEnv ?rho |]
  ==> ?X #[?rho] #[?y1.0 // ?y]_?ys = ?X #[?rho &[?y1.0 // ?y]_?ys]
local.psubst_compose:
  [| good ?X; goodEnv ?rho; goodEnv ?rho' |]
  ==> ?X #[?rho] #[?rho'] = ?X #[?rho &[?rho']]
local.Abs_swap_fresh:
  [| good ?X; fresh ?xs ?x' ?X |]
  ==> Abs ?xs ?x ?X = Abs ?xs ?x' (?X #[?x' \<and> ?x]_?xs)
local.fresh_swap_id:
  [| good ?X; fresh ?xs ?x1.0 ?X; fresh ?xs ?x2.0 ?X |]
  ==> ?X #[?x1.0 \<and> ?x2.0]_?xs = ?X
local.vsubstAbs_psubstAbs_compose:
  [| goodAbs ?A; goodEnv ?rho |]
  ==> ?A $[?rho] $[?y1.0 // ?y]_?ys = ?A $[?rho &[?y1.0 // ?y]_?ys]
local.psubstAbs_compose:
  [| goodAbs ?A; goodEnv ?rho; goodEnv ?rho' |]
  ==> ?A $[?rho] $[?rho'] = ?A $[?rho &[?rho']]
local.freshAbs_swapAbs_id:
  [| goodAbs ?A; freshAbs ?xs ?x1.0 ?A; freshAbs ?xs ?x2.0 ?A |]
  ==> ?A $[?x1.0 \<and> ?x2.0]_?xs = ?A
local.vsubstEnv_psubstEnv_compose:
  [| goodEnv ?rho; goodEnv ?rho' |]
  ==> ?rho &[?rho'] &[?y1.0 // ?y]_?ys = ?rho &[?rho' &[?y1.0 // ?y]_?ys]
local.psubstEnv_compose:
  [| goodEnv ?rho; goodEnv ?rho'; goodEnv ?rho'' |]
  ==> ?rho &[?rho'] &[?rho''] = ?rho &[?rho' &[?rho'']]
local.freshEnv_swapEnv_id:
  [| goodEnv ?rho; freshEnv ?xs ?x1.0 ?rho; freshEnv ?xs ?x2.0 ?rho |]
  ==> ?rho &[?x1.0 \<and> ?x2.0]_?xs = ?rho
local.fresh_vsubstEnv_updEnv:
  [| goodEnv ?rho; freshEnv ?ys ?y ?rho |]
  ==> ?rho &[?y1.0 // ?y]_?ys = ?rho [?y \<leftarrow> Var ?ys ?y1.0]_?ys
local.freshEnv_getEnv1:
  [| freshEnv ?ys ?y ?rho; ?rho ?xs ?x = Some ?X |]
  ==> ?ys ~= ?xs | ?y ~= ?x
local.vsubst_compose1:
  good ?X ==>
  ?X #[?y1.0 // ?y]_?ys #[?y2.0 // ?y]_?ys =
  ?X #[?y1.0 @?ys[?y2.0 / ?y]_?ys // ?y]_?ys
local.freshAbs_simp:
  good ?X ==>
  freshAbs ?ys ?y (Abs ?xs ?x ?X) = (?ys = ?xs & ?y = ?x | fresh ?ys ?y ?X)
local.vsubstAbs_compose1:
  goodAbs ?A ==>
  ?A $[?y1.0 // ?y]_?ys $[?y2.0 // ?y]_?ys =
  ?A $[?y1.0 @?ys[?y2.0 / ?y]_?ys // ?y]_?ys
local.vsubstEnv_compose1:
  goodEnv ?rho ==>
  ?rho &[?y1.0 // ?y]_?ys &[?y2.0 // ?y]_?ys =
  ?rho &[?y1.0 @?ys[?y2.0 / ?y]_?ys // ?y]_?ys
local.goodEnv_def:
  goodEnv ?rho ==
  (ALL ys. liftAll good (?rho ys)) &
  (ALL ys. |{y. ?rho ys y ~= None}| <o |UNIV|)
local.vsubst_trans:
  [| good ?X; fresh ?ys ?y1.0 ?X |]
  ==> ?X #[?y1.0 // ?y]_?ys #[?y2.0 // ?y1.0]_?ys = ?X #[?y2.0 // ?y]_?ys
local.vsubstAbs_trans:
  [| goodAbs ?A; freshAbs ?ys ?y1.0 ?A |]
  ==> ?A $[?y1.0 // ?y]_?ys $[?y2.0 // ?y1.0]_?ys = ?A $[?y2.0 // ?y]_?ys
local.fresh_substEnv_updEnv:
  [| goodEnv ?rho; good ?Y; freshEnv ?ys ?y ?rho |]
  ==> ?rho &[?Y / ?y]_?ys = ?rho [?y \<leftarrow> ?Y]_?ys
local.fresh_Op_simp:
  [| goodInp ?inp; goodBinp ?binp |]
  ==> fresh ?xs ?x (Op ?delta ?inp ?binp) =
      (freshInp ?xs ?x ?inp & freshBinp ?xs ?x ?binp)
local.swapAbs_simp:
  good ?X ==>
  Abs ?xs ?x ?X $[?y1.0 \<and> ?y2.0]_?ys =
  Abs ?xs (?x @?xs[?y1.0 \<and> ?y2.0]_?ys) (?X #[?y1.0 \<and> ?y2.0]_?ys)
local.fresh_psubst_I1:
  [| good ?X; goodEnv ?rho; fresh ?zs ?z ?X; freshEnv ?zs ?z ?rho |]
  ==> fresh ?zs ?z ?X #[?rho]
local.subst_Var_simp1:
  [| good ?Y; ?ys ~= ?xs | ?y ~= ?x |]
  ==> Var ?xs ?x #[?Y / ?y]_?ys = Var ?xs ?x
local.freshAbs_psubstAbs_I1:
  [| goodAbs ?A; goodEnv ?rho; freshAbs ?zs ?z ?A; freshEnv ?zs ?z ?rho |]
  ==> freshAbs ?zs ?z ?A $[?rho]
local.psubstEnv_preserves_freshEnv:
  [| goodEnv ?rho; goodEnv ?rho'; freshEnv ?zs ?z ?rho;
     freshEnv ?zs ?z ?rho' |]
  ==> freshEnv ?zs ?z ?rho &[?rho']
local.getEnv_substEnv3:
  [| ?ys ~= ?xs | ?y ~= ?x; freshEnv ?xs ?x ?rho |]
  ==> (?rho &[?Y / ?y]_?ys) ?xs ?x = None
local.getEnv_vsubstEnv3:
  [| ?ys ~= ?xs | ?y ~= ?x; freshEnv ?xs ?x ?rho |]
  ==> (?rho &[?z // ?y]_?ys) ?xs ?x = None
local.vsubst_subst_compose1:
  [| good ?X; good ?Y |]
  ==> ?X #[?Y / ?y]_?ys #[?y1.0 // ?y]_?ys =
      ?X #[?Y #[?y1.0 // ?y]_?ys / ?y]_?ys
local.subst_psubst_compose:
  [| good ?X; good ?Y; goodEnv ?rho |]
  ==> ?X #[?rho] #[?Y / ?y]_?ys = ?X #[?rho &[?Y / ?y]_?ys]
local.fresh_subst_E2:
  [| good ?X; good ?Y; fresh ?zs ?z (?X #[?Y / ?y]_?ys) |]
  ==> fresh ?ys ?y ?X | fresh ?zs ?z ?Y
local.psubst_vsubst_compose:
  [| good ?X; goodEnv ?rho |]
  ==> ?X #[?y1.0 // ?y]_?ys #[?rho] =
      ?X #[?rho [?y \<leftarrow> Var ?ys ?y1.0 #[?rho]]_?ys]
local.swap_psubst:
  [| good ?X; goodEnv ?rho |]
  ==> ?X #[?rho] #[?z1.0 \<and> ?z2.0]_?zs =
      ?X #[?z1.0 \<and> ?z2.0]_?zs #[?rho &[?z1.0 \<and> ?z2.0]_?zs]
local.psubstAbs_simp:
  [| good ?X; goodEnv ?rho; freshEnv ?xs ?x ?rho |]
  ==> Abs ?xs ?x ?X $[?rho] = Abs ?xs ?x ?X #[?rho]
local.fresh_swap_exchange2:
  [| good ?X; {?x1.0, ?x2.0} <= ?var ?xs |]
  ==> fresh ?xs ?x2.0 (?X #[?x2.0 \<and> ?x1.0]_?xs) = fresh ?xs ?x1.0 ?X
local.vsubstAbs_substAbs_compose1:
  [| goodAbs ?A; good ?Y |]
  ==> ?A $[?Y / ?y]_?ys $[?y1.0 // ?y]_?ys =
      ?A $[?Y #[?y1.0 // ?y]_?ys / ?y]_?ys
local.substAbs_psubstAbs_compose:
  [| goodAbs ?A; good ?Y; goodEnv ?rho |]
  ==> ?A $[?rho] $[?Y / ?y]_?ys = ?A $[?rho &[?Y / ?y]_?ys]
local.freshAbs_substAbs_E2:
  [| goodAbs ?A; good ?Y; freshAbs ?zs ?z (?A $[?Y / ?y]_?ys) |]
  ==> freshAbs ?ys ?y ?A | fresh ?zs ?z ?Y
local.psubstAbs_vsubstAbs_compose:
  [| goodAbs ?A; goodEnv ?rho |]
  ==> ?A $[?y1.0 // ?y]_?ys $[?rho] =
      ?A $[?rho [?y \<leftarrow> Var ?ys ?y1.0 #[?rho]]_?ys]
local.swapAbs_psubstAbs:
  [| goodAbs ?A; goodEnv ?rho |]
  ==> ?A $[?rho] $[?z1.0 \<and> ?z2.0]_?zs =
      ?A $[?z1.0 \<and> ?z2.0]_?zs $[?rho &[?z1.0 \<and> ?z2.0]_?zs]
local.vsubstEnv_substEnv_compose1:
  [| goodEnv ?rho; good ?Y |]
  ==> ?rho &[?Y / ?y]_?ys &[?y1.0 // ?y]_?ys =
      ?rho &[?Y #[?y1.0 // ?y]_?ys / ?y]_?ys
local.substEnv_psubstEnv_compose:
  [| goodEnv ?rho; good ?Y; goodEnv ?rho' |]
  ==> ?rho &[?rho'] &[?Y / ?y]_?ys = ?rho &[?rho' &[?Y / ?y]_?ys]
local.psubstEnv_vsubstEnv_compose:
  [| goodEnv ?rho; goodEnv ?rho' |]
  ==> ?rho &[?y1.0 // ?y]_?ys &[?rho'] =
      ?rho &[?rho' [?y \<leftarrow> Var ?ys ?y1.0 #[?rho']]_?ys]
local.swapEnv_psubstEnv:
  [| goodEnv ?rho; goodEnv ?rho' |]
  ==> ?rho &[?rho'] &[?z1.0 \<and> ?z2.0]_?zs =
      ?rho &[?z1.0 \<and> ?z2.0]_?zs &[?rho' &[?z1.0 \<and> ?z2.0]_?zs]
local.psubst_Op_simp:
  [| goodInp ?inp; goodBinp ?binp; goodEnv ?rho |]
  ==> Op ?delta ?inp ?binp #[?rho] = Op ?delta ?inp %[?rho] ?binp %%[?rho]
local.getEnv_substEnv1:
  [| ?ys ~= ?xs | ?y ~= ?x; ?rho ?xs ?x = None |]
  ==> (?rho &[?Y / ?y]_?ys) ?xs ?x = None
local.getEnv_vsubstEnv1:
  [| ?ys ~= ?xs | ?y ~= ?x; ?rho ?xs ?x = None |]
  ==> (?rho &[?y1.0 // ?y]_?ys) ?xs ?x = None
local.getEnv_swapEnv2:
  ?rho ?xs (?x @?xs[?z1.0 \<and> ?z2.0]_?zs) = Some ?X ==>
  (?rho &[?z1.0 \<and> ?z2.0]_?zs) ?xs ?x =
  Some (?X #[?z1.0 \<and> ?z2.0]_?zs)
local.swapEnv_updEnv:
  ?rho [?x \<leftarrow> ?X]_?xs &[?y1.0 \<and> ?y2.0]_?ys =
  ?rho &[?y1.0 \<and> ?y2.0]_?ys [?x @?xs[?y1.0 \<and> ?y2.0]_?ys \<leftarrow> ?X #[?y1.0 \<and> ?y2.0]_?ys]_?xs
local.subst_preserves_fresh:
  [| good ?X; good ?Y; fresh ?zs ?z ?X; fresh ?zs ?z ?Y |]
  ==> fresh ?zs ?z (?X #[?Y / ?y]_?ys)
local.fresh_vsubst_E2:
  [| good ?X; fresh ?zs ?z (?X #[?y1.0 // ?y]_?ys) |]
  ==> fresh ?ys ?y ?X | ?zs ~= ?ys | ?z ~= ?y1.0
local.freshEnv_psubst_ident:
  [| good ?X; goodEnv ?rho; !!zs z. freshEnv zs z ?rho | fresh zs z ?X |]
  ==> ?X #[?rho] = ?X
local.substAbs_preserves_freshAbs:
  [| goodAbs ?A; good ?Y; freshAbs ?zs ?z ?A; fresh ?zs ?z ?Y |]
  ==> freshAbs ?zs ?z (?A $[?Y / ?y]_?ys)
local.freshAbs_vsubstAbs_E2:
  [| goodAbs ?A; freshAbs ?zs ?z (?A $[?y1.0 // ?y]_?ys) |]
  ==> freshAbs ?ys ?y ?A | ?zs ~= ?ys | ?z ~= ?y1.0
local.freshEnv_psubstAbs_ident:
  [| goodAbs ?A; goodEnv ?rho;
     !!zs z. freshEnv zs z ?rho | freshAbs zs z ?A |]
  ==> ?A $[?rho] = ?A
local.psubst_subst_compose:
  [| good ?X; good ?Y; goodEnv ?rho |]
  ==> ?X #[?Y / ?y]_?ys #[?rho] =
      ?X #[?rho [?y \<leftarrow> ?Y #[?rho]]_?ys]
local.fresh_psubst_updEnv:
  [| good ?X; good ?Y; goodEnv ?rho; fresh ?xs ?x ?Y |]
  ==> ?Y #[?rho [?x \<leftarrow> ?X]_?xs] = ?Y #[?rho]
local.subst_vsubst_compose1:
  [| good ?X; good ?Y; ?y ~= ?y1.0 |]
  ==> ?X #[?y1.0 // ?y]_?ys #[?Y / ?y]_?ys = ?X #[?y1.0 // ?y]_?ys
local.subst_vsubst_trans:
  [| good ?X; good ?Y; fresh ?ys ?y1.0 ?X |]
  ==> ?X #[?y1.0 // ?y]_?ys #[?Y / ?y1.0]_?ys = ?X #[?Y / ?y]_?ys
local.freshAbs_psubstAbs_updEnv:
  [| good ?X; goodAbs ?A; goodEnv ?rho; freshAbs ?xs ?x ?A |]
  ==> ?A $[?rho [?x \<leftarrow> ?X]_?xs] = ?A $[?rho]
local.vsubstEnv_updEnv_fresh:
  [| good ?X; fresh ?ys ?y ?X |]
  ==> ?rho [?x \<leftarrow> ?X]_?xs &[?y1.0 // ?y]_?ys =
      ?rho &[?y1.0 // ?y]_?ys [?x \<leftarrow> ?X]_?xs
local.vsubst_preserves_fresh:
  [| good ?X; fresh ?zs ?z ?X; ?zs ~= ?ys | ?z ~= ?y1.0 |]
  ==> fresh ?zs ?z (?X #[?y1.0 // ?y]_?ys)
local.fresh_vsubst_E1:
  [| good ?X; fresh ?zs ?z (?X #[?y1.0 // ?y]_?ys); ?zs ~= ?ys | ?z ~= ?y |]
  ==> fresh ?zs ?z ?X
local.psubstAbs_substAbs_compose:
  [| goodAbs ?A; good ?Y; goodEnv ?rho |]
  ==> ?A $[?Y / ?y]_?ys $[?rho] =
      ?A $[?rho [?y \<leftarrow> ?Y #[?rho]]_?ys]
local.substAbs_vsubstAbs_compose1:
  [| goodAbs ?A; good ?Y; ?y ~= ?y1.0 |]
  ==> ?A $[?y1.0 // ?y]_?ys $[?Y / ?y]_?ys = ?A $[?y1.0 // ?y]_?ys
local.substAbs_vsubstAbs_trans:
  [| goodAbs ?A; good ?Y; freshAbs ?ys ?y1.0 ?A |]
  ==> ?A $[?y1.0 // ?y]_?ys $[?Y / ?y1.0]_?ys = ?A $[?Y / ?y]_?ys
local.vsubstAbs_preserves_freshAbs:
  [| goodAbs ?A; freshAbs ?zs ?z ?A; ?zs ~= ?ys | ?z ~= ?y1.0 |]
  ==> freshAbs ?zs ?z (?A $[?y1.0 // ?y]_?ys)
local.freshAbs_vsubstAbs_E1:
  [| goodAbs ?A; freshAbs ?zs ?z (?A $[?y1.0 // ?y]_?ys);
     ?zs ~= ?ys | ?z ~= ?y |]
  ==> freshAbs ?zs ?z ?A
local.psubstEnv_substEnv_compose:
  [| goodEnv ?rho; good ?Y; goodEnv ?rho' |]
  ==> ?rho &[?Y / ?y]_?ys &[?rho'] =
      ?rho &[?rho' [?y \<leftarrow> ?Y #[?rho']]_?ys]
local.substEnv_vsubstEnv_compose1:
  [| goodEnv ?rho; good ?Y; ?y ~= ?y1.0 |]
  ==> ?rho &[?y1.0 // ?y]_?ys &[?Y / ?y]_?ys = ?rho &[?y1.0 // ?y]_?ys
local.swap_Op_simp:
  [| goodInp ?inp; goodBinp ?binp |]
  ==> Op ?delta ?inp ?binp #[?x1.0 \<and> ?x2.0]_?xs =
      Op ?delta (?inp %[?x1.0 \<and> ?x2.0]_?xs)
       (?binp %%[?x1.0 \<and> ?x2.0]_?xs)
local.vsubst_Op_simp:
  [| goodInp ?inp; goodBinp ?binp |]
  ==> Op ?delta ?inp ?binp #[?y1.0 // ?y]_?ys =
      Op ?delta (?inp %[?y1.0 // ?y]_?ys) (?binp %%[?y1.0 // ?y]_?ys)
local.substEnv_def2:
  ?rho &[?Y / ?y]_?ys =
  (%xs x.
      case ?rho xs x of None => if xs = ?ys & x = ?y then Some ?Y else None
      | Some X => Some (X #[?Y / ?y]_?ys))
local.fresh_psubst:
  [| good ?X; goodEnv ?rho |]
  ==> fresh ?zs ?z ?X #[?rho] =
      (ALL ys y. fresh ys y ?X | freshImEnvAt ?zs ?z ?rho ys y)
local.obtain_rep:
  [| good ?X; fresh ?xs ?x' ?X |]
  ==> EX X'. (?X, X') : swapped & good X' & Abs ?xs ?x ?X = Abs ?xs ?x' X'
local.freshAbs_psubstAbs:
  [| goodAbs ?A; goodEnv ?rho |]
  ==> freshAbs ?zs ?z ?A $[?rho] =
      (ALL ys y. freshAbs ys y ?A | freshImEnvAt ?zs ?z ?rho ys y)
local.updEnv_commute:
  ?xs ~= ?ys | ?x ~= ?y ==>
  ?rho [?x \<leftarrow> ?X]_?xs [?y \<leftarrow> ?Y]_?ys =
  ?rho [?y \<leftarrow> ?Y]_?ys [?x \<leftarrow> ?X]_?xs
local.subst_compose1:
  [| good ?X; good ?Y1.0; good ?Y2.0 |]
  ==> ?X #[?Y1.0 / ?y]_?ys #[?Y2.0 / ?y]_?ys =
      ?X #[?Y1.0 #[?Y2.0 / ?y]_?ys / ?y]_?ys
local.fresh_swap_compose:
  [| good ?X; fresh ?xs ?y ?X; fresh ?xs ?z ?X |]
  ==> ?X #[?y \<and> ?x]_?xs #[?z \<and> ?y]_?xs = ?X #[?z \<and> ?x]_?xs
local.substAbs_compose1:
  [| goodAbs ?A; good ?Y1.0; good ?Y2.0 |]
  ==> ?A $[?Y1.0 / ?y]_?ys $[?Y2.0 / ?y]_?ys =
      ?A $[?Y1.0 #[?Y2.0 / ?y]_?ys / ?y]_?ys
local.substEnv_compose1:
  [| goodEnv ?rho; good ?Y1.0; good ?Y2.0 |]
  ==> ?rho &[?Y1.0 / ?y]_?ys &[?Y2.0 / ?y]_?ys =
      ?rho &[?Y1.0 #[?Y2.0 / ?y]_?ys / ?y]_?ys
local.freshEnv_swapEnv_compose:
  [| goodEnv ?rho; freshEnv ?xs ?y ?rho; freshEnv ?xs ?z ?rho |]
  ==> ?rho &[?y \<and> ?x]_?xs &[?z \<and> ?y]_?xs =
      ?rho &[?z \<and> ?x]_?xs
local.vsubstEnv_def2:
  ?rho &[?y1.0 // ?y]_?ys =
  (%xs x.
      case ?rho xs x of
      None => if xs = ?ys & x = ?y then Some (Var ?ys ?y1.0) else None
      | Some X => Some (X #[?y1.0 // ?y]_?ys))
local.term_nchotomy:
  good ?X ==>
  (EX xs x. ?X = Var xs x) |
  (EX delta inp binp. goodInp inp & goodBinp binp & ?X = Op delta inp binp)
local.swap_preserves_fresh_distinct:
  [| good ?X; ?xs ~= ?ys | ?x ~: {?y1.0, ?y2.0} |]
  ==> fresh ?xs ?x (?X #[?y1.0 \<and> ?y2.0]_?ys) = fresh ?xs ?x ?X
local.swapEnv_preserves_freshEnv_distinct:
  [| goodEnv ?rho; ?xs ~= ?ys | ?x ~: {?y1.0, ?y2.0} |]
  ==> freshEnv ?xs ?x (?rho &[?y1.0 \<and> ?y2.0]_?ys) =
      freshEnv ?xs ?x ?rho
local.swap_vsubst:
  good ?X ==>
  ?X #[?y1.0 // ?y]_?ys #[?z1.0 \<and> ?z2.0]_?zs =
  ?X #[?z1.0 \<and> ?z2.0]_?zs #[?y1.0 @?ys[?z1.0 \<and> ?z2.0]_?zs // ?y @?ys[?z1.0 \<and> ?z2.0]_?zs]_?ys
local.swap_compose:
  good ?X ==>
  ?X #[?x \<and> ?y]_?zs #[?x' \<and> ?y']_?zs' =
  ?X #[?x' \<and> ?y']_?zs' #[?x @?zs[?x' \<and> ?y']_?zs' \<and> ?y @?zs[?x' \<and> ?y']_?zs']_?zs
local.substEnv_updEnv_fresh:
  [| good ?X; good ?Y; fresh ?ys ?y ?X |]
  ==> ?rho [?x \<leftarrow> ?X]_?xs &[?Y / ?y]_?ys =
      ?rho &[?Y / ?y]_?ys [?x \<leftarrow> ?X]_?xs
local.fresh_subst_E1:
  [| good ?X; good ?Y; fresh ?zs ?z (?X #[?Y / ?y]_?ys);
     ?zs ~= ?ys | ?z ~= ?y |]
  ==> fresh ?zs ?z ?X
local.fresh_psubst_E2:
  [| good ?X; goodEnv ?rho; ?rho ?ys ?y = Some ?Y;
     fresh ?zs ?z ?X #[?rho] |]
  ==> fresh ?ys ?y ?X | fresh ?zs ?z ?Y
local.subst_Op_simp:
  [| good ?Y; goodInp ?inp; goodBinp ?binp |]
  ==> Op ?delta ?inp ?binp #[?Y / ?y]_?ys =
      Op ?delta (?inp %[?Y / ?y]_?ys) (?binp %%[?Y / ?y]_?ys)
local.swapAbs_vsubstAbs:
  goodAbs ?A ==>
  ?A $[?y1.0 // ?y]_?ys $[?z1.0 \<and> ?z2.0]_?zs =
  ?A $[?z1.0 \<and> ?z2.0]_?zs $[?y1.0 @?ys[?z1.0 \<and> ?z2.0]_?zs // ?y @?ys[?z1.0 \<and> ?z2.0]_?zs]_?ys
local.freshAbs_substAbs_E1:
  [| goodAbs ?A; good ?Y; freshAbs ?zs ?z (?A $[?Y / ?y]_?ys);
     ?zs ~= ?ys | ?z ~= ?y |]
  ==> freshAbs ?zs ?z ?A
local.freshAbs_psubstAbs_E2:
  [| goodAbs ?A; goodEnv ?rho; ?rho ?ys ?y = Some ?Y;
     freshAbs ?zs ?z ?A $[?rho] |]
  ==> freshAbs ?ys ?y ?A | fresh ?zs ?z ?Y
local.swapEnv_vsubstEnv:
  goodEnv ?rho ==>
  ?rho &[?y1.0 // ?y]_?ys &[?z1.0 \<and> ?z2.0]_?zs =
  ?rho &[?z1.0 \<and> ?z2.0]_?zs &[?y1.0 @?ys[?z1.0 \<and> ?z2.0]_?zs // ?y @?ys[?z1.0 \<and> ?z2.0]_?zs]_?ys
local.swapEnv_compose:
  goodEnv ?rho ==>
  ?rho &[?x \<and> ?y]_?zs &[?x' \<and> ?y']_?zs' =
  ?rho &[?x' \<and> ?y']_?zs' &[?x @?zs[?x' \<and> ?y']_?zs' \<and> ?y @?zs[?x' \<and> ?y']_?zs']_?zs
local.vsubstEnv_preserves_freshEnv:
  [| goodEnv ?rho; freshEnv ?zs ?z ?rho; ?zs ~= ?ys | ?z ~: {?y, ?y1.0} |]
  ==> freshEnv ?zs ?z (?rho &[?y1.0 // ?y]_?ys)
local.freshEnv_updEnv_E4:
  [| freshEnv ?ys ?y (?rho [?x \<leftarrow> ?X]_?xs); ?zs ~= ?xs | ?z ~= ?x;
     ?rho ?zs ?z = Some ?Z |]
  ==> fresh ?ys ?y ?Z
local.getEnv_substEnv2:
  [| ?ys ~= ?xs | ?y ~= ?x; ?rho ?xs ?x = Some ?X |]
  ==> (?rho &[?Y / ?y]_?ys) ?xs ?x = Some (?X #[?Y / ?y]_?ys)
local.getEnv_vsubstEnv2:
  [| ?ys ~= ?xs | ?y ~= ?x; ?rho ?xs ?x = Some ?X |]
  ==> (?rho &[?y1.0 // ?y]_?ys) ?xs ?x = Some (?X #[?y1.0 // ?y]_?ys)
local.freshImEnvAt_def:
  freshImEnvAt ?xs ?x ?rho ?ys ?y ==
  ?rho ?ys ?y = None & (?ys ~= ?xs | ?y ~= ?x) |
  (EX Y. ?rho ?ys ?y = Some Y & fresh ?xs ?x Y)
local.psubstAbs_substAbs_compose_freshEnv:
  [| goodAbs ?A; goodEnv ?rho; good ?Y; freshEnv ?ys ?y ?rho |]
  ==> ?A $[?Y / ?y]_?ys $[?rho] = ?A $[?rho] $[?Y #[?rho] / ?y]_?ys
local.psubst_subst_compose_freshEnv:
  [| goodEnv ?rho; good ?X; good ?Y; freshEnv ?ys ?y ?rho |]
  ==> ?X #[?Y / ?y]_?ys #[?rho] = ?X #[?rho] #[?Y #[?rho] / ?y]_?ys
local.psubstEnv_substEnv_compose_freshEnv:
  [| goodEnv ?rho; goodEnv ?rho'; good ?Y; freshEnv ?ys ?y ?rho' |]
  ==> ?rho &[?Y / ?y]_?ys &[?rho'] = ?rho &[?rho'] &[?Y #[?rho'] / ?y]_?ys
local.swap_subst:
  [| good ?X; good ?Y |]
  ==> ?X #[?Y / ?y]_?ys #[?z1.0 \<and> ?z2.0]_?zs =
      ?X #[?z1.0 \<and> ?z2.0]_?zs #[?Y #[?z1.0 \<and> ?z2.0]_?zs / ?y @?ys[?z1.0 \<and> ?z2.0]_?zs]_?ys
local.vsubstAbs_simp:
  [| good ?X; ?xs ~= ?ys | ?x ~: {?y, ?y1.0} |]
  ==> Abs ?xs ?x ?X $[?y1.0 // ?y]_?ys = Abs ?xs ?x (?X #[?y1.0 // ?y]_?ys)
local.swapEnv_substEnv:
  [| good ?Y; goodEnv ?rho |]
  ==> ?rho &[?Y / ?y]_?ys &[?z1.0 \<and> ?z2.0]_?zs =
      ?rho &[?z1.0 \<and> ?z2.0]_?zs &[?Y #[?z1.0 \<and> ?z2.0]_?zs / ?y @?ys[?z1.0 \<and> ?z2.0]_?zs]_?ys
local.swapAbs_substAbs:
  [| goodAbs ?A; good ?Y |]
  ==> ?A $[?Y / ?y]_?ys $[?z1.0 \<and> ?z2.0]_?zs =
      ?A $[?z1.0 \<and> ?z2.0]_?zs $[?Y #[?z1.0 \<and> ?z2.0]_?zs / ?y @?ys[?z1.0 \<and> ?z2.0]_?zs]_?ys
local.psubst_cong:
  [| good ?X; goodEnv ?rho; goodEnv ?rho';
     !!ys y. fresh ys y ?X | ?rho ys y = ?rho' ys y |]
  ==> ?X #[?rho] = ?X #[?rho']
local.fresh_psubst_E1:
  [| good ?X; goodEnv ?rho; ?rho ?ys ?y = None; fresh ?zs ?z ?X #[?rho] |]
  ==> fresh ?ys ?y ?X | ?ys ~= ?zs | ?y ~= ?z
local.psubstAbs_cong:
  [| goodAbs ?A; goodEnv ?rho; goodEnv ?rho';
     !!ys y. freshAbs ys y ?A | ?rho ys y = ?rho' ys y |]
  ==> ?A $[?rho] = ?A $[?rho']
local.freshAbs_psubstAbs_E1:
  [| goodAbs ?A; goodEnv ?rho; ?rho ?ys ?y = None;
     freshAbs ?zs ?z ?A $[?rho] |]
  ==> freshAbs ?ys ?y ?A | ?ys ~= ?zs | ?y ~= ?z
local.Op_inj:
  [| goodInp ?inp; goodBinp ?binp; goodInp ?inp'; goodBinp ?binp' |]
  ==> (Op ?delta ?inp ?binp = Op ?delta' ?inp' ?binp') =
      (?delta = ?delta' & ?inp = ?inp' & ?binp = ?binp')
local.pickQFreshEnv_def:
  pickQFreshEnv ?xs ?V ?XS ?Rho ==
  pickQFresh ?xs (?V Un (UN rho:?Rho. {x. rho ?xs x ~= None}))
   (?XS Un (UN rho:?Rho. {X. EX ys y. rho ys y = Some X}))
local.fresh_subst:
  [| good ?X; good ?Y |]
  ==> fresh ?zs ?z (?X #[?Y / ?y]_?ys) =
      ((?zs = ?ys & ?z = ?y | fresh ?zs ?z ?X) &
       (fresh ?ys ?y ?X | fresh ?zs ?z ?Y))
local.freshAbs_substAbs:
  [| goodAbs ?A; good ?Y |]
  ==> freshAbs ?zs ?z (?A $[?Y / ?y]_?ys) =
      ((?zs = ?ys & ?z = ?y | freshAbs ?zs ?z ?A) &
       (freshAbs ?ys ?y ?A | fresh ?zs ?z ?Y))
local.substEnv_preserves_freshEnv:
  [| goodEnv ?rho; good ?Y; freshEnv ?zs ?z ?rho; fresh ?zs ?z ?Y;
     ?zs ~= ?ys | ?z ~= ?y |]
  ==> freshEnv ?zs ?z (?rho &[?Y / ?y]_?ys)
local.vsubstAll_ident:
  goodPar ?P ==>
  (good ?X --> (ALL z. z : varsOf ?P --> ?X #[z // z]_?zs = ?X)) &
  (goodAbs ?A --> (ALL z. z : varsOf ?P --> ?A $[z // z]_?zs = ?A))
local.fresh_vsubst:
  good ?X ==>
  fresh ?zs ?z (?X #[?y1.0 // ?y]_?ys) =
  ((?zs = ?ys & ?z = ?y | fresh ?zs ?z ?X) &
   (fresh ?ys ?y ?X | ?zs ~= ?ys | ?z ~= ?y1.0))
local.freshAbs_vsubstAbs:
  goodAbs ?A ==>
  freshAbs ?zs ?z (?A $[?y1.0 // ?y]_?ys) =
  ((?zs = ?ys & ?z = ?y | freshAbs ?zs ?z ?A) &
   (freshAbs ?ys ?y ?A | ?zs ~= ?ys | ?z ~= ?y1.0))
local.Abs_cong:
  [| good ?X; good ?X'; fresh ?xs ?y ?X; fresh ?xs ?y ?X';
     ?X #[?y \<and> ?x]_?xs = ?X' #[?y \<and> ?x']_?xs |]
  ==> Abs ?xs ?x ?X = Abs ?xs ?x' ?X'
local.substAbs_simp:
  [| good ?Y; good ?X; ?xs ~= ?ys | ?x ~= ?y; fresh ?xs ?x ?Y |]
  ==> Abs ?xs ?x ?X $[?Y / ?y]_?ys = Abs ?xs ?x (?X #[?Y / ?y]_?ys)
local.Par_preserves_good:
  [| !!X. X : set ?XL ==> good X; !!A. A : set ?AL ==> goodAbs A;
     !!rho. rho : set ?rhoL ==> goodEnv rho |]
  ==> goodPar (Par ?xL ?XL ?AL ?rhoL)
local.vsubst_compose2:
  [| good ?X; ?ys ~= ?zs | ?y ~: {?z, ?z1.0} |]
  ==> ?X #[?y1.0 // ?y]_?ys #[?z1.0 // ?z]_?zs =
      ?X #[?z1.0 // ?z]_?zs #[?y1.0 @?ys[?z1.0 / ?z]_?zs // ?y]_?ys
local.swap_commute:
  [| good ?X; ?zs ~= ?zs' | {?x, ?y} Int {?x', ?y'} = {} |]
  ==> ?X #[?x \<and> ?y]_?zs #[?x' \<and> ?y']_?zs' =
      ?X #[?x' \<and> ?y']_?zs' #[?x \<and> ?y]_?zs
local.vsubstAbs_compose2:
  [| goodAbs ?A; ?ys ~= ?zs | ?y ~: {?z, ?z1.0} |]
  ==> ?A $[?y1.0 // ?y]_?ys $[?z1.0 // ?z]_?zs =
      ?A $[?z1.0 // ?z]_?zs $[?y1.0 @?ys[?z1.0 / ?z]_?zs // ?y]_?ys
local.vsubstEnv_compose2:
  [| goodEnv ?rho; ?ys ~= ?zs | ?y ~: {?z, ?z1.0} |]
  ==> ?rho &[?y1.0 // ?y]_?ys &[?z1.0 // ?z]_?zs =
      ?rho &[?z1.0 // ?z]_?zs &[?y1.0 @?ys[?z1.0 / ?z]_?zs // ?y]_?ys
local.vsubst_subst_compose2:
  [| good ?X; good ?Y; ?ys ~= ?zs | ?y ~: {?z, ?z1.0} |]
  ==> ?X #[?Y / ?y]_?ys #[?z1.0 // ?z]_?zs =
      ?X #[?z1.0 // ?z]_?zs #[?Y #[?z1.0 // ?z]_?zs / ?y]_?ys
local.vsubstAbs_substAbs_compose2:
  [| goodAbs ?A; good ?Y; ?ys ~= ?zs | ?y ~: {?z, ?z1.0} |]
  ==> ?A $[?Y / ?y]_?ys $[?z1.0 // ?z]_?zs =
      ?A $[?z1.0 // ?z]_?zs $[?Y #[?z1.0 // ?z]_?zs / ?y]_?ys
local.vsubstEnv_substEnv_compose2:
  [| goodEnv ?rho; good ?Y; ?ys ~= ?zs | ?y ~: {?z, ?z1.0} |]
  ==> ?rho &[?Y / ?y]_?ys &[?z1.0 // ?z]_?zs =
      ?rho &[?z1.0 // ?z]_?zs &[?Y #[?z1.0 // ?z]_?zs / ?y]_?ys
local.subst_vsubst_compose2:
  [| good ?X; good ?Z; ?ys ~= ?zs | ?y ~= ?z; fresh ?ys ?y ?Z |]
  ==> ?X #[?y1.0 // ?y]_?ys #[?Z / ?z]_?zs =
      ?X #[?Z / ?z]_?zs #[Var ?ys ?y1.0 #[?Z / ?z]_?zs / ?y]_?ys
local.substAbs_vsubstAbs_compose2:
  [| goodAbs ?A; good ?Z; ?ys ~= ?zs | ?y ~= ?z; fresh ?ys ?y ?Z |]
  ==> ?A $[?y1.0 // ?y]_?ys $[?Z / ?z]_?zs =
      ?A $[?Z / ?z]_?zs $[Var ?ys ?y1.0 #[?Z / ?z]_?zs / ?y]_?ys
local.substEnv_vsubstEnv_compose2:
  [| goodEnv ?rho; good ?Z; ?ys ~= ?zs | ?y ~= ?z; fresh ?ys ?y ?Z |]
  ==> ?rho &[?y1.0 // ?y]_?ys &[?Z / ?z]_?zs =
      ?rho &[?Z / ?z]_?zs &[Var ?ys ?y1.0 #[?Z / ?z]_?zs / ?y]_?ys
local.swapEnv_updEnv_fresh:
  [| ?ys ~= ?xs | ?x ~: {?y1.0, ?y2.0}; good ?X; fresh ?ys ?y1.0 ?X;
     fresh ?ys ?y2.0 ?X |]
  ==> ?rho [?x \<leftarrow> ?X]_?xs &[?y1.0 \<and> ?y2.0]_?ys =
      ?rho &[?y1.0 \<and> ?y2.0]_?ys [?x \<leftarrow> ?X]_?xs
local.pickQFresh_card_of:
  [| |?V| <o |UNIV|; |?XS| <o |UNIV|; Ball ?XS qGood |]
  ==> pickQFresh ?xs ?V ?XS ~: ?V &
      (ALL X:?XS.
          qAFresh ?xs (pickQFresh ?xs ?V ?XS) X &
          qFresh ?xs (pickQFresh ?xs ?V ?XS) X)
local.subst_compose2:
  [| good ?X; good ?Y; good ?Z; ?ys ~= ?zs | ?y ~= ?z; fresh ?ys ?y ?Z |]
  ==> ?X #[?Y / ?y]_?ys #[?Z / ?z]_?zs =
      ?X #[?Z / ?z]_?zs #[?Y #[?Z / ?z]_?zs / ?y]_?ys
local.fresh_psubst_I:
  [| good ?X; goodEnv ?rho; ?rho ?zs ?z = None ==> fresh ?zs ?z ?X;
     !!ys y Y. ?rho ys y = Some Y ==> fresh ys y ?X | fresh ?zs ?z Y |]
  ==> fresh ?zs ?z ?X #[?rho]
local.substAbs_compose2:
  [| goodAbs ?A; good ?Y; good ?Z; ?ys ~= ?zs | ?y ~= ?z; fresh ?ys ?y ?Z |]
  ==> ?A $[?Y / ?y]_?ys $[?Z / ?z]_?zs =
      ?A $[?Z / ?z]_?zs $[?Y #[?Z / ?z]_?zs / ?y]_?ys
local.freshAbs_psubstAbs_I:
  [| goodAbs ?A; goodEnv ?rho; ?rho ?zs ?z = None ==> freshAbs ?zs ?z ?A;
     !!ys y Y. ?rho ys y = Some Y ==> freshAbs ys y ?A | fresh ?zs ?z Y |]
  ==> freshAbs ?zs ?z ?A $[?rho]
local.substEnv_compose2:
  [| goodEnv ?rho; good ?Y; good ?Z; ?ys ~= ?zs | ?y ~= ?z;
     fresh ?ys ?y ?Z |]
  ==> ?rho &[?Y / ?y]_?ys &[?Z / ?z]_?zs =
      ?rho &[?Z / ?z]_?zs &[?Y #[?Z / ?z]_?zs / ?y]_?ys
local.Abs_ainj_all:
  [| good ?X; good ?X' |]
  ==> (Abs ?xs ?x ?X = Abs ?xs' ?x' ?X') =
      (?xs = ?xs' &
       (ALL y.
           (y = ?x | fresh ?xs y ?X) & (y = ?x' | fresh ?xs y ?X') -->
           ?X #[y \<and> ?x]_?xs = ?X' #[y \<and> ?x']_?xs))
local.swapEnv_commute:
  [| goodEnv ?rho; {?x, ?y} <= ?var ?zs;
     ?zs ~= ?zs' | {?x, ?y} Int {?x', ?y'} = {} |]
  ==> ?rho &[?x \<and> ?y]_?zs &[?x' \<and> ?y']_?zs' =
      ?rho &[?x' \<and> ?y']_?zs' &[?x \<and> ?y]_?zs
local.Abs_ainj_ex:
  [| good ?X; good ?X' |]
  ==> (Abs ?xs ?x ?X = Abs ?xs' ?x' ?X') =
      (?xs = ?xs' &
       (EX y. y ~: {?x, ?x'} &
              fresh ?xs y ?X &
              fresh ?xs y ?X' &
              ?X #[y \<and> ?x]_?xs = ?X' #[y \<and> ?x']_?xs))
local.vsubst_commute:
  [| good ?X; ?xs ~= ?xs' | {?x, ?y} Int {?x', ?y'} = {}; fresh ?xs ?x ?X;
     fresh ?xs' ?x' ?X |]
  ==> ?X #[?x // ?y]_?xs #[?x' // ?y']_?xs' =
      ?X #[?x' // ?y']_?xs' #[?x // ?y]_?xs
local.skelAll_vsubstAll:
  goodPar ?P ==>
  (good ?X -->
   (ALL y1 y2.
       {y1, y2} <= varsOf ?P --> skel (?X #[y1 // y2]_?ys) = skel ?X)) &
  (goodAbs ?A -->
   (ALL y1 y2.
       {y1, y2} <= varsOf ?P --> skelAbs (?A $[y1 // y2]_?ys) = skelAbs ?A))
local.psubstAll_ident:
  goodPar ?P ==>
  (good ?X -->
   (ALL rho:envsOf ?P.
       (ALL zs z. freshEnv zs z rho | fresh zs z ?X) --> ?X #[rho] = ?X)) &
  (goodAbs ?A -->
   (ALL rho:envsOf ?P.
       (ALL zs z. freshEnv zs z rho | freshAbs zs z ?A) --> ?A $[rho] = ?A))
local.pickQFresh:
  [| finite ?V | |?V| <o |UNIV|; finite ?XS | |?XS| <o |UNIV|;
     Ball ?XS qGood |]
  ==> pickQFresh ?xs ?V ?XS ~: ?V &
      (ALL X:?XS.
          qAFresh ?xs (pickQFresh ?xs ?V ?XS) X &
          qFresh ?xs (pickQFresh ?xs ?V ?XS) X)
local.psubstAll_compose:
  goodPar ?P ==>
  (good ?X -->
   (ALL rho rho'.
       {rho, rho'} <= envsOf ?P -->
       ?X #[rho] #[rho'] = ?X #[rho &[rho']])) &
  (goodAbs ?A -->
   (ALL rho rho'.
       {rho, rho'} <= envsOf ?P --> ?A $[rho] $[rho'] = ?A $[rho &[rho']]))
local.swappedp.simps:
  swappedp ?a1.0 ?a2.0 =
  ((EX X. ?a1.0 = X & ?a2.0 = X) |
   (EX X Y Z. ?a1.0 = X & ?a2.0 = Z & swappedp X Y & swappedp Y Z) |
   (EX X Y x y zs. ?a1.0 = X & ?a2.0 = Y #[x \<and> y]_zs & swappedp X Y))
local.freshEnv_updEnv_I:
  [| ?ys ~= ?xs | ?y ~= ?x; fresh ?ys ?y ?X; ?rho ?ys ?y = None;
     !!zs z Z.
        [| zs ~= ?xs | z ~= ?x; ?rho zs z = Some Z |] ==> fresh ?ys ?y Z |]
  ==> freshEnv ?ys ?y (?rho [?x \<leftarrow> ?X]_?xs)
local.swapped.simps:
  ((?a1.0, ?a2.0) : swapped) =
  ((EX X. ?a1.0 = X & ?a2.0 = X) |
   (EX X Y Z. ?a1.0 = X & ?a2.0 = Z & (X, Y) : swapped & (Y, Z) : swapped) |
   (EX X Y x y zs.
       ?a1.0 = X & ?a2.0 = Y #[x \<and> y]_zs & (X, Y) : swapped))
local.vsubstAll_swapAll:
  goodPar ?P ==>
  (good ?X -->
   (ALL y1 y2.
       {y1, y2} <= varsOf ?P & fresh ?ys y1 ?X -->
       ?X #[y1 // y2]_?ys = ?X #[y1 \<and> y2]_?ys)) &
  (goodAbs ?A -->
   (ALL y1 y2.
       {y1, y2} <= varsOf ?P & freshAbs ?ys y1 ?A -->
       ?A $[y1 // y2]_?ys = ?A $[y1 \<and> y2]_?ys))
local.obtain_fresh1:
  [| |?V| <o |UNIV| | finite ?V; |?XS| <o |UNIV| | finite ?XS;
     Ball ?XS good; |?Rho| <o |UNIV| | finite ?Rho; Ball ?Rho goodEnv |]
  ==> EX z. z ~: ?V &
            (ALL X:?XS. fresh ?xs z X) & (ALL rho:?Rho. freshEnv ?xs z rho)
local.freshAll_psubstAll:
  goodPar ?P ==>
  (good ?X -->
   ?z : varsOf ?P -->
   (ALL rho:envsOf ?P.
       fresh ?zs ?z ?X #[rho] =
       (ALL ys y. fresh ys y ?X | freshImEnvAt ?zs ?z rho ys y))) &
  (goodAbs ?A -->
   ?z : varsOf ?P -->
   (ALL rho:envsOf ?P.
       freshAbs ?zs ?z ?A $[rho] =
       (ALL ys y. freshAbs ys y ?A | freshImEnvAt ?zs ?z rho ys y)))
local.pickQFreshEnv_card_of:
  [| |?V| <o |UNIV|; |?XS| <o |UNIV|; Ball ?XS qGood; |?Rho| <o |UNIV|;
     Ball ?Rho qGoodEnv |]
  ==> pickQFreshEnv ?xs ?V ?XS ?Rho ~: ?V &
      (ALL X:?XS. qFresh ?xs (pickQFreshEnv ?xs ?V ?XS ?Rho) X) &
      (ALL rho:?Rho. qFreshEnv ?xs (pickQFreshEnv ?xs ?V ?XS ?Rho) rho)
local.term_rawInduct:
  [| !!xs x. ?phi (Var xs x);
     !!delta inp binp.
        [| goodInp inp; goodBinp binp; liftAll ?phi inp;
           liftAll ?phiAbs binp |]
        ==> ?phi (Op delta inp binp);
     !!xs x X. [| good X; ?phi X |] ==> ?phiAbs (Abs xs x X) |]
  ==> (good ?X --> ?phi ?X) & (goodAbs ?A --> ?phiAbs ?A)
local.swappedp.induct:
  [| swappedp ?x1.0 ?x2.0; !!X. ?P X X;
     !!X Y Z. [| swappedp X Y; ?P X Y; swappedp Y Z; ?P Y Z |] ==> ?P X Z;
     !!X Y x y zs.
        [| swappedp X Y; ?P X Y |] ==> ?P X (Y #[x \<and> y]_zs) |]
  ==> ?P ?x1.0 ?x2.0
local.swappedp.cases:
  [| swappedp ?a1.0 ?a2.0; !!X. [| ?a1.0 = X; ?a2.0 = X |] ==> ?P;
     !!X Y Z. [| ?a1.0 = X; ?a2.0 = Z; swappedp X Y; swappedp Y Z |] ==> ?P;
     !!X Y x y zs.
        [| ?a1.0 = X; ?a2.0 = Y #[x \<and> y]_zs; swappedp X Y |] ==> ?P |]
  ==> ?P
local.pickQFreshEnv:
  [| |?V| <o |UNIV| | finite ?V; |?XS| <o |UNIV| | finite ?XS;
     Ball ?XS qGood; |?Rho| <o |UNIV| | finite ?Rho; Ball ?Rho qGoodEnv |]
  ==> pickQFreshEnv ?xs ?V ?XS ?Rho ~: ?V &
      (ALL X:?XS. qFresh ?xs (pickQFreshEnv ?xs ?V ?XS ?Rho) X) &
      (ALL rho:?Rho. qFreshEnv ?xs (pickQFreshEnv ?xs ?V ?XS ?Rho) rho)
local.swapped.induct:
  [| (?x1.0, ?x2.0) : swapped; !!X. ?P X X;
     !!X Y Z.
        [| (X, Y) : swapped; ?P X Y; (Y, Z) : swapped; ?P Y Z |] ==> ?P X Z;
     !!X Y x y zs.
        [| (X, Y) : swapped; ?P X Y |] ==> ?P X (Y #[x \<and> y]_zs) |]
  ==> ?P ?x1.0 ?x2.0
local.psubstAll_cong:
  goodPar ?P ==>
  (good ?X -->
   (ALL rho rho'.
       {rho, rho'} <= envsOf ?P -->
       (ALL ys y. fresh ys y ?X | rho ys y = rho' ys y) -->
       ?X #[rho] = ?X #[rho'])) &
  (goodAbs ?A -->
   (ALL rho rho'.
       {rho, rho'} <= envsOf ?P -->
       (ALL ys y. freshAbs ys y ?A | rho ys y = rho' ys y) -->
       ?A $[rho] = ?A $[rho']))
local.swapAll_psubstAll:
  goodPar ?P ==>
  (good ?X -->
   (ALL rho z1 z2.
       rho : envsOf ?P & {z1, z2} <= varsOf ?P -->
       ?X #[rho] #[z1 \<and> z2]_?zs =
       ?X #[z1 \<and> z2]_?zs #[rho &[z1 \<and> z2]_?zs])) &
  (goodAbs ?A -->
   (ALL rho z1 z2.
       rho : envsOf ?P & {z1, z2} <= varsOf ?P -->
       ?A $[rho] $[z1 \<and> z2]_?zs =
       ?A $[z1 \<and> z2]_?zs $[rho &[z1 \<and> z2]_?zs]))
local.swapped.cases:
  [| (?a1.0, ?a2.0) : swapped; !!X. [| ?a1.0 = X; ?a2.0 = X |] ==> ?P;
     !!X Y Z.
        [| ?a1.0 = X; ?a2.0 = Z; (X, Y) : swapped; (Y, Z) : swapped |]
        ==> ?P;
     !!X Y x y zs.
        [| ?a1.0 = X; ?a2.0 = Y #[x \<and> y]_zs; (X, Y) : swapped |]
        ==> ?P |]
  ==> ?P
local.term_induct:
  [| !!xs x. ?phi (Var xs x);
     !!delta inp binp.
        [| goodInp inp; goodBinp binp; liftAll ?phi inp;
           liftAll ?phiAbs binp |]
        ==> ?phi (Op delta inp binp);
     !!xs x X.
        [| good X; !!Y. (X, Y) : swapped ==> ?phi Y;
           !!Y. [| good Y; skel Y = skel X |] ==> ?phi Y |]
        ==> ?phiAbs (Abs xs x X) |]
  ==> (good ?X --> ?phi ?X) & (goodAbs ?A --> ?phiAbs ?A)
local.obtain_fresh:
  [| |?V| <o |UNIV| | finite ?V; |?XS| <o |UNIV| | finite ?XS;
     |?AS| <o |UNIV| | finite ?AS; |?Rho| <o |UNIV| | finite ?Rho;
     Ball ?XS good; Ball ?AS goodAbs; Ball ?Rho goodEnv |]
  ==> EX z. z ~: ?V &
            (ALL X:?XS. fresh ?xs z X) &
            (ALL A:?AS. freshAbs ?xs z A) &
            (ALL rho:?Rho. freshEnv ?xs z rho)
local.term_templateInduct:
  [| !!X Y. [| good X; (X, Y) : ?rel |] ==> good Y & skel Y = skel X;
     !!xs x. ?phi (Var xs x);
     !!delta inp binp.
        [| goodInp inp; goodBinp binp; liftAll ?phi inp;
           liftAll ?phiAbs binp |]
        ==> ?phi (Op delta inp binp);
     !!xs x X.
        [| good X; !!Y. (X, Y) : ?rel ==> ?phi Y |]
        ==> ?phiAbs (Abs xs x X) |]
  ==> (good ?X --> ?phi ?X) & (goodAbs ?A --> ?phiAbs ?A)
local.term_induct_fresh:
  [| goodPar ?P; !!xs x. ?phi (Var xs x);
     !!delta inp binp.
        [| goodInp inp; goodBinp binp; liftAll ?phi inp;
           liftAll ?phiAbs binp |]
        ==> ?phi (Op delta inp binp);
     !!xs x X.
        [| good X; x ~: varsOf ?P; !!Y. Y : termsOf ?P ==> fresh xs x Y;
           !!A. A : absOf ?P ==> freshAbs xs x A;
           !!rho. rho : envsOf ?P ==> freshEnv xs x rho; ?phi X |]
        ==> ?phiAbs (Abs xs x X) |]
  ==> (good ?X --> ?phi ?X) & (goodAbs ?A --> ?phiAbs ?A)
local.term_fresh_forall_induct:
  [| !!p xs. |?varsOf xs p| <o |UNIV|; !!xs x p. ?phi (Var xs x) p;
     !!delta inp binp p.
        [| |{i. inp i ~= None}| <o |UNIV|; |{i. binp i ~= None}| <o |UNIV|;
           liftAll (%X. good X & (ALL q. ?phi X p)) inp;
           liftAll (%A. goodAbs A & (ALL q. ?phiAbs A p)) binp |]
        ==> ?phi (Op delta inp binp) p;
     !!xs x X p.
        [| good X; x ~: ?varsOf p xs; ?phi X p |]
        ==> ?phiAbs (Abs xs x X) p |]
  ==> (good ?X --> (ALL p. ?phi ?X p)) &
      (goodAbs ?A --> (ALL p. ?phiAbs ?A p))
local.term_rawInduct_fresh:
  [| !!xs. (|?vars xs| <o |UNIV| | finite (?vars xs)) &
           (|?terms| <o |UNIV| | finite ?terms) &
           Ball ?terms good &
           (|?abs| <o |UNIV| | finite ?abs) &
           Ball ?abs goodAbs &
           (|?envs| <o |UNIV| | finite ?envs) & Ball ?envs goodEnv;
     !!xs x. ?phi (Var xs x);
     !!delta inp binp.
        [| goodInp inp; goodBinp binp; liftAll ?phi inp;
           liftAll ?phiAbs binp |]
        ==> ?phi (Op delta inp binp);
     !!xs x X.
        [| good X; x ~: ?vars xs; !!Y. Y : ?terms ==> fresh xs x Y;
           !!A. A : ?abs ==> freshAbs xs x A;
           !!rho. rho : ?envs ==> freshEnv xs x rho; ?phi X |]
        ==> ?phiAbs (Abs xs x X) |]
  ==> (good ?X --> ?phi ?X) & (goodAbs ?A --> ?phiAbs ?A)
local.term_templateInduct_fresh:
  [| !!xs. (|?vars xs| <o |UNIV| | finite (?vars xs)) &
           (|?terms| <o |UNIV| | finite ?terms) &
           Ball ?terms good &
           (|?abs| <o |UNIV| | finite ?abs) &
           Ball ?abs goodAbs &
           (|?envs| <o |UNIV| | finite ?envs) & Ball ?envs goodEnv;
     !!X Y. [| good X; (X, Y) : ?rel |] ==> good Y & skel Y = skel X;
     !!xs x. ?phi (Var xs x);
     !!delta inp binp.
        [| goodInp inp; goodBinp binp; liftAll ?phi inp;
           liftAll ?phiAbs binp |]
        ==> ?phi (Op delta inp binp);
     !!xs x X.
        [| good X; x ~: ?vars xs; !!Y. Y : ?terms ==> fresh xs x Y;
           !!A. A : ?abs ==> freshAbs xs x A;
           !!rho. rho : ?envs ==> freshEnv xs x rho;
           !!Y. (X, Y) : ?rel ==> ?phi Y |]
        ==> ?phiAbs (Abs xs x X) |]
  ==> (good ?X --> ?phi ?X) & (goodAbs ?A --> ?phiAbs ?A)
locale FixSyn
  fixes dummyV :: "'var"
    and Delta :: "('index, 'bindex, 'varSort, 'sort, 'opSym) signature"
  assumes "FixSyn TYPE('var) Delta"
find_theorems
  name: "local."
  "rec"
found 17 theorem(s):
local.rec_def: rec ?MOD == fromIMor (iter (fromMOD ?MOD))
local.wlsFSb_recAll_termFSbMorph:
  wlsFSb ?MOD ==> termFSbMorph (rec ?MOD) (recAbs ?MOD) ?MOD
local.wlsFSbSw_recAll_termFSwSbMorph:
  wlsFSbSw ?MOD ==> termFSwSbMorph (rec ?MOD) (recAbs ?MOD) ?MOD
local.wlsFSw_recAll_termFSwMorph:
  wlsFSw ?MOD ==> termFSwMorph (rec ?MOD) (recAbs ?MOD) ?MOD
local.wlsFSwSb_recAll_termFSwSbMorph:
  wlsFSwSb ?MOD ==> termFSwSbMorph (rec ?MOD) (recAbs ?MOD) ?MOD
local.wlsFSb_recAll_isInjAll:
  [| wlsFSb ?MOD; gConsInj ?MOD |] ==> isInjAll (rec ?MOD) (recAbs ?MOD)
local.wlsFSb_recAll_reflFreshAll:
  [| wlsFSb ?MOD; gFreshClsRev ?MOD |]
  ==> reflFreshAll (rec ?MOD) (recAbs ?MOD) ?MOD
local.wlsFSw_recAll_reflFreshAll:
  [| wlsFSw ?MOD; gFreshClsRev ?MOD |]
  ==> reflFreshAll (rec ?MOD) (recAbs ?MOD) ?MOD
local.wlsFSw_recAll_isInjAll:
  [| wlsFSw ?MOD; gAbsRenS ?MOD; gConsInj ?MOD |]
  ==> isInjAll (rec ?MOD) (recAbs ?MOD)
local.wlsFSb_recAll_isSurjAll:
  [| wlsFSb ?MOD; gConsIndif ?MOD; gInduct ?MOD |]
  ==> isSurjAll (rec ?MOD) (recAbs ?MOD) ?MOD
local.wlsFSw_recAll_isSurjAll:
  [| wlsFSw ?MOD; gConsIndif ?MOD; gInduct ?MOD |]
  ==> isSurjAll (rec ?MOD) (recAbs ?MOD) ?MOD
local.wlsFSb_recAll_unique_presCons:
  [| wlsFSb ?MOD; presCons ?h ?hA ?MOD |]
  ==> (wls ?s ?X --> ?h ?X = rec ?MOD ?X) &
      (wlsAbs (?us, ?s') ?A --> ?hA ?A = recAbs ?MOD ?A)
local.wlsFSbSw_recAll_unique_presCons:
  [| wlsFSbSw ?MOD; presCons ?h ?hA ?MOD |]
  ==> (wls ?s ?X --> ?h ?X = rec ?MOD ?X) &
      (wlsAbs (?us, ?s') ?A --> ?hA ?A = recAbs ?MOD ?A)
local.wlsFSw_recAll_unique_presCons:
  [| wlsFSw ?MOD; presCons ?h ?hA ?MOD |]
  ==> (wls ?s ?X --> ?h ?X = rec ?MOD ?X) &
      (wlsAbs (?us, ?s') ?A --> ?hA ?A = recAbs ?MOD ?A)
local.wlsFSwSb_recAll_unique_presCons:
  [| wlsFSwSb ?MOD; presCons ?h ?hA ?MOD |]
  ==> (wls ?s ?X --> ?h ?X = rec ?MOD ?X) &
      (wlsAbs (?us, ?s') ?A --> ?hA ?A = recAbs ?MOD ?A)
local.gInduct_gConsIndif_recAll_isSurjAll:
  [| presWlsAll (rec ?MOD) (recAbs ?MOD) ?MOD;
     presCons (rec ?MOD) (recAbs ?MOD) ?MOD; gConsIndif ?MOD;
     gInduct ?MOD |]
  ==> isSurjAll (rec ?MOD) (recAbs ?MOD) ?MOD
local.gFreshClsRev_recAll_reflFreshAll:
  [| presWlsAll (rec ?MOD) (recAbs ?MOD) ?MOD;
     presCons (rec ?MOD) (recAbs ?MOD) ?MOD;
     presFreshAll (rec ?MOD) (recAbs ?MOD) ?MOD; gFreshClsRev ?MOD |]
  ==> reflFreshAll (rec ?MOD) (recAbs ?MOD) ?MOD
locale FixSyn
  fixes dummyV :: "'var"
    and Delta :: "('index, 'bindex, 'varSort, 'sort, 'opSym) signature"
  assumes "FixSyn TYPE('var) Delta"
find_theorems
  name: "local."
  "semInt"
found 16 theorem(s):
local.semInt_def: semInt ?SEM == iter (asIMOD ?SEM)
local.semInt_prFresh: wlsSEM ?SEM ==> prFresh (semInt ?SEM) ?SEM
local.semInt_prSubst: wlsSEM ?SEM ==> prSubst (semInt ?SEM) ?SEM
local.semInt_prSwap: wlsSEM ?SEM ==> prSwap (semInt ?SEM) ?SEM
local.semInt_prVar: wlsSEM ?SEM ==> prVar (semInt ?SEM) ?SEM
local.semInt_prWls: wlsSEM ?SEM ==> prWls (semInt ?SEM) ?SEM
local.semIntAll_compInt:
  wlsSEM ?SEM ==> compInt (semInt ?SEM) (semIntAbs ?SEM) ?SEM
local.semIntAll_prCons:
  wlsSEM ?SEM ==> prCons (semInt ?SEM) (semIntAbs ?SEM) ?SEM
local.semIntAll_prFreshAll:
  wlsSEM ?SEM ==> prFreshAll (semInt ?SEM) (semIntAbs ?SEM) ?SEM
local.semIntAll_prOp:
  wlsSEM ?SEM ==> prOp (semInt ?SEM) (semIntAbs ?SEM) ?SEM
local.semIntAbs_prSubstAbs:
  wlsSEM ?SEM ==> prSubstAbs (semInt ?SEM) (semIntAbs ?SEM) ?SEM
local.semIntAll_prSubstAll:
  wlsSEM ?SEM ==> prSubstAll (semInt ?SEM) (semIntAbs ?SEM) ?SEM
local.semIntAll_prSwapAll:
  wlsSEM ?SEM ==> prSwapAll (semInt ?SEM) (semIntAbs ?SEM) ?SEM
local.semIntAll_prWlsAll:
  wlsSEM ?SEM ==> prWlsAll (semInt ?SEM) (semIntAbs ?SEM) ?SEM
local.semIntAll_prAbs:
  wlsSEM ?SEM ==> prAbs (semInt ?SEM) (semIntAbs ?SEM) ?SEM
local.semIntAll_termFSwSbImorph:
  wlsSEM ?SEM ==>
  termFSwSbImorph (semInt ?SEM) (semIntAbs ?SEM) (asIMOD ?SEM)
locale FixSyn
  fixes dummyV :: "'var"
    and Delta :: "('index, 'bindex, 'varSort, 'sort, 'opSym) signature"
  assumes "FixSyn TYPE('var) Delta"
### theory "Draft.Binding_Syntax"
### 2.174s elapsed time, 3.492s cpu time, 0.391s GC time
Loading theory "Draft.Binding_SyntaxTemplates"
find_theorems
  name: "local."
  -name: "ig"
  -name: "ip"
  -name: "q"
  -name: "alpha"
  -name: "termMOD"
  -"iter"
  -"rec"
  -name: "iter"
  -name: "rec"
  -"asTerm"
  -"asAbs"
  -"asInp"
  -"asBinp"
  -"semInt"
  -"semIntAbs"
  -"asIMOD"
  -"fromMOD"
  -name: "gFresh"
  -name: "gSwap"
  -name: "gSubst"
  -name: "gVar"
  -name: "gCons"
  -name: "gVar"
  -name: "gOp"
  -name: "sFresh"
  -name: "sSwap"
  -name: "sSubst"
  -name: "sVar"
  -name: "sCons"
  -name: "sVar"
  -name: "sOp"
  -name: "eFresh"
  -name: "eSwap"
  -name: "eSubst"
  -name: "eVar"
  -name: "IMor"
  -name: "iwls"
  -"good"
  -"goodAbs"
  -"goodInp"
  -"goodBinp"
  -name: "Imorph"
  -name: "sWls"
  -"ERR"
  -"OK"
  -name: "error"
  -name: "FSb"
  -name: "FSw"
  -name: "gInduct"
found 588 theorem(s):
local.var_infinite: var_infinite undefined
local.var_regular: var_regular undefined
local.idEnv_preserves_good: goodEnv idEnv
local.varSortAsSort_inj: varSortAsSort_inj Delta
local.var_regular_INNER: regular |UNIV|
local.var_infinite_INNER: infinite UNIV
local.FixVars_axioms: FixVars TYPE('var) TYPE('varSort)
local.varSort_lt_var: varSort_lt_var undefined undefined
local.swappedp.Refl: swappedp ?X ?X
local.FixSyn_axioms: FixSyn TYPE('var) Delta
local.idEnv_preserves_wls: wlsEnv idEnv
local.arityOf_lt_var: arityOf_lt_var undefined Delta
local.barityOf_lt_var: barityOf_lt_var undefined Delta
local.sort_lt_var: sort_lt_var undefined undefined
local.varSortAsSort_inj_INNER: inj asSort
local.freshEnv_idEnv: freshEnv ?xs ?x idEnv
local.idEnv_def: idEnv == %xs. Map.empty
local.checkI_OKI: checkI (OKI ?inp) = ?inp
local.psubstEnv_idEnv: idEnv &[?rho] = ?rho
local.getEnv_idEnv: idEnv ?xs ?x = None
local.swapped.Refl: (?X, ?X) : swapped
local.freshBinp_empBinp: freshBinp ?xs ?x empBinp
local.freshInp_empInp: freshInp ?xs ?x empInp
local.checkI_def: checkI ?einp == lift check ?einp
local.pickBinp_def: pickBinp ?binp == lift pick ?binp
local.pickInp_def: pickInp ?inp == lift pick ?inp
local.skel_def: skel ?X == qSkel (pick ?X)
local.skelAbs_def: skelAbs ?A == qSkelAbs (pick ?A)
local.skelBinp_def: skelBinp ?binp = qSkelBinp (pickBinp ?binp)
local.skelInp_def: skelInp ?inp = qSkelInp (pickInp ?inp)
local.cast_simps(2): ~ isOp ?s (Var ?xs ?X)
local.infinite_var_regular_INNER: infinite UNIV & regular |UNIV|
local.psubstInp_empInp: empInp %[?rho] = empInp
local.psubstBinp_empBinp: empBinp %%[?rho] = empBinp
local.swapVal_ident: ?val ^[?x \<and> ?x]_?xs = ?val
local.swapEnv_idEnv: idEnv &[?x \<and> ?y]_?xs = idEnv
local.sort_le_var: |UNIV| \<le>o |UNIV|
local.sort_lt_var_INNER: |UNIV| <o |UNIV|
local.varSort_le_Var: |UNIV| \<le>o |UNIV|
local.varSort_lt_var_INNER: |UNIV| <o |UNIV|
local.varSort_sort_le_var: |UNIV| \<le>o |UNIV|
local.varSort_sort_lt_var: |UNIV| <o |UNIV|
local.pickE_def: pickE ?rho == %xs. lift pick (?rho xs)
local.psubstBinp_def: ?binp %%[?rho] == lift (psubstAbs ?rho) ?binp
local.psubstInp_def: ?inp %[?rho] == lift (psubst ?rho) ?inp
local.wlsEnv_imp_goodEnv: wlsEnv ?rho ==> goodEnv ?rho
local.exists_asSort_wls: EX X. wls (asSort ?xs) X
local.swapEnv_defs(2): ?f o ?g = (%x. ?f (?g x))
local.wls_wlsAbs_wlsInp_wlsBinp.Var: wls (asSort ?xs) (Var ?xs ?x)
local.swapped_def: swapped == {(x, y). swappedp x y}
local.Var_diff_Op: Var ?xs ?x ~= Op ?delta ?inp ?binp
local.good_item_simps(35): Var ?xsa ?xa ~= Op ?delta ?inp ?binpa
local.Op_diff_Var: Op ?delta ?inp ?binp ~= Var ?xs ?x
local.good_item_simps(36): Op ?delta ?inp ?binpa ~= Var ?xsa ?xa
local.substInp_empInp: empInp %[?Y / ?y]_?ys = empInp
local.swapInp_empInp: empInp %[?x1.0 \<and> ?x2.0]_?xs = empInp
local.vsubstInp_empInp: empInp %[?y1.0 // ?y]_?ys = empInp
local.substBinp_empBinp: empBinp %%[?Y / ?y]_?ys = empBinp
local.swapBinp_empBinp: empBinp %%[?x1.0 \<and> ?x2.0]_?xs = empBinp
local.vsubstBinp_empBinp: empBinp %%[?y1.0 // ?y]_?ys = empBinp
local.param_simps(3): envsOf (Par ?uu ?uva ?uwa ?rhoL) = set ?rhoL
local.paramS_simps(4): envsOfS (ParS ?uu ?uv ?uw ?rhoL) = set ?rhoL
local.param_simps(2): absOf (Par ?uu ?uva ?ALa ?uw) = set ?ALa
local.param_simps(1): termsOf (Par ?uu ?XLa ?uv ?uw) = set ?XLa
local.OKI_inj: (OKI ?inp = OKI ?inp') = (?inp = ?inp')
local.swap_swapped: (?X, ?X #[?x \<and> ?y]_?zs) : swapped
local.gWlsAllDisj_def: gWlsAllDisj ?MOD == gWlsDisj ?MOD & gWlsAbsDisj ?MOD
local.fresh_def: fresh ?xs ?x ?X == qFresh ?xs ?x (pick ?X)
local.freshAbs_def: freshAbs ?xs ?x ?A == qFreshAbs ?xs ?x (pick ?A)
local.freshBinp_def:
  freshBinp ?xs ?x ?binp == liftAll (freshAbs ?xs ?x) ?binp
local.freshInp_def: freshInp ?xs ?x ?inp == liftAll (fresh ?xs ?x) ?inp
local.psubstEnv_idEnv_id: goodEnv ?rho ==> ?rho &[idEnv] = ?rho
local.good_item_simps(65): goodEnv ?rhoa ==> ?rhoa &[idEnv] = ?rhoa
local.substBinp_def2: substBinp ?ys ?Y ?y = lift (substAbs ?ys ?Y ?y)
local.substInp_def2: substInp ?ys ?Y ?y = lift (subst ?ys ?Y ?y)
local.freshBinp_def2:
  freshBinp ?xs ?x ?binp = qFreshBinp ?xs ?x (pickBinp ?binp)
local.freshEnv_def2: freshEnv ?xs ?x ?rho = qFreshEnv ?xs ?x (pickE ?rho)
local.freshInp_def2: freshInp ?xs ?x ?inp = qFreshInp ?xs ?x (pickInp ?inp)
local.getEnv_updEnv2: (?rho [?x \<leftarrow> ?X]_?xs) ?xs ?x = Some ?X
local.skel_Var_simp: skel (Var ?xs ?x) = Branch Map.empty Map.empty
local.substBinp_def:
  substBinp ?xs ?X ?x == psubstBinp (idEnv [?x \<leftarrow> ?X]_?xs)
local.vsubstBinp_def:
  vsubstBinp ?ys ?y1.0 ?y2.0 == substBinp ?ys (Var ?ys ?y1.0) ?y2.0
local.substInp_def:
  substInp ?xs ?X ?x == psubstInp (idEnv [?x \<leftarrow> ?X]_?xs)
local.vsubstInp_def:
  vsubstInp ?ys ?y1.0 ?y2.0 == substInp ?ys (Var ?ys ?y1.0) ?y2.0
local.substEnv_def:
  substEnv ?xs ?X ?x == psubstEnv (idEnv [?x \<leftarrow> ?X]_?xs)
local.vsubstEnv_def:
  vsubstEnv ?ys ?y1.0 ?y2.0 == substEnv ?ys (Var ?ys ?y1.0) ?y2.0
local.substAbs_def:
  substAbs ?xs ?X ?x == psubstAbs (idEnv [?x \<leftarrow> ?X]_?xs)
local.vsubstAbs_def:
  vsubstAbs ?ys ?y1.0 ?y2.0 == substAbs ?ys (Var ?ys ?y1.0) ?y2.0
local.subst_def: subst ?xs ?X ?x == psubst (idEnv [?x \<leftarrow> ?X]_?xs)
local.vsubst_def: vsubst ?ys ?y1.0 ?y2.0 == subst ?ys (Var ?ys ?y1.0) ?y2.0
local.swapEnvDom_preserves_good:
  goodEnv ?rho ==> goodEnv (swapEnvDom ?xs ?x ?y ?rho)
local.swapEnvIm_preserves_good:
  goodEnv ?rho ==> goodEnv (swapEnvIm ?xs ?x ?y ?rho)
local.swapEnv_preserves_good:
  goodEnv ?rho ==> goodEnv (?rho &[?x \<and> ?y]_?xs)
local.vsubstEnv_preserves_good:
  goodEnv ?rho ==> goodEnv (?rho &[?x1.0 // ?x]_?xs)
local.good_item_simps(15):
  goodEnv ?rhoa ==> goodEnv (?rhoa &[?xa \<and> ?y]_?xsa)
local.good_item_simps(33):
  goodEnv ?rhoa ==> goodEnv (?rhoa &[?x1.0 // ?xa]_?xsa)
local.wls_psubstEnv_idEnv_id: wlsEnv ?rho ==> ?rho &[idEnv] = ?rho
local.swapVal_sym: ?val ^[?x \<and> ?y]_?zs = ?val ^[?y \<and> ?x]_?zs
local.swapVal_involutive:
  ?val ^[?x \<and> ?y]_?zs ^[?x \<and> ?y]_?zs = ?val
local.substEnv_idEnv: idEnv &[?X / ?x]_?xs = idEnv [?x \<leftarrow> ?X]_?xs
local.swapEnv_sym: ?rho &[?x \<and> ?y]_?zs = ?rho &[?y \<and> ?x]_?zs
local.paramS_simps(1): varsOfS (ParS ?xLF ?uu ?uv ?uw) ?xs = set (?xLF ?xs)
local.paramS_simps(2): termsOfS (ParS ?uu ?XLF ?uv ?uw) ?s = set (?XLF ?s)
local.swap_sym: ?X #[?x \<and> ?y]_?zs = ?X #[?y \<and> ?x]_?zs
local.asSort_inj: (asSort ?xs = asSort ?ys) = (?xs = ?ys)
local.swapBinp_def:
  ?binp %%[?x \<and> ?y]_?xs == lift (swapAbs ?xs ?x ?y) ?binp
local.swapInp_def: ?inp %[?x \<and> ?y]_?xs == lift (swap ?xs ?x ?y) ?inp
local.isInjAll_def: isInjAll ?h ?hA == isInj ?h & isInjAbs ?hA
local.pickE_asEnv: qGoodEnv ?qrho ==> pickE (asEnv ?qrho) &= ?qrho
local.swapEnv_ident: goodEnv ?rho ==> ?rho &[?x \<and> ?x]_?xs = ?rho
local.good_item_simps(59):
  goodEnv ?rhoa ==> ?rhoa &[?xa \<and> ?xa]_?xsa = ?rhoa
local.freshEnv_getEnv: freshEnv ?ys ?y ?rho ==> ?rho ?ys ?y = None
local.cast_simps(16): compatAbsVsubst ?xs ?s ?f ==> compatAbsSubst ?xs ?s ?f
local.wls_psubst_idEnv: wls ?s ?X ==> ?X #[idEnv] = ?X
local.vsubstBinp_def2:
  ?binp %%[?y1.0 // ?y2.0]_?ys = lift (vsubstAbs ?ys ?y1.0 ?y2.0) ?binp
local.vsubstInp_def2:
  ?inp %[?y1.0 // ?y2.0]_?ys = lift (vsubst ?ys ?y1.0 ?y2.0) ?inp
local.wls_Var_simp: wls ?s (Var ?xs ?x) = (?s = asSort ?xs)
local.castVar_asSort_Var: castVar (asSort ?xs) (Var ?xs ?x) = (?xs, ?x)
local.wlsSEM_def:
  wlsSEM ?SEM == sWlsNE ?SEM & sWlsDisj ?SEM & sOpPrSWls ?SEM
local.psubstEnv_preserves_good:
  [| goodEnv ?rho; goodEnv ?rho' |] ==> goodEnv ?rho &[?rho']
local.good_item_simps(20):
  [| goodEnv ?rhoa; goodEnv ?rho' |] ==> goodEnv ?rhoa &[?rho']
local.envsOf_preserves_good:
  [| goodPar ?P; ?rho : envsOf ?P |] ==> goodEnv ?rho
local.good_item_simps(7):
  [| goodPar ?P; ?rhoa : envsOf ?P |] ==> goodEnv ?rhoa
local.conjLeft: [| ?phi1.0 & ?phi2.0; ?phi1.0 ==> ?chi |] ==> ?chi
local.swappedp.Swap: swappedp ?X ?Y ==> swappedp ?X (?Y #[?x \<and> ?y]_?zs)
local.wls_swapEnv_ident: wlsEnv ?rho ==> ?rho &[?x \<and> ?x]_?xs = ?rho
local.swapEnv_preserves_wls:
  wlsEnv ?rho ==> wlsEnv (?rho &[?z1.0 \<and> ?z2.0]_?zs)
local.swapEnvDom_preserves_wls:
  wlsEnv ?rho ==> wlsEnv (swapEnvDom ?xs ?x ?y ?rho)
local.swapEnvIm_preserves_wls:
  wlsEnv ?rho ==> wlsEnv (swapEnvIm ?xs ?x ?y ?rho)
local.vsubstEnv_preserves_wls:
  wlsEnv ?rho ==> wlsEnv (?rho &[?x1.0 // ?x]_?xs)
local.wls_skelBinp_def2:
  wlsBinp ?delta ?binp ==> skelBinp ?binp = lift skelAbs ?binp
local.wls_skelInp_def2: wlsInp ?delta ?inp ==> skelInp ?inp = lift skel ?inp
local.substEnv_psubstEnv_idEnv:
  ?rho &[?Y / ?y]_?ys = ?rho &[idEnv [?y \<leftarrow> ?Y]_?ys]
local.vsubstEnv_idEnv:
  idEnv &[?y // ?x]_?xs = idEnv [?x \<leftarrow> Var ?xs ?y]_?xs
local.subst_psubst_idEnv:
  ?X #[?Y / ?y]_?ys = ?X #[idEnv [?y \<leftarrow> ?Y]_?ys]
local.semDom_simps(6):
  sWlsVal ?SEM (?val ^[?z1.0 \<and> ?z2.0]_?zs) = sWlsVal ?SEM ?val
local.swapEnvIm_def:
  swapEnvIm ?xs ?x ?y ?rho == %zs. lift (swap ?xs ?x ?y) (?rho zs)
local.swapEnv_defs(4):
  swapEnvIm ?xsa ?xa ?ya ?rhoa == %zs. lift (swap ?xsa ?xa ?ya) (?rhoa zs)
local.swapEnv_def:
  swapEnv ?xs ?x ?y == swapEnvIm ?xs ?x ?y o swapEnvDom ?xs ?x ?y
local.swapEnv_defs(1):
  swapEnv ?xsa ?xa ?ya == swapEnvIm ?xsa ?xa ?ya o swapEnvDom ?xsa ?xa ?ya
local.asEnv_pickE: goodEnv ?rho ==> asEnv (pickE ?rho) ?xs ?x = ?rho ?xs ?x
local.swappedp.Trans:
  [| swappedp ?X ?Y; swappedp ?Y ?Z |] ==> swappedp ?X ?Z
local.wls_swap_ident: wls ?s ?X ==> ?X #[?x \<and> ?x]_?xs = ?X
local.wls_vsubst_ident: wls ?s ?X ==> ?X #[?z // ?z]_?zs = ?X
local.wls_psubstAbs_idEnv: wlsAbs (?us, ?s) ?A ==> ?A $[idEnv] = ?A
local.sortTermCase_asSort_Var_simp:
  sortTermCase ?fVar ?fOp (asSort ?xs) (Var ?xs ?x) = ?fVar ?xs ?x
local.eWlsBinp_simp1:
  eWlsBinp ?MOD ?delta (OKI ?binp) = igWlsBinp ?MOD ?delta ?binp
local.eWlsInp_simp1:
  eWlsInp ?MOD ?delta (OKI ?inp) = igWlsInp ?MOD ?delta ?inp
local.gWlsInp_defs(2):
  sameDom ?inp1.0 ?inp2.0 == ALL i. (?inp1.0 i = None) = (?inp2.0 i = None)
local.isSurjAll_def:
  isSurjAll ?h ?hA ?MOD == isSurj ?h ?MOD & isSurjAbs ?hA ?MOD
local.reflFreshAll_def:
  reflFreshAll ?h ?hA ?MOD == reflFresh ?h ?MOD & reflFreshAbs ?hA ?MOD
local.prFreshAll_def:
  prFreshAll ?g ?gA ?SEM == prFresh ?g ?SEM & prFreshAbs ?gA ?SEM
local.prSwapAll_def:
  prSwapAll ?g ?gA ?SEM == prSwap ?g ?SEM & prSwapAbs ?gA ?SEM
local.prWlsAll_def:
  prWlsAll ?g ?gA ?SEM == prWls ?g ?SEM & prWlsAbs ?gA ?SEM
local.envsOfS_preserves_wls:
  [| wlsPar ?P; ?rho : envsOfS ?P |] ==> wlsEnv ?rho
local.swap_preserves_wls:
  wls ?s ?X ==> wls ?s (?X #[?z1.0 \<and> ?z2.0]_?zs)
local.vsubst_preserves_wls: wls ?s ?Y ==> wls ?s (?Y #[?x1.0 // ?x]_?xs)
local.swapBinp_preserves_wls:
  wlsBinp ?delta ?binp ==> wlsBinp ?delta (?binp %%[?z1.0 \<and> ?z2.0]_?zs)
local.vsubstBinp_preserves_wls:
  wlsBinp ?delta ?binp ==> wlsBinp ?delta (?binp %%[?x1.0 // ?x]_?xs)
local.swapInp_preserves_wls:
  wlsInp ?delta ?inp ==> wlsInp ?delta (?inp %[?z1.0 \<and> ?z2.0]_?zs)
local.vsubstInp_preserves_wls:
  wlsInp ?delta ?inp ==> wlsInp ?delta (?inp %[?x1.0 // ?x]_?xs)
local.freshEnv_updEnv_E1:
  freshEnv ?xs ?y (?rho [?x \<leftarrow> ?X]_?xs) ==> ?y ~= ?x
local.freshEnv_updEnv_E2:
  freshEnv ?ys ?y (?rho [?x \<leftarrow> ?X]_?xs) ==> fresh ?ys ?y ?X
local.updVal_over:
  ?val (?x := ?sX)_?xs (?x := ?sX')_?xs = ?val (?x := ?sX')_?xs
local.vsubstEnv_psubstEnv_idEnv:
  ?rho &[?z // ?y]_?ys = ?rho &[idEnv [?y \<leftarrow> Var ?ys ?z]_?ys]
local.psubstEnv_updEnv_idEnv:
  idEnv [?x \<leftarrow> ?X]_?xs &[?rho] =
  ?rho [?x \<leftarrow> ?X #[?rho]]_?xs
local.updEnv_overwrite:
  ?rho [?x \<leftarrow> ?X]_?xs [?x \<leftarrow> ?X']_?xs =
  ?rho [?x \<leftarrow> ?X']_?xs
local.paramS_simps(3):
  absOfS (ParS ?uu ?uv ?ALF ?uw) (?xs, ?s) = set (?ALF (?xs, ?s))
local.vsubst_psubst_idEnv:
  ?X #[?z // ?y]_?ys = ?X #[idEnv [?y \<leftarrow> Var ?ys ?z]_?ys]
local.Var_inj: (Var ?xs ?x = Var ?ys ?y) = (?xs = ?ys & ?x = ?y)
local.swapEnvDom_def:
  swapEnvDom ?xs ?x ?y ?rho == %zs z. ?rho zs (z @zs[?x \<and> ?y]_?xs)
local.swapVal_def:
  ?val ^[?z1.0 \<and> ?z2.0]_?zs ==
  %xs x. ?val xs (x @xs[?z1.0 \<and> ?z2.0]_?zs)
local.prSubstAll_def:
  prSubstAll ?g ?gA ?SEM == prSubst ?g ?SEM & prSubstAbs ?g ?gA ?SEM
local.swapEnv_involutive:
  goodEnv ?rho ==> ?rho &[?x \<and> ?y]_?zs &[?x \<and> ?y]_?zs = ?rho
local.swapEnv_involutive2:
  goodEnv ?rho ==> ?rho &[?x \<and> ?y]_?zs &[?y \<and> ?x]_?zs = ?rho
local.good_item_simps(60):
  goodEnv ?rhoa ==> ?rhoa &[?xa \<and> ?y]_?zs &[?xa \<and> ?y]_?zs = ?rhoa
local.good_item_simps(61):
  goodEnv ?rhoa ==> ?rhoa &[?xa \<and> ?y]_?zs &[?y \<and> ?xa]_?zs = ?rhoa
local.psubstEnv_preserves_wls:
  [| wlsEnv ?rho; wlsEnv ?rho' |] ==> wlsEnv ?rho &[?rho']
local.stOf_castOp: isOp ?s ?X ==> stOf (fst3 (castOp ?s ?X)) = ?s
local.asSort_castVar: isVar ?s ?X ==> asSort (fst (castVar ?s ?X)) = ?s
local.wls_subst_ident: wls ?s ?X ==> ?X #[Var ?zs ?z / ?z]_?zs = ?X
local.wls_skel_swap:
  wls ?s ?X ==> skel (?X #[?x1.0 \<and> ?x2.0]_?xs) = skel ?X
local.wls_skel_vsubst:
  wls ?s ?X ==> skel (?X #[?y1.0 // ?y2.0]_?ys) = skel ?X
local.wls_disjoint: [| wls ?s ?X; wls ?s' ?X |] ==> ?s = ?s'
local.wls_swapAbs_ident: wlsAbs (?us, ?s) ?A ==> ?A $[?x \<and> ?x]_?xs = ?A
local.wls_vsubstAbs_ident: wlsAbs (?us, ?s) ?A ==> ?A $[?z // ?z]_?zs = ?A
local.freshEnv_updEnv_E3:
  freshEnv ?ys ?y (?rho [?x \<leftarrow> ?X]_?xs) ==> ?rho ?ys ?y = None
local.swap_Var_simp:
  Var ?xs ?x #[?y1.0 \<and> ?y2.0]_?ys =
  Var ?xs (?x @?xs[?y1.0 \<and> ?y2.0]_?ys)
local.vsubst_Var_simp:
  Var ?xs ?x #[?y1.0 // ?y]_?ys = Var ?xs (?x @?xs[?y1.0 / ?y]_?ys)
local.fresh_Var_simp: fresh ?ys ?y (Var ?xs ?x) = (?ys ~= ?xs | ?y ~= ?x)
local.wls_swapEnv_involutive:
  wlsEnv ?rho ==> ?rho &[?x \<and> ?y]_?zs &[?x \<and> ?y]_?zs = ?rho
local.wls_swapEnv_involutive2:
  wlsEnv ?rho ==> ?rho &[?x \<and> ?y]_?zs &[?y \<and> ?x]_?zs = ?rho
local.termsOfS_preserves_wls:
  [| wlsPar ?P; ?X : termsOfS ?P ?s |] ==> wls ?s ?X
local.getEnv_substEnv4:
  freshEnv ?ys ?y ?rho ==> (?rho &[?Y / ?y]_?ys) ?ys ?y = Some ?Y
local.getEnv_psubstEnv_None:
  ?rho ?xs ?x = None ==> ?rho &[?rho'] ?xs ?x = ?rho' ?xs ?x
local.swapped.Swap:
  (?X, ?Y) : swapped ==> (?X, ?Y #[?x \<and> ?y]_?zs) : swapped
local.getEnv_ext: (!!xs x. ?rho xs x = ?rho' xs x) ==> ?rho = ?rho'
local.psubstEnv_updEnv:
  ?rho [?x \<leftarrow> ?X]_?xs &[?rho'] =
  ?rho &[?rho'] [?x \<leftarrow> ?X #[?rho']]_?xs
local.psubstEnv_def:
  ?rho' &[?rho] ==
  %xs x. case ?rho' xs x of None => ?rho xs x | Some X => Some X #[?rho]
local.freshEnv_swapEnv_exchange1:
  goodEnv ?rho ==>
  freshEnv ?xs ?x2.0 (?rho &[?x1.0 \<and> ?x2.0]_?xs) =
  freshEnv ?xs ?x1.0 ?rho
local.freshEnv_swapEnv_exchange2:
  goodEnv ?rho ==>
  freshEnv ?xs ?x2.0 (?rho &[?x2.0 \<and> ?x1.0]_?xs) =
  freshEnv ?xs ?x1.0 ?rho
local.wls_swap_involutive:
  wls ?s ?X ==> ?X #[?x \<and> ?y]_?zs #[?x \<and> ?y]_?zs = ?X
local.wls_swap_involutive2:
  wls ?s ?X ==> ?X #[?x \<and> ?y]_?zs #[?y \<and> ?x]_?zs = ?X
local.psubst_preserves_wls:
  [| wls ?s ?X; wlsEnv ?rho |] ==> wls ?s ?X #[?rho]
local.swapped_preserves_wls:
  [| wls ?s ?X; (?X, ?Y) : swapped |] ==> wls ?s ?Y
local.psubstBinp_preserves_wls:
  [| wlsBinp ?delta ?binp; wlsEnv ?rho |] ==> wlsBinp ?delta ?binp %%[?rho]
local.psubstInp_preserves_wls:
  [| wlsInp ?delta ?inp; wlsEnv ?rho |] ==> wlsInp ?delta ?inp %[?rho]
local.wls_subst_Var_simp2:
  wls (asSort ?xs) ?Y ==> Var ?xs ?x #[?Y / ?x]_?xs = ?Y
local.wls_substAbs_ident:
  wlsAbs (?us, ?s) ?A ==> ?A $[Var ?zs ?z / ?z]_?zs = ?A
local.wls_skelAbs_swapAbs:
  wlsAbs (?us, ?s) ?A ==>
  skelAbs (?A $[?x1.0 \<and> ?x2.0]_?xs) = skelAbs ?A
local.wls_skelAbs_vsubstAbs:
  wlsAbs (?us, ?s) ?A ==> skelAbs (?A $[?y1.0 // ?y2.0]_?ys) = skelAbs ?A
local.wls_castAbs: wlsAbs (?xs, ?s) ?A ==> wls ?s (snd (castAbs ?xs ?s ?A))
local.finite_ordLess_var: (|?S| <o |UNIV| | finite ?S) = (|?S| <o |UNIV|)
local.isInBar_def:
  isInBar ?xs_s == EX delta i. wlsOpS delta & barOf delta i = Some ?xs_s
local.freshEnv_def:
  freshEnv ?xs ?x ?rho ==
  ?rho ?xs ?x = None & (ALL ys. liftAll (fresh ?xs ?x) (?rho ys))
local.wls_freshEnv_swapEnv_exchange1:
  wlsEnv ?rho ==>
  freshEnv ?xs ?x2.0 (?rho &[?x1.0 \<and> ?x2.0]_?xs) =
  freshEnv ?xs ?x1.0 ?rho
local.wls_freshEnv_swapEnv_exchange2:
  wlsEnv ?rho ==>
  freshEnv ?xs ?x2.0 (?rho &[?x2.0 \<and> ?x1.0]_?xs) =
  freshEnv ?xs ?x1.0 ?rho
local.wlsInp_empAr_empInp:
  [| wlsOpS ?delta; arOf ?delta = empAr |] ==> wlsInp ?delta empInp
local.wlsBinp_empBar_empBinp:
  [| wlsOpS ?delta; barOf ?delta = empBar |] ==> wlsBinp ?delta empBinp
local.freshEnv_getEnv2:
  [| freshEnv ?ys ?y ?rho; ?rho ?xs ?x = Some ?X |] ==> fresh ?ys ?y ?X
local.getEnv_vsubstEnv4:
  freshEnv ?ys ?y ?rho ==> (?rho &[?z // ?y]_?ys) ?ys ?y = Some (Var ?ys ?z)
local.wlsBinp_castOp:
  isOp ?s ?X ==> wlsBinp (fst3 (castOp ?s ?X)) (trd3 (castOp ?s ?X))
local.wlsInp_castOp:
  isOp ?s ?X ==> wlsInp (fst3 (castOp ?s ?X)) (snd3 (castOp ?s ?X))
local.wls_swapped_skel:
  [| wls ?s ?X; (?X, ?Y) : swapped |] ==> skel ?Y = skel ?X
local.getEnv_psubstEnv_Some:
  ?rho ?xs ?x = Some ?X ==> ?rho &[?rho'] ?xs ?x = Some ?X #[?rho']
local.vsubstAbs_preserves_wls:
  wlsAbs (?us, ?s) ?A ==> wlsAbs (?us, ?s) (?A $[?x1.0 // ?x]_?xs)
local.swapAbs_preserves_wls:
  wlsAbs (?xs, ?x) ?A ==> wlsAbs (?xs, ?x) (?A $[?z1.0 \<and> ?z2.0]_?zs)
local.getEnv_updEnv_idEnv:
  (idEnv [?x \<leftarrow> ?X]_?xs) ?ys ?y =
  (if ?ys = ?xs & ?y = ?x then Some ?X else None)
local.updVal_def:
  ?val (?x := ?sX)_?xs ==
  %ys y. if ys = ?xs & y = ?x then ?sX else ?val ys y
local.psubst_Var:
  goodEnv ?rho ==>
  Var ?xs ?x #[?rho] =
  (case ?rho ?xs ?x of None => Var ?xs ?x | Some X => X)
local.psubst_Var_simp2:
  [| goodEnv ?rho; ?rho ?xs ?x = Some ?X |] ==> Var ?xs ?x #[?rho] = ?X
local.good_item_simps(44):
  [| goodEnv ?rhoa; ?rhoa ?xsa ?xa = Some ?X |]
  ==> Var ?xsa ?xa #[?rhoa] = ?X
local.getEnv_preserves_wls:
  [| wlsEnv ?rho; ?rho ?xs ?x = Some ?X |] ==> wls (asSort ?xs) ?X
local.Var_castVar:
  isVar ?s ?X ==> Var (fst (castVar ?s ?X)) (snd (castVar ?s ?X)) = ?X
local.wls_fresh_swap_exchange1:
  wls ?s ?X ==>
  fresh ?xs ?x2.0 (?X #[?x1.0 \<and> ?x2.0]_?xs) = fresh ?xs ?x1.0 ?X
local.wls_fresh_swap_exchange2:
  wls ?s ?X ==>
  fresh ?xs ?x2.0 (?X #[?x2.0 \<and> ?x1.0]_?xs) = fresh ?xs ?x1.0 ?X
local.wls_skelAbs_simp:
  wls ?s ?X ==>
  skelAbs (Abs ?xs ?x ?X) = Branch (%i. Some (skel ?X)) Map.empty
local.wls_single_non_fresh_ordLess_var:
  wls ?s ?X ==> |{x. ~ fresh ?xs x ?X}| <o |UNIV|
local.wls_fresh_vsubst_ident:
  [| wls ?s ?X; fresh ?ys ?y ?X |] ==> ?X #[?y1.0 // ?y]_?ys = ?X
local.swapped.Trans:
  [| (?X, ?Y) : swapped; (?Y, ?Z) : swapped |] ==> (?X, ?Z) : swapped
local.wls_swapAbs_sym:
  wlsAbs (?us, ?s) ?A ==> ?A $[?x \<and> ?y]_?zs = ?A $[?y \<and> ?x]_?zs
local.wls_swapAbs_involutive:
  wlsAbs (?us, ?s) ?A ==> ?A $[?x \<and> ?y]_?zs $[?x \<and> ?y]_?zs = ?A
local.wls_swapAbs_involutive2:
  wlsAbs (?us, ?s) ?A ==> ?A $[?x \<and> ?y]_?zs $[?y \<and> ?x]_?zs = ?A
local.exists_asSort_wlsAbs:
  isInBar (?us, asSort ?xs) ==> EX A. wlsAbs (?us, asSort ?xs) A
local.updVal_simp:
  (?val (?x := ?sX)_?xs) ?ys ?y =
  (if ?ys = ?xs & ?y = ?x then ?sX else ?val ?ys ?y)
local.updEnv_def:
  ?rho [?x \<leftarrow> ?X]_?xs ==
  %ys y. if ys = ?xs & y = ?x then Some ?X else ?rho ys y
local.castVar_def:
  castVar ?s ?X ==
  SOME xs_x. ?s = asSort (fst xs_x) & ?X = Var (fst xs_x) (snd xs_x)
local.psubst_Var_simp1:
  [| goodEnv ?rho; ?rho ?xs ?x = None |] ==> Var ?xs ?x #[?rho] = Var ?xs ?x
local.good_item_simps(43):
  [| goodEnv ?rhoa; ?rhoa ?xsa ?xa = None |]
  ==> Var ?xsa ?xa #[?rhoa] = Var ?xsa ?xa
local.wls_psubst_Var_simp2:
  [| wlsEnv ?rho; ?rho ?xs ?x = Some ?X |] ==> Var ?xs ?x #[?rho] = ?X
local.updEnv_preserves_wls:
  [| wlsEnv ?rho; wls (asSort ?xs) ?X |]
  ==> wlsEnv (?rho [?x \<leftarrow> ?X]_?xs)
local.substEnv_preserves_wls:
  [| wlsEnv ?rho; wls (asSort ?ys) ?Y |] ==> wlsEnv (?rho &[?Y / ?y]_?ys)
local.absOfS_preserves_wls:
  [| wlsPar ?P; ?A : absOfS ?P (?us, ?s) |] ==> wlsAbs (?us, ?s) ?A
local.arityOf_lt_var_INNER:
  wlsOpS ?delta ==> |{i. arOf ?delta i ~= None}| <o |UNIV|
local.barityOf_lt_var_INNER:
  wlsOpS ?delta ==> |{i. barOf ?delta i ~= None}| <o |UNIV|
local.wls_diff_fresh_vsubst:
  [| wls ?s ?X; ?y ~= ?y1.0 |] ==> fresh ?ys ?y (?X #[?y1.0 // ?y]_?ys)
local.not_isInBar_absOfS_empty:
  [| ~ isInBar (?us, ?s); wlsPar ?P |] ==> absOfS ?P (?us, ?s) = {}
local.getEnv_updEnv:
  (?rho [?x \<leftarrow> ?X]_?xs) ?ys ?y =
  (if ?ys = ?xs & ?y = ?x then Some ?X else ?rho ?ys ?y)
local.gWlsDisj_def:
  gWlsDisj ?MOD == ALL s s' X. gWls ?MOD s X & gWls ?MOD s' X --> s = s'
local.gWlsAbsIsInBar_def:
  gWlsAbsIsInBar ?MOD ==
  ALL us s A. gWlsAbs ?MOD (us, s) A --> isInBar (us, s)
local.prCons_def:
  prCons ?g ?gA ?SEM == prVar ?g ?SEM & prAbs ?g ?gA ?SEM & prOp ?g ?gA ?SEM
local.castAbs_def:
  castAbs ?xs ?s ?A ==
  SOME x_X. wls ?s (snd x_X) & ?A = Abs ?xs (fst x_X) (snd x_X)
local.wls_psubst_Var_simp1:
  [| wlsEnv ?rho; ?rho ?xs ?x = None |] ==> Var ?xs ?x #[?rho] = Var ?xs ?x
local.barOf_isInBar:
  [| wlsOpS ?delta; barOf ?delta ?i = Some (?us, ?s) |]
  ==> isInBar (?us, ?s)
local.wls_Var_diff_Op:
  [| wlsInp ?delta ?inp; wlsBinp ?delta ?binp |]
  ==> Var ?xs ?x ~= Op ?delta ?inp ?binp
local.wls_Op_diff_Var:
  [| wlsInp ?delta ?inp; wlsBinp ?delta ?binp |]
  ==> Op ?delta ?inp ?binp ~= Var ?xs ?x
local.cast_simps(1):
  [| wlsInp ?delta ?inp; wlsBinp ?delta ?binp |]
  ==> isOp (stOf ?delta) (Op ?delta ?inp ?binp)
local.wls_wlsAbs_wlsInp_wlsBinp.Op:
  [| wlsInp ?delta ?inp; wlsBinp ?delta ?binp |]
  ==> wls (stOf ?delta) (Op ?delta ?inp ?binp)
local.wls_freshAbs_swapAbs_exchange1:
  wlsAbs (?us, ?s) ?A ==>
  freshAbs ?xs ?x2.0 (?A $[?x1.0 \<and> ?x2.0]_?xs) = freshAbs ?xs ?x1.0 ?A
local.wls_freshAbs_swapAbs_exchange2:
  wlsAbs (?us, ?s) ?A ==>
  freshAbs ?xs ?x2.0 (?A $[?x2.0 \<and> ?x1.0]_?xs) = freshAbs ?xs ?x1.0 ?A
local.wls_single_non_freshAbs_ordLess_var:
  wlsAbs (?us, ?s) ?A ==> |{x. ~ freshAbs ?xs x ?A}| <o |UNIV|
local.wls_freshAbs_vsubstAbs_ident:
  [| wlsAbs (?us, ?s) ?A; freshAbs ?xs ?x ?A |]
  ==> ?A $[?x1.0 // ?x]_?xs = ?A
local.psubstAbs_preserves_wls:
  [| wlsAbs (?xs, ?s) ?A; wlsEnv ?rho |] ==> wlsAbs (?xs, ?s) ?A $[?rho]
local.eWlsBinp_invert:
  eWlsBinp ?MOD ?delta ?ebinp ==>
  EX binp. igWlsBinp ?MOD ?delta binp & ?ebinp = OKI binp
local.eWlsInp_invert:
  eWlsInp ?MOD ?delta ?einp ==>
  EX inp. igWlsInp ?MOD ?delta inp & ?einp = OKI inp
local.getEnv_swapEnv1:
  ?rho ?xs (?x @?xs[?z1.0 \<and> ?z2.0]_?zs) = None ==>
  (?rho &[?z1.0 \<and> ?z2.0]_?zs) ?xs ?x = None
local.wlsBinp_iff:
  wlsBinp ?delta ?binp =
  (wlsOpS ?delta &
   sameDom (barOf ?delta) ?binp & liftAll2 wlsAbs (barOf ?delta) ?binp)
local.wlsInp_iff:
  wlsInp ?delta ?inp =
  (wlsOpS ?delta &
   sameDom (arOf ?delta) ?inp & liftAll2 wls (arOf ?delta) ?inp)
local.gWlsBinp_def:
  gWlsBinp ?MOD ?delta ?binp ==
  wlsOpS ?delta &
  sameDom (barOf ?delta) ?binp &
  liftAll2 (gWlsAbs ?MOD) (barOf ?delta) ?binp
local.gWlsInp_def:
  gWlsInp ?MOD ?delta ?inp ==
  wlsOpS ?delta &
  sameDom (arOf ?delta) ?inp & liftAll2 (gWls ?MOD) (arOf ?delta) ?inp
local.swapEnv_preserves_freshEnv:
  goodEnv ?rho ==>
  freshEnv ?xs (?x @?xs[?y1.0 \<and> ?y2.0]_?ys)
   (?rho &[?y1.0 \<and> ?y2.0]_?ys) =
  freshEnv ?xs ?x ?rho
local.good_item_simps(62):
  goodEnv ?rhoa ==>
  freshEnv ?xsa (?xa @?xsa[?y1.0 \<and> ?y2.0]_?ys)
   (?rhoa &[?y1.0 \<and> ?y2.0]_?ys) =
  freshEnv ?xsa ?xa ?rhoa
local.subst_preserves_wls:
  [| wls ?s ?X; wls (asSort ?ys) ?Y |] ==> wls ?s (?X #[?Y / ?y]_?ys)
local.substBinp_preserves_wls:
  [| wlsBinp ?delta ?binp; wls (asSort ?ys) ?Y |]
  ==> wlsBinp ?delta (?binp %%[?Y / ?y]_?ys)
local.substInp_preserves_wls:
  [| wlsInp ?delta ?inp; wls (asSort ?ys) ?Y |]
  ==> wlsInp ?delta (?inp %[?Y / ?y]_?ys)
local.wls_wlsAbs_wlsInp_wlsBinp.Abs:
  [| isInBar (?xs, ?s); wls ?s ?X |] ==> wlsAbs (?xs, ?s) (Abs ?xs ?x ?X)
local.semDom_simps(3):
  [| sWls ?SEM (asSort ?xs) ?sX; sWlsVal ?SEM ?val |]
  ==> sWlsVal ?SEM (?val (?x := ?sX)_?xs)
local.wls_diff_freshAbs_vsubstAbs:
  [| wlsAbs (?us, ?s) ?A; ?y ~= ?y1.0 |]
  ==> freshAbs ?ys ?y (?A $[?y1.0 // ?y]_?ys)
local.getEnv_updEnv1:
  ?ys ~= ?xs | ?y ~= ?x ==>
  (?rho [?x \<leftarrow> ?X]_?xs) ?ys ?y = ?rho ?ys ?y
local.substEnv_updEnv:
  ?rho [?x \<leftarrow> ?X]_?xs &[?Y / ?y]_?ys =
  ?rho &[?Y / ?y]_?ys [?x \<leftarrow> ?X #[?Y / ?y]_?ys]_?xs
local.vsubstEnv_updEnv:
  ?rho [?x \<leftarrow> ?X]_?xs &[?y1.0 // ?y]_?ys =
  ?rho &[?y1.0 // ?y]_?ys [?x \<leftarrow> ?X #[?y1.0 // ?y]_?ys]_?xs
local.pickQFresh_def:
  pickQFresh ?xs ?V ?XS ==
  SOME x. x ~: ?V & (ALL X:?XS. qAFresh ?xs x X & qFresh ?xs x X)
local.vsubstEnv_psubstEnv_compose:
  [| goodEnv ?rho; goodEnv ?rho' |]
  ==> ?rho &[?rho'] &[?y1.0 // ?y]_?ys = ?rho &[?rho' &[?y1.0 // ?y]_?ys]
local.psubstEnv_compose:
  [| goodEnv ?rho; goodEnv ?rho'; goodEnv ?rho'' |]
  ==> ?rho &[?rho'] &[?rho''] = ?rho &[?rho' &[?rho'']]
local.freshEnv_swapEnv_id:
  [| goodEnv ?rho; freshEnv ?xs ?x1.0 ?rho; freshEnv ?xs ?x2.0 ?rho |]
  ==> ?rho &[?x1.0 \<and> ?x2.0]_?xs = ?rho
local.fresh_vsubstEnv_updEnv:
  [| goodEnv ?rho; freshEnv ?ys ?y ?rho |]
  ==> ?rho &[?y1.0 // ?y]_?ys = ?rho [?y \<leftarrow> Var ?ys ?y1.0]_?ys
local.good_item_simps(63):
  [| goodEnv ?rhoa; freshEnv ?xsa ?x1.0 ?rhoa; freshEnv ?xsa ?x2.0 ?rhoa |]
  ==> ?rhoa &[?x1.0 \<and> ?x2.0]_?xsa = ?rhoa
local.good_item_simps(78):
  [| goodEnv ?rhoa; freshEnv ?ys ?y ?rhoa |]
  ==> ?rhoa &[?y1.0 // ?y]_?ys = ?rhoa [?y \<leftarrow> Var ?ys ?y1.0]_?ys
local.wls_swapEnv_preserves_freshEnv:
  wlsEnv ?rho ==>
  freshEnv ?xs (?x @?xs[?y1.0 \<and> ?y2.0]_?ys)
   (?rho &[?y1.0 \<and> ?y2.0]_?ys) =
  freshEnv ?xs ?x ?rho
local.freshEnv_getEnv1:
  [| freshEnv ?ys ?y ?rho; ?rho ?xs ?x = Some ?X |]
  ==> ?ys ~= ?xs | ?y ~= ?x
local.wls_skel_Op_simp:
  [| wlsInp ?delta ?inp; wlsBinp ?delta ?binp |]
  ==> skel (Op ?delta ?inp ?binp) = Branch (skelInp ?inp) (skelBinp ?binp)
local.exists_wls_imp_exists_wlsAbs:
  [| isInBar (?us, ?s); EX X. wls ?s X |] ==> EX A. wlsAbs (?us, ?s) A
local.wlsAbs_disjoint:
  [| wlsAbs (?xs, ?s) ?A; wlsAbs (?xs', ?s') ?A |] ==> ?xs = ?xs' & ?s = ?s'
local.updVal_swapVal:
  ?val (?x := ?sX)_?xs ^[?y1.0 \<and> ?y2.0]_?ys =
  ?val ^[?y1.0 \<and> ?y2.0]_?ys (?x @?xs[?y1.0 \<and> ?y2.0]_?ys := ?sX)_?xs
local.isSurj_def:
  isSurj ?h ?MOD == ALL s X. gWls ?MOD s X --> (EX X'. wls s X' & ?h X' = X)
local.prVar_def:
  prVar ?g ?SEM ==
  ALL xs x val. sWlsVal ?SEM val --> ?g (Var xs x) val = val xs x
local.vsubstEnv_compose1:
  goodEnv ?rho ==>
  ?rho &[?y1.0 // ?y]_?ys &[?y2.0 // ?y]_?ys =
  ?rho &[?y1.0 @?ys[?y2.0 / ?y]_?ys // ?y]_?ys
local.wls_freshEnv_swapEnv_id:
  [| wlsEnv ?rho; freshEnv ?xs ?x1.0 ?rho; freshEnv ?xs ?x2.0 ?rho |]
  ==> ?rho &[?x1.0 \<and> ?x2.0]_?xs = ?rho
local.wls_fresh_vsubstEnv_updEnv:
  [| wlsEnv ?rho; freshEnv ?ys ?y ?rho |]
  ==> ?rho &[?y1.0 // ?y]_?ys = ?rho [?y \<leftarrow> Var ?ys ?y1.0]_?ys
local.Op_castOp:
  isOp ?s ?X ==>
  Op (fst3 (castOp ?s ?X)) (snd3 (castOp ?s ?X)) (trd3 (castOp ?s ?X)) = ?X
local.wls_swap_preserves_fresh:
  wls ?s ?X ==>
  fresh ?xs (?x @?xs[?y1.0 \<and> ?y2.0]_?ys)
   (?X #[?y1.0 \<and> ?y2.0]_?ys) =
  fresh ?xs ?x ?X
local.Abs_castAbs:
  wlsAbs (?xs, ?s) ?A ==>
  Abs ?xs (fst (castAbs ?xs ?s ?A)) (snd (castAbs ?xs ?s ?A)) = ?A
local.gWlsInp_defs(3):
  liftAll2 ?phi ?inp1.0 ?inp2.0 ==
  ALL i v1 v2. ?inp1.0 i = Some v1 & ?inp2.0 i = Some v2 --> ?phi v1 v2
local.wls_vsubstEnv_compose1:
  wlsEnv ?rho ==>
  ?rho &[?y1.0 // ?y]_?ys &[?y2.0 // ?y]_?ys =
  ?rho &[?y1.0 @?ys[?y2.0 / ?y]_?ys // ?y]_?ys
local.wls_vsubstEnv_psubstEnv_compose:
  [| wlsEnv ?rho; wlsEnv ?rho' |]
  ==> ?rho &[?rho'] &[?y1.0 // ?y]_?ys = ?rho &[?rho' &[?y1.0 // ?y]_?ys]
local.wls_swapEnv_inj:
  [| wlsEnv ?rho; wlsEnv ?rho' |]
  ==> (?rho &[?x \<and> ?y]_?zs = ?rho' &[?x \<and> ?y]_?zs) =
      (?rho = ?rho')
local.wls_Abs_swap_fresh:
  [| wls ?s ?X; fresh ?xs ?x' ?X |]
  ==> Abs ?xs ?x' (?X #[?x' \<and> ?x]_?xs) = Abs ?xs ?x ?X
local.wls_Abs_vsubst_fresh:
  [| wls ?s ?X; fresh ?xs ?x' ?X |]
  ==> Abs ?xs ?x' (?X #[?x' // ?x]_?xs) = Abs ?xs ?x ?X
local.wls_fresh_swap_id:
  [| wls ?s ?X; fresh ?xs ?x1.0 ?X; fresh ?xs ?x2.0 ?X |]
  ==> ?X #[?x1.0 \<and> ?x2.0]_?xs = ?X
local.wls_Abs_inj:
  [| wls ?s ?X; wls ?s ?X' |]
  ==> (Abs ?xs ?x ?X = Abs ?xs ?x ?X') = (?X = ?X')
local.prWls_def:
  prWls ?g ?SEM ==
  ALL s X val. wls s X & sWlsVal ?SEM val --> sWls ?SEM s (?g X val)
local.psubstEnv_preserves_freshEnv:
  [| goodEnv ?rho; goodEnv ?rho'; freshEnv ?zs ?z ?rho;
     freshEnv ?zs ?z ?rho' |]
  ==> freshEnv ?zs ?z ?rho &[?rho']
local.wls_psubstEnv_compose:
  [| wlsEnv ?rho; wlsEnv ?rho'; wlsEnv ?rho'' |]
  ==> ?rho &[?rho'] &[?rho''] = ?rho &[?rho' &[?rho'']]
local.wls_vsubst_compose1:
  wls ?s ?X ==>
  ?X #[?y1.0 // ?y]_?ys #[?y2.0 // ?y]_?ys =
  ?X #[?y1.0 @?ys[?y2.0 / ?y]_?ys // ?y]_?ys
local.wls_freshAbs_simp:
  wls ?s ?X ==>
  freshAbs ?ys ?y (Abs ?xs ?x ?X) = (?ys = ?xs & ?y = ?x | fresh ?ys ?y ?X)
local.wls_vsubst_psubst_compose:
  [| wls ?s ?X; wlsEnv ?rho |]
  ==> ?X #[?rho] #[?y1.0 // ?y]_?ys = ?X #[?rho &[?y1.0 // ?y]_?ys]
local.sameDom_gInput_simps(3):
  [| wlsBinp ?delta ?binp'; gWlsBinp ?MOD ?delta ?binp |]
  ==> sameDom (?binp' %%[?z1.0 \<and> ?z2.0]_?zs)
       (gSwapBinp ?MOD ?zs ?z1.0 ?z2.0 ?binp' ?binp)
local.sameDom_gInput_simps(1):
  [| wlsInp ?delta ?inp'; gWlsInp ?MOD ?delta ?inp |]
  ==> sameDom (?inp' %[?z1.0 \<and> ?z2.0]_?zs)
       (gSwapInp ?MOD ?zs ?z1.0 ?z2.0 ?inp' ?inp)
local.wls_swapAbs_preserves_freshAbs:
  wlsAbs (?us, ?s) ?A ==>
  freshAbs ?xs (?x @?xs[?y1.0 \<and> ?y2.0]_?ys)
   (?A $[?y1.0 \<and> ?y2.0]_?ys) =
  freshAbs ?xs ?x ?A
local.substAbs_preserves_wls:
  [| wlsAbs (?xs, ?s) ?A; wls (asSort ?ys) ?Y |]
  ==> wlsAbs (?xs, ?s) (?A $[?Y / ?y]_?ys)
local.getEnv_substEnv3:
  [| ?ys ~= ?xs | ?y ~= ?x; freshEnv ?xs ?x ?rho |]
  ==> (?rho &[?Y / ?y]_?ys) ?xs ?x = None
local.getEnv_vsubstEnv3:
  [| ?ys ~= ?xs | ?y ~= ?x; freshEnv ?xs ?x ?rho |]
  ==> (?rho &[?z // ?y]_?ys) ?xs ?x = None
local.absCase_def:
  absCase ?xs ?s ?f ?A ==
  if wlsAbs (?xs, ?s) ?A
  then ?f (fst (castAbs ?xs ?s ?A)) (snd (castAbs ?xs ?s ?A)) else undefined
local.psubstEnv_vsubstEnv_compose:
  [| goodEnv ?rho; goodEnv ?rho' |]
  ==> ?rho &[?y1.0 // ?y]_?ys &[?rho'] =
      ?rho &[?rho' [?y \<leftarrow> Var ?ys ?y1.0 #[?rho']]_?ys]
local.swapEnv_psubstEnv:
  [| goodEnv ?rho; goodEnv ?rho' |]
  ==> ?rho &[?rho'] &[?z1.0 \<and> ?z2.0]_?zs =
      ?rho &[?z1.0 \<and> ?z2.0]_?zs &[?rho' &[?z1.0 \<and> ?z2.0]_?zs]
local.wls_psubst_compose:
  [| wls ?s ?X; wlsEnv ?rho; wlsEnv ?rho' |]
  ==> ?X #[?rho] #[?rho'] = ?X #[?rho &[?rho']]
local.wls_Abs_subst_Var_fresh:
  [| wls ?s ?X; fresh ?xs ?x' ?X |]
  ==> Abs ?xs ?x' (?X #[Var ?xs ?x' / ?x]_?xs) = Abs ?xs ?x ?X
local.wls_vsubst_trans:
  [| wls ?s ?X; fresh ?ys ?y1.0 ?X |]
  ==> ?X #[?y1.0 // ?y]_?ys #[?y2.0 // ?y1.0]_?ys = ?X #[?y2.0 // ?y]_?ys
local.wls_swap_inj:
  [| wls ?s ?X; wls ?s ?X' |]
  ==> (?X #[?x \<and> ?y]_?zs = ?X' #[?x \<and> ?y]_?zs) = (?X = ?X')
local.wls_substAbs_Abs:
  [| wls ?s ?X; wls (asSort ?xs) ?Y |]
  ==> Abs ?xs ?x ?X $[?Y / ?x]_?xs = Abs ?xs ?x ?X
local.sameDom_gInput_simps(4):
  [| wlsBinp ?delta ?binp'; gWlsBinp ?MOD ?delta ?binp |]
  ==> sameDom (?binp' %%[?Y' / ?y]_?ys)
       (gSubstBinp ?MOD ?ys ?Y' ?Y ?y ?binp' ?binp)
local.castOp_stOf_Op:
  [| wlsInp ?delta ?inp; wlsBinp ?delta ?binp |]
  ==> castOp (stOf ?delta) (Op ?delta ?inp ?binp) = (?delta, ?inp, ?binp)
local.sameDom_gInput_simps(2):
  [| wlsInp ?delta ?inp'; gWlsInp ?MOD ?delta ?inp |]
  ==> sameDom (?inp' %[?Y' / ?y]_?ys)
       (gSubstInp ?MOD ?ys ?Y' ?Y ?y ?inp' ?inp)
local.wls_fresh_subst_ident:
  [| wls (asSort ?ys) ?Y; wls ?s ?X; fresh ?ys ?y ?X |]
  ==> ?X #[?Y / ?y]_?ys = ?X
local.wls_freshAbs_swapAbs_id:
  [| wlsAbs (?us, ?s) ?A; freshAbs ?xs ?x1.0 ?A; freshAbs ?xs ?x2.0 ?A |]
  ==> ?A $[?x1.0 \<and> ?x2.0]_?xs = ?A
local.wlsAbs_freshAbs_nchotomy:
  [| wlsAbs (?xs, ?s) ?A; freshAbs ?xs ?x ?A |]
  ==> EX X. wls ?s X & ?A = Abs ?xs ?x X
local.getEnv_substEnv1:
  [| ?ys ~= ?xs | ?y ~= ?x; ?rho ?xs ?x = None |]
  ==> (?rho &[?Y / ?y]_?ys) ?xs ?x = None
local.getEnv_vsubstEnv1:
  [| ?ys ~= ?xs | ?y ~= ?x; ?rho ?xs ?x = None |]
  ==> (?rho &[?y1.0 // ?y]_?ys) ?xs ?x = None
local.getEnv_swapEnv2:
  ?rho ?xs (?x @?xs[?z1.0 \<and> ?z2.0]_?zs) = Some ?X ==>
  (?rho &[?z1.0 \<and> ?z2.0]_?zs) ?xs ?x =
  Some (?X #[?z1.0 \<and> ?z2.0]_?zs)
local.swapEnv_updEnv:
  ?rho [?x \<leftarrow> ?X]_?xs &[?y1.0 \<and> ?y2.0]_?ys =
  ?rho &[?y1.0 \<and> ?y2.0]_?ys [?x @?xs[?y1.0 \<and> ?y2.0]_?ys \<leftarrow> ?X #[?y1.0 \<and> ?y2.0]_?ys]_?xs
local.wlsAbs:
  wlsAbs (?xs, ?s) ?A =
  (isInBar (?xs, ?s) & (EX x X. wls ?s X & ?A = Abs ?xs x X))
local.isInj_def:
  isInj ?h == ALL s X Y. wls s X & wls s Y --> ?h X = ?h Y --> X = Y
local.wf_exists_wls:
  [| wf ?R; !!s. (EX xs. s = asSort xs) | witOpS s (?f s) ?R |]
  ==> EX X. wls ?s X
local.wls_psubstEnv_preserves_freshEnv:
  [| wlsEnv ?rho; wlsEnv ?rho'; freshEnv ?zs ?z ?rho;
     freshEnv ?zs ?z ?rho' |]
  ==> freshEnv ?zs ?z ?rho &[?rho']
local.wls_swapAbs_simp:
  wls ?s ?X ==>
  Abs ?xs ?x ?X $[?y1.0 \<and> ?y2.0]_?ys =
  Abs ?xs (?x @?xs[?y1.0 \<and> ?y2.0]_?ys) (?X #[?y1.0 \<and> ?y2.0]_?ys)
local.prWlsAbs_wlsBinp:
  [| wlsBinp ?delta ?binp; prWlsAbs ?gA ?SEM; sWlsVal ?SEM ?val |]
  ==> sWlsBinp ?SEM ?delta (lift (%A. ?gA A ?val) ?binp)
local.prWls_wlsInp:
  [| wlsInp ?delta ?inp; prWls ?g ?SEM; sWlsVal ?SEM ?val |]
  ==> sWlsInp ?SEM ?delta (lift (%X. ?g X ?val) ?inp)
local.sortTermCase_stOf_Op_simp:
  [| wlsInp ?delta ?inp; wlsBinp ?delta ?binp |]
  ==> sortTermCase ?fVar ?fOp (stOf ?delta) (Op ?delta ?inp ?binp) =
      ?fOp ?delta ?inp ?binp
local.wls_fresh_fresh_subst:
  [| wls (asSort ?ys) ?Y; wls ?s ?X; fresh ?ys ?y ?Y |]
  ==> fresh ?ys ?y (?X #[?Y / ?y]_?ys)
local.wls_vsubstAbs_compose1:
  wlsAbs (?us, ?s) ?A ==>
  ?A $[?y1.0 // ?y]_?ys $[?y2.0 // ?y]_?ys =
  ?A $[?y1.0 @?ys[?y2.0 / ?y]_?ys // ?y]_?ys
local.wls_vsubstAbs_psubstAbs_compose:
  [| wlsAbs (?us, ?s) ?A; wlsEnv ?rho |]
  ==> ?A $[?rho] $[?y1.0 // ?y]_?ys = ?A $[?rho &[?y1.0 // ?y]_?ys]
local.swapVal_compose:
  ?val ^[?x \<and> ?y]_?zs ^[?x' \<and> ?y']_?zs' =
  ?val ^[?x' @?zs'[?x \<and> ?y]_?zs \<and> ?y' @?zs'[?x \<and> ?y]_?zs]_?zs' ^[?x \<and> ?y]_?zs
local.reflFresh_def:
  reflFresh ?h ?MOD ==
  ALL ys y s X. wls s X --> gFresh ?MOD ys y X (?h X) --> fresh ys y X
local.wls_psubstEnv_vsubstEnv_compose:
  [| wlsEnv ?rho; wlsEnv ?rho' |]
  ==> ?rho &[?y1.0 // ?y]_?ys &[?rho'] =
      ?rho &[?rho' [?y \<leftarrow> Var ?ys ?y1.0 #[?rho']]_?ys]
local.wls_swapEnv_psubstEnv:
  [| wlsEnv ?rho; wlsEnv ?rho' |]
  ==> ?rho &[?rho'] &[?z1.0 \<and> ?z2.0]_?zs =
      ?rho &[?z1.0 \<and> ?z2.0]_?zs &[?rho' &[?z1.0 \<and> ?z2.0]_?zs]
local.castOp_inj:
  [| isOp ?s ?X; isOp ?s' ?X' |]
  ==> (castOp ?s ?X = castOp ?s' ?X') = (?s = ?s' & ?X = ?X')
local.castVar_inj:
  [| isVar ?s ?X; isVar ?s' ?X' |]
  ==> (castVar ?s ?X = castVar ?s' ?X') = (?s = ?s' & ?X = ?X')
local.wls_fresh_psubst_I1:
  [| wls ?s ?X; wlsEnv ?rho; fresh ?zs ?z ?X; freshEnv ?zs ?z ?rho |]
  ==> fresh ?zs ?z ?X #[?rho]
local.wls_fresh_Op_simp:
  [| wlsInp ?delta ?inp; wlsBinp ?delta ?binp |]
  ==> fresh ?xs ?x (Op ?delta ?inp ?binp) =
      (freshInp ?xs ?x ?inp & freshBinp ?xs ?x ?binp)
local.wls_freshAbs_substAbs_ident:
  [| wls (asSort ?xs) ?X; wlsAbs (?us, ?s) ?A; freshAbs ?xs ?x ?A |]
  ==> ?A $[?X / ?x]_?xs = ?A
local.wls_psubstAbs_compose:
  [| wlsAbs (?us, ?s) ?A; wlsEnv ?rho; wlsEnv ?rho' |]
  ==> ?A $[?rho] $[?rho'] = ?A $[?rho &[?rho']]
local.wls_vsubstAbs_trans:
  [| wlsAbs (?us, ?s) ?A; freshAbs ?ys ?y1.0 ?A |]
  ==> ?A $[?y1.0 // ?y]_?ys $[?y2.0 // ?y1.0]_?ys = ?A $[?y2.0 // ?y]_?ys
local.wlsAbs_nchotomy:
  wlsAbs (?xs, ?s) ?A ==>
  isInBar (?xs, ?s) & (EX x X. wls ?s X & ?A = Abs ?xs x X)
local.substEnv_def2:
  ?rho &[?Y / ?y]_?ys =
  (%xs x.
      case ?rho xs x of None => if xs = ?ys & x = ?y then Some ?Y else None
      | Some X => Some (X #[?Y / ?y]_?ys))
local.wlsEnv_def:
  wlsEnv ?rho ==
  (ALL ys. liftAll (wls (asSort ys)) (?rho ys)) &
  (ALL ys. |{y. ?rho ys y ~= None}| <o |UNIV|)
local.isSurjAbs_def:
  isSurjAbs ?hA ?MOD ==
  ALL us s A.
     gWlsAbs ?MOD (us, s) A --> (EX A'. wlsAbs (us, s) A' & ?hA A' = A)
local.wls_fresh_substEnv_updEnv:
  [| wlsEnv ?rho; wls (asSort ?ys) ?Y; freshEnv ?ys ?y ?rho |]
  ==> ?rho &[?Y / ?y]_?ys = ?rho [?y \<leftarrow> ?Y]_?ys
local.wls_psubst_vsubst_compose:
  [| wls ?s ?X; wlsEnv ?rho |]
  ==> ?X #[?y1.0 // ?y]_?ys #[?rho] =
      ?X #[?rho [?y \<leftarrow> Var ?ys ?y1.0 #[?rho]]_?ys]
local.wls_swap_psubst:
  [| wls ?s ?X; wlsEnv ?rho |]
  ==> ?X #[?rho] #[?z1.0 \<and> ?z2.0]_?zs =
      ?X #[?z1.0 \<and> ?z2.0]_?zs #[?rho &[?z1.0 \<and> ?z2.0]_?zs]
local.wls_psubstAbs_simp:
  [| wls ?s ?X; wlsEnv ?rho; freshEnv ?xs ?x ?rho |]
  ==> Abs ?xs ?x ?X $[?rho] = Abs ?xs ?x ?X #[?rho]
local.wls_fresh_vsubst_E2:
  [| wls ?s ?X; fresh ?zs ?z (?X #[?y1.0 // ?y]_?ys) |]
  ==> fresh ?ys ?y ?X | ?zs ~= ?ys | ?z ~= ?y1.0
local.wls_fresh_freshAbs_substAbs:
  [| wls (asSort ?ys) ?Y; wlsAbs (?us, ?s) ?A; fresh ?ys ?y ?Y |]
  ==> freshAbs ?ys ?y (?A $[?Y / ?y]_?ys)
local.wls_subst_Var_simp1:
  [| wls (asSort ?ys) ?Y; ?ys ~= ?xs | ?y ~= ?x |]
  ==> Var ?xs ?x #[?Y / ?y]_?ys = Var ?xs ?x
local.updVal_commute:
  ?xs ~= ?ys | ?x ~= ?y ==>
  ?val (?x := ?sX)_?xs (?y := ?sY)_?ys =
  ?val (?y := ?sY)_?ys (?x := ?sX)_?xs
local.updEnv_commute:
  ?xs ~= ?ys | ?x ~= ?y ==>
  ?rho [?x \<leftarrow> ?X]_?xs [?y \<leftarrow> ?Y]_?ys =
  ?rho [?y \<leftarrow> ?Y]_?ys [?x \<leftarrow> ?X]_?xs
local.freshEnv_swapEnv_compose:
  [| goodEnv ?rho; freshEnv ?xs ?y ?rho; freshEnv ?xs ?z ?rho |]
  ==> ?rho &[?y \<and> ?x]_?xs &[?z \<and> ?y]_?xs =
      ?rho &[?z \<and> ?x]_?xs
local.wls_freshEnv_psubst_ident:
  [| wls ?s ?X; wlsEnv ?rho; !!zs z. freshEnv zs z ?rho | fresh zs z ?X |]
  ==> ?X #[?rho] = ?X
local.wls_vsubstEnv_updEnv_fresh:
  [| wls ?s ?X; fresh ?ys ?y ?X |]
  ==> ?rho [?x \<leftarrow> ?X]_?xs &[?y1.0 // ?y]_?ys =
      ?rho &[?y1.0 // ?y]_?ys [?x \<leftarrow> ?X]_?xs
local.wls_vsubst_preserves_fresh:
  [| wls ?s ?X; fresh ?zs ?z ?X; ?zs ~= ?ys | ?z ~= ?y1.0 |]
  ==> fresh ?zs ?z (?X #[?y1.0 // ?y]_?ys)
local.wls_fresh_vsubst_E1:
  [| wls ?s ?X; fresh ?zs ?z (?X #[?y1.0 // ?y]_?ys);
     ?zs ~= ?ys | ?z ~= ?y |]
  ==> fresh ?zs ?z ?X
local.wls_freshAbs_psubstAbs_I1:
  [| wlsAbs (?us, ?s) ?A; wlsEnv ?rho; freshAbs ?zs ?z ?A;
     freshEnv ?zs ?z ?rho |]
  ==> freshAbs ?zs ?z ?A $[?rho]
local.wls_swapAbs_inj:
  [| wlsAbs (?us, ?s) ?A; wlsAbs (?us, ?s) ?A' |]
  ==> (?A $[?x \<and> ?y]_?zs = ?A' $[?x \<and> ?y]_?zs) = (?A = ?A')
local.castAbs_inj:
  [| wlsAbs (?xs, ?s) ?A; wlsAbs (?xs, ?s) ?A' |]
  ==> (castAbs ?xs ?s ?A = castAbs ?xs ?s ?A') = (?A = ?A')
local.vsubstEnv_def2:
  ?rho &[?y1.0 // ?y]_?ys =
  (%xs x.
      case ?rho xs x of
      None => if xs = ?ys & x = ?y then Some (Var ?ys ?y1.0) else None
      | Some X => Some (X #[?y1.0 // ?y]_?ys))
local.swapEnv_preserves_freshEnv_distinct:
  [| goodEnv ?rho; ?xs ~= ?ys | ?x ~: {?y1.0, ?y2.0} |]
  ==> freshEnv ?xs ?x (?rho &[?y1.0 \<and> ?y2.0]_?ys) =
      freshEnv ?xs ?x ?rho
local.wls_freshEnv_swapEnv_compose:
  [| wlsEnv ?rho; freshEnv ?xs ?y ?rho; freshEnv ?xs ?z ?rho |]
  ==> ?rho &[?y \<and> ?x]_?xs &[?z \<and> ?y]_?xs =
      ?rho &[?z \<and> ?x]_?xs
local.wls_vsubstEnv_substEnv_compose1:
  [| wlsEnv ?rho; wls (asSort ?ys) ?Y |]
  ==> ?rho &[?Y / ?y]_?ys &[?y1.0 // ?y]_?ys =
      ?rho &[?Y #[?y1.0 // ?y]_?ys / ?y]_?ys
local.wls_psubst_Op_simp:
  [| wlsInp ?delta ?inp; wlsBinp ?delta ?binp; wlsEnv ?rho |]
  ==> Op ?delta ?inp ?binp #[?rho] = Op ?delta ?inp %[?rho] ?binp %%[?rho]
local.absCase_Abs_swap:
  [| isInBar (?xs, ?s); wls ?s ?X; compatAbsSwap ?xs ?s ?f |]
  ==> absCase ?xs ?s ?f (Abs ?xs ?x ?X) = ?f ?x ?X
local.absCase_Abs_vsubst:
  [| isInBar (?xs, ?s); wls ?s ?X; compatAbsVsubst ?xs ?s ?f |]
  ==> absCase ?xs ?s ?f (Abs ?xs ?x ?X) = ?f ?x ?X
local.wls_psubstAbs_vsubstAbs_compose:
  [| wlsAbs (?us, ?s) ?A; wlsEnv ?rho |]
  ==> ?A $[?y1.0 // ?y]_?ys $[?rho] =
      ?A $[?rho [?y \<leftarrow> Var ?ys ?y1.0 #[?rho]]_?ys]
local.wls_swapAbs_psubstAbs:
  [| wlsAbs (?us, ?s) ?A; wlsEnv ?rho |]
  ==> ?A $[?rho] $[?z1.0 \<and> ?z2.0]_?zs =
      ?A $[?z1.0 \<and> ?z2.0]_?zs $[?rho &[?z1.0 \<and> ?z2.0]_?zs]
local.wls_freshAbs_vsubstAbs_E2:
  [| wlsAbs (?us, ?s) ?A; freshAbs ?zs ?z (?A $[?y1.0 // ?y]_?ys) |]
  ==> freshAbs ?ys ?y ?A | ?zs ~= ?ys | ?z ~= ?y1.0
local.reflFreshAbs_def:
  reflFreshAbs ?hA ?MOD ==
  ALL ys y us s A.
     wlsAbs (us, s) A --> gFreshAbs ?MOD ys y A (?hA A) --> freshAbs ys y A
local.prWlsAbs_def:
  prWlsAbs ?gA ?SEM ==
  ALL us s A val.
     wlsAbs (us, s) A & sWlsVal ?SEM val -->
     sWlsAbs ?SEM (us, s) (?gA A val)
local.compatAbsVsubst_def:
  compatAbsVsubst ?xs ?s ?f ==
  ALL x X x' X'.
     (ALL y. X #[y // x]_?xs = X' #[y // x']_?xs) --> ?f x X = ?f x' X'
local.swapEnv_vsubstEnv:
  goodEnv ?rho ==>
  ?rho &[?y1.0 // ?y]_?ys &[?z1.0 \<and> ?z2.0]_?zs =
  ?rho &[?z1.0 \<and> ?z2.0]_?zs &[?y1.0 @?ys[?z1.0 \<and> ?z2.0]_?zs // ?y @?ys[?z1.0 \<and> ?z2.0]_?zs]_?ys
local.swapEnv_compose:
  goodEnv ?rho ==>
  ?rho &[?x \<and> ?y]_?zs &[?x' \<and> ?y']_?zs' =
  ?rho &[?x' \<and> ?y']_?zs' &[?x @?zs[?x' \<and> ?y']_?zs' \<and> ?y @?zs[?x' \<and> ?y']_?zs']_?zs
local.vsubstEnv_preserves_freshEnv:
  [| goodEnv ?rho; freshEnv ?zs ?z ?rho; ?zs ~= ?ys | ?z ~: {?y, ?y1.0} |]
  ==> freshEnv ?zs ?z (?rho &[?y1.0 // ?y]_?ys)
local.wls_substEnv_psubstEnv_compose:
  [| wlsEnv ?rho; wls (asSort ?ys) ?Y; wlsEnv ?rho' |]
  ==> ?rho &[?rho'] &[?Y / ?y]_?ys = ?rho &[?rho' &[?Y / ?y]_?ys]
local.wls_swapEnv_preserves_freshEnv_distinct:
  [| wlsEnv ?rho; ?xs ~= ?ys | ?x ~: {?y1.0, ?y2.0} |]
  ==> freshEnv ?xs ?x (?rho &[?y1.0 \<and> ?y2.0]_?ys) =
      freshEnv ?xs ?x ?rho
local.wls_fresh_psubst:
  [| wls ?s ?X; wlsEnv ?rho |]
  ==> fresh ?zs ?z ?X #[?rho] =
      (ALL ys y. fresh ys y ?X | freshImEnvAt ?zs ?z ?rho ys y)
local.wls_fresh_swap_compose:
  [| wls ?s ?X; fresh ?xs ?y ?X; fresh ?xs ?z ?X |]
  ==> ?X #[?y \<and> ?x]_?xs #[?z \<and> ?y]_?xs = ?X #[?z \<and> ?x]_?xs
local.wls_vsubst_subst_compose1:
  [| wls ?s ?X; wls (asSort ?ys) ?Y |]
  ==> ?X #[?Y / ?y]_?ys #[?y1.0 // ?y]_?ys =
      ?X #[?Y #[?y1.0 // ?y]_?ys / ?y]_?ys
local.wls_fresh_subst_E2:
  [| wls ?s ?X; wls (asSort ?ys) ?Y; fresh ?zs ?z (?X #[?Y / ?y]_?ys) |]
  ==> fresh ?ys ?y ?X | fresh ?zs ?z ?Y
local.wls_swap_Op_simp:
  [| wlsInp ?delta ?inp; wlsBinp ?delta ?binp |]
  ==> Op ?delta ?inp ?binp #[?x1.0 \<and> ?x2.0]_?xs =
      Op ?delta (?inp %[?x1.0 \<and> ?x2.0]_?xs)
       (?binp %%[?x1.0 \<and> ?x2.0]_?xs)
local.wls_vsubst_Op_simp:
  [| wlsInp ?delta ?inp; wlsBinp ?delta ?binp |]
  ==> Op ?delta ?inp ?binp #[?y1.0 // ?y]_?ys =
      Op ?delta (?inp %[?y1.0 // ?y]_?ys) (?binp %%[?y1.0 // ?y]_?ys)
local.absCase_Abs_subst:
  [| isInBar (?xs, ?s); wls ?s ?X; compatAbsSubst ?xs ?s ?f |]
  ==> absCase ?xs ?s ?f (Abs ?xs ?x ?X) = ?f ?x ?X
local.wls_freshEnv_psubstAbs_ident:
  [| wlsAbs (?us, ?s) ?A; wlsEnv ?rho;
     !!zs z. freshEnv zs z ?rho | freshAbs zs z ?A |]
  ==> ?A $[?rho] = ?A
local.wls_vsubstAbs_preserves_freshAbs:
  [| wlsAbs (?us, ?s) ?A; freshAbs ?zs ?z ?A; ?zs ~= ?ys | ?z ~= ?y1.0 |]
  ==> freshAbs ?zs ?z (?A $[?y1.0 // ?y]_?ys)
local.wls_freshAbs_vsubstAbs_E1:
  [| wlsAbs (?us, ?s) ?A; freshAbs ?zs ?z (?A $[?y1.0 // ?y]_?ys);
     ?z ~= ?y | ?zs ~= ?ys |]
  ==> freshAbs ?zs ?z ?A
local.freshEnv_updEnv_E4:
  [| freshEnv ?ys ?y (?rho [?x \<leftarrow> ?X]_?xs); ?zs ~= ?xs | ?z ~= ?x;
     ?rho ?zs ?z = Some ?Z |]
  ==> fresh ?ys ?y ?Z
local.getEnv_substEnv2:
  [| ?ys ~= ?xs | ?y ~= ?x; ?rho ?xs ?x = Some ?X |]
  ==> (?rho &[?Y / ?y]_?ys) ?xs ?x = Some (?X #[?Y / ?y]_?ys)
local.getEnv_vsubstEnv2:
  [| ?ys ~= ?xs | ?y ~= ?x; ?rho ?xs ?x = Some ?X |]
  ==> (?rho &[?y1.0 // ?y]_?ys) ?xs ?x = Some (?X #[?y1.0 // ?y]_?ys)
local.isInjAbs_def:
  isInjAbs ?hA ==
  ALL us s A B.
     wlsAbs (us, s) A & wlsAbs (us, s) B --> ?hA A = ?hA B --> A = B
local.compInt_def:
  compInt ?g ?gA ?SEM ==
  prWlsAll ?g ?gA ?SEM &
  prCons ?g ?gA ?SEM &
  prFreshAll ?g ?gA ?SEM & prSwapAll ?g ?gA ?SEM & prSubstAll ?g ?gA ?SEM
local.wls_swapEnv_vsubstEnv:
  wlsEnv ?rho ==>
  ?rho &[?y1.0 // ?y]_?ys &[?z1.0 \<and> ?z2.0]_?zs =
  ?rho &[?z1.0 \<and> ?z2.0]_?zs &[?y1.0 @?ys[?z1.0 \<and> ?z2.0]_?zs // ?y @?ys[?z1.0 \<and> ?z2.0]_?zs]_?ys
local.wls_swapEnv_compose:
  wlsEnv ?rho ==>
  ?rho &[?x \<and> ?y]_?zs &[?x' \<and> ?y']_?zs' =
  ?rho &[?x' \<and> ?y']_?zs' &[?x @?zs[?x' \<and> ?y']_?zs' \<and> ?y @?zs[?x' \<and> ?y']_?zs']_?zs
local.wls_vsubstEnv_preserves_freshEnv:
  [| wlsEnv ?rho; freshEnv ?zs ?z ?rho; ?zs ~= ?ys | ?z ~: {?y, ?y1.0} |]
  ==> freshEnv ?zs ?z (?rho &[?y1.0 // ?y]_?ys)
local.wls_substEnv_vsubstEnv_compose1:
  [| wlsEnv ?rho; wls (asSort ?ys) ?Y; ?y ~= ?y1.0 |]
  ==> ?rho &[?y1.0 // ?y]_?ys &[?Y / ?y]_?ys = ?rho &[?y1.0 // ?y]_?ys
local.wls_subst_psubst_compose:
  [| wls ?s ?X; wls (asSort ?ys) ?Y; wlsEnv ?rho |]
  ==> ?X #[?rho] #[?Y / ?y]_?ys = ?X #[?rho &[?Y / ?y]_?ys]
local.wls_subst_preserves_fresh:
  [| wls ?s ?X; wls (asSort ?ys) ?Y; fresh ?zs ?z ?X; fresh ?zs ?z ?Y |]
  ==> fresh ?zs ?z (?X #[?Y / ?y]_?ys)
local.wls_swap_preserves_fresh_distinct:
  [| wls ?s ?X; ?xs ~= ?ys | ?x ~: {?y1.0, ?y2.0} |]
  ==> fresh ?xs ?x (?X #[?y1.0 \<and> ?y2.0]_?ys) = fresh ?xs ?x ?X
local.wlsAbs_castAbs:
  wlsAbs (?xs, ?s) ?A ==>
  wls ?s (snd (castAbs ?xs ?s ?A)) &
  Abs ?xs (fst (castAbs ?xs ?s ?A)) (snd (castAbs ?xs ?s ?A)) = ?A
local.freshImEnvAt_def:
  freshImEnvAt ?xs ?x ?rho ?ys ?y ==
  ?rho ?ys ?y = None & (?ys ~= ?xs | ?y ~= ?x) |
  (EX Y. ?rho ?ys ?y = Some Y & fresh ?xs ?x Y)
local.wls_psubstEnv_substEnv_compose:
  [| wlsEnv ?rho; wls (asSort ?ys) ?Y; wlsEnv ?rho' |]
  ==> ?rho &[?Y / ?y]_?ys &[?rho'] =
      ?rho &[?rho' [?y \<leftarrow> ?Y #[?rho']]_?ys]
local.wls_swap_vsubst:
  wls ?s ?X ==>
  ?X #[?y1.0 // ?y]_?ys #[?z1.0 \<and> ?z2.0]_?zs =
  ?X #[?z1.0 \<and> ?z2.0]_?zs #[?y1.0 @?ys[?z1.0 \<and> ?z2.0]_?zs // ?y @?ys[?z1.0 \<and> ?z2.0]_?zs]_?ys
local.wls_swap_compose:
  wls ?s ?X ==>
  ?X #[?x \<and> ?y]_?zs #[?x' \<and> ?y']_?zs' =
  ?X #[?x' \<and> ?y']_?zs' #[?x @?zs[?x' \<and> ?y']_?zs' \<and> ?y @?zs[?x' \<and> ?y']_?zs']_?zs
local.wls_Abs_vsubst_all:
  [| wls ?s ?X; wls ?s ?X' |]
  ==> (Abs ?xs ?x ?X = Abs ?xs ?x' ?X') =
      (ALL y. ?X #[y // ?x]_?xs = ?X' #[y // ?x']_?xs)
local.wls_subst_vsubst_compose1:
  [| wls ?s ?X; wls (asSort ?ys) ?Y; ?y ~= ?y1.0 |]
  ==> ?X #[?y1.0 // ?y]_?ys #[?Y / ?y]_?ys = ?X #[?y1.0 // ?y]_?ys
local.wls_subst_vsubst_trans:
  [| wls ?s ?X; wls (asSort ?ys) ?Y; fresh ?ys ?y1.0 ?X |]
  ==> ?X #[?y1.0 // ?y]_?ys #[?Y / ?y1.0]_?ys = ?X #[?Y / ?y]_?ys
local.wls_freshAbs_psubstAbs:
  [| wlsAbs (?us, ?s) ?A; wlsEnv ?rho |]
  ==> freshAbs ?zs ?z ?A $[?rho] =
      (ALL ys y. freshAbs ys y ?A | freshImEnvAt ?zs ?z ?rho ys y)
local.wls_freshAbs_swapAbs_compose:
  [| wlsAbs (?us, ?s) ?A; freshAbs ?xs ?y ?A; freshAbs ?xs ?z ?A |]
  ==> ?A $[?y \<and> ?x]_?xs $[?z \<and> ?y]_?xs = ?A $[?z \<and> ?x]_?xs
local.wls_vsubstAbs_substAbs_compose1:
  [| wlsAbs (?us, ?s) ?A; wls (asSort ?ys) ?Y |]
  ==> ?A $[?Y / ?y]_?ys $[?y1.0 // ?y]_?ys =
      ?A $[?Y #[?y1.0 // ?y]_?ys / ?y]_?ys
local.wls_freshAbs_substAbs_E2:
  [| wlsAbs (?us, ?s) ?A; wls (asSort ?ys) ?Y;
     freshAbs ?zs ?z (?A $[?Y / ?y]_?ys) |]
  ==> freshAbs ?ys ?y ?A | fresh ?zs ?z ?Y
local.wlsAbs.simps:
  wlsAbs ?a1.0 ?a2.0 =
  (EX xs s X x.
      ?a1.0 = (xs, s) & ?a2.0 = Abs xs x X & isInBar (xs, s) & wls s X)
local.castOp_def:
  castOp ?s ?X ==
  SOME delta_inp_binp.
     wlsInp (fst3 delta_inp_binp) (snd3 delta_inp_binp) &
     wlsBinp (fst3 delta_inp_binp) (trd3 delta_inp_binp) &
     ?s = stOf (fst3 delta_inp_binp) &
     ?X =
     Op (fst3 delta_inp_binp) (snd3 delta_inp_binp) (trd3 delta_inp_binp)
local.wls_fresh_psubst_E2:
  [| wls ?s ?X; wlsEnv ?rho; ?rho ?ys ?y = Some ?Y;
     fresh ?zs ?z ?X #[?rho] |]
  ==> fresh ?ys ?y ?X | fresh ?zs ?z ?Y
local.wls_psubst_subst_compose:
  [| wls ?s ?X; wls (asSort ?ys) ?Y; wlsEnv ?rho |]
  ==> ?X #[?Y / ?y]_?ys #[?rho] =
      ?X #[?rho [?y \<leftarrow> ?Y #[?rho]]_?ys]
local.wls_fresh_psubst_updEnv:
  [| wls (asSort ?ys) ?Y; wls ?s ?X; wlsEnv ?rho; fresh ?ys ?y ?X |]
  ==> ?X #[?rho [?y \<leftarrow> ?Y]_?ys] = ?X #[?rho]
local.wls_substAbs_psubstAbs_compose:
  [| wlsAbs (?us, ?s) ?A; wls (asSort ?ys) ?Y; wlsEnv ?rho |]
  ==> ?A $[?rho] $[?Y / ?y]_?ys = ?A $[?rho &[?Y / ?y]_?ys]
local.wls_substAbs_preserves_freshAbs:
  [| wlsAbs (?us, ?s) ?A; wls (asSort ?ys) ?Y; freshAbs ?zs ?z ?A;
     fresh ?zs ?z ?Y |]
  ==> freshAbs ?zs ?z (?A $[?Y / ?y]_?ys)
local.wls_swapAbs_preserves_freshAbs_distinct:
  [| wlsAbs (?us, ?s) ?A; ?xs ~= ?ys | ?x ~: {?y1.0, ?y2.0} |]
  ==> freshAbs ?xs ?x (?A $[?y1.0 \<and> ?y2.0]_?ys) = freshAbs ?xs ?x ?A
local.presAbs_def:
  presAbs ?h ?hA ?MOD ==
  ALL xs x s X.
     isInBar (xs, s) & wls s X -->
     ?hA (Abs xs x X) = gAbs ?MOD xs x X (?h X)
local.wf_exists_wlsAbs:
  [| isInBar (?us, ?s); wf ?R;
     !!s. (EX xs. s = asSort xs) | witOpS s (?f s) ?R |]
  ==> EX A. wlsAbs (?us, ?s) A
local.wls_swapAbs_vsubstAbs:
  wlsAbs (?us, ?s) ?A ==>
  ?A $[?y1.0 // ?y]_?ys $[?z1.0 \<and> ?z2.0]_?zs =
  ?A $[?z1.0 \<and> ?z2.0]_?zs $[?y1.0 @?ys[?z1.0 \<and> ?z2.0]_?zs // ?y @?ys[?z1.0 \<and> ?z2.0]_?zs]_?ys
local.wls_swapAbs_compose:
  wlsAbs (?us, ?s) ?A ==>
  ?A $[?x \<and> ?y]_?zs $[?x' \<and> ?y']_?zs' =
  ?A $[?x' \<and> ?y']_?zs' $[?x @?zs[?x' \<and> ?y']_?zs' \<and> ?y @?zs[?x' \<and> ?y']_?zs']_?zs
local.wls_substAbs_vsubstAbs_compose1:
  [| wlsAbs (?us, ?s) ?A; wls (asSort ?ys) ?Y; ?y ~= ?y1.0 |]
  ==> ?A $[?y1.0 // ?y]_?ys $[?Y / ?y]_?ys = ?A $[?y1.0 // ?y]_?ys
local.wls_substAbs_vsubstAbs_trans:
  [| wlsAbs (?us, ?s) ?A; wls (asSort ?ys) ?Y; freshAbs ?ys ?y1.0 ?A |]
  ==> ?A $[?y1.0 // ?y]_?ys $[?Y / ?y1.0]_?ys = ?A $[?Y / ?y]_?ys
local.witOpS_def:
  witOpS ?s ?delta ?R ==
  wlsOpS ?delta &
  stOf ?delta = ?s &
  liftAll (%s'. (s', ?s) : ?R) (arOf ?delta) &
  liftAll (%(us, s'). (s', ?s) : ?R) (barOf ?delta)
local.Abs_inj_fresh:
  [| wls ?s ?X; wls ?s ?X'; fresh ?ys ?x ?X; fresh ?ys ?x' ?X';
     Abs ?ys ?x ?X = Abs ?ys ?x' ?X' |]
  ==> ?X = ?X'
local.wls_vsubstAbs_simp:
  [| wls ?s ?X; ?xs ~= ?ys | ?x ~: {?y, ?y1.0} |]
  ==> Abs ?xs ?x ?X $[?y1.0 // ?y]_?ys = Abs ?xs ?x (?X #[?y1.0 // ?y]_?ys)
local.castAbs_Abs_vsubst:
  [| isInBar (?xs, ?s); wls ?s ?X;
     castAbs ?xs ?s (Abs ?xs ?x ?X) = (?x', ?X') |]
  ==> ?X #[?y // ?x]_?xs = ?X' #[?y // ?x']_?xs
local.wls_freshAbs_psubstAbs_updEnv:
  [| wls (asSort ?xs) ?X; wlsAbs (?us, ?s) ?A; wlsEnv ?rho;
     freshAbs ?xs ?x ?A |]
  ==> ?A $[?rho [?x \<leftarrow> ?X]_?xs] = ?A $[?rho]
local.wls_freshAbs_psubstAbs_E2:
  [| wlsAbs (?us, ?s) ?A; wlsEnv ?rho; ?rho ?ys ?y = Some ?Y;
     freshAbs ?zs ?z ?A $[?rho] |]
  ==> freshAbs ?ys ?y ?A | fresh ?zs ?z ?Y
local.wls_psubstAbs_substAbs_compose:
  [| wlsAbs (?us, ?s) ?A; wls (asSort ?ys) ?Y; wlsEnv ?rho |]
  ==> ?A $[?Y / ?y]_?ys $[?rho] =
      ?A $[?rho [?y \<leftarrow> ?Y #[?rho]]_?ys]
local.pickQFreshEnv_def:
  pickQFreshEnv ?xs ?V ?XS ?Rho ==
  pickQFresh ?xs (?V Un (UN rho:?Rho. {x. rho ?xs x ~= None}))
   (?XS Un (UN rho:?Rho. {X. EX ys y. rho ys y = Some X}))
local.wls_fresh_subst_E1:
  [| wls ?s ?X; wls (asSort ?ys) ?Y; fresh ?zs ?z (?X #[?Y / ?y]_?ys);
     ?zs ~= ?ys | ?z ~= ?y |]
  ==> fresh ?zs ?z ?X
local.swapVal_commute:
  ?zs ~= ?zs' | {?x, ?y} Int {?x', ?y'} = {} ==>
  ?val ^[?x \<and> ?y]_?zs ^[?x' \<and> ?y']_?zs' =
  ?val ^[?x' \<and> ?y']_?zs' ^[?x \<and> ?y]_?zs
local.gAbsPresGWls_def:
  gAbsPresGWls ?MOD ==
  ALL xs s x X' X.
     isInBar (xs, s) & wls s X' & gWls ?MOD s X -->
     gWlsAbs ?MOD (xs, s) (gAbs ?MOD xs x X' X)
local.wlsPar_def:
  wlsPar ?P ==
  (ALL s. ALL X:termsOfS ?P s. wls s X) &
  (ALL xs s. ALL A:absOfS ?P (xs, s). wlsAbs (xs, s) A) &
  Ball (envsOfS ?P) wlsEnv
local.wls_substEnv_compose1:
  [| wlsEnv ?rho; wls (asSort ?ys) ?Y1.0; wls (asSort ?ys) ?Y2.0 |]
  ==> ?rho &[?Y1.0 / ?y]_?ys &[?Y2.0 / ?y]_?ys =
      ?rho &[?Y1.0 #[?Y2.0 / ?y]_?ys / ?y]_?ys
local.psubstAll_preserves_wlsAll:
  wlsPar ?P ==>
  (wls ?s ?X --> (ALL rho:envsOfS ?P. wls ?s ?X #[rho])) &
  (wlsAbs (?xs, ?s') ?A -->
   (ALL rho:envsOfS ?P. wlsAbs (?xs, ?s') ?A $[rho]))
local.wls_fresh_psubst_E1:
  [| wls ?s ?X; wlsEnv ?rho; ?rho ?ys ?y = None; fresh ?zs ?z ?X #[?rho] |]
  ==> fresh ?ys ?y ?X | ?ys ~= ?zs | ?y ~= ?z
local.wls_obtain_rep:
  [| wls ?s ?X; fresh ?xs ?x' ?X |]
  ==> EX X'.
         skel X' = skel ?X &
         (?X, X') : swapped & wls ?s X' & Abs ?xs ?x ?X = Abs ?xs ?x' X'
local.wlsAbs_cases:
  [| wlsAbs (?xs, ?s) ?A;
     !!x X.
        [| isInBar (?xs, ?s); wls ?s X |]
        ==> ?phiAbs (?xs, ?s) (Abs ?xs x X) |]
  ==> ?phiAbs (?xs, ?s) ?A
local.prSwap_def:
  prSwap ?g ?SEM ==
  ALL zs z1 z2 s X val.
     wls s X & sWlsVal ?SEM val -->
     ?g (X #[z1 \<and> z2]_zs) val = ?g X (val ^[z1 \<and> z2]_zs)
local.wls_psubstEnv_substEnv_compose_freshEnv:
  [| wlsEnv ?rho; wlsEnv ?rho'; wls (asSort ?ys) ?Y;
     freshEnv ?ys ?y ?rho' |]
  ==> ?rho &[?Y / ?y]_?ys &[?rho'] = ?rho &[?rho'] &[?Y #[?rho'] / ?y]_?ys
local.wls_psubst_cong:
  [| wls ?s ?X; wlsEnv ?rho; wlsEnv ?rho';
     !!ys y. fresh ys y ?X | ?rho ys y = ?rho' ys y |]
  ==> ?X #[?rho] = ?X #[?rho']
local.wls_subst_compose1:
  [| wls ?s ?X; wls (asSort ?ys) ?Y1.0; wls (asSort ?ys) ?Y2.0 |]
  ==> ?X #[?Y1.0 / ?y]_?ys #[?Y2.0 / ?y]_?ys =
      ?X #[?Y1.0 #[?Y2.0 / ?y]_?ys / ?y]_?ys
local.wls_substEnv_updEnv_fresh:
  [| wls (asSort ?xs) ?X; wls (asSort ?ys) ?Y; fresh ?ys ?y ?X |]
  ==> ?rho [?x \<leftarrow> ?X]_?xs &[?Y / ?y]_?ys =
      ?rho &[?Y / ?y]_?ys [?x \<leftarrow> ?X]_?xs
local.wls_swapEnv_substEnv:
  [| wls (asSort ?ys) ?Y; wlsEnv ?rho |]
  ==> ?rho &[?Y / ?y]_?ys &[?z1.0 \<and> ?z2.0]_?zs =
      ?rho &[?z1.0 \<and> ?z2.0]_?zs &[?Y #[?z1.0 \<and> ?z2.0]_?zs / ?y @?ys[?z1.0 \<and> ?z2.0]_?zs]_?ys
local.wls_subst_Op_simp:
  [| wls (asSort ?ys) ?Y; wlsInp ?delta ?inp; wlsBinp ?delta ?binp |]
  ==> Op ?delta ?inp ?binp #[?Y / ?y]_?ys =
      Op ?delta (?inp %[?Y / ?y]_?ys) (?binp %%[?Y / ?y]_?ys)
local.wls_freshAbs_substAbs_E1:
  [| wlsAbs (?us, ?s) ?A; wls (asSort ?ys) ?Y;
     freshAbs ?zs ?z (?A $[?Y / ?y]_?ys); ?z ~= ?y | ?zs ~= ?ys |]
  ==> freshAbs ?zs ?z ?A
local.wls_psubst_subst_compose_freshEnv:
  [| wlsEnv ?rho; wls ?s ?X; wls (asSort ?ys) ?Y; freshEnv ?ys ?y ?rho |]
  ==> ?X #[?Y / ?y]_?ys #[?rho] = ?X #[?rho] #[?Y #[?rho] / ?y]_?ys
local.wls_fresh_vsubst:
  wls ?s ?X ==>
  fresh ?zs ?z (?X #[?y1.0 // ?y]_?ys) =
  ((?zs = ?ys & ?z = ?y | fresh ?zs ?z ?X) &
   (fresh ?ys ?y ?X | ?zs ~= ?ys | ?z ~= ?y1.0))
local.wls_Abs_subst_all:
  [| wls ?s ?X; wls ?s ?X' |]
  ==> (Abs ?xs ?x ?X = Abs ?xs ?x' ?X') =
      (ALL Y. wls (asSort ?xs) Y --> ?X #[Y / ?x]_?xs = ?X' #[Y / ?x']_?xs)
local.wls_swap_subst:
  [| wls ?s ?X; wls (asSort ?ys) ?Y |]
  ==> ?X #[?Y / ?y]_?ys #[?z1.0 \<and> ?z2.0]_?zs =
      ?X #[?z1.0 \<and> ?z2.0]_?zs #[?Y #[?z1.0 \<and> ?z2.0]_?zs / ?y @?ys[?z1.0 \<and> ?z2.0]_?zs]_?ys
local.wls_freshAbs_psubstAbs_E1:
  [| wlsAbs (?us, ?s) ?A; wlsEnv ?rho; ?rho ?ys ?y = None;
     freshAbs ?zs ?z ?A $[?rho] |]
  ==> freshAbs ?ys ?y ?A | ?ys ~= ?zs | ?y ~= ?z
local.vsubstEnv_compose2:
  [| goodEnv ?rho; ?ys ~= ?zs | ?y ~: {?z, ?z1.0} |]
  ==> ?rho &[?y1.0 // ?y]_?ys &[?z1.0 // ?z]_?zs =
      ?rho &[?z1.0 // ?z]_?zs &[?y1.0 @?ys[?z1.0 / ?z]_?zs // ?y]_?ys
local.wls_psubstAbs_cong:
  [| wlsAbs (?us, ?s) ?A; wlsEnv ?rho; wlsEnv ?rho';
     !!ys y. freshAbs ys y ?A | ?rho ys y = ?rho' ys y |]
  ==> ?A $[?rho] = ?A $[?rho']
local.wls_substAbs_compose1:
  [| wlsAbs (?us, ?s) ?A; wls (asSort ?ys) ?Y1.0; wls (asSort ?ys) ?Y2.0 |]
  ==> ?A $[?Y1.0 / ?y]_?ys $[?Y2.0 / ?y]_?ys =
      ?A $[?Y1.0 #[?Y2.0 / ?y]_?ys / ?y]_?ys
local.sortTermCase_def:
  sortTermCase ?fVar ?fOp ?s ?X ==
  if isVar ?s ?X then ?fVar (fst (castVar ?s ?X)) (snd (castVar ?s ?X))
  else if isOp ?s ?X
       then ?fOp (fst3 (castOp ?s ?X)) (snd3 (castOp ?s ?X))
             (trd3 (castOp ?s ?X))
       else undefined
local.wls_substEnv_preserves_freshEnv:
  [| wlsEnv ?rho; wls (asSort ?ys) ?Y; freshEnv ?zs ?z ?rho;
     fresh ?zs ?z ?Y; ?zs ~= ?ys | ?z ~= ?y |]
  ==> freshEnv ?zs ?z (?rho &[?Y / ?y]_?ys)
local.wls_psubstAbs_substAbs_compose_freshEnv:
  [| wlsEnv ?rho; wlsAbs (?us, ?s) ?A; wls (asSort ?ys) ?Y;
     freshEnv ?ys ?y ?rho |]
  ==> ?A $[?Y / ?y]_?ys $[?rho] = ?A $[?rho] $[?Y #[?rho] / ?y]_?ys
local.wls_vsubstEnv_compose2:
  [| wlsEnv ?rho; ?ys ~= ?zs | ?y ~: {?z, ?z1.0} |]
  ==> ?rho &[?y1.0 // ?y]_?ys &[?z1.0 // ?z]_?zs =
      ?rho &[?z1.0 // ?z]_?zs &[?y1.0 @?ys[?z1.0 / ?z]_?zs // ?y]_?ys
local.wls_swapEnv_commute:
  [| wlsEnv ?rho; ?zs ~= ?zs' | {?x, ?y} Int {?x', ?y'} = {} |]
  ==> ?rho &[?x \<and> ?y]_?zs &[?x' \<and> ?y']_?zs' =
      ?rho &[?x' \<and> ?y']_?zs' &[?x \<and> ?y]_?zs
local.wls_freshAbs_vsubstAbs:
  wlsAbs (?us, ?s) ?A ==>
  freshAbs ?zs ?z (?A $[?y1.0 // ?y]_?ys) =
  ((?zs = ?ys & ?z = ?y | freshAbs ?zs ?z ?A) &
   (freshAbs ?ys ?y ?A | ?zs ~= ?ys | ?z ~= ?y1.0))
local.wls_swapAbs_substAbs:
  [| wlsAbs (?us, ?s) ?A; wls (asSort ?ys) ?Y |]
  ==> ?A $[?Y / ?y]_?ys $[?z1.0 \<and> ?z2.0]_?zs =
      ?A $[?z1.0 \<and> ?z2.0]_?zs $[?Y #[?z1.0 \<and> ?z2.0]_?zs / ?y @?ys[?z1.0 \<and> ?z2.0]_?zs]_?ys
local.prSwapAbs_def:
  prSwapAbs ?gA ?SEM ==
  ALL zs z1 z2 us s A val.
     wlsAbs (us, s) A & sWlsVal ?SEM val -->
     ?gA (A $[z1 \<and> z2]_zs) val = ?gA A (val ^[z1 \<and> z2]_zs)
local.wls_fresh_subst:
  [| wls ?s ?X; wls (asSort ?ys) ?Y |]
  ==> fresh ?zs ?z (?X #[?Y / ?y]_?ys) =
      ((?zs = ?ys & ?z = ?y | fresh ?zs ?z ?X) &
       (fresh ?ys ?y ?X | fresh ?zs ?z ?Y))
local.wls_vsubst_compose2:
  [| wls ?s ?X; ?ys ~= ?zs | ?y ~: {?z, ?z1.0} |]
  ==> ?X #[?y1.0 // ?y]_?ys #[?z1.0 // ?z]_?zs =
      ?X #[?z1.0 // ?z]_?zs #[?y1.0 @?ys[?z1.0 / ?z]_?zs // ?y]_?ys
local.wls_swap_commute:
  [| wls ?s ?X; ?zs ~= ?zs' | {?x, ?y} Int {?x', ?y'} = {} |]
  ==> ?X #[?x \<and> ?y]_?zs #[?x' \<and> ?y']_?zs' =
      ?X #[?x' \<and> ?y']_?zs' #[?x \<and> ?y]_?zs
local.wls_Op_inj:
  [| wlsInp ?delta ?inp; wlsBinp ?delta ?binp; wlsInp ?delta' ?inp';
     wlsBinp ?delta' ?binp' |]
  ==> (Op ?delta ?inp ?binp = Op ?delta' ?inp' ?binp') =
      (?delta = ?delta' & ?inp = ?inp' & ?binp = ?binp')
local.gWlsAbsDisj_def:
  gWlsAbsDisj ?MOD ==
  ALL xs s xs' s' A.
     isInBar (xs, s) &
     isInBar (xs', s') &
     gWlsAbs ?MOD (xs, s) A & gWlsAbs ?MOD (xs', s') A -->
     xs = xs' & s = s'
local.wls_Abs_swap_cong:
  [| wls ?s ?X; wls ?s ?X'; fresh ?xs ?y ?X; fresh ?xs ?y ?X';
     ?X #[?y \<and> ?x]_?xs = ?X' #[?y \<and> ?x']_?xs |]
  ==> Abs ?xs ?x ?X = Abs ?xs ?x' ?X'
local.wls_Abs_vsubst_cong:
  [| wls ?s ?X; wls ?s ?X'; fresh ?xs ?y ?X; fresh ?xs ?y ?X';
     ?X #[?y // ?x]_?xs = ?X' #[?y // ?x']_?xs |]
  ==> Abs ?xs ?x ?X = Abs ?xs ?x' ?X'
local.wlsAbs.cases:
  [| wlsAbs ?a1.0 ?a2.0;
     !!xs s X x.
        [| ?a1.0 = (xs, s); ?a2.0 = Abs xs x X; isInBar (xs, s); wls s X |]
        ==> ?P |]
  ==> ?P
local.castAbs_Abs_subst:
  [| isInBar (?xs, ?s); wls ?s ?X; wls (asSort ?xs) ?Y;
     castAbs ?xs ?s (Abs ?xs ?x ?X) = (?x', ?X') |]
  ==> ?X #[?Y / ?x]_?xs = ?X' #[?Y / ?x']_?xs
local.wlsAll_inversion2:
  (wls ?s ?X --> True) &
  (wlsAbs ?xs_s ?A -->
   isInBar ?xs_s & (EX x X. wls (snd ?xs_s) X & ?A = Abs (fst ?xs_s) x X)) &
  (wlsInp ?delta ?inp --> True) & (wlsBinp ?delta ?binp --> True)
local.wls_wlsAbs_wlsInp_wlsBinp.Inp:
  [| wlsOpS ?delta;
     !!i. arOf ?delta i = None & ?inp i = None |
          (EX s X. arOf ?delta i = Some s & ?inp i = Some X & wls s X) |]
  ==> wlsInp ?delta ?inp
local.wls_freshAbs_substAbs:
  [| wlsAbs (?us, ?s) ?A; wls (asSort ?ys) ?Y |]
  ==> freshAbs ?zs ?z (?A $[?Y / ?y]_?ys) =
      ((?zs = ?ys & ?z = ?y | freshAbs ?zs ?z ?A) &
       (freshAbs ?ys ?y ?A | fresh ?zs ?z ?Y))
local.wls_vsubstAbs_compose2:
  [| wlsAbs (?us, ?s) ?A; ?ys ~= ?zs | ?y ~: {?z, ?z1.0} |]
  ==> ?A $[?y1.0 // ?y]_?ys $[?z1.0 // ?z]_?zs =
      ?A $[?z1.0 // ?z]_?zs $[?y1.0 @?ys[?z1.0 / ?z]_?zs // ?y]_?ys
local.wls_swapAbs_commute:
  [| ?zs ~= ?zs' | {?x, ?y} Int {?x', ?y'} = {}; wlsAbs (?us, ?s) ?A |]
  ==> ?A $[?x \<and> ?y]_?zs $[?x' \<and> ?y']_?zs' =
      ?A $[?x' \<and> ?y']_?zs' $[?x \<and> ?y]_?zs
local.wls_substAbs_simp:
  [| wls (asSort ?ys) ?Y; wls ?s ?X; ?xs ~= ?ys | ?x ~= ?y;
     fresh ?xs ?x ?Y |]
  ==> Abs ?xs ?x ?X $[?Y / ?y]_?ys = Abs ?xs ?x (?X #[?Y / ?y]_?ys)
local.wls.simps:
  wls ?a1.0 ?a2.0 =
  ((EX xs x. ?a1.0 = asSort xs & ?a2.0 = Var xs x) |
   (EX delta inp binp.
       ?a1.0 = stOf delta &
       ?a2.0 = Op delta inp binp & wlsInp delta inp & wlsBinp delta binp))
local.gAbsIndif_def:
  gAbsIndif ?MOD ==
  ALL xs s x X1' X2' X.
     isInBar (xs, s) & wls s X1' & wls s X2' & gWls ?MOD s X -->
     gAbs ?MOD xs x X1' X = gAbs ?MOD xs x X2' X
local.prFresh_def:
  prFresh ?g ?SEM ==
  ALL ys y s X val val'.
     wls s X &
     fresh ys y X &
     sWlsVal ?SEM val & sWlsVal ?SEM val' & eqBut val val' ys y -->
     ?g X val = ?g X val'
local.prSubst_def:
  prSubst ?g ?SEM ==
  ALL ys Y y s X val.
     wls (asSort ys) Y & wls s X & sWlsVal ?SEM val -->
     ?g (X #[Y / y]_ys) val = ?g X (val (y := ?g Y val)_ys)
local.prOp_def:
  prOp ?g ?gA ?SEM ==
  ALL delta inp binp val.
     wlsInp delta inp & wlsBinp delta binp & sWlsVal ?SEM val -->
     ?g (Op delta inp binp) val =
     sOp ?SEM delta (lift (%X. ?g X val) inp) (lift (%A. ?gA A val) binp)
local.wls_nchotomy:
  wls ?s ?X ==>
  (EX xs x. asSort xs = ?s & ?X = Var xs x) |
  (EX delta inp binp.
      stOf delta = ?s &
      wlsInp delta inp & wlsBinp delta binp & ?X = Op delta inp binp)
local.wls_vsubstEnv_substEnv_compose2:
  [| wlsEnv ?rho; wls (asSort ?ys) ?Y; ?ys ~= ?zs | ?y ~: {?z, ?z1.0} |]
  ==> ?rho &[?Y / ?y]_?ys &[?z1.0 // ?z]_?zs =
      ?rho &[?z1.0 // ?z]_?zs &[?Y #[?z1.0 // ?z]_?zs / ?y]_?ys
local.pickQFresh_card_of:
  [| |?V| <o |UNIV|; |?XS| <o |UNIV|; Ball ?XS qGood |]
  ==> pickQFresh ?xs ?V ?XS ~: ?V &
      (ALL X:?XS.
          qAFresh ?xs (pickQFresh ?xs ?V ?XS) X &
          qFresh ?xs (pickQFresh ?xs ?V ?XS) X)
local.wls_obtain_fresh_paramS:
  wlsPar ?P ==>
  EX z. (ALL xs. z ~: varsOfS ?P xs) &
        (ALL s. ALL X:termsOfS ?P s. fresh ?zs z X) &
        (ALL us s. ALL A:absOfS ?P (us, s). freshAbs ?zs z A) &
        (ALL rho:envsOfS ?P. freshEnv ?zs z rho)
local.wls_vsubst_subst_compose2:
  [| wls ?s ?X; wls (asSort ?ys) ?Y; ?ys ~= ?zs | ?y ~: {?z, ?z1.0} |]
  ==> ?X #[?Y / ?y]_?ys #[?z1.0 // ?z]_?zs =
      ?X #[?z1.0 // ?z]_?zs #[?Y #[?z1.0 // ?z]_?zs / ?y]_?ys
local.prFreshAbs_def:
  prFreshAbs ?gA ?SEM ==
  ALL ys y us s A val val'.
     wlsAbs (us, s) A &
     freshAbs ys y A &
     sWlsVal ?SEM val & sWlsVal ?SEM val' & eqBut val val' ys y -->
     ?gA A val = ?gA A val'
local.swapEnv_commute:
  [| goodEnv ?rho; {?x, ?y} <= ?var ?zs;
     ?zs ~= ?zs' | {?x, ?y} Int {?x', ?y'} = {} |]
  ==> ?rho &[?x \<and> ?y]_?zs &[?x' \<and> ?y']_?zs' =
      ?rho &[?x' \<and> ?y']_?zs' &[?x \<and> ?y]_?zs
local.wls_wlsAbs_wlsInp_wlsBinp.Binp:
  [| wlsOpS ?delta;
     !!i. barOf ?delta i = None & ?binp i = None |
          (EX us s A.
              barOf ?delta i = Some (us, s) &
              ?binp i = Some A & wlsAbs (us, s) A) |]
  ==> wlsBinp ?delta ?binp
local.wls_Abs_swap_all:
  [| wls ?s ?X; wls ?s ?X' |]
  ==> (Abs ?xs ?x ?X = Abs ?xs ?x' ?X') =
      (ALL y.
          (y = ?x | fresh ?xs y ?X) & (y = ?x' | fresh ?xs y ?X') -->
          ?X #[y \<and> ?x]_?xs = ?X' #[y \<and> ?x']_?xs)
local.wls_Abs_vsubst_all_aux:
  [| wls ?s ?X; wls ?s ?X' |]
  ==> (Abs ?xs ?x ?X = Abs ?xs ?x' ?X') =
      (ALL y.
          (y = ?x | fresh ?xs y ?X) & (y = ?x' | fresh ?xs y ?X') -->
          ?X #[y // ?x]_?xs = ?X' #[y // ?x']_?xs)
local.wls_Abs_swap_ex:
  [| wls ?s ?X; wls ?s ?X' |]
  ==> (Abs ?xs ?x ?X = Abs ?xs ?x' ?X') =
      (EX y. y ~: {?x, ?x'} &
             fresh ?xs y ?X &
             fresh ?xs y ?X' &
             ?X #[y \<and> ?x]_?xs = ?X' #[y \<and> ?x']_?xs)
local.wls_Abs_vsubst_ex:
  [| wls ?s ?X; wls ?s ?X' |]
  ==> (Abs ?xs ?x ?X = Abs ?xs ?x' ?X') =
      (EX y. y ~: {?x, ?x'} &
             fresh ?xs y ?X &
             fresh ?xs y ?X' & ?X #[y // ?x]_?xs = ?X' #[y // ?x']_?xs)
local.wls_Abs_vsubst_congSTR:
  [| wls ?s ?X; wls ?s ?X'; ?y = ?x | fresh ?xs ?y ?X;
     ?y = ?x' | fresh ?xs ?y ?X';
     ?X #[?y // ?x]_?xs = ?X' #[?y // ?x']_?xs |]
  ==> Abs ?xs ?x ?X = Abs ?xs ?x' ?X'
local.wls_vsubstAbs_substAbs_compose2:
  [| wlsAbs (?us, ?s) ?A; wls (asSort ?ys) ?Y;
     ?ys ~= ?zs | ?y ~: {?z, ?z1.0} |]
  ==> ?A $[?Y / ?y]_?ys $[?z1.0 // ?z]_?zs =
      ?A $[?z1.0 // ?z]_?zs $[?Y #[?z1.0 // ?z]_?zs / ?y]_?ys
local.wls_swapEnv_updEnv_fresh:
  [| ?zs ~= ?ys | ?y ~: {?z1.0, ?z2.0}; wls (asSort ?ys) ?Y;
     fresh ?zs ?z1.0 ?Y; fresh ?zs ?z2.0 ?Y |]
  ==> ?rho [?y \<leftarrow> ?Y]_?ys &[?z1.0 \<and> ?z2.0]_?zs =
      ?rho &[?z1.0 \<and> ?z2.0]_?zs [?y \<leftarrow> ?Y]_?ys
local.prSubstAbs_def:
  prSubstAbs ?g ?gA ?SEM ==
  ALL ys Y y us s A val.
     wls (asSort ys) Y & wlsAbs (us, s) A & sWlsVal ?SEM val -->
     ?gA (A $[Y / y]_ys) val = ?gA A (val (y := ?g Y val)_ys)
local.wls_substEnv_vsubstEnv_compose2:
  [| wlsEnv ?rho; wls (asSort ?zs) ?Z; ?ys ~= ?zs | ?y ~= ?z;
     fresh ?ys ?y ?Z |]
  ==> ?rho &[?y1.0 // ?y]_?ys &[?Z / ?z]_?zs =
      ?rho &[?Z / ?z]_?zs &[Var ?ys ?y1.0 #[?Z / ?z]_?zs / ?y]_?ys
local.wls_fresh_psubst_I:
  [| wls ?s ?X; wlsEnv ?rho; ?rho ?zs ?z = None ==> fresh ?zs ?z ?X;
     !!ys y Y. ?rho ys y = Some Y ==> fresh ys y ?X | fresh ?zs ?z Y |]
  ==> fresh ?zs ?z ?X #[?rho]
local.wls_subst_vsubst_compose2:
  [| wls ?s ?X; wls (asSort ?zs) ?Z; ?ys ~= ?zs | ?y ~= ?z;
     fresh ?ys ?y ?Z |]
  ==> ?X #[?y1.0 // ?y]_?ys #[?Z / ?z]_?zs =
      ?X #[?Z / ?z]_?zs #[Var ?ys ?y1.0 #[?Z / ?z]_?zs / ?y]_?ys
local.wls_freshAbs_swapAbs_compose_aux:
  [| wlsAbs (?us, ?s) ?A; wlsPar ?P |]
  ==> ALL x y z.
         {x, y, z} <= varsOfS ?P ?xs &
         freshAbs ?xs y ?A & freshAbs ?xs z ?A -->
         ?A $[y \<and> x]_?xs $[z \<and> y]_?xs = ?A $[z \<and> x]_?xs
local.wlsInp.simps:
  wlsInp ?a1.0 ?a2.0 =
  (EX delta inp.
      ?a1.0 = delta &
      ?a2.0 = inp &
      wlsOpS delta &
      (ALL x.
          arOf delta x = None & inp x = None |
          (EX s X. arOf delta x = Some s & inp x = Some X & wls s X)))
local.wls_Abs_ainj_all:
  [| wls ?s ?X; wls ?s' ?X' |]
  ==> (Abs ?xs ?x ?X = Abs ?xs' ?x' ?X') =
      (?xs = ?xs' &
       (ALL y.
           (y = ?x | fresh ?xs y ?X) & (y = ?x' | fresh ?xs y ?X') -->
           ?X #[y \<and> ?x]_?xs = ?X' #[y \<and> ?x']_?xs))
local.wls_vsubst_commute:
  [| wls ?s ?X; ?xs ~= ?xs' | {?x, ?y} Int {?x', ?y'} = {}; fresh ?xs ?x ?X;
     fresh ?xs' ?x' ?X |]
  ==> ?X #[?x // ?y]_?xs #[?x' // ?y']_?xs' =
      ?X #[?x' // ?y']_?xs' #[?x // ?y]_?xs
local.wls_freshAbs_psubstAbs_I:
  [| wlsAbs (?us, ?s) ?A; wlsEnv ?rho;
     ?rho ?zs ?z = None ==> freshAbs ?zs ?z ?A;
     !!ys y Y. ?rho ys y = Some Y ==> freshAbs ys y ?A | fresh ?zs ?z Y |]
  ==> freshAbs ?zs ?z ?A $[?rho]
local.pickQFresh:
  [| finite ?V | |?V| <o |UNIV|; finite ?XS | |?XS| <o |UNIV|;
     Ball ?XS qGood |]
  ==> pickQFresh ?xs ?V ?XS ~: ?V &
      (ALL X:?XS.
          qAFresh ?xs (pickQFresh ?xs ?V ?XS) X &
          qFresh ?xs (pickQFresh ?xs ?V ?XS) X)
local.prAbs_def:
  prAbs ?g ?gA ?SEM ==
  ALL xs s x X val.
     isInBar (xs, s) & wls s X & sWlsVal ?SEM val -->
     ?gA (Abs xs x X) val =
     sAbs xs
      (%sX. if sWls ?SEM (asSort xs) sX then ?g X (val (x := sX)_xs)
            else sDummy ?SEM s)
local.wls_Abs_ainj_ex:
  [| wls ?s ?X; wls ?s ?X' |]
  ==> (Abs ?xs ?x ?X = Abs ?xs' ?x' ?X') =
      (?xs = ?xs' &
       (EX y. y ~: {?x, ?x'} &
              fresh ?xs y ?X &
              fresh ?xs y ?X' &
              ?X #[y \<and> ?x]_?xs = ?X' #[y \<and> ?x']_?xs))
local.castAbs_Abs_swap:
  [| isInBar (?xs, ?s); wls ?s ?X; ?y = ?x | fresh ?xs ?y ?X;
     ?y = ?x' | fresh ?xs ?y ?X';
     castAbs ?xs ?s (Abs ?xs ?x ?X) = (?x', ?X') |]
  ==> ?X #[?y \<and> ?x]_?xs = ?X' #[?y \<and> ?x']_?xs
local.wls_substAbs_vsubstAbs_compose2:
  [| wlsAbs (?us, ?s) ?A; wls (asSort ?zs) ?Z; ?ys ~= ?zs | ?y ~= ?z;
     fresh ?ys ?y ?Z |]
  ==> ?A $[?y1.0 // ?y]_?ys $[?Z / ?z]_?zs =
      ?A $[?Z / ?z]_?zs $[Var ?ys ?y1.0 #[?Z / ?z]_?zs / ?y]_?ys
local.swapAll_pres_wlsAll:
  (wls ?s ?X --> wls ?s (?X #[?z1.0 \<and> ?z2.0]_?zs)) &
  (wlsAbs (?xs, ?s') ?A -->
   wlsAbs (?xs, ?s') (?A $[?z1.0 \<and> ?z2.0]_?zs)) &
  (wlsInp ?delta ?inp --> wlsInp ?delta (?inp %[?z1.0 \<and> ?z2.0]_?zs)) &
  (wlsBinp ?delta ?binp -->
   wlsBinp ?delta (?binp %%[?z1.0 \<and> ?z2.0]_?zs))
local.wls_vsubstAbs_commute:
  [| wlsAbs (?us, ?s) ?A; ?xs ~= ?xs' | {?x, ?y} Int {?x', ?y'} = {};
     freshAbs ?xs ?x ?A; freshAbs ?xs' ?x' ?A |]
  ==> ?A $[?x // ?y]_?xs $[?x' // ?y']_?xs' =
      ?A $[?x' // ?y']_?xs' $[?x // ?y]_?xs
local.gAbsInj_def:
  gAbsInj ?MOD ==
  ALL xs s x X' X X1' X1.
     isInBar (xs, s) &
     wls s X' &
     gWls ?MOD s X &
     wls s X1' &
     gWls ?MOD s X1 & gAbs ?MOD xs x X' X = gAbs ?MOD xs x X1' X1 -->
     X = X1
local.ParS_preserves_wls:
  [| !!s X. X : set (?XLF s) ==> wls s X;
     !!xs s A. A : set (?ALF (xs, s)) ==> wlsAbs (xs, s) A;
     !!rho. rho : set ?rhoF ==> wlsEnv rho |]
  ==> wlsPar (ParS ?xLF ?XLF ?ALF ?rhoF)
local.swappedp.simps:
  swappedp ?a1.0 ?a2.0 =
  ((EX X. ?a1.0 = X & ?a2.0 = X) |
   (EX X Y Z. ?a1.0 = X & ?a2.0 = Z & swappedp X Y & swappedp Y Z) |
   (EX X Y x y zs. ?a1.0 = X & ?a2.0 = Y #[x \<and> y]_zs & swappedp X Y))
local.wls_substEnv_compose2:
  [| wlsEnv ?rho; wls (asSort ?ys) ?Y; wls (asSort ?zs) ?Z;
     ?ys ~= ?zs | ?y ~= ?z; fresh ?ys ?y ?Z |]
  ==> ?rho &[?Y / ?y]_?ys &[?Z / ?z]_?zs =
      ?rho &[?Z / ?z]_?zs &[?Y #[?Z / ?z]_?zs / ?y]_?ys
local.sortTermCase_cong:
  [| !!xs x. ?fVar xs x = ?gVar xs x;
     !!delta inp binp.
        [| wlsInp delta inp; wlsInp delta inp |]
        ==> ?fOp delta inp binp = ?gOp delta inp binp;
     wls ?s ?X |]
  ==> sortTermCase ?fVar ?fOp ?s ?X = sortTermCase ?gVar ?gOp ?s ?X
local.wls_subst_compose2:
  [| wls ?s ?X; wls (asSort ?ys) ?Y; wls (asSort ?zs) ?Z;
     ?ys ~= ?zs | ?y ~= ?z; fresh ?ys ?y ?Z |]
  ==> ?X #[?Y / ?y]_?ys #[?Z / ?z]_?zs =
      ?X #[?Z / ?z]_?zs #[?Y #[?Z / ?z]_?zs / ?y]_?ys
local.wlsBinp.simps:
  wlsBinp ?a1.0 ?a2.0 =
  (EX delta binp.
      ?a1.0 = delta &
      ?a2.0 = binp &
      wlsOpS delta &
      (ALL x.
          barOf delta x = None & binp x = None |
          (EX us s A.
              barOf delta x = Some (us, s) &
              binp x = Some A & wlsAbs (us, s) A)))
local.freshEnv_updEnv_I:
  [| ?ys ~= ?xs | ?y ~= ?x; fresh ?ys ?y ?X; ?rho ?ys ?y = None;
     !!zs z Z.
        [| zs ~= ?xs | z ~= ?x; ?rho zs z = Some Z |] ==> fresh ?ys ?y Z |]
  ==> freshEnv ?ys ?y (?rho [?x \<leftarrow> ?X]_?xs)
local.wls.cases:
  [| wls ?a1.0 ?a2.0;
     !!xs x. [| ?a1.0 = asSort xs; ?a2.0 = Var xs x |] ==> ?P;
     !!delta inp binp.
        [| ?a1.0 = stOf delta; ?a2.0 = Op delta inp binp; wlsInp delta inp;
           wlsBinp delta binp |]
        ==> ?P |]
  ==> ?P
local.wls_substAbs_compose2:
  [| wlsAbs (?us, ?s) ?A; wls (asSort ?ys) ?Y; wls (asSort ?zs) ?Z;
     ?ys ~= ?zs | ?y ~= ?z; fresh ?ys ?y ?Z |]
  ==> ?A $[?Y / ?y]_?ys $[?Z / ?z]_?zs =
      ?A $[?Z / ?z]_?zs $[?Y #[?Z / ?z]_?zs / ?y]_?ys
local.gAbsRenS_def:
  gAbsRenS ?MOD ==
  ALL xs y x s X' X.
     isInBar (xs, s) & wls s X' & gWls ?MOD s X -->
     fresh xs y X' & gFresh ?MOD xs y X' X -->
     gAbs ?MOD xs y (X' #[y \<and> x]_xs) (gSwap ?MOD xs y x X' X) =
     gAbs ?MOD xs x X' X
local.wlsInp.cases:
  [| wlsInp ?a1.0 ?a2.0;
     !!delta inp.
        [| ?a1.0 = delta; ?a2.0 = inp; wlsOpS delta;
           !!i. arOf delta i = None & inp i = None |
                (EX s X.
                    arOf delta i = Some s & inp i = Some X & wls s X) |]
        ==> ?P |]
  ==> ?P
local.swapped.simps:
  ((?a1.0, ?a2.0) : swapped) =
  ((EX X. ?a1.0 = X & ?a2.0 = X) |
   (EX X Y Z. ?a1.0 = X & ?a2.0 = Z & (X, Y) : swapped & (Y, Z) : swapped) |
   (EX X Y x y zs.
       ?a1.0 = X & ?a2.0 = Y #[x \<and> y]_zs & (X, Y) : swapped))
local.gAbsRen_def:
  gAbsRen ?MOD ==
  ALL xs y x s X' X.
     isInBar (xs, s) & wls s X' & gWls ?MOD s X -->
     fresh xs y X' & gFresh ?MOD xs y X' X -->
     gAbs ?MOD xs y (X' #[y // x]_xs)
      (gSubst ?MOD xs (Var xs y) (gVar ?MOD xs y) x X' X) =
     gAbs ?MOD xs x X' X
local.wlsBinp.cases:
  [| wlsBinp ?a1.0 ?a2.0;
     !!delta binp.
        [| ?a1.0 = delta; ?a2.0 = binp; wlsOpS delta;
           !!i. barOf delta i = None & binp i = None |
                (EX us s A.
                    barOf delta i = Some (us, s) &
                    binp i = Some A & wlsAbs (us, s) A) |]
        ==> ?P |]
  ==> ?P
local.pickQFreshEnv_card_of:
  [| |?V| <o |UNIV|; |?XS| <o |UNIV|; Ball ?XS qGood; |?Rho| <o |UNIV|;
     Ball ?Rho qGoodEnv |]
  ==> pickQFreshEnv ?xs ?V ?XS ?Rho ~: ?V &
      (ALL X:?XS. qFresh ?xs (pickQFreshEnv ?xs ?V ?XS ?Rho) X) &
      (ALL rho:?Rho. qFreshEnv ?xs (pickQFreshEnv ?xs ?V ?XS ?Rho) rho)
local.wlsAbs_fresh_nchotomy:
  [| wlsAbs (?xs, ?s) ?A; wlsPar ?P |]
  ==> EX x X.
         ?A = Abs ?xs x X &
         wls ?s X &
         (ALL ys. x ~: varsOfS ?P ys) &
         (ALL s'. ALL Y:termsOfS ?P s'. fresh ?xs x Y) &
         (ALL us s'. ALL B:absOfS ?P (us, s'). freshAbs ?xs x B) &
         (ALL rho:envsOfS ?P. freshEnv ?xs x rho)
local.absCase_cong:
  [| compatAbsSwap ?xs ?s ?f |
     compatAbsSubst ?xs ?s ?f | compatAbsVsubst ?xs ?s ?f;
     compatAbsSwap ?xs ?s ?f' |
     compatAbsSubst ?xs ?s ?f' | compatAbsVsubst ?xs ?s ?f';
     !!x X. wls ?s X ==> ?f x X = ?f' x X; wlsAbs (?xs, ?s) ?A |]
  ==> absCase ?xs ?s ?f ?A = absCase ?xs ?s ?f' ?A
local.swappedp.induct:
  [| swappedp ?x1.0 ?x2.0; !!X. ?P X X;
     !!X Y Z. [| swappedp X Y; ?P X Y; swappedp Y Z; ?P Y Z |] ==> ?P X Z;
     !!X Y x y zs.
        [| swappedp X Y; ?P X Y |] ==> ?P X (Y #[x \<and> y]_zs) |]
  ==> ?P ?x1.0 ?x2.0
local.swappedp.cases:
  [| swappedp ?a1.0 ?a2.0; !!X. [| ?a1.0 = X; ?a2.0 = X |] ==> ?P;
     !!X Y Z. [| ?a1.0 = X; ?a2.0 = Z; swappedp X Y; swappedp Y Z |] ==> ?P;
     !!X Y x y zs.
        [| ?a1.0 = X; ?a2.0 = Y #[x \<and> y]_zs; swappedp X Y |] ==> ?P |]
  ==> ?P
local.pickQFreshEnv:
  [| |?V| <o |UNIV| | finite ?V; |?XS| <o |UNIV| | finite ?XS;
     Ball ?XS qGood; |?Rho| <o |UNIV| | finite ?Rho; Ball ?Rho qGoodEnv |]
  ==> pickQFreshEnv ?xs ?V ?XS ?Rho ~: ?V &
      (ALL X:?XS. qFresh ?xs (pickQFreshEnv ?xs ?V ?XS ?Rho) X) &
      (ALL rho:?Rho. qFreshEnv ?xs (pickQFreshEnv ?xs ?V ?XS ?Rho) rho)
local.swapped.induct:
  [| (?x1.0, ?x2.0) : swapped; !!X. ?P X X;
     !!X Y Z.
        [| (X, Y) : swapped; ?P X Y; (Y, Z) : swapped; ?P Y Z |] ==> ?P X Z;
     !!X Y x y zs.
        [| (X, Y) : swapped; ?P X Y |] ==> ?P X (Y #[x \<and> y]_zs) |]
  ==> ?P ?x1.0 ?x2.0
local.swapped.cases:
  [| (?a1.0, ?a2.0) : swapped; !!X. [| ?a1.0 = X; ?a2.0 = X |] ==> ?P;
     !!X Y Z.
        [| ?a1.0 = X; ?a2.0 = Z; (X, Y) : swapped; (Y, Z) : swapped |]
        ==> ?P;
     !!X Y x y zs.
        [| ?a1.0 = X; ?a2.0 = Y #[x \<and> y]_zs; (X, Y) : swapped |]
        ==> ?P |]
  ==> ?P
local.wlsAbs_fresh_cases:
  [| wlsAbs (?xs, ?s) ?A; wlsPar ?P;
     !!x X.
        [| wls ?s X; !!ys. x ~: varsOfS ?P ys;
           !!s' Y. Y : termsOfS ?P s' ==> fresh ?xs x Y;
           !!us s' B. B : absOfS ?P (us, s') ==> freshAbs ?xs x B;
           !!rho. rho : envsOfS ?P ==> freshEnv ?xs x rho |]
        ==> ?phi (?xs, ?s) (Abs ?xs x X) ?P |]
  ==> ?phi (?xs, ?s) ?A ?P
local.gAbsCongS_def:
  gAbsCongS ?MOD ==
  ALL xs x x2 y s X' X X2' X2.
     isInBar (xs, s) &
     wls s X' & gWls ?MOD s X & wls s X2' & gWls ?MOD s X2 -->
     fresh xs y X' &
     gFresh ?MOD xs y X' X &
     fresh xs y X2' &
     gFresh ?MOD xs y X2' X2 &
     X' #[y \<and> x]_xs = X2' #[y \<and> x2]_xs -->
     gSwap ?MOD xs y x X' X = gSwap ?MOD xs y x2 X2' X2 -->
     gAbs ?MOD xs x X' X = gAbs ?MOD xs x2 X2' X2
local.wls_rawInduct:
  [| !!xs x. ?phi (asSort xs) (Var xs x);
     !!delta inp binp.
        [| wlsInp delta inp; wlsBinp delta binp;
           liftAll2 ?phi (arOf delta) inp;
           liftAll2 ?phiAbs (barOf delta) binp |]
        ==> ?phi (stOf delta) (Op delta inp binp);
     !!s xs x X.
        [| isInBar (xs, s); wls s X; ?phi s X |]
        ==> ?phiAbs (xs, s) (Abs xs x X) |]
  ==> (wls ?s ?X --> ?phi ?s ?X) &
      (wlsAbs (?xs, ?s') ?A --> ?phiAbs (?xs, ?s') ?A)
local.wls_obtain_fresh:
  [| ALL xs. |?V xs| <o |UNIV| | finite (?V xs);
     ALL s. |?XS s| <o |UNIV| | finite (?XS s);
     ALL xs s. |?AS xs s| <o |UNIV| | finite (?AS xs s);
     ALL s. ALL X:?XS s. wls s X;
     ALL xs s. ALL A:?AS xs s. wlsAbs (xs, s) A;
     |?Rho| <o |UNIV| | finite ?Rho; Ball ?Rho wlsEnv |]
  ==> EX z. (ALL xs. z ~: ?V xs) &
            (ALL s. ALL X:?XS s. fresh ?zs z X) &
            (ALL xs s. ALL A:?AS xs s. freshAbs ?zs z A) &
            (ALL rho:?Rho. freshEnv ?zs z rho)
local.wls_templateInduct:
  [| !!s X Y. [| wls s X; (X, Y) : ?rel s |] ==> wls s Y & skel Y = skel X;
     !!xs x. ?phi (asSort xs) (Var xs x);
     !!delta inp binp.
        [| wlsInp delta inp; wlsBinp delta binp;
           liftAll2 ?phi (arOf delta) inp;
           liftAll2 ?phiAbs (barOf delta) binp |]
        ==> ?phi (stOf delta) (Op delta inp binp);
     !!s xs x X.
        [| isInBar (xs, s); wls s X; !!Y. (X, Y) : ?rel s ==> ?phi s Y |]
        ==> ?phiAbs (xs, s) (Abs xs x X) |]
  ==> (wls ?s ?X --> ?phi ?s ?X) &
      (wlsAbs (?xs, ?s') ?A --> ?phiAbs (?xs, ?s') ?A)
local.wls_induct:
  [| !!xs x. ?phi (asSort xs) (Var xs x);
     !!delta inp binp.
        [| wlsInp delta inp; wlsBinp delta binp;
           liftAll2 ?phi (arOf delta) inp;
           liftAll2 ?phiAbs (barOf delta) binp |]
        ==> ?phi (stOf delta) (Op delta inp binp);
     !!s xs x X.
        [| isInBar (xs, s); wls s X; !!Y. (X, Y) : swapped ==> ?phi s Y;
           !!ys y1 y2. ?phi s (X #[y1 // y2]_ys);
           !!Y. [| wls s Y; skel Y = skel X |] ==> ?phi s Y |]
        ==> ?phiAbs (xs, s) (Abs xs x X) |]
  ==> (wls ?s ?X --> ?phi ?s ?X) &
      (wlsAbs (?xs, ?s') ?A --> ?phiAbs (?xs, ?s') ?A)
local.wls_induct_fresh:
  [| wlsPar ?P; !!xs x. ?phi (asSort xs) (Var xs x);
     !!delta inp binp.
        [| wlsInp delta inp; wlsBinp delta binp;
           liftAll2 ?phi (arOf delta) inp;
           liftAll2 (%(us, s). ?phiAbs (us, s)) (barOf delta) binp |]
        ==> ?phi (stOf delta) (Op delta inp binp);
     !!s xs x X.
        [| isInBar (xs, s); wls s X; x ~: varsOfS ?P xs;
           !!s' Y. Y : termsOfS ?P s' ==> fresh xs x Y;
           !!us s' A. A : absOfS ?P (us, s') ==> freshAbs xs x A;
           !!rho. rho : envsOfS ?P ==> freshEnv xs x rho; ?phi s X |]
        ==> ?phiAbs (xs, s) (Abs xs x X) |]
  ==> (wls ?s ?X --> ?phi ?s ?X) &
      (wlsAbs (?xs, ?s') ?A --> ?phiAbs (?xs, ?s') ?A)
local.wls_cases:
  [| wls ?x1.0 ?x2.0; !!xs x. ?P1.0 (asSort xs) (Var xs x);
     !!delta inp binp.
        [| wlsInp delta inp; ?P3.0 delta inp; wlsBinp delta binp;
           ?P4.0 delta binp |]
        ==> ?P1.0 (stOf delta) (Op delta inp binp);
     !!delta inp.
        [| wlsOpS delta;
           !!i. arOf delta i = None & inp i = None |
                (EX s X.
                    arOf delta i = Some s &
                    inp i = Some X & wls s X & ?P1.0 s X) |]
        ==> ?P3.0 delta inp;
     !!delta binp.
        [| wlsOpS delta;
           !!i. barOf delta i = None & binp i = None |
                (EX us s A.
                    barOf delta i = Some (us, s) &
                    binp i = Some A & wlsAbs (us, s) A & ?P2.0 (us, s) A) |]
        ==> ?P4.0 delta binp;
     !!xs s X x.
        [| isInBar (xs, s); wls s X; ?P1.0 s X |]
        ==> ?P2.0 (xs, s) (Abs xs x X) |]
  ==> ?P1.0 ?x1.0 ?x2.0
local.wls_wlsAbs_wlsInp_wlsBinp.inducts(2):
  [| wlsAbs ?x3.0 ?x4.0; !!xs x. ?P1.0 (asSort xs) (Var xs x);
     !!delta inp binp.
        [| wlsInp delta inp; ?P3.0 delta inp; wlsBinp delta binp;
           ?P4.0 delta binp |]
        ==> ?P1.0 (stOf delta) (Op delta inp binp);
     !!delta inp.
        [| wlsOpS delta;
           !!i. arOf delta i = None & inp i = None |
                (EX s X.
                    arOf delta i = Some s &
                    inp i = Some X & wls s X & ?P1.0 s X) |]
        ==> ?P3.0 delta inp;
     !!delta binp.
        [| wlsOpS delta;
           !!i. barOf delta i = None & binp i = None |
                (EX us s A.
                    barOf delta i = Some (us, s) &
                    binp i = Some A & wlsAbs (us, s) A & ?P2.0 (us, s) A) |]
        ==> ?P4.0 delta binp;
     !!xs s X x.
        [| isInBar (xs, s); wls s X; ?P1.0 s X |]
        ==> ?P2.0 (xs, s) (Abs xs x X) |]
  ==> ?P2.0 ?x3.0 ?x4.0
local.wls_wlsAbs_wlsInp_wlsBinp.inducts(4):
  [| wlsBinp ?x7.0 ?x8.0; !!xs x. ?P1.0 (asSort xs) (Var xs x);
     !!delta inp binp.
        [| wlsInp delta inp; ?P3.0 delta inp; wlsBinp delta binp;
           ?P4.0 delta binp |]
        ==> ?P1.0 (stOf delta) (Op delta inp binp);
     !!delta inp.
        [| wlsOpS delta;
           !!i. arOf delta i = None & inp i = None |
                (EX s X.
                    arOf delta i = Some s &
                    inp i = Some X & wls s X & ?P1.0 s X) |]
        ==> ?P3.0 delta inp;
     !!delta binp.
        [| wlsOpS delta;
           !!i. barOf delta i = None & binp i = None |
                (EX us s A.
                    barOf delta i = Some (us, s) &
                    binp i = Some A & wlsAbs (us, s) A & ?P2.0 (us, s) A) |]
        ==> ?P4.0 delta binp;
     !!xs s X x.
        [| isInBar (xs, s); wls s X; ?P1.0 s X |]
        ==> ?P2.0 (xs, s) (Abs xs x X) |]
  ==> ?P4.0 ?x7.0 ?x8.0
local.wls_wlsAbs_wlsInp_wlsBinp.inducts(3):
  [| wlsInp ?x5.0 ?x6.0; !!xs x. ?P1.0 (asSort xs) (Var xs x);
     !!delta inp binp.
        [| wlsInp delta inp; ?P3.0 delta inp; wlsBinp delta binp;
           ?P4.0 delta binp |]
        ==> ?P1.0 (stOf delta) (Op delta inp binp);
     !!delta inp.
        [| wlsOpS delta;
           !!i. arOf delta i = None & inp i = None |
                (EX s X.
                    arOf delta i = Some s &
                    inp i = Some X & wls s X & ?P1.0 s X) |]
        ==> ?P3.0 delta inp;
     !!delta binp.
        [| wlsOpS delta;
           !!i. barOf delta i = None & binp i = None |
                (EX us s A.
                    barOf delta i = Some (us, s) &
                    binp i = Some A & wlsAbs (us, s) A & ?P2.0 (us, s) A) |]
        ==> ?P4.0 delta binp;
     !!xs s X x.
        [| isInBar (xs, s); wls s X; ?P1.0 s X |]
        ==> ?P2.0 (xs, s) (Abs xs x X) |]
  ==> ?P3.0 ?x5.0 ?x6.0
local.wls_wlsAbs_wlsInp_wlsBinp.induct:
  [| !!xs x. ?P1.0 (asSort xs) (Var xs x);
     !!delta inp binp.
        [| wlsInp delta inp; ?P3.0 delta inp; wlsBinp delta binp;
           ?P4.0 delta binp |]
        ==> ?P1.0 (stOf delta) (Op delta inp binp);
     !!delta inp.
        [| wlsOpS delta;
           !!i. arOf delta i = None & inp i = None |
                (EX s X.
                    arOf delta i = Some s &
                    inp i = Some X & wls s X & ?P1.0 s X) |]
        ==> ?P3.0 delta inp;
     !!delta binp.
        [| wlsOpS delta;
           !!i. barOf delta i = None & binp i = None |
                (EX us s A.
                    barOf delta i = Some (us, s) &
                    binp i = Some A & wlsAbs (us, s) A & ?P2.0 (us, s) A) |]
        ==> ?P4.0 delta binp;
     !!xs s X x.
        [| isInBar (xs, s); wls s X; ?P1.0 s X |]
        ==> ?P2.0 (xs, s) (Abs xs x X) |]
  ==> (wls ?x1.0 ?x2.0 --> ?P1.0 ?x1.0 ?x2.0) &
      (wlsAbs ?x3.0 ?x4.0 --> ?P2.0 ?x3.0 ?x4.0) &
      (wlsInp ?x5.0 ?x6.0 --> ?P3.0 ?x5.0 ?x6.0) &
      (wlsBinp ?x7.0 ?x8.0 --> ?P4.0 ?x7.0 ?x8.0)
local.wls_rawInduct_fresh:
  [| !!xs us s.
        (|?vars xs| <o |UNIV| | finite (?vars xs)) &
        (|?terms s| <o |UNIV| | finite (?terms s)) &
        (ALL X:?terms s. wls s X) &
        (|?abs (us, s)| <o |UNIV| | finite (?abs (us, s))) &
        (ALL A:?abs (us, s). wlsAbs (us, s) A) &
        (|?envs| <o |UNIV| | finite ?envs) & Ball ?envs wlsEnv;
     !!xs x. ?phi (asSort xs) (Var xs x);
     !!delta inp binp.
        [| wlsInp delta inp; wlsBinp delta binp;
           liftAll2 ?phi (arOf delta) inp;
           liftAll2 (%(us, s). ?phiAbs (us, s)) (barOf delta) binp |]
        ==> ?phi (stOf delta) (Op delta inp binp);
     !!s xs x X.
        [| isInBar (xs, s); wls s X; x ~: ?vars xs;
           !!s' Y. Y : ?terms s' ==> fresh xs x Y;
           !!us s' A. A : ?abs (us, s') ==> freshAbs xs x A;
           !!rho. rho : ?envs ==> freshEnv xs x rho; ?phi s X |]
        ==> ?phiAbs (xs, s) (Abs xs x X) |]
  ==> (wls ?s ?X --> ?phi ?s ?X) &
      (wlsAbs (?xs, ?s') ?A --> ?phiAbs (?xs, ?s') ?A)
local.wls_templateInduct_fresh:
  [| !!xs us s.
        (|?vars xs| <o |UNIV| | finite (?vars xs)) &
        (|?terms s| <o |UNIV| | finite (?terms s)) &
        (|?abs (us, s)| <o |UNIV| | finite (?abs (us, s))) &
        (ALL X:?terms s. wls s X) &
        (ALL A:?abs (us, s). wlsAbs (us, s) A) &
        (|?envs| <o |UNIV| | finite ?envs) & Ball ?envs wlsEnv;
     !!s X Y. [| wls s X; (X, Y) : ?rel s |] ==> wls s Y & skel Y = skel X;
     !!xs x. ?phi (asSort xs) (Var xs x);
     !!delta inp binp.
        [| wlsInp delta inp; wlsBinp delta binp;
           liftAll2 ?phi (arOf delta) inp;
           liftAll2 (%(us, s). ?phiAbs (us, s)) (barOf delta) binp |]
        ==> ?phi (stOf delta) (Op delta inp binp);
     !!s xs x X.
        [| isInBar (xs, s); wls s X; x ~: ?vars xs;
           !!s' Y. Y : ?terms s' ==> fresh xs x Y;
           !!xs' s' A. A : ?abs (xs', s') ==> freshAbs xs x A;
           !!rho. rho : ?envs ==> freshEnv xs x rho;
           !!Y. (X, Y) : ?rel s ==> ?phi s Y |]
        ==> ?phiAbs (xs, s) (Abs xs x X) |]
  ==> (wls ?s ?X --> ?phi ?s ?X) &
      (wlsAbs (?xs, ?s') ?A --> ?phiAbs (?xs, ?s') ?A)
val templateLemmas = []: (string * thm * template) list
### theory "Draft.Binding_SyntaxTemplates"
### 0.612s elapsed time, 1.913s cpu time, 0.233s GC time
val it = (): unit
