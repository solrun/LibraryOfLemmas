Loading theory "Draft.Simplex_Auxiliary" (required by "Draft.Simplex_IncrementalTemplates" via "Draft.Simplex_Incremental" via "Draft.Simplex" via "Draft.Rel_Chain")
Loading theory "Draft.Simplex_Algebra" (required by "Draft.Simplex_IncrementalTemplates" via "Draft.Simplex_Incremental" via "Draft.Simplex" via "Draft.Linear_Poly_Maps" via "Draft.Abstract_Linear_Poly")
Loading theory "Draft.Templates" (required by "Draft.Simplex_IncrementalTemplates" via "Draft.ExtrEqs")
datatype template_term
=
     t_empty
   | template_app of template_term * template_term
   | template_hole of int
   | template_var of int
datatype sign
= equals | greater_equals | greater_than | less_equals | less_than
datatype template
=
     template_bimplication of template * template
   | template_dunno
   | template_equation of template_term * template_term
   | template_implication of template list * template
   | template_inequation of sign * template_term * template_term
   | template_negation of template
   | template_predicate of template_term
constructor t_empty: template_term
constructor template_app: template_term * template_term -> template_term
constructor template_hole: int -> template_term
constructor template_var: int -> template_term
constructor equals: sign
constructor greater_equals: sign
constructor greater_than: sign
constructor less_equals: sign
constructor less_than: sign
constructor template_bimplication: template * template -> template
constructor template_dunno: template
constructor template_equation: template_term * template_term -> template
constructor template_implication: template list * template -> template
constructor template_inequation:
   sign * template_term * template_term -> template
constructor template_negation: template -> template
constructor template_predicate: template_term -> template
val vfs = fn: term -> (indexname * typ) list * (string * typ) list
val indexOf = fn: ''a list -> ''a -> int -> int
val has_eq = fn: term -> bool
val term2template = fn:
   (indexname * typ) list -> (string * typ) list -> term -> template_term
val lemma2predicate = fn: term -> term -> template
val makeTemplatewithContext = fn: term -> term -> template
val lemma2template = fn: term -> template
val thm2template = fn: thm -> template
val tterm2string = fn: template_term -> string
val template2string = fn: template -> string
val t = "height ?t <= size ?t": thm
val th =
   Const ("HOL.Trueprop", "bool => prop") $
     (Const ("Orderings.ord_class.less_eq", "nat => nat => bool") $
       (Const ("Tree.height_class.height", "?'a tree => nat") $
         Var (("t", 0), "?'a tree")) $
       (Const ("Nat.size_class.size", "?'a tree => nat") $
         Var (("t", 0), "?'a tree"))):
   term
### theory "Draft.Templates"
### 0.082s elapsed time, 0.284s cpu time, 0.000s GC time
Loading theory "Draft.ExtrEqs" (required by "Draft.Simplex_IncrementalTemplates")
class scaleRat = type +
  fixes scaleRat :: "rat => 'a => 'a"
### theory "Draft.Simplex_Auxiliary"
### 0.095s elapsed time, 0.323s cpu time, 0.000s GC time
Loading theory "Draft.Rel_Chain" (required by "Draft.Simplex_IncrementalTemplates" via "Draft.Simplex_Incremental" via "Draft.Simplex")
### theory "Draft.Rel_Chain"
### 0.086s elapsed time, 0.244s cpu time, 0.028s GC time
class rational_vector = ab_group_add + scaleRat +
  assumes
    "scaleRat_right_distrib": "!!a x y. a *R (x + y) = a *R x + a *R y"
    and "scaleRat_left_distrib": "!!a b x. (a + b) *R x = a *R x + b *R x"
    and "scaleRat_scaleRat": "!!a b x. a *R b *R x = (a * b) *R x"
    and "scaleRat_one": "!!x. 1 *R x = x"
val eqpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Var (("_dummy_", 2), "?'a"))
       ):
   term Find_Theorems.criterion
val badeqpattern = Pattern (Const ("Pure.eq", "?'a => ?'a => prop")):
   term Find_Theorems.criterion
val undefpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Const ("HOL.undefined", "?'a"))
       ):
   term Find_Theorems.criterion
val thmpattern =
   Pattern
    (Const ("HOL.Trueprop", "bool => prop") $ Var (("_dummy_", 1), "bool")):
   term Find_Theorems.criterion
val badnames =
   ["*nitpick*", "*Nitpick*", "*full_exhaustive*", "*_def*", "Enum.finite*",
    "*Quickcheck*", "ATP*", "*Nunchaku*", "*Code*", "*BNF*", "*SMT*",
    "*.*.*"]:
   string list
val unwanted_names =
   [(false, Name "*nitpick*"), (false, Name "*Nitpick*"),
    (false, Name "*full_exhaustive*"), (false, Name "*_def*"),
    (false, Name "Enum.finite*"), (false, Name "*Quickcheck*"),
    (false, Name "ATP*"), (false, Name "*Nunchaku*"),
    (false, Name "*Code*"), (false, Name "*BNF*"), (false, Name "*SMT*"),
    (false, Name "*.*.*")]:
   (bool * term Find_Theorems.criterion) list
val has_vars = fn: term -> bool
val get_all_eqs = fn: string -> Proof.context -> (string * thm) list
val get_all_thms = fn: string -> Proof.context -> (string * thm) list
val get_noneq_thms = fn: string -> Proof.context -> (string * thm) list
val template_eqs = fn:
   string -> Proof.context -> (string * thm * template) list
val template_thms = fn:
   string -> Proof.context -> (string * thm * template) list
### theory "Draft.ExtrEqs"
### 0.581s elapsed time, 1.294s cpu time, 0.100s GC time
class linordered_rational_vector = linorder + ordered_rational_vector +
  assumes "plus_less": "!!a b c. a < b ==> a + c < b + c"
    and "scaleRat_less1": "!!a b k. [| a < b; 0 < k |] ==> k *R a < k *R b"
    and "scaleRat_less2": "!!a b k. [| a < b; k < 0 |] ==> k *R b < k *R a"
class lrv = one + linordered_rational_vector +
  assumes "zero_neq_one": "(0::'a) ~= (1::'a)"
instantiation
  rat :: rational_vector
  scaleRat_rat == scaleRat :: rat => rat => rat
instantiation
  rat :: ordered_rational_vector
instantiation
  rat :: linordered_rational_vector
instantiation
  rat :: lrv
### theory "Draft.Simplex_Algebra"
### 1.724s elapsed time, 2.670s cpu time, 0.148s GC time
Loading theory "Draft.Abstract_Linear_Poly" (required by "Draft.Simplex_IncrementalTemplates" via "Draft.Simplex_Incremental" via "Draft.Simplex" via "Draft.Linear_Poly_Maps")
instantiation
  linear_poly :: rational_vector
  uminus_linear_poly == uminus :: linear_poly => linear_poly
  zero_linear_poly == zero_class.zero :: linear_poly
  minus_linear_poly == minus :: linear_poly => linear_poly => linear_poly
  plus_linear_poly == plus :: linear_poly => linear_poly => linear_poly
  scaleRat_linear_poly == scaleRat :: rat => linear_poly => linear_poly
### theory "Draft.Abstract_Linear_Poly"
### 0.327s elapsed time, 0.372s cpu time, 0.034s GC time
Loading theory "Draft.Linear_Poly_Maps" (required by "Draft.Simplex_IncrementalTemplates" via "Draft.Simplex_Incremental" via "Draft.Simplex")
Loading theory "Draft.QDelta" (required by "Draft.Simplex_IncrementalTemplates" via "Draft.Simplex_Incremental" via "Draft.Simplex")
consts
  qdfst :: "QDelta => rat"
consts
  qdsnd :: "QDelta => rat"
instantiation
  QDelta :: rational_vector
  uminus_QDelta == uminus :: QDelta => QDelta
  zero_QDelta == zero_class.zero :: QDelta
  minus_QDelta == minus :: QDelta => QDelta => QDelta
  plus_QDelta == plus :: QDelta => QDelta => QDelta
  scaleRat_QDelta == scaleRat :: rat => QDelta => QDelta
instantiation
  QDelta :: linorder
  less_eq_QDelta == less_eq :: QDelta => QDelta => bool
  less_QDelta == less :: QDelta => QDelta => bool
instantiation
  QDelta :: linordered_rational_vector
instantiation
  QDelta :: lrv
  one_QDelta == one_class.one :: QDelta
consts
  \<delta>_min :: "(QDelta * QDelta) list => rat"
### theory "Draft.QDelta"
### 0.365s elapsed time, 0.762s cpu time, 0.077s GC time
instantiation
  linear_poly :: equal
  equal_linear_poly == equal_class.equal ::
    linear_poly => linear_poly => bool
### theory "Draft.Linear_Poly_Maps"
### 0.630s elapsed time, 1.278s cpu time, 0.442s GC time
Loading theory "Draft.Simplex" (required by "Draft.Simplex_IncrementalTemplates" via "Draft.Simplex_Incremental")
consts
  satisfies_constraint :: "(nat => 'a) => constraint => bool"
Found termination order: "{}"
locale Solve
  fixes solve :: "('i * constraint) list => 'i list + (nat => rat)"
  assumes "Solve solve"
### Ignoring duplicate rewrite rule:
### Mapping.lookup Mapping.empty ?k1 == None
locale SolveExec
  fixes
    solve_exec :: "('i * constraint) list => 'i list + (nat, rat) mapping"
  assumes "SolveExec solve_exec"
### Ambiguous input (line 177 of "$AFP/Simplex/Simplex.thy") produces 5 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Orderings.ord_class.less_eq"
###     ("\<^fixed>satisfiable_ns_constraint" ("_position" v)
###       ("_applC" ("_position" LEQ_ns)
###         ("_cargs" ("_position" l)
###           ("_valuate" ("\<^const>HOL.iff" ("_position" r) ("_position" l))
###             ("_position" v)))))
###     ("_position" r)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Orderings.ord_class.less_eq"
###     ("\<^fixed>satisfiable_ns_constraint" ("_position" v)
###       ("_applC" ("_position" LEQ_ns)
###         ("_valuate"
###           ("\<^const>HOL.iff" ("_applC" ("_position" l) ("_position" r))
###             ("_position" l))
###           ("_position" v))))
###     ("_position" r)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Orderings.ord_class.less_eq"
###     ("\<^fixed>satisfiable_ns_constraint" ("_position" v)
###       ("_valuate"
###         ("\<^const>HOL.iff"
###           ("_applC" ("_position" LEQ_ns)
###             ("_cargs" ("_position" l) ("_position" r)))
###           ("_position" l))
###         ("_position" v)))
###     ("_position" r)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.iff"
###     ("\<^fixed>satisfiable_ns_constraint" ("_position" v)
###       ("_applC" ("_position" LEQ_ns)
###         ("_cargs" ("_position" l) ("_position" r))))
###     ("\<^const>Orderings.ord_class.less_eq"
###       ("_valuate" ("_position" l) ("_position" v)) ("_position" r))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Orderings.ord_class.less_eq"
###     ("_valuate"
###       ("\<^const>HOL.iff"
###         ("\<^fixed>satisfiable_ns_constraint" ("_position" v)
###           ("_applC" ("_position" LEQ_ns)
###             ("_cargs" ("_position" l) ("_position" r))))
###         ("_position" l))
###       ("_position" v))
###     ("_position" r)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 178 of "$AFP/Simplex/Simplex.thy") produces 5 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Orderings.ord_class.greater_eq"
###     ("\<^fixed>satisfiable_ns_constraint" ("_position" v)
###       ("_applC" ("_position" GEQ_ns)
###         ("_cargs" ("_position" l)
###           ("_valuate" ("\<^const>HOL.iff" ("_position" r) ("_position" l))
###             ("_position" v)))))
###     ("_position" r)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Orderings.ord_class.greater_eq"
###     ("\<^fixed>satisfiable_ns_constraint" ("_position" v)
###       ("_applC" ("_position" GEQ_ns)
###         ("_valuate"
###           ("\<^const>HOL.iff" ("_applC" ("_position" l) ("_position" r))
###             ("_position" l))
###           ("_position" v))))
###     ("_position" r)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Orderings.ord_class.greater_eq"
###     ("\<^fixed>satisfiable_ns_constraint" ("_position" v)
###       ("_valuate"
###         ("\<^const>HOL.iff"
###           ("_applC" ("_position" GEQ_ns)
###             ("_cargs" ("_position" l) ("_position" r)))
###           ("_position" l))
###         ("_position" v)))
###     ("_position" r)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.iff"
###     ("\<^fixed>satisfiable_ns_constraint" ("_position" v)
###       ("_applC" ("_position" GEQ_ns)
###         ("_cargs" ("_position" l) ("_position" r))))
###     ("\<^const>Orderings.ord_class.greater_eq"
###       ("_valuate" ("_position" l) ("_position" v)) ("_position" r))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Orderings.ord_class.greater_eq"
###     ("_valuate"
###       ("\<^const>HOL.iff"
###         ("\<^fixed>satisfiable_ns_constraint" ("_position" v)
###           ("_applC" ("_position" GEQ_ns)
###             ("_cargs" ("_position" l) ("_position" r))))
###         ("_position" l))
###       ("_position" v))
###     ("_position" r)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
consts
  satisfiable_ns_constraint :: "(nat => 'a) => 'a ns_constraint => bool"
Found termination order: "{}"
consts
  poly :: "'a ns_constraint => linear_poly"
consts
  ns_constraint_const :: "'a ns_constraint => 'a"
locale To_ns
  fixes to_ns :: "('i * constraint) list => ('i * 'a ns_constraint) list"
    and
    from_ns ::
      "(nat, 'a) mapping => 'a ns_constraint list => (nat, rat) mapping"
  assumes "To_ns to_ns from_ns"
locale Solve_exec_ns
  fixes
    solve_exec_ns ::
      "('i * 'a ns_constraint) list => 'i list + (nat, 'a) mapping"
  assumes "Solve_exec_ns solve_exec_ns"
locale SolveExec'
  fixes to_ns :: "('i * constraint) list => ('i * 'a ns_constraint) list"
    and
    from_ns ::
      "(nat, 'a) mapping => 'a ns_constraint list => (nat, rat) mapping"
    and
    solve_exec_ns ::
      "('i * 'a ns_constraint) list => 'i list + (nat, 'a) mapping"
  assumes "SolveExec' to_ns from_ns solve_exec_ns"
consts
  lhs :: "nat * linear_poly => nat"
consts
  rhs :: "nat * linear_poly => linear_poly"
### Ambiguous input (line 281 of "$AFP/Simplex/Simplex.thy") produces 3 parse trees:
### ("\<^const>Pure.eq"
###   ("\<^fixed>satisfies_eq" ("_position" v) ("_position" eq))
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" v) ("_applC" ("_position" lhs) ("_position" eq)))
###     ("_valuate" ("_applC" ("_position" rhs) ("_position" eq))
###       ("_position" v))))
### ("\<^const>Pure.eq"
###   ("\<^fixed>satisfies_eq" ("_position" v) ("_position" eq))
###   ("_applC" ("_position" v)
###     ("_valuate"
###       ("\<^const>HOL.eq" ("_applC" ("_position" lhs) ("_position" eq))
###         ("_applC" ("_position" rhs) ("_position" eq)))
###       ("_position" v))))
### ("\<^const>Pure.eq"
###   ("\<^fixed>satisfies_eq" ("_position" v) ("_position" eq))
###   ("_valuate"
###     ("\<^const>HOL.eq"
###       ("_applC" ("_position" v)
###         ("_applC" ("_position" lhs) ("_position" eq)))
###       ("_applC" ("_position" rhs) ("_position" eq)))
###     ("_position" v)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 283 of "$AFP/Simplex/Simplex.thy") produces 3 parse trees:
### ("\<^const>Pure.eq"
###   ("\<^const>Simplex.satisfies_eq" ("_position" v)
###     ("_tuple" ("_position" x) ("_tuple_arg" ("_position" p))))
###   ("\<^const>HOL.eq" ("_applC" ("_position" v) ("_position" x))
###     ("_valuate" ("_position" p) ("_position" v))))
### ("\<^const>Pure.eq"
###   ("\<^const>Simplex.satisfies_eq" ("_position" v)
###     ("_tuple" ("_position" x) ("_tuple_arg" ("_position" p))))
###   ("_applC" ("_position" v)
###     ("_valuate" ("\<^const>HOL.eq" ("_position" x) ("_position" p))
###       ("_position" v))))
### ("\<^const>Pure.eq"
###   ("\<^const>Simplex.satisfies_eq" ("_position" v)
###     ("_tuple" ("_position" x) ("_tuple_arg" ("_position" p))))
###   ("_valuate"
###     ("\<^const>HOL.eq" ("_applC" ("_position" v) ("_position" x))
###       ("_position" p))
###     ("_position" v)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
consts
  atom_var :: "'a atom => nat"
consts
  atom_const :: "'a atom => 'a"
consts
  satisfies_atom :: "(nat => 'a) => 'a atom => bool"
Found termination order: "{}"
Found termination order: "{}"
locale Preprocess
  fixes
    preprocess ::
      "('i * 'a ns_constraint) list
       => (nat * linear_poly) list *
          ('i * 'a atom) list *
          ((nat, 'a) mapping => (nat, 'a) mapping) * 'i list"
  assumes "Preprocess preprocess"
locale AssertAll
  fixes
    assert_all ::
      "(nat * linear_poly) list
       => ('i * 'a atom) list => 'i list + (nat, 'a) mapping"
  assumes "AssertAll assert_all"
locale Solve_exec_ns'
  fixes
    preprocess ::
      "('i * 'a ns_constraint) list
       => (nat * linear_poly) list *
          ('i * 'a atom) list *
          ((nat, 'a) mapping => (nat, 'a) mapping) * 'i list"
    and
    assert_all ::
      "(nat * linear_poly) list
       => ('i * 'a atom) list => 'i list + (nat, 'a) mapping"
  assumes "Solve_exec_ns' preprocess assert_all"
locale Preprocess
  fixes
    preprocess ::
      "('i * 'a ns_constraint) list
       => (nat * linear_poly) list *
          ('i * 'a atom) list *
          ((nat, 'a) mapping => (nat, 'a) mapping) * 'i list"
  assumes "Preprocess preprocess"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
locale AssertAllState
  fixes
    assert_all_state ::
      "(nat * linear_poly) list => ('i * 'a atom) list => ('i, 'a) state"
  assumes "AssertAllState assert_all_state"
locale Init'
  fixes init :: "(nat * linear_poly) list => ('i, 'a) state"
  assumes "Init' init"
locale Init
  fixes init :: "(nat * linear_poly) list => ('i, 'a) state"
  assumes "Init init"
locale Assert
  fixes assert :: "'i * 'a atom => ('i, 'a) state => ('i, 'a) state"
  assumes "Assert assert"
locale AssertAllState'
  fixes init :: "(nat * linear_poly) list => ('i, 'a) state"
    and assert :: "'i * 'a atom => ('i, 'a) state => ('i, 'a) state"
  assumes "AssertAllState' init assert"
Found termination order: "{}"
locale AssertBound
  fixes assert_bound :: "'i * 'a atom => ('i, 'a) state => ('i, 'a) state"
  assumes "AssertBound assert_bound"
locale AssertBoundNoLhs
  fixes assert_bound :: "'i * 'a atom => ('i, 'a) state => ('i, 'a) state"
  assumes "AssertBoundNoLhs assert_bound"
locale Check
  fixes check :: "('i, 'a) state => ('i, 'a) state"
  assumes "Check check"
locale Assert'
  fixes assert_bound :: "'i * 'a atom => ('i, 'a) state => ('i, 'a) state"
    and check :: "('i, 'a) state => ('i, 'a) state"
  assumes "Assert' assert_bound check"
locale AssertAllState''
  fixes init :: "(nat * linear_poly) list => ('i, 'a) state"
    and assert_bound :: "'i * 'a atom => ('i, 'a) state => ('i, 'a) state"
    and check :: "('i, 'a) state => ('i, 'a) state"
  assumes "AssertAllState'' init assert_bound check"
locale Update
  fixes update :: "nat => 'a => ('i, 'a) state => ('i, 'a) state"
  assumes "Update update"
Found termination order: "{}"
locale EqForLVar
  fixes eq_idx_for_lvar :: "(nat * linear_poly) list => nat => nat"
  assumes "EqForLVar eq_idx_for_lvar"
### Ambiguous input (line 2350 of "$AFP/Simplex/Simplex.thy") produces 7 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Simplex.satisfies_eq" ("_map2fun" ("_position" v))
###       ("_position" e)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("_applC" ("_position" rhs_eq_val)
###         ("_cargs" ("_position" v)
###           ("_cargs" ("_position" x)
###             ("_cargs" ("_position" c) ("_position" e)))))
###       ("_applC" ("_position" rhs)
###         ("_valuate" ("_position" e)
###           ("_Update" ("_map2fun" ("_position" v))
###             ("_updbind" ("_position" x) ("_position" c))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Simplex.satisfies_eq" ("_map2fun" ("_position" v))
###       ("_position" e)))
###   ("\<^const>HOL.Trueprop"
###     ("_applC" ("_position" rhs_eq_val)
###       ("_cargs" ("_position" v)
###         ("_cargs" ("_position" x)
###           ("_cargs" ("_position" c)
###             ("_valuate"
###               ("\<^const>HOL.eq" ("_position" e)
###                 ("_applC" ("_position" rhs) ("_position" e)))
###               ("_Update" ("_map2fun" ("_position" v))
###                 ("_updbind" ("_position" x) ("_position" c))))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Simplex.satisfies_eq" ("_map2fun" ("_position" v))
###       ("_position" e)))
###   ("\<^const>HOL.Trueprop"
###     ("_applC" ("_position" rhs_eq_val)
###       ("_cargs" ("_position" v)
###         ("_cargs" ("_position" x)
###           ("_valuate"
###             ("\<^const>HOL.eq" ("_applC" ("_position" c) ("_position" e))
###               ("_applC" ("_position" rhs) ("_position" e)))
###             ("_Update" ("_map2fun" ("_position" v))
###               ("_updbind" ("_position" x) ("_position" c)))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Simplex.satisfies_eq" ("_map2fun" ("_position" v))
###       ("_position" e)))
###   ("\<^const>HOL.Trueprop"
###     ("_applC" ("_position" rhs_eq_val)
###       ("_cargs" ("_position" v)
###         ("_valuate"
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" x)
###               ("_cargs" ("_position" c) ("_position" e)))
###             ("_applC" ("_position" rhs) ("_position" e)))
###           ("_Update" ("_map2fun" ("_position" v))
###             ("_updbind" ("_position" x) ("_position" c))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Simplex.satisfies_eq" ("_map2fun" ("_position" v))
###       ("_position" e)))
###   ("\<^const>HOL.Trueprop"
###     ("_applC" ("_position" rhs_eq_val)
###       ("_valuate"
###         ("\<^const>HOL.eq"
###           ("_applC" ("_position" v)
###             ("_cargs" ("_position" x)
###               ("_cargs" ("_position" c) ("_position" e))))
###           ("_applC" ("_position" rhs) ("_position" e)))
###         ("_Update" ("_map2fun" ("_position" v))
###           ("_updbind" ("_position" x) ("_position" c)))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Simplex.satisfies_eq" ("_map2fun" ("_position" v))
###       ("_position" e)))
###   ("\<^const>HOL.Trueprop"
###     ("_valuate"
###       ("\<^const>HOL.eq"
###         ("_applC" ("_position" rhs_eq_val)
###           ("_cargs" ("_position" v)
###             ("_cargs" ("_position" x)
###               ("_cargs" ("_position" c) ("_position" e)))))
###         ("_applC" ("_position" rhs) ("_position" e)))
###       ("_Update" ("_map2fun" ("_position" v))
###         ("_updbind" ("_position" x) ("_position" c))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Simplex.satisfies_eq" ("_map2fun" ("_position" v))
###       ("_position" e)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("_applC" ("_position" rhs_eq_val)
###         ("_cargs" ("_position" v)
###           ("_cargs" ("_position" x)
###             ("_cargs" ("_position" c) ("_position" e)))))
###       ("_valuate" ("_applC" ("_position" rhs) ("_position" e))
###         ("_Update" ("_map2fun" ("_position" v))
###           ("_updbind" ("_position" x) ("_position" c)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
locale RhsEqVal
  fixes
    rhs_eq_val ::
      "(nat, 'a) mapping => nat => 'a => nat * linear_poly => 'a"
  assumes "RhsEqVal rhs_eq_val"
### Ambiguous input (line 2383 of "$AFP/Simplex/Simplex.thy") produces 7 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" rhs)
###       ("_valuate" ("_position" e)
###         ("_map2fun"
###           ("_applC" ("_position" \<V>)
###             ("_applC" ("_position" update)
###               ("_cargs" ("_position" x)
###                 ("_cargs" ("_position" c) ("_position" s))))))))
###     ("_applC" ("_position" rhs)
###       ("_valuate" ("_position" e)
###         ("_Update"
###           ("_map2fun" ("_applC" ("_position" \<V>) ("_position" s)))
###           ("_updbind" ("_position" x) ("_position" c)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_valuate" ("_applC" ("_position" rhs) ("_position" e))
###       ("_map2fun"
###         ("_applC" ("_position" \<V>)
###           ("_applC" ("_position" update)
###             ("_cargs" ("_position" x)
###               ("_cargs" ("_position" c) ("_position" s)))))))
###     ("_applC" ("_position" rhs)
###       ("_valuate" ("_position" e)
###         ("_Update"
###           ("_map2fun" ("_applC" ("_position" \<V>) ("_position" s)))
###           ("_updbind" ("_position" x) ("_position" c)))))))
### ("\<^const>HOL.Trueprop"
###   ("_valuate"
###     ("\<^const>HOL.eq"
###       ("_valuate" ("_applC" ("_position" rhs) ("_position" e))
###         ("_map2fun"
###           ("_applC" ("_position" \<V>)
###             ("_applC" ("_position" update)
###               ("_cargs" ("_position" x)
###                 ("_cargs" ("_position" c) ("_position" s)))))))
###       ("_applC" ("_position" rhs) ("_position" e)))
###     ("_Update" ("_map2fun" ("_applC" ("_position" \<V>) ("_position" s)))
###       ("_updbind" ("_position" x) ("_position" c)))))
### ("\<^const>HOL.Trueprop"
###   ("_applC" ("_position" rhs)
###     ("_valuate"
###       ("\<^const>HOL.eq"
###         ("_valuate" ("_position" e)
###           ("_map2fun"
###             ("_applC" ("_position" \<V>)
###               ("_applC" ("_position" update)
###                 ("_cargs" ("_position" x)
###                   ("_cargs" ("_position" c) ("_position" s)))))))
###         ("_applC" ("_position" rhs) ("_position" e)))
###       ("_Update" ("_map2fun" ("_applC" ("_position" \<V>) ("_position" s)))
###         ("_updbind" ("_position" x) ("_position" c))))))
### ("\<^const>HOL.Trueprop"
###   ("_valuate"
###     ("\<^const>HOL.eq"
###       ("_applC" ("_position" rhs)
###         ("_valuate" ("_position" e)
###           ("_map2fun"
###             ("_applC" ("_position" \<V>)
###               ("_applC" ("_position" update)
###                 ("_cargs" ("_position" x)
###                   ("_cargs" ("_position" c) ("_position" s))))))))
###       ("_applC" ("_position" rhs) ("_position" e)))
###     ("_Update" ("_map2fun" ("_applC" ("_position" \<V>) ("_position" s)))
###       ("_updbind" ("_position" x) ("_position" c)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" rhs)
###       ("_valuate" ("_position" e)
###         ("_map2fun"
###           ("_applC" ("_position" \<V>)
###             ("_applC" ("_position" update)
###               ("_cargs" ("_position" x)
###                 ("_cargs" ("_position" c) ("_position" s))))))))
###     ("_valuate" ("_applC" ("_position" rhs) ("_position" e))
###       ("_Update" ("_map2fun" ("_applC" ("_position" \<V>) ("_position" s)))
###         ("_updbind" ("_position" x) ("_position" c))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_valuate" ("_applC" ("_position" rhs) ("_position" e))
###       ("_map2fun"
###         ("_applC" ("_position" \<V>)
###           ("_applC" ("_position" update)
###             ("_cargs" ("_position" x)
###               ("_cargs" ("_position" c) ("_position" s)))))))
###     ("_valuate" ("_applC" ("_position" rhs) ("_position" e))
###       ("_Update" ("_map2fun" ("_applC" ("_position" \<V>) ("_position" s)))
###         ("_updbind" ("_position" x) ("_position" c))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
locale Pivot
  fixes eq_idx_for_lvar :: "(nat * linear_poly) list => nat => nat"
    and pivot :: "nat => nat => ('i, 'a) state => ('i, 'a) state"
  assumes "Pivot eq_idx_for_lvar pivot"
locale PivotAndUpdate
  fixes eq_idx_for_lvar :: "(nat * linear_poly) list => nat => nat"
    and
    pivot_and_update ::
      "nat => nat => 'a => ('i, 'a) state => ('i, 'a) state"
  assumes "PivotAndUpdate eq_idx_for_lvar pivot_and_update"
locale PivotUpdate
  fixes eq_idx_for_lvar :: "(nat * linear_poly) list => nat => nat"
    and pivot :: "nat => nat => ('i, 'a) state => ('i, 'a) state"
    and update :: "nat => 'a => ('i, 'a) state => ('i, 'a) state"
  assumes "PivotUpdate eq_idx_for_lvar pivot update"
### Additional type variable(s) in locale specification "PivotEq": 'a
locale PivotEq
  fixes pivot_eq :: "nat * linear_poly => nat => nat * linear_poly"
  assumes "PivotEq TYPE('a) pivot_eq"
### Ambiguous input (line 3332 of "$AFP/Simplex/Simplex.thy") produces 28 parse trees (10 displayed):
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_valuate"
###       ("\<^const>HOL.implies"
###         ("_valuate"
###           ("\<^const>HOL.eq"
###             ("_applC"
###               ("_constrain" ("_position" v)
###                 ("_tapp"
###                   ("_ofsort" ("_position_sort" 'a) ("_class_name" lrv))
###                   ("_type_name" valuation)))
###               ("_position" x\<^sub>j))
###             ("_position" lp'))
###           ("_position" v))
###         ("_position" lp))
###       ("_position" v))
###     ("_valuate"
###       ("_applC" ("_position" subst_var)
###         ("_cargs" ("_position" x\<^sub>j)
###           ("_cargs" ("_position" lp') ("_position" lp))))
###       ("_position" v))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC"
###       ("_constrain" ("_position" v)
###         ("_tapp" ("_ofsort" ("_position_sort" 'a) ("_class_name" lrv))
###           ("_type_name" valuation)))
###       ("_valuate"
###         ("\<^const>HOL.implies"
###           ("_valuate"
###             ("\<^const>HOL.eq" ("_position" x\<^sub>j) ("_position" lp'))
###             ("_position" v))
###           ("_position" lp))
###         ("_position" v)))
###     ("_valuate"
###       ("_applC" ("_position" subst_var)
###         ("_cargs" ("_position" x\<^sub>j)
###           ("_cargs" ("_position" lp') ("_position" lp))))
###       ("_position" v))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_valuate"
###       ("\<^const>HOL.implies"
###         ("_applC"
###           ("_constrain" ("_position" v)
###             ("_tapp" ("_ofsort" ("_position_sort" 'a) ("_class_name" lrv))
###               ("_type_name" valuation)))
###           ("_valuate"
###             ("\<^const>HOL.eq" ("_position" x\<^sub>j) ("_position" lp'))
###             ("_position" v)))
###         ("_position" lp))
###       ("_position" v))
###     ("_valuate"
###       ("_applC" ("_position" subst_var)
###         ("_cargs" ("_position" x\<^sub>j)
###           ("_cargs" ("_position" lp') ("_position" lp))))
###       ("_position" v))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>HOL.eq"
###       ("_applC"
###         ("_constrain" ("_position" v)
###           ("_tapp" ("_ofsort" ("_position_sort" 'a) ("_class_name" lrv))
###             ("_type_name" valuation)))
###         ("_position" x\<^sub>j))
###       ("_valuate"
###         ("\<^const>HOL.implies"
###           ("_valuate" ("_position" lp') ("_position" v)) ("_position" lp))
###         ("_position" v)))
###     ("_valuate"
###       ("_applC" ("_position" subst_var)
###         ("_cargs" ("_position" x\<^sub>j)
###           ("_cargs" ("_position" lp') ("_position" lp))))
###       ("_position" v))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC"
###       ("_constrain" ("_position" v)
###         ("_tapp" ("_ofsort" ("_position_sort" 'a) ("_class_name" lrv))
###           ("_type_name" valuation)))
###       ("_valuate"
###         ("\<^const>HOL.implies"
###           ("\<^const>HOL.eq" ("_position" x\<^sub>j)
###             ("_valuate" ("_position" lp') ("_position" v)))
###           ("_position" lp))
###         ("_position" v)))
###     ("_valuate"
###       ("_applC" ("_position" subst_var)
###         ("_cargs" ("_position" x\<^sub>j)
###           ("_cargs" ("_position" lp') ("_position" lp))))
###       ("_position" v))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.implies"
###     ("\<^const>HOL.eq"
###       ("_applC"
###         ("_constrain" ("_position" v)
###           ("_tapp" ("_ofsort" ("_position_sort" 'a) ("_class_name" lrv))
###             ("_type_name" valuation)))
###         ("_position" x\<^sub>j))
###       ("_valuate" ("_position" lp') ("_position" v)))
###     ("\<^const>HOL.eq" ("_valuate" ("_position" lp) ("_position" v))
###       ("_valuate"
###         ("_applC" ("_position" subst_var)
###           ("_cargs" ("_position" x\<^sub>j)
###             ("_cargs" ("_position" lp') ("_position" lp))))
###         ("_position" v)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.implies"
###     ("_applC"
###       ("_constrain" ("_position" v)
###         ("_tapp" ("_ofsort" ("_position_sort" 'a) ("_class_name" lrv))
###           ("_type_name" valuation)))
###       ("_valuate"
###         ("\<^const>HOL.eq" ("_position" x\<^sub>j) ("_position" lp'))
###         ("_position" v)))
###     ("\<^const>HOL.eq" ("_valuate" ("_position" lp) ("_position" v))
###       ("_valuate"
###         ("_applC" ("_position" subst_var)
###           ("_cargs" ("_position" x\<^sub>j)
###             ("_cargs" ("_position" lp') ("_position" lp))))
###         ("_position" v)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.implies"
###     ("_valuate"
###       ("\<^const>HOL.eq"
###         ("_applC"
###           ("_constrain" ("_position" v)
###             ("_tapp" ("_ofsort" ("_position_sort" 'a) ("_class_name" lrv))
###               ("_type_name" valuation)))
###           ("_position" x\<^sub>j))
###         ("_position" lp'))
###       ("_position" v))
###     ("\<^const>HOL.eq" ("_valuate" ("_position" lp) ("_position" v))
###       ("_valuate"
###         ("_applC" ("_position" subst_var)
###           ("_cargs" ("_position" x\<^sub>j)
###             ("_cargs" ("_position" lp') ("_position" lp))))
###         ("_position" v)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_valuate"
###       ("\<^const>HOL.implies"
###         ("\<^const>HOL.eq"
###           ("_applC"
###             ("_constrain" ("_position" v)
###               ("_tapp" ("_ofsort" ("_position_sort" 'a) ("_class_name" lrv))
###                 ("_type_name" valuation)))
###             ("_position" x\<^sub>j))
###           ("_valuate" ("_position" lp') ("_position" v)))
###         ("_position" lp))
###       ("_position" v))
###     ("_valuate"
###       ("_applC" ("_position" subst_var)
###         ("_cargs" ("_position" x\<^sub>j)
###           ("_cargs" ("_position" lp') ("_position" lp))))
###       ("_position" v))))
### ("\<^const>HOL.Trueprop"
###   ("_valuate"
###     ("\<^const>HOL.eq"
###       ("_valuate"
###         ("\<^const>HOL.implies"
###           ("\<^const>HOL.eq"
###             ("_applC"
###               ("_constrain" ("_position" v)
###                 ("_tapp"
###                   ("_ofsort" ("_position_sort" 'a) ("_class_name" lrv))
###                   ("_type_name" valuation)))
###               ("_position" x\<^sub>j))
###             ("_valuate" ("_position" lp') ("_position" v)))
###           ("_position" lp))
###         ("_position" v))
###       ("_applC" ("_position" subst_var)
###         ("_cargs" ("_position" x\<^sub>j)
###           ("_cargs" ("_position" lp') ("_position" lp)))))
###     ("_position" v)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Additional type variable(s) in locale specification "SubstVar": 'a
locale SubstVar
  fixes subst_var :: "nat => linear_poly => linear_poly => linear_poly"
  assumes "SubstVar TYPE('a) subst_var"
locale Pivot'
  fixes eq_idx_for_lvar :: "(nat * linear_poly) list => nat => nat"
    and pivot_eq :: "nat * linear_poly => nat => nat * linear_poly"
    and subst_var :: "nat => linear_poly => linear_poly => linear_poly"
  assumes "Pivot' TYPE('a) eq_idx_for_lvar pivot_eq subst_var"
locale MinLVarNotInBounds
  fixes min_lvar_not_in_bounds :: "('i, 'a) state => nat option"
  assumes "MinLVarNotInBounds min_lvar_not_in_bounds"
### Ambiguous input (line 3762 of "$AFP/Simplex/Simplex.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.implies"
###     ("\<^const>HOL.eq"
###       ("_applC" ("_position" min_lvar_not_in_bounds) ("_position" s))
###       ("_position" None))
###     ("_applC"
###       ("_satisfies_bounds_set"
###         ("_map2fun" ("_applC" ("_position" \<V>) ("_position" s)))
###         ("_applC" ("\<^const>Simplex.Bounds") ("_position" s))
###         ("_position" lvars))
###       ("_applC" ("_position" \<T>) ("_position" s)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.implies"
###     ("\<^const>HOL.eq"
###       ("_applC" ("_position" min_lvar_not_in_bounds) ("_position" s))
###       ("_position" None))
###     ("_satisfies_bounds_set"
###       ("_map2fun" ("_applC" ("_position" \<V>) ("_position" s)))
###       ("_applC" ("\<^const>Simplex.Bounds") ("_position" s))
###       ("_applC" ("_position" lvars)
###         ("_applC" ("_position" \<T>) ("_position" s))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
locale MinRVarsEq
  fixes
    min_rvar_incdec_eq ::
      "('i, 'a) Direction
       => ('i, 'a) state => nat * linear_poly => 'i list + nat"
  assumes "MinRVarsEq min_rvar_incdec_eq"
locale MinRVars
  fixes eq_idx_for_lvar :: "(nat * linear_poly) list => nat => nat"
    and
    min_rvar_incdec_eq ::
      "('i, 'a) Direction
       => ('i, 'a) state => nat * linear_poly => 'i list + nat"
  assumes "MinRVars eq_idx_for_lvar min_rvar_incdec_eq"
locale MinVars
  fixes min_lvar_not_in_bounds :: "('i, 'a) state => nat option"
    and eq_idx_for_lvar :: "(nat * linear_poly) list => nat => nat"
    and
    min_rvar_incdec_eq ::
      "('i, 'a) Direction
       => ('i, 'a) state => nat * linear_poly => 'i list + nat"
  assumes
    "MinVars min_lvar_not_in_bounds eq_idx_for_lvar min_rvar_incdec_eq"
locale PivotUpdateMinVars
  fixes eq_idx_for_lvar :: "(nat * linear_poly) list => nat => nat"
    and min_lvar_not_in_bounds :: "('i, 'a) state => nat option"
    and
    min_rvar_incdec_eq ::
      "('i, 'a) Direction
       => ('i, 'a) state => nat * linear_poly => 'i list + nat"
    and
    pivot_and_update ::
      "nat => nat => 'a => ('i, 'a) state => ('i, 'a) state"
  assumes
    "PivotUpdateMinVars eq_idx_for_lvar min_lvar_not_in_bounds
      min_rvar_incdec_eq pivot_and_update"
Proofs for inductive predicate(s) "check_dom"
  Proving monotonicity ...
locale PivotUpdateMinVars
  fixes eq_idx_for_lvar :: "(nat * linear_poly) list => nat => nat"
    and min_lvar_not_in_bounds :: "('i, 'a) state => nat option"
    and
    min_rvar_incdec_eq ::
      "('i, 'a) Direction
       => ('i, 'a) state => nat * linear_poly => 'i list + nat"
    and
    pivot_and_update ::
      "nat => nat => 'a => ('i, 'a) state => ('i, 'a) state"
  assumes
    "PivotUpdateMinVars eq_idx_for_lvar min_lvar_not_in_bounds
      min_rvar_incdec_eq pivot_and_update"
consts
  eq_idx_for_lvar_aux :: "(nat * linear_poly) list => nat => nat => nat"
### Cannot skip proof of schematic goal statement
### Introduced fixed type variable(s): 'b in "v__"
### Ambiguous input (line 6932 of "$AFP/Simplex/Simplex.thy") produces 7 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" rhs_eq_val)
###       ("_cargs" ("_position" v)
###         ("_cargs" ("_position" x)
###           ("_cargs" ("_position" c) ("_position" e)))))
###     ("_applC" ("_position" rhs)
###       ("_valuate" ("_position" e)
###         ("_Update" ("_map2fun" ("_position" v))
###           ("_updbind" ("_position" x) ("_position" c)))))))
### ("\<^const>HOL.Trueprop"
###   ("_applC" ("_position" rhs_eq_val)
###     ("_cargs" ("_position" v)
###       ("_cargs" ("_position" x)
###         ("_cargs" ("_position" c)
###           ("_valuate"
###             ("\<^const>HOL.eq" ("_position" e)
###               ("_applC" ("_position" rhs) ("_position" e)))
###             ("_Update" ("_map2fun" ("_position" v))
###               ("_updbind" ("_position" x) ("_position" c)))))))))
### ("\<^const>HOL.Trueprop"
###   ("_applC" ("_position" rhs_eq_val)
###     ("_cargs" ("_position" v)
###       ("_cargs" ("_position" x)
###         ("_valuate"
###           ("\<^const>HOL.eq" ("_applC" ("_position" c) ("_position" e))
###             ("_applC" ("_position" rhs) ("_position" e)))
###           ("_Update" ("_map2fun" ("_position" v))
###             ("_updbind" ("_position" x) ("_position" c))))))))
### ("\<^const>HOL.Trueprop"
###   ("_applC" ("_position" rhs_eq_val)
###     ("_cargs" ("_position" v)
###       ("_valuate"
###         ("\<^const>HOL.eq"
###           ("_applC" ("_position" x)
###             ("_cargs" ("_position" c) ("_position" e)))
###           ("_applC" ("_position" rhs) ("_position" e)))
###         ("_Update" ("_map2fun" ("_position" v))
###           ("_updbind" ("_position" x) ("_position" c)))))))
### ("\<^const>HOL.Trueprop"
###   ("_applC" ("_position" rhs_eq_val)
###     ("_valuate"
###       ("\<^const>HOL.eq"
###         ("_applC" ("_position" v)
###           ("_cargs" ("_position" x)
###             ("_cargs" ("_position" c) ("_position" e))))
###         ("_applC" ("_position" rhs) ("_position" e)))
###       ("_Update" ("_map2fun" ("_position" v))
###         ("_updbind" ("_position" x) ("_position" c))))))
### ("\<^const>HOL.Trueprop"
###   ("_valuate"
###     ("\<^const>HOL.eq"
###       ("_applC" ("_position" rhs_eq_val)
###         ("_cargs" ("_position" v)
###           ("_cargs" ("_position" x)
###             ("_cargs" ("_position" c) ("_position" e)))))
###       ("_applC" ("_position" rhs) ("_position" e)))
###     ("_Update" ("_map2fun" ("_position" v))
###       ("_updbind" ("_position" x) ("_position" c)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" rhs_eq_val)
###       ("_cargs" ("_position" v)
###         ("_cargs" ("_position" x)
###           ("_cargs" ("_position" c) ("_position" e)))))
###     ("_valuate" ("_applC" ("_position" rhs) ("_position" e))
###       ("_Update" ("_map2fun" ("_position" v))
###         ("_updbind" ("_position" x) ("_position" c))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Cannot skip proof of schematic goal statement
### Cannot skip proof of schematic goal statement
### Cannot skip proof of schematic goal statement
### Cannot skip proof of schematic goal statement
### Cannot skip proof of schematic goal statement
consts
  monom_to_atom :: "QDelta ns_constraint => QDelta atom"
consts
  qdelta_constraint_to_atom :: "QDelta ns_constraint => nat => QDelta atom"
consts
  qdelta_constraint_to_atom' :: "QDelta ns_constraint => nat => QDelta atom"
Found termination order: "{}"
consts
  zero_satisfies :: "'a ns_constraint => bool"
Found termination order:
  "(%p. size_list (%p. size (snd p)) (fst p)) <*mlex*> {}"
Found termination order: "{}"
Found termination order: "size_list (%p. size (snd p)) <*mlex*> {}"
consts
  constraint_to_qdelta_constraint ::
    "constraint => QDelta ns_constraint list"
consts
  i_constraint_to_qdelta_constraint ::
    "'i * constraint => ('i * QDelta ns_constraint) list"
### Ambiguous input (line 7794 of "$AFP/Simplex/Simplex.thy") produces 5 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" \<delta>0_val)
###       ("_cargs"
###         ("_applC" ("_position" LEQ_ns)
###           ("_cargs" ("_position" lll) ("_position" rrr)))
###         ("_position" vl)))
###     ("_applC"
###       ("_valuate" ("_applC" ("_position" \<delta>0) ("_position" lll))
###         ("_position" vl))
###       ("_position" rrr))))
### ("\<^const>HOL.Trueprop"
###   ("_applC"
###     ("_valuate"
###       ("\<^const>HOL.eq"
###         ("_applC" ("_position" \<delta>0_val)
###           ("_cargs"
###             ("_applC" ("_position" LEQ_ns)
###               ("_cargs" ("_position" lll) ("_position" rrr)))
###             ("_position" vl)))
###         ("_applC" ("_position" \<delta>0) ("_position" lll)))
###       ("_position" vl))
###     ("_position" rrr)))
### ("\<^const>HOL.Trueprop"
###   ("_applC" ("_position" \<delta>0_val)
###     ("_cargs"
###       ("_valuate"
###         ("\<^const>HOL.eq"
###           ("_applC"
###             ("_applC" ("_position" LEQ_ns)
###               ("_cargs" ("_position" lll) ("_position" rrr)))
###             ("_position" vl))
###           ("_applC" ("_position" \<delta>0) ("_position" lll)))
###         ("_position" vl))
###       ("_position" rrr))))
### ("\<^const>HOL.Trueprop"
###   ("_applC" ("_position" \<delta>0_val)
###     ("_cargs"
###       ("_applC" ("_position" LEQ_ns)
###         ("_cargs" ("_position" lll) ("_position" rrr)))
###       ("_cargs"
###         ("_valuate"
###           ("\<^const>HOL.eq" ("_position" vl)
###             ("_applC" ("_position" \<delta>0) ("_position" lll)))
###           ("_position" vl))
###         ("_position" rrr)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" \<delta>0_val)
###       ("_cargs"
###         ("_applC" ("_position" LEQ_ns)
###           ("_cargs" ("_position" lll) ("_position" rrr)))
###         ("_position" vl)))
###     ("_applC" ("_position" \<delta>0)
###       ("_cargs" ("_valuate" ("_position" lll) ("_position" vl))
###         ("_position" rrr)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 7795 of "$AFP/Simplex/Simplex.thy") produces 6 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" \<delta>0_val)
###       ("_cargs"
###         ("_applC" ("_position" GEQ_ns)
###           ("_cargs" ("_position" lll) ("_position" rrr)))
###         ("_position" vl)))
###     ("_applC" ("_position" \<delta>0)
###       ("_cargs" ("_position" rrr)
###         ("_valuate" ("_position" lll) ("_position" vl))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" \<delta>0_val)
###       ("_cargs"
###         ("_applC" ("_position" GEQ_ns)
###           ("_cargs" ("_position" lll) ("_position" rrr)))
###         ("_position" vl)))
###     ("_applC" ("_position" \<delta>0)
###       ("_valuate" ("_applC" ("_position" rrr) ("_position" lll))
###         ("_position" vl)))))
### ("\<^const>HOL.Trueprop"
###   ("_applC" ("_position" \<delta>0_val)
###     ("_cargs"
###       ("_applC" ("_position" GEQ_ns)
###         ("_cargs" ("_position" lll) ("_position" rrr)))
###       ("_valuate"
###         ("\<^const>HOL.eq" ("_position" vl)
###           ("_applC" ("_position" \<delta>0)
###             ("_cargs" ("_position" rrr) ("_position" lll))))
###         ("_position" vl)))))
### ("\<^const>HOL.Trueprop"
###   ("_applC" ("_position" \<delta>0_val)
###     ("_valuate"
###       ("\<^const>HOL.eq"
###         ("_applC"
###           ("_applC" ("_position" GEQ_ns)
###             ("_cargs" ("_position" lll) ("_position" rrr)))
###           ("_position" vl))
###         ("_applC" ("_position" \<delta>0)
###           ("_cargs" ("_position" rrr) ("_position" lll))))
###       ("_position" vl))))
### ("\<^const>HOL.Trueprop"
###   ("_valuate"
###     ("\<^const>HOL.eq"
###       ("_applC" ("_position" \<delta>0_val)
###         ("_cargs"
###           ("_applC" ("_position" GEQ_ns)
###             ("_cargs" ("_position" lll) ("_position" rrr)))
###           ("_position" vl)))
###       ("_applC" ("_position" \<delta>0)
###         ("_cargs" ("_position" rrr) ("_position" lll))))
###     ("_position" vl)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" \<delta>0_val)
###       ("_cargs"
###         ("_applC" ("_position" GEQ_ns)
###           ("_cargs" ("_position" lll) ("_position" rrr)))
###         ("_position" vl)))
###     ("_valuate"
###       ("_applC" ("_position" \<delta>0)
###         ("_cargs" ("_position" rrr) ("_position" lll)))
###       ("_position" vl))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
consts
  \<delta>0_val :: "QDelta ns_constraint => (nat => QDelta) => rat"
consts
  \<delta>0_val_min :: "QDelta ns_constraint list => (nat => QDelta) => rat"
### theory "Draft.Simplex"
### 10.409s elapsed time, 12.357s cpu time, 2.699s GC time
Loading theory "Draft.Simplex_Incremental" (required by "Draft.Simplex_IncrementalTemplates")
locale Incremental_Atom_Ops
  fixes init_s :: "(nat * linear_poly) list => 's"
    and assert_s :: "'i * 'a atom => 's => 'i list + 's"
    and check_s :: "'s => 'i list + 's"
    and solution_s :: "'s => (nat, 'a) mapping"
    and checkpoint_s :: "'s => 'c"
    and backtrack_s :: "'c => 's => 's"
    and precond_s :: "(nat * linear_poly) list => bool"
    and
    invariant_s ::
      "(nat * linear_poly) list => ('i * 'a atom) set => 's => bool"
    and
    checked_s ::
      "(nat * linear_poly) list => ('i * 'a atom) set => 's => bool"
  assumes
    "Incremental_Atom_Ops init_s assert_s check_s solution_s checkpoint_s
      backtrack_s precond_s invariant_s checked_s"
Found termination order:
  "(%p. size_list (%p. size (snd p)) (fst p)) <*mlex*> {}"
locale Incremental_State_Ops_Simplex
  fixes assert_bound :: "'i * 'a atom => ('i, 'a) state => ('i, 'a) state"
    and init :: "(nat * linear_poly) list => ('i, 'a) state"
    and check :: "('i, 'a) state => ('i, 'a) state"
  assumes "Incremental_State_Ops_Simplex assert_bound init check"
Found termination order: "{}"
locale Incremental_NS_Constraint_Ops
  fixes init_nsc :: "('i * 'a ns_constraint) list => 's"
    and assert_nsc :: "'i => 's => 'i list + 's"
    and check_nsc :: "'s => 'i list + 's"
    and solution_nsc :: "'s => (nat, 'a) mapping"
    and checkpoint_nsc :: "'s => 'c"
    and backtrack_nsc :: "'c => 's => 's"
    and
    invariant_nsc :: "('i * 'a ns_constraint) list => 'i set => 's => bool"
    and
    checked_nsc :: "('i * 'a ns_constraint) list => 'i set => 's => bool"
  assumes
    "Incremental_NS_Constraint_Ops init_nsc assert_nsc check_nsc
      solution_nsc checkpoint_nsc backtrack_nsc invariant_nsc checked_nsc"
Found termination order: "size_list size <*mlex*> {}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
locale Incremental_Atom_Ops_For_NS_Constraint_Ops
  fixes init_s :: "(nat * linear_poly) list => 's"
    and assert_s :: "'i * 'a atom => 's => 'i list + 's"
    and check_s :: "'s => 'i list + 's"
    and solution_s :: "'s => (nat, 'a) mapping"
    and checkpoint_s :: "'s => 'c"
    and backtrack_s :: "'c => 's => 's"
    and
    invariant_s ::
      "(nat * linear_poly) list => ('i * 'a atom) set => 's => bool"
    and
    checked_s ::
      "(nat * linear_poly) list => ('i * 'a atom) set => 's => bool"
    and
    preprocess ::
      "('i * 'a ns_constraint) list
       => (nat * linear_poly) list *
          ('i * 'a atom) list *
          ((nat, 'a) mapping => (nat, 'a) mapping) * 'i list"
  assumes
    "Incremental_Atom_Ops_For_NS_Constraint_Ops init_s assert_s check_s
      solution_s checkpoint_s backtrack_s invariant_s checked_s preprocess"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
locale Incremental_Simplex_Ops
  fixes init_cs :: "('i * constraint) list => 's"
    and assert_cs :: "'i => 's => 'i list + 's"
    and check_cs :: "'s => 'i list + 's"
    and solution_cs :: "'s => nat => rat"
    and checkpoint_cs :: "'s => 'c"
    and backtrack_cs :: "'c => 's => 's"
    and invariant_cs :: "('i * constraint) list => 'i set => 's => bool"
    and checked_cs :: "('i * constraint) list => 'i set => 's => bool"
  assumes
    "Incremental_Simplex_Ops init_cs assert_cs check_cs solution_cs
      checkpoint_cs backtrack_cs invariant_cs checked_cs"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
locale Incremental_NS_Constraint_Ops_To_Ns_For_Incremental_Simplex
  fixes init_nsc :: "('i * 'a ns_constraint) list => 's"
    and assert_nsc :: "'i => 's => 'i list + 's"
    and check_nsc :: "'s => 'i list + 's"
    and solution_nsc :: "'s => (nat, 'a) mapping"
    and checkpoint_nsc :: "'s => 'c"
    and backtrack_nsc :: "'c => 's => 's"
    and
    invariant_nsc :: "('i * 'a ns_constraint) list => 'i set => 's => bool"
    and
    checked_nsc :: "('i * 'a ns_constraint) list => 'i set => 's => bool"
    and to_ns :: "('i * constraint) list => ('i * 'a ns_constraint) list"
    and
    from_ns ::
      "(nat, 'a) mapping => 'a ns_constraint list => (nat, rat) mapping"
  assumes
    "Incremental_NS_Constraint_Ops_To_Ns_For_Incremental_Simplex init_nsc
      assert_nsc check_nsc solution_nsc checkpoint_nsc backtrack_nsc
      invariant_nsc checked_nsc to_ns from_ns"
Found termination order: "{}"
Found termination order: "{}"
### Cannot skip proof of schematic goal statement
### Cannot skip proof of schematic goal statement
### Cannot skip proof of schematic goal statement
### Cannot skip proof of schematic goal statement
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "(%p. length (fst p)) <*mlex*> {}"
### theory "Draft.Simplex_Incremental"
### 3.831s elapsed time, 4.272s cpu time, 0.520s GC time
Loading theory "Draft.Simplex_IncrementalTemplates"
val templateLemmas =
   [("Simplex_Incremental.init_simplex",
     "checked_simplex ?cs {} (init_simplex ?cs)",
     template_predicate
      (
         template_app
          (template_app
            (template_app (template_hole 2, template_var 0),
             template_hole 1),
           template_app (template_hole 0, template_var 0))
         )),
    ("Simplex_Incremental.solution_simplex'",
     "solution_simplex (Simplex_State ?s) = solution_simplex' ?s",
     template_equation
      (template_app
        (template_hole 2, template_app (template_hole 1, template_var 0)),
       template_app (template_hole 0, template_var 0))),
    ("Simplex_Incremental.init_simplex'",
     "init_simplex ?cs = Simplex_State (init_simplex' ?cs)",
     template_equation
      (template_app (template_hole 2, template_var 0),
       template_app
        (template_hole 1, template_app (template_hole 0, template_var 0)))),
    ("Simplex_Incremental.checkpoint_simplex'",
     "checkpoint_simplex (Simplex_State ?s) =
      Simplex_Checkpoint (checkpoint_simplex' ?s)",
     template_equation
      (template_app
        (template_hole 3, template_app (template_hole 2, template_var 0)),
       template_app
        (template_hole 1, template_app (template_hole 0, template_var 0)))),
    ("Simplex_Incremental.check_simplex'",
     "check_simplex (Simplex_State ?s) =
      map_sum id Simplex_State (check_simplex' ?s)",
     template_equation
      (template_app
        (template_hole 4, template_app (template_hole 3, template_var 0)),
       template_app
        (template_app
          (template_app (template_hole 2, template_hole 1),
           template_hole 3),
         template_app (template_hole 0, template_var 0)))),
    ("Simplex_Incremental.code_lemmas",
     "checkpoint_simplex' (?cs, ?asi_tv, ?s) = checkpoint_s ?s",
     template_equation
      (template_app
        (template_hole 3,
         template_app
          (template_app (template_hole 2, template_var 2),
           template_app
            (template_app (template_hole 1, template_var 1),
             template_var 0))),
       template_app (template_hole 0, template_var 0))),
    ("Simplex_Incremental.backtrack_simplex'",
     "backtrack_simplex (Simplex_Checkpoint ?c) (Simplex_State ?s) =
      Simplex_State (backtrack_simplex' ?c ?s)",
     template_equation
      (template_app
        (template_app
          (template_hole 3, template_app (template_hole 2, template_var 1)),
         template_app (template_hole 1, template_var 0)),
       template_app
        (template_hole 1,
         template_app
          (template_app (template_hole 0, template_var 1),
           template_var 0)))),
    ("Simplex_Incremental.checked_invariant_simplex",
     "checked_simplex ?cs ?J ?s ==> invariant_simplex ?cs ?J ?s",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 1, template_var 2),
                template_var 1),
              template_var 0)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 0, template_var 2),
               template_var 1),
             template_var 0)
           ))),
    ("Simplex_Incremental.assert_simplex'",
     "assert_simplex ?i (Simplex_State ?s) =
      map_sum id Simplex_State (assert_simplex' ?i ?s)",
     template_equation
      (template_app
        (template_app (template_hole 4, template_var 1),
         template_app (template_hole 3, template_var 0)),
       template_app
        (template_app
          (template_app (template_hole 2, template_hole 1),
           template_hole 3),
         template_app
          (template_app (template_hole 0, template_var 1),
           template_var 0)))),
    ("Simplex_Incremental.list_map_to_fun_create_map",
     "set (list_map_to_fun (create_map ?ias) ?i) =
      set ?ias Int {?i} \<times> UNIV",
     template_equation
      (template_app
        (template_hole 7,
         template_app
          (template_app
            (template_hole 6,
             template_app (template_hole 5, template_var 1)),
           template_var 0)),
       template_app
        (template_app
          (template_hole 4, template_app (template_hole 7, template_var 1)),
         template_app
          (template_app
            (template_hole 3,
             template_app
              (template_app (template_hole 2, template_var 0),
               template_hole 1)),
           t_empty)))),
    ("Simplex_Incremental.code_lemmas",
     "backtrack_simplex' ?c (?cs, ?asi_tv, ?s) =
      (?cs, ?asi_tv, backtrack_s ?c ?s)",
     template_equation
      (template_app
        (template_app (template_hole 3, template_var 3),
         template_app
          (template_app (template_hole 2, template_var 2),
           template_app
            (template_app (template_hole 1, template_var 1),
             template_var 0))),
       template_app
        (template_app (template_hole 2, template_var 2),
         template_app
          (template_app (template_hole 1, template_var 1),
           template_app
            (template_app (template_hole 0, template_var 3),
             template_var 0))))),
    ("Simplex_Incremental.check_simplex_ok",
     "[| invariant_simplex ?cs ?J ?s; check_simplex ?s = Inr ?s' |]
      ==> checked_simplex ?cs ?J ?s'",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 4, template_var 3),
                template_var 2),
              template_var 1)
            ),
        template_equation
         (template_app (template_hole 2, template_var 1),
          template_app (template_hole 1, template_var 0))],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 0, template_var 3),
               template_var 2),
             template_var 0)
           ))),
    ("Simplex_Incremental.solution_simplex",
     "[| checked_simplex ?cs ?J ?s; solution_simplex ?s = ?v |]
      ==> (?J, ?v) \<Turnstile>\<^sub>i\<^sub>c\<^sub>s set ?cs",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 5, template_var 3),
                template_var 2),
              template_var 1)
            ),
        template_equation
         (template_app (template_hole 3, template_var 1), template_var 0)],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 2,
               template_app
                (template_app (template_hole 1, template_var 2),
                 template_var 0)),
             template_app (template_hole 0, template_var 3))
           ))),
    ("Simplex_Incremental.code_lemmas",
     "solution_simplex' (?cs, (?asi, ?tv), ?s) =
      \<langle>from_ns (solution_nsc \<V> ((?asi, ?tv), ?s)) ?cs\<rangle>",
     template_equation
      (template_app
        (template_hole 7,
         template_app
          (template_app (template_hole 6, template_var 3),
           template_app
            (template_app
              (template_hole 5,
               template_app
                (template_app (template_hole 4, template_var 2),
                 template_var 1)),
             template_var 0))),
       template_app
        (template_hole 3,
         template_app
          (template_app
            (template_hole 2,
             template_app
              (template_app (template_hole 1, template_hole 0),
               template_app
                (template_app
                  (template_hole 5,
                   template_app
                    (template_app (template_hole 4, template_var 2),
                     template_var 1)),
                 template_var 0))),
           template_var 3)))),
    ("Simplex_Incremental.code_lemmas",
     "check_simplex' (?cs, ?asi_tv, ?s) =
      (case check_s ?s of Inl y => Inl y
       | Inr s' => Inr (?cs, ?asi_tv, s'))",
     template_equation
      (template_app
        (template_hole 6,
         template_app
          (template_app (template_hole 5, template_var 2),
           template_app
            (template_app (template_hole 4, template_var 1),
             template_var 0))),
       template_app
        (template_app (template_app (template_hole 3, t_empty), t_empty),
         template_app (template_hole 0, template_var 0)))),
    ("Simplex_Incremental.assert_simplex_ok",
     "[| invariant_simplex ?cs ?J ?s; assert_simplex ?j ?s = Inr ?s' |]
      ==> invariant_simplex ?cs (insert ?j ?J) ?s'",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 4, template_var 4),
                template_var 3),
              template_var 2)
            ),
        template_equation
         (template_app
           (template_app (template_hole 2, template_var 1), template_var 2),
          template_app (template_hole 1, template_var 0))],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 4, template_var 4),
               template_app
                (template_app (template_hole 0, template_var 1),
                 template_var 3)),
             template_var 0)
           ))),
    ("Simplex_Incremental.assert_all_simplex_ok",
     "[| invariant_simplex ?cs ?J ?s; assert_all_simplex ?K ?s = Inr ?s' |]
      ==> invariant_simplex ?cs (?J Un set ?K) ?s'",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 5, template_var 4),
                template_var 3),
              template_var 2)
            ),
        template_equation
         (template_app
           (template_app (template_hole 3, template_var 1), template_var 2),
          template_app (template_hole 2, template_var 0))],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 5, template_var 4),
               template_app
                (template_app (template_hole 1, template_var 3),
                 template_app (template_hole 0, template_var 1))),
             template_var 0)
           ))),
    ("Simplex_Incremental.check_simplex_unsat",
     "[| invariant_simplex ?cs ?J ?s; check_simplex ?s = Inl ?I |]
      ==> set ?I <= ?J & minimal_unsat_core (set ?I) ?cs",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 7, template_var 3),
                template_var 2),
              template_var 1)
            ),
        template_equation
         (template_app (template_hole 5, template_var 1),
          template_app (template_hole 4, template_var 0))],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 3,
               template_app
                (template_app
                  (template_hole 2,
                   template_app (template_hole 1, template_var 0)),
                 template_var 2)),
             template_app
              (template_app
                (template_hole 0,
                 template_app (template_hole 1, template_var 0)),
               template_var 3))
           ))),
    ("Simplex_Incremental.assert_simplex_unsat",
     "[| invariant_simplex ?cs ?J ?s; assert_simplex ?j ?s = Inl ?I |]
      ==> set ?I <= insert ?j ?J & minimal_unsat_core (set ?I) ?cs",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 8, template_var 4),
                template_var 3),
              template_var 2)
            ),
        template_equation
         (template_app
           (template_app (template_hole 6, template_var 1), template_var 2),
          template_app (template_hole 5, template_var 0))],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 4,
               template_app
                (template_app
                  (template_hole 3,
                   template_app (template_hole 2, template_var 0)),
                 template_app
                  (template_app (template_hole 1, template_var 1),
                   template_var 3))),
             template_app
              (template_app
                (template_hole 0,
                 template_app (template_hole 2, template_var 0)),
               template_var 4))
           ))),
    ("Simplex_Incremental.assert_all_simplex_unsat",
     "[| invariant_simplex ?cs ?J ?s; assert_all_simplex ?K ?s = Inl ?I |]
      ==> set ?I <= set ?K Un ?J & minimal_unsat_core (set ?I) ?cs",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 8, template_var 4),
                template_var 3),
              template_var 2)
            ),
        template_equation
         (template_app
           (template_app (template_hole 6, template_var 1), template_var 2),
          template_app (template_hole 5, template_var 0))],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 4,
               template_app
                (template_app
                  (template_hole 3,
                   template_app (template_hole 2, template_var 0)),
                 template_app
                  (template_app
                    (template_hole 1,
                     template_app (template_hole 2, template_var 1)),
                   template_var 3))),
             template_app
              (template_app
                (template_hole 0,
                 template_app (template_hole 2, template_var 0)),
               template_var 4))
           ))),
    ("Simplex_Incremental.code_lemmas",
     "init_simplex' ?cs =
      (let tons_cs = to_ns ?cs
       in (map snd tons_cs,
           case preprocess tons_cs of
           (t, as, trans_v, ui) =>
             ((create_map as, trans_v, remdups ui), init_state t)))",
     template_equation
      (template_app (template_hole 15, template_var 0),
       template_app
        (template_app
          (template_hole 14,
           template_app (template_hole 13, template_var 0)),
         t_empty))),
    ("Simplex_Incremental.case_sum_case_sum",
     "(case case ?x of Inl y => Inl (?f1.0 y) | Inr z => Inr (?f2.0 z) of
       Inl y => Inl (?g1.0 y) | Inr z => Inr (?g2.0 z)) =
      (case ?x of Inl y => Inl (?g1.0 (?f1.0 y))
       | Inr z => Inr (?g2.0 (?f2.0 z)))",
     template_equation
      (template_app
        (template_app (template_app (template_hole 6, t_empty), t_empty),
         template_app
          (template_app (template_app (template_hole 3, t_empty), t_empty),
           template_var 0)),
       template_app
        (template_app (template_app (template_hole 0, t_empty), t_empty),
         template_var 0))),
    ("Simplex_Incremental.backtrack_simplex",
     "[| checked_simplex ?cs ?J ?s; checkpoint_simplex ?s = ?c;
         invariant_simplex ?cs ?K ?s'; backtrack_simplex ?c ?s' = ?s'';
         ?J <= ?K |]
      ==> invariant_simplex ?cs ?J ?s''",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 6, template_var 6),
                template_var 5),
              template_var 4)
            ),
        template_equation
         (template_app (template_hole 4, template_var 4), template_var 3),
        template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 3, template_var 6),
                template_var 2),
              template_var 1)
            ),
        template_equation
         (template_app
           (template_app (template_hole 1, template_var 3), template_var 1),
          template_var 0),
        template_inequation (less_equals, template_var 5, template_var 2)],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 3, template_var 6),
               template_var 5),
             template_var 0)
           ))),
    ("Simplex_Incremental.code_lemmas",
     "assert_simplex' ?i (?cs, (?asi, ?tv, ?ui), ?s) =
      (case if ?i : set ?ui then Inl [?i]
            else case assert_all_s (list_map_to_fun ?asi ?i) ?s of
                 Inl x => Inl x | Inr s' => Inr ((?asi, ?tv, ?ui), s') of
       Inl x => Inl x | Inr s' => Inr (?cs, s'))",
     template_equation
      (template_app
        (template_app (template_hole 17, template_var 5),
         template_app
          (template_app (template_hole 16, template_var 4),
           template_app
            (template_app
              (template_hole 15,
               template_app
                (template_app (template_hole 14, template_var 3),
                 template_app
                  (template_app (template_hole 13, template_var 2),
                   template_var 1))),
             template_var 0))),
       template_app
        (template_app
          (template_app (template_hole 12, template_hole 11), t_empty),
         template_app
          (template_app
            (template_app
              (template_hole 9,
               template_app
                (template_app (template_hole 8, template_var 5),
                 template_app (template_hole 7, template_var 1))),
             template_app
              (template_hole 6,
               template_app
                (template_app (template_hole 5, template_var 5),
                 template_hole 4))),
           template_app
            (template_app
              (template_app (template_hole 3, template_hole 6), t_empty),
             template_app
              (template_app
                (template_hole 1,
                 template_app
                  (template_app (template_hole 0, template_var 3),
                   template_var 5)),
               template_var 0))))))]:
   (string * thm * template) list
### theory "Draft.Simplex_IncrementalTemplates"
### 0.766s elapsed time, 1.723s cpu time, 0.161s GC time
"([1, 4, 3],
  [(''x_'', 0, ''='', 8 / 3), (''x_'', 1, ''='', 3),
   (''x_'', 2, ''='', 3 / 2), (''x_'', 3, ''='', 5 / 6)])"
  :: "int list * (char list * nat * char list * rat) list"
val it = (): unit
