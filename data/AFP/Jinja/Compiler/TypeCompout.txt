Loading theory "Draft.Auxiliary" (required by "Draft.TypeCompMoreTemplates" via "Draft.TypeComp" via "Draft.Compiler" via "Draft.Correctness1" via "Draft.J1WellForm" via "Draft.JWellForm" via "Draft.WellForm" via "Draft.TypeRel" via "Draft.Decl" via "Draft.Type")
Loading theory "HOL-Library.Function_Algebras" (required by "Draft.TypeCompMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
Loading theory "HOL-Library.Nat_Bijection" (required by "Draft.TypeCompMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.Stream")
Loading theory "HOL-Library.Set_Algebras" (required by "Draft.TypeCompMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
instantiation
  set :: (plus) plus
  plus_set == plus :: 'a set => 'a set => 'a set
instantiation
  fun :: (type, plus) plus
  plus_fun == plus :: ('a => 'b) => ('a => 'b) => 'a => 'b
### Ignoring duplicate safe elimination (elim!)
### [| ?x # ?xs = map ?f ?ys;
###    EX z zs. ?ys = z # zs & ?x = ?f z & ?xs = map ?f zs ==> PROP ?W |]
### ==> PROP ?W
### Ignoring duplicate safe elimination (elim!)
### [| ?x # ?xs = map ?f ?ys;
###    EX z zs. ?ys = z # zs & ?x = ?f z & ?xs = map ?f zs ==> PROP ?W |]
### ==> PROP ?W
instantiation
  set :: (times) times
  times_set == times :: 'a set => 'a set => 'a set
instantiation
  fun :: (type, zero) zero
  zero_fun == zero_class.zero :: 'a => 'b
instantiation
  set :: (zero) zero
  zero_set == zero_class.zero :: 'a set
instantiation
  fun :: (type, times) times
  times_fun == times :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  set :: (one) one
  one_set == one_class.one :: 'a set
instantiation
  fun :: (type, one) one
  one_fun == one_class.one :: 'a => 'b
### theory "Draft.Auxiliary"
### 0.104s elapsed time, 0.434s cpu time, 0.033s GC time
Loading theory "Draft.Type" (required by "Draft.TypeCompMoreTemplates" via "Draft.TypeComp" via "Draft.Compiler" via "Draft.Correctness1" via "Draft.J1WellForm" via "Draft.JWellForm" via "Draft.WellForm" via "Draft.TypeRel" via "Draft.Decl")
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
### theory "HOL-Library.Function_Algebras"
### 0.145s elapsed time, 0.598s cpu time, 0.033s GC time
Loading theory "HOL-Library.Sublist" (required by "Draft.TypeCompMoreTemplates" via "Draft.TypeComp" via "Draft.Compiler" via "Draft.Correctness2")
### theory "HOL-Library.Set_Algebras"
### 0.199s elapsed time, 0.816s cpu time, 0.033s GC time
Loading theory "HOL-Library.Transitive_Closure_Table" (required by "Draft.TypeCompMoreTemplates" via "Draft.TypeComp" via "Draft.Compiler" via "Draft.Correctness1" via "Draft.J1WellForm" via "Draft.JWellForm" via "Draft.WellForm" via "Draft.TypeRel")
Found termination order: "size_list size <*mlex*> {}"
Proofs for inductive predicate(s) "rtrancl_path"
  Proving monotonicity ...
Proofs for inductive predicate(s) "rtrancl_tab"
  Proving monotonicity ...
### theory "HOL-Library.Nat_Bijection"
### 0.383s elapsed time, 1.536s cpu time, 0.129s GC time
Loading theory "HOL-Library.Stream" (required by "Draft.TypeCompMoreTemplates" via "Draft.ExtrEqs")
consts
  prefixes :: "'a list => 'a list list"
### theory "Draft.Type"
### 0.392s elapsed time, 1.540s cpu time, 0.161s GC time
Loading theory "Draft.Decl" (required by "Draft.TypeCompMoreTemplates" via "Draft.TypeComp" via "Draft.Compiler" via "Draft.Correctness1" via "Draft.J1WellForm" via "Draft.JWellForm" via "Draft.WellForm" via "Draft.TypeRel")
### theory "Draft.Decl"
### 0.053s elapsed time, 0.210s cpu time, 0.000s GC time
Loading theory "HOL-Library.Tree" (required by "Draft.TypeCompMoreTemplates" via "Draft.ExtrEqs" via "Draft.Templates")
### theory "HOL-Library.Transitive_Closure_Table"
### 0.357s elapsed time, 1.402s cpu time, 0.161s GC time
Loading theory "Draft.TypeRel" (required by "Draft.TypeCompMoreTemplates" via "Draft.TypeComp" via "Draft.Compiler" via "Draft.Correctness1" via "Draft.J1WellForm" via "Draft.JWellForm" via "Draft.WellForm")
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
Proofs for inductive predicate(s) "subcls1p"
  Proving monotonicity ...
Proofs for inductive predicate(s) "widen"
  Proving monotonicity ...
consts
  shift :: "'a list => 'a stream => 'a stream"
Proofs for coinductive predicate(s) "streamsp"
  Proving monotonicity ...
Proofs for inductive predicate(s) "Methods"
  Proving monotonicity ...
consts
  suffixes :: "'a list => 'a list list"
consts
  snth :: "'a stream => nat => 'a"
Proofs for inductive predicate(s) "list_emb"
consts
  stake :: "nat => 'a stream => 'a list"
  Proving monotonicity ...
consts
  sdrop :: "nat => 'a stream => 'a stream"
Proofs for inductive predicate(s) "Fields"
  Proving monotonicity ...
consts
  sfilter :: "('a => bool) => 'a stream => 'a stream"
consts
  cycle :: "'a list => 'a stream"
consts
  siterate :: "('a => 'a) => 'a => 'a stream"
consts
  left :: "'a tree => 'a tree"
consts
  right :: "'a tree => 'a tree"
consts
  flat :: "'a list stream => 'a stream"
Found termination order: "size <*mlex*> {}"
### Introduced fixed type variable(s): 'a in "y"
### Introduced fixed type variable(s): 'a in "z"
consts
  sinterleave :: "'a stream => 'a stream => 'a stream"
consts
  szip :: "'a stream => 'b stream => ('a * 'b) stream"
Found termination order: "size <*mlex*> {}"
consts
  smap2 :: "('a => 'b => 'c) => 'a stream => 'b stream => 'c stream"
### theory "HOL-Library.Stream"
### 1.147s elapsed time, 4.344s cpu time, 0.920s GC time
Loading theory "HOL-Library.While_Combinator" (required by "Draft.TypeCompMoreTemplates" via "Draft.TypeComp" via "Draft.BVSpec" via "Draft.Effect" via "Draft.JVM_SemiType" via "Draft.SemiType" via "Draft.Semilattices" via "Draft.Err" via "Draft.Semilat")
Found termination order: "size <*mlex*> {}"
class height = type +
  fixes height :: "'a => nat"
instantiation
  tree :: (type) height
  height_tree == height :: 'a tree => nat
Found termination order: "size <*mlex*> {}"
consts
  sublists :: "'a list => 'a list list"
Found termination order: "size <*mlex*> {}"
Found termination order: "{}"
Found termination order: "size <*mlex*> {}"
### theory "HOL-Library.Sublist"
### 1.646s elapsed time, 6.311s cpu time, 1.087s GC time
Loading theory "HOL-Library.BigO" (required by "Draft.TypeCompMoreTemplates" via "Draft.ExtrEqs")
Found termination order: "{}"
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "{}"
### theory "Draft.TypeRel"
### 1.403s elapsed time, 5.360s cpu time, 0.986s GC time
Loading theory "Draft.Value" (required by "Draft.TypeCompMoreTemplates" via "Draft.TypeComp" via "Draft.Compiler" via "Draft.Correctness1" via "Draft.J1WellForm" via "Draft.JWellForm" via "Draft.WellForm" via "Draft.SystemClasses" via "Draft.Exceptions" via "Draft.Objects")
### theory "HOL-Library.While_Combinator"
### 0.443s elapsed time, 1.742s cpu time, 0.130s GC time
Loading theory "Draft.Semilat" (required by "Draft.TypeCompMoreTemplates" via "Draft.TypeComp" via "Draft.BVSpec" via "Draft.Effect" via "Draft.JVM_SemiType" via "Draft.SemiType" via "Draft.Semilattices" via "Draft.Err")
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
locale Semilat
  fixes A :: "'a set"
    and r :: "'a => 'a => bool"
    and f :: "'a => 'a => 'a"
  assumes "Semilat A r f"
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
### theory "Draft.Semilat"
### 0.306s elapsed time, 1.210s cpu time, 0.118s GC time
Loading theory "Draft.Err" (required by "Draft.TypeCompMoreTemplates" via "Draft.TypeComp" via "Draft.BVSpec" via "Draft.Effect" via "Draft.JVM_SemiType" via "Draft.SemiType" via "Draft.Semilattices")
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
### No equation for constructor "Unit"
### No equation for constructor "Null"
### No equation for constructor "Bool"
### No equation for constructor "Addr"
consts
  the_Intg :: "val => int"
### No equation for constructor "Unit"
### No equation for constructor "Null"
### No equation for constructor "Bool"
### No equation for constructor "Intg"
consts
  the_Addr :: "val => nat"
consts
  default_val :: "ty => val"
### theory "Draft.Value"
### 0.480s elapsed time, 1.888s cpu time, 0.188s GC time
Loading theory "Draft.Objects" (required by "Draft.TypeCompMoreTemplates" via "Draft.TypeComp" via "Draft.Compiler" via "Draft.Correctness1" via "Draft.J1WellForm" via "Draft.JWellForm" via "Draft.WellForm" via "Draft.SystemClasses" via "Draft.Exceptions")
consts
  typeof_h ::
    "(nat => (char list * (char list * char list => val option)) option)
     => val => ty option"
### theory "Draft.Objects"
### 0.159s elapsed time, 0.629s cpu time, 0.078s GC time
Loading theory "Draft.Exceptions" (required by "Draft.TypeCompMoreTemplates" via "Draft.TypeComp" via "Draft.Compiler" via "Draft.Correctness1" via "Draft.J1WellForm" via "Draft.JWellForm" via "Draft.WellForm" via "Draft.SystemClasses")
Found termination order: "size <*mlex*> {}"
### theory "HOL-Library.BigO"
### 0.875s elapsed time, 3.427s cpu time, 0.381s GC time
Loading theory "Draft.JVMState" (required by "Draft.TypeCompMoreTemplates" via "Draft.TypeComp" via "Draft.Compiler" via "Draft.Correctness2" via "Draft.Compiler2" via "Draft.JVMExec" via "Draft.JVMExecInstr" via "Draft.JVMInstructions")
### theory "Draft.JVMState"
### 0.030s elapsed time, 0.118s cpu time, 0.000s GC time
Loading theory "Draft.JVMInstructions" (required by "Draft.TypeCompMoreTemplates" via "Draft.TypeComp" via "Draft.Compiler" via "Draft.Correctness2" via "Draft.Compiler2" via "Draft.JVMExec" via "Draft.JVMExecInstr")
### theory "Draft.Exceptions"
### 0.117s elapsed time, 0.456s cpu time, 0.055s GC time
Loading theory "Draft.Expr" (required by "Draft.TypeCompMoreTemplates" via "Draft.TypeComp" via "Draft.Compiler" via "Draft.Correctness1" via "Draft.J1WellForm" via "Draft.JWellForm" via "Draft.WWellForm")
### No equation for constructor "Err"
consts
  ok_val :: "'a err => 'a"
consts
  strict :: "('a => 'b err) => 'a err => 'b err"
### theory "HOL-Library.Tree"
### 2.281s elapsed time, 8.799s cpu time, 1.367s GC time
Loading theory "Draft.State" (required by "Draft.TypeCompMoreTemplates" via "Draft.TypeComp" via "Draft.Compiler" via "Draft.Correctness1" via "Draft.J1WellForm" via "Draft.JWellForm" via "Draft.DefAss" via "Draft.BigStep")
### theory "Draft.State"
### 0.036s elapsed time, 0.144s cpu time, 0.000s GC time
Loading theory "Draft.SystemClasses" (required by "Draft.TypeCompMoreTemplates" via "Draft.TypeComp" via "Draft.Compiler" via "Draft.Correctness1" via "Draft.J1WellForm" via "Draft.JWellForm" via "Draft.WellForm")
### theory "Draft.SystemClasses"
### 0.072s elapsed time, 0.280s cpu time, 0.063s GC time
Loading theory "Draft.WellForm" (required by "Draft.TypeCompMoreTemplates" via "Draft.TypeComp" via "Draft.Compiler" via "Draft.Correctness1" via "Draft.J1WellForm" via "Draft.JWellForm")
### theory "Draft.Err"
### 0.689s elapsed time, 2.696s cpu time, 0.326s GC time
Loading theory "Draft.Templates" (required by "Draft.TypeCompMoreTemplates" via "Draft.ExtrEqs")
datatype template_term
=
     t_empty
   | template_app of template_term * template_term
   | template_hole of int
   | template_var of int
datatype sign
= equals | greater_equals | greater_than | less_equals | less_than
datatype template
=
     template_bimplication of template * template
   | template_dunno
   | template_equation of template_term * template_term
   | template_implication of template list * template
   | template_inequation of sign * template_term * template_term
   | template_negation of template
   | template_predicate of template_term
constructor t_empty: template_term
constructor template_app: template_term * template_term -> template_term
constructor template_hole: int -> template_term
constructor template_var: int -> template_term
constructor equals: sign
constructor greater_equals: sign
constructor greater_than: sign
constructor less_equals: sign
constructor less_than: sign
constructor template_bimplication: template * template -> template
constructor template_dunno: template
constructor template_equation: template_term * template_term -> template
constructor template_implication: template list * template -> template
constructor template_inequation:
   sign * template_term * template_term -> template
constructor template_negation: template -> template
constructor template_predicate: template_term -> template
val vfs = fn: term -> (indexname * typ) list * (string * typ) list
val indexOf = fn: ''a list -> ''a -> int -> int
val has_eq = fn: term -> bool
val term2template = fn:
   (indexname * typ) list -> (string * typ) list -> term -> template_term
val lemma2predicate = fn: term -> term -> template
val makeTemplatewithContext = fn: term -> term -> template
val lemma2template = fn: term -> template
val thm2template = fn: thm -> template
val tterm2string = fn: template_term -> string
val template2string = fn: template -> string
val t = "height ?t <= size ?t": thm
val th =
   Const ("HOL.Trueprop", "bool => prop") $
     (Const ("Orderings.ord_class.less_eq", "nat => nat => bool") $
       (Const ("Tree.height_class.height", "?'a tree => nat") $
         Var (("t", 0), "?'a tree")) $
       (Const ("Nat.size_class.size", "?'a tree => nat") $
         Var (("t", 0), "?'a tree"))):
   term
### theory "Draft.Templates"
### 0.083s elapsed time, 0.324s cpu time, 0.057s GC time
Loading theory "Draft.Listn" (required by "Draft.TypeCompMoreTemplates" via "Draft.TypeComp" via "Draft.BVSpec" via "Draft.Effect" via "Draft.JVM_SemiType" via "Draft.SemiType" via "Draft.Semilattices")
consts
  coalesce :: "'a err list => 'a list err"
### theory "Draft.WellForm"
### 0.284s elapsed time, 1.112s cpu time, 0.130s GC time
Loading theory "Draft.PCompiler" (required by "Draft.TypeCompMoreTemplates" via "Draft.TypeComp" via "Draft.Compiler" via "Draft.Correctness1" via "Draft.Compiler1")
### theory "Draft.Listn"
### 0.706s elapsed time, 2.593s cpu time, 1.280s GC time
Loading theory "Draft.Opt" (required by "Draft.TypeCompMoreTemplates" via "Draft.TypeComp" via "Draft.BVSpec" via "Draft.Effect" via "Draft.JVM_SemiType" via "Draft.SemiType" via "Draft.Semilattices")
### theory "Draft.PCompiler"
### 0.558s elapsed time, 2.027s cpu time, 1.207s GC time
Loading theory "Draft.Product" (required by "Draft.TypeCompMoreTemplates" via "Draft.TypeComp" via "Draft.BVSpec" via "Draft.Effect" via "Draft.JVM_SemiType" via "Draft.SemiType" via "Draft.Semilattices")
### theory "Draft.Product"
### 0.128s elapsed time, 0.506s cpu time, 0.120s GC time
Loading theory "Draft.ExtrEqs" (required by "Draft.TypeCompMoreTemplates")
### theory "Draft.Opt"
### 0.134s elapsed time, 0.523s cpu time, 0.120s GC time
Loading theory "Draft.Semilattices" (required by "Draft.TypeCompMoreTemplates" via "Draft.TypeComp" via "Draft.BVSpec" via "Draft.Effect" via "Draft.JVM_SemiType" via "Draft.SemiType")
### theory "Draft.Semilattices"
### 0.271s elapsed time, 1.079s cpu time, 0.073s GC time
Loading theory "Draft.SemiType" (required by "Draft.TypeCompMoreTemplates" via "Draft.TypeComp" via "Draft.BVSpec" via "Draft.Effect" via "Draft.JVM_SemiType")
### No equation for constructor "Void"
### No equation for constructor "Boolean"
### No equation for constructor "Integer"
### No equation for constructor "NT"
consts
  the_Class :: "ty => char list"
### theory "Draft.SemiType"
### 0.681s elapsed time, 2.508s cpu time, 1.368s GC time
Loading theory "Draft.JVM_SemiType" (required by "Draft.TypeCompMoreTemplates" via "Draft.TypeComp" via "Draft.BVSpec" via "Draft.Effect")
### theory "Draft.JVMInstructions"
### 2.225s elapsed time, 8.409s cpu time, 3.021s GC time
Loading theory "Draft.JVMExceptions" (required by "Draft.TypeCompMoreTemplates" via "Draft.TypeComp" via "Draft.Compiler" via "Draft.Correctness2" via "Draft.Compiler2" via "Draft.JVMExec")
val eqpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Var (("_dummy_", 2), "?'a"))
       ):
   term Find_Theorems.criterion
val badeqpattern = Pattern (Const ("Pure.eq", "?'a => ?'a => prop")):
   term Find_Theorems.criterion
val undefpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Const ("HOL.undefined", "?'a"))
       ):
   term Find_Theorems.criterion
val thmpattern =
   Pattern
    (Const ("HOL.Trueprop", "bool => prop") $ Var (("_dummy_", 1), "bool")):
   term Find_Theorems.criterion
val badnames =
   ["*nitpick*", "*Nitpick*", "*full_exhaustive*", "*_def*", "Enum.finite*",
    "*Quickcheck*", "ATP*", "*Nunchaku*", "*Code*", "*BNF*", "*SMT*",
    "*.*.*"]:
   string list
val unwanted_names =
   [(false, Name "*nitpick*"), (false, Name "*Nitpick*"),
    (false, Name "*full_exhaustive*"), (false, Name "*_def*"),
    (false, Name "Enum.finite*"), (false, Name "*Quickcheck*"),
    (false, Name "ATP*"), (false, Name "*Nunchaku*"),
    (false, Name "*Code*"), (false, Name "*BNF*"), (false, Name "*SMT*"),
    (false, Name "*.*.*")]:
   (bool * term Find_Theorems.criterion) list
val has_vars = fn: term -> bool
val get_all_eqs = fn: string -> Proof.context -> (string * thm) list
val get_all_thms = fn: string -> Proof.context -> (string * thm) list
val get_noneq_thms = fn: string -> Proof.context -> (string * thm) list
val template_eqs = fn:
   string -> Proof.context -> (string * thm * template) list
val template_thms = fn:
   string -> Proof.context -> (string * thm * template) list
### theory "Draft.ExtrEqs"
### 1.035s elapsed time, 3.923s cpu time, 1.441s GC time
Loading theory "Draft.JVMExecInstr" (required by "Draft.TypeCompMoreTemplates" via "Draft.TypeComp" via "Draft.Compiler" via "Draft.Correctness2" via "Draft.Compiler2" via "Draft.JVMExec")
consts
  match_ex_table ::
    "(char list *
      char list *
      (char list * ty) list * (char list * ty list * ty * 'm) list) list
     => char list
        => nat
           => (nat * nat * char list * nat * nat) list
              => (nat * nat) option"
consts
  find_handler ::
    "(char list *
      char list *
      (char list * ty) list *
      (char list *
       ty list *
       ty *
       nat *
       nat *
       instr list * (nat * nat * char list * nat * nat) list) list) list
     => nat
        => (nat
            => (char list * (char list * char list => val option)) option)
           => (val list * val list * char list * char list * nat) list
              => nat option *
                 (nat
                  => (char list *
                      (char list * char list => val option)) option) *
                 (val list * val list * char list * char list * nat) list"
### theory "Draft.JVM_SemiType"
### 0.283s elapsed time, 1.117s cpu time, 0.112s GC time
Loading theory "List-Index.List_Index" (required by "Draft.TypeCompMoreTemplates" via "Draft.TypeComp" via "Draft.Compiler" via "Draft.Correctness1" via "Draft.Compiler1" via "Draft.Hidden")
### theory "Draft.JVMExceptions"
### 0.233s elapsed time, 0.918s cpu time, 0.112s GC time
Loading theory "Draft.Effect" (required by "Draft.TypeCompMoreTemplates" via "Draft.TypeComp" via "Draft.BVSpec")
consts
  find_index :: "('a => bool) => 'a list => nat"
consts
  exec_instr ::
    "instr
     => (char list *
         char list *
         (char list * ty) list *
         (char list *
          ty list *
          ty *
          nat *
          nat *
          instr list * (nat * nat * char list * nat * nat) list) list) list
        => (nat
            => (char list * (char list * char list => val option)) option)
           => val list
              => val list
                 => char list
                    => char list
                       => nat
                          => (val list *
                              val list * char list * char list * nat) list
                             => nat option *
                                (nat
                                 => (char list *
                                     (char list * char list
=> val option)) option) *
                                (val list *
                                 val list *
                                 char list * char list * nat) list"
locale prog
  fixes
    P :: "(char list *
           char list *
           (char list * ty) list *
           (char list * ty list * ty * 'a) list) list"
locale jvm_method
  fixes
    P :: "(char list *
           char list *
           (char list * ty) list *
           (char list * ty list * ty * 'a) list) list"
    and mxs :: "nat"
    and mxl\<^sub>0 :: "nat"
    and Ts :: "ty list"
    and T\<^sub>r :: "ty"
    and "is" :: "instr list"
    and xt :: "(nat * nat * char list * nat * nat) list"
    and mxl :: "nat"
  defines "mxl == 1 + length Ts + mxl\<^sub>0"
consts
  map_index' :: "nat => (nat => 'a => 'b) => 'a list => 'b list"
consts
  succs :: "instr => ty list * ty err list => nat => nat list"
### Missing patterns in function definition:
### the_class Void = undefined
### the_class Boolean = undefined
### the_class Integer = undefined
### (1 more)
consts
  insert_nth :: "nat => 'a => 'a list => 'a list"
Found termination order: "{}"
### theory "Draft.JVMExecInstr"
### 0.510s elapsed time, 2.004s cpu time, 0.238s GC time
Loading theory "Draft.JVMExec" (required by "Draft.TypeCompMoreTemplates" via "Draft.TypeComp" via "Draft.Compiler" via "Draft.Correctness2" via "Draft.Compiler2")
### Missing patterns in function definition:
### !!vb v ve. eff\<^sub>i (Store vb, v, [], ve) = undefined
### !!vb vc v vf. eff\<^sub>i (Getfield vb vc, v, [], vf) = undefined
### !!vb vc v vf. eff\<^sub>i (Putfield vb vc, v, [], vf) = undefined
### (10 more)
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
### theory "List-Index.List_Index"
### 0.418s elapsed time, 1.641s cpu time, 0.185s GC time
Loading theory "Draft.Hidden" (required by "Draft.TypeCompMoreTemplates" via "Draft.TypeComp" via "Draft.Compiler" via "Draft.Correctness1" via "Draft.Compiler1")
### theory "Draft.Hidden"
### 0.052s elapsed time, 0.208s cpu time, 0.000s GC time
Found termination order: "{}"
Proofs for inductive predicate(s) "exec_1p"
  Proving monotonicity ...
### theory "Draft.JVMExec"
### 0.687s elapsed time, 2.376s cpu time, 0.269s GC time
Found termination order: "{}"
### Ambiguous input (line 81 of "$AFP/Jinja/J/Expr.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_Update" ("_position" fv)
###       ("_updbind"
###         ("\<^const>Expr.exp.FAcc" ("_position" e\<^sub>1) ("_position" F)
###           ("_position" D))
###         ("_position" e\<^sub>2)))
###     ("\<^const>Set.union"
###       ("_applC" ("_position" fv) ("_position" e\<^sub>1))
###       ("_applC" ("_position" fv) ("_position" e\<^sub>2)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" fv)
###       ("\<^const>Expr.exp.FAss" ("_position" e\<^sub>1) ("_position" F)
###         ("_position" D) ("_position" e\<^sub>2)))
###     ("\<^const>Set.union"
###       ("_applC" ("_position" fv) ("_position" e\<^sub>1))
###       ("_applC" ("_position" fv) ("_position" e\<^sub>2)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" fv)
###       ("\<^const>Expr.exp.LAss"
###         ("\<^const>Expr.exp.FAcc" ("_position" e\<^sub>1) ("_position" F)
###           ("_position" D))
###         ("_position" e\<^sub>2)))
###     ("\<^const>Set.union"
###       ("_applC" ("_position" fv) ("_position" e\<^sub>1))
###       ("_applC" ("_position" fv) ("_position" e\<^sub>2)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Found termination order: "{}"
Found termination order: "{}"
consts
  fv :: "char list exp => char list set"
  fvs :: "char list exp list => char list set"
### theory "Draft.Expr"
### 4.805s elapsed time, 16.027s cpu time, 3.822s GC time
Loading theory "Draft.BigStep" (required by "Draft.TypeCompMoreTemplates" via "Draft.TypeComp" via "Draft.Compiler" via "Draft.Correctness1" via "Draft.J1WellForm" via "Draft.JWellForm" via "Draft.DefAss")
Loading theory "Draft.WellType" (required by "Draft.TypeCompMoreTemplates" via "Draft.TypeComp" via "Draft.Compiler" via "Draft.Correctness1" via "Draft.J1WellForm" via "Draft.JWellForm")
Loading theory "Draft.WWellForm" (required by "Draft.TypeCompMoreTemplates" via "Draft.TypeComp" via "Draft.Compiler" via "Draft.Correctness1" via "Draft.J1WellForm" via "Draft.JWellForm")
### Ambiguous input (line 63 of "$AFP/Jinja/J/WellType.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>WT" ("_position" P) ("_position" E) ("_position" e\<^sub>1)
###         ("_applC" ("_position" Class) ("_position" C))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>TypeRel.sees_field" ("_position" P) ("_position" C)
###           ("_position" F) ("_position" T) ("_position" D)))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^fixed>WT" ("_position" P) ("_position" E)
###             ("_position" e\<^sub>2) ("_position" T')))
###         ("_asm"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>TypeRel.widen" ("_position" P) ("_position" T')
###               ("_position" T)))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>WT" ("_position" P) ("_position" E)
###       ("\<^const>Expr.exp.FAss" ("_position" e\<^sub>1) ("_position" F)
###         ("_position" D) ("_position" e\<^sub>2))
###       ("_position" Void))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>WT" ("_position" P) ("_position" E) ("_position" e\<^sub>1)
###         ("_applC" ("_position" Class) ("_position" C))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>TypeRel.sees_field" ("_position" P) ("_position" C)
###           ("_position" F) ("_position" T) ("_position" D)))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^fixed>WT" ("_position" P) ("_position" E)
###             ("_position" e\<^sub>2) ("_position" T')))
###         ("_asm"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>TypeRel.widen" ("_position" P) ("_position" T')
###               ("_position" T)))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>WT" ("_position" P) ("_position" E)
###       ("\<^const>Expr.exp.LAss"
###         ("\<^const>Expr.exp.FAcc" ("_position" e\<^sub>1) ("_position" F)
###           ("_position" D))
###         ("_position" e\<^sub>2))
###       ("_position" Void))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Proofs for inductive predicate(s) "WT", "WTs"
  Proving monotonicity ...
### Ambiguous input (line 83 of "$AFP/Jinja/J/BigStep.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval" ("_position" P) ("_position" e\<^sub>1)
###         ("_position" s\<^sub>0)
###         ("_applC" ("_position" addr) ("_position" a))
###         ("_position" s\<^sub>1)))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^fixed>eval" ("_position" P) ("_position" e\<^sub>2)
###           ("_position" s\<^sub>1)
###           ("_applC" ("_position" Val) ("_position" v))
###           ("_tuple" ("_position" h\<^sub>2)
###             ("_tuple_arg" ("_position" l\<^sub>2)))))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" h\<^sub>2) ("_position" a))
###             ("_applC" ("_position" Some)
###               ("_tuple" ("_position" C) ("_tuple_arg" ("_position" fs))))))
###         ("_asms"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq" ("_position" fs')
###               ("_MapUpd" ("_position" fs)
###                 ("_maplet"
###                   ("_tuple" ("_position" F) ("_tuple_arg" ("_position" D)))
###                   ("_position" v)))))
###           ("_asm"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq" ("_position" h\<^sub>2')
###                 ("_MapUpd" ("_position" h\<^sub>2)
###                   ("_maplet" ("_position" a)
###                     ("_tuple" ("_position" C)
###                       ("_tuple_arg" ("_position" fs'))))))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval" ("_position" P)
###       ("\<^const>Expr.exp.LAss"
###         ("\<^const>Expr.exp.FAcc" ("_position" e\<^sub>1) ("_position" F)
###           ("_position" D))
###         ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0) ("_position" unit)
###       ("_tuple" ("_position" h\<^sub>2')
###         ("_tuple_arg" ("_position" l\<^sub>2))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval" ("_position" P) ("_position" e\<^sub>1)
###         ("_position" s\<^sub>0)
###         ("_applC" ("_position" addr) ("_position" a))
###         ("_position" s\<^sub>1)))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^fixed>eval" ("_position" P) ("_position" e\<^sub>2)
###           ("_position" s\<^sub>1)
###           ("_applC" ("_position" Val) ("_position" v))
###           ("_tuple" ("_position" h\<^sub>2)
###             ("_tuple_arg" ("_position" l\<^sub>2)))))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" h\<^sub>2) ("_position" a))
###             ("_applC" ("_position" Some)
###               ("_tuple" ("_position" C) ("_tuple_arg" ("_position" fs))))))
###         ("_asms"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq" ("_position" fs')
###               ("_MapUpd" ("_position" fs)
###                 ("_maplet"
###                   ("_tuple" ("_position" F) ("_tuple_arg" ("_position" D)))
###                   ("_position" v)))))
###           ("_asm"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq" ("_position" h\<^sub>2')
###                 ("_MapUpd" ("_position" h\<^sub>2)
###                   ("_maplet" ("_position" a)
###                     ("_tuple" ("_position" C)
###                       ("_tuple_arg" ("_position" fs'))))))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval" ("_position" P)
###       ("\<^const>Expr.exp.FAss" ("_position" e\<^sub>1) ("_position" F)
###         ("_position" D) ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0) ("_position" unit)
###       ("_tuple" ("_position" h\<^sub>2')
###         ("_tuple_arg" ("_position" l\<^sub>2))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 88 of "$AFP/Jinja/J/BigStep.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval" ("_position" P) ("_position" e\<^sub>1)
###         ("_position" s\<^sub>0) ("_position" null) ("_position" s\<^sub>1)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^fixed>eval" ("_position" P) ("_position" e\<^sub>2)
###           ("_position" s\<^sub>1)
###           ("_applC" ("_position" Val) ("_position" v))
###           ("_position" s\<^sub>2)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval" ("_position" P)
###       ("\<^const>Expr.exp.LAss"
###         ("\<^const>Expr.exp.FAcc" ("_position" e\<^sub>1) ("_position" F)
###           ("_position" D))
###         ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0)
###       ("_applC" ("_position" THROW) ("_position" NullPointer))
###       ("_position" s\<^sub>2))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval" ("_position" P) ("_position" e\<^sub>1)
###         ("_position" s\<^sub>0) ("_position" null) ("_position" s\<^sub>1)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^fixed>eval" ("_position" P) ("_position" e\<^sub>2)
###           ("_position" s\<^sub>1)
###           ("_applC" ("_position" Val) ("_position" v))
###           ("_position" s\<^sub>2)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval" ("_position" P)
###       ("\<^const>Expr.exp.FAss" ("_position" e\<^sub>1) ("_position" F)
###         ("_position" D) ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0)
###       ("_applC" ("_position" THROW) ("_position" NullPointer))
###       ("_position" s\<^sub>2))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 92 of "$AFP/Jinja/J/BigStep.thy") produces 2 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval" ("_position" P) ("_position" e\<^sub>1)
###       ("_position" s\<^sub>0)
###       ("_applC" ("_position" throw) ("_position" e'))
###       ("_position" s\<^sub>1)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval" ("_position" P)
###       ("\<^const>Expr.exp.LAss"
###         ("\<^const>Expr.exp.FAcc" ("_position" e\<^sub>1) ("_position" F)
###           ("_position" D))
###         ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0)
###       ("_applC" ("_position" throw) ("_position" e'))
###       ("_position" s\<^sub>1))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval" ("_position" P) ("_position" e\<^sub>1)
###       ("_position" s\<^sub>0)
###       ("_applC" ("_position" throw) ("_position" e'))
###       ("_position" s\<^sub>1)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval" ("_position" P)
###       ("\<^const>Expr.exp.FAss" ("_position" e\<^sub>1) ("_position" F)
###         ("_position" D) ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0)
###       ("_applC" ("_position" throw) ("_position" e'))
###       ("_position" s\<^sub>1))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "Draft.WWellForm"
### 0.169s elapsed time, 0.671s cpu time, 0.000s GC time
### Ambiguous input (line 96 of "$AFP/Jinja/J/BigStep.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval" ("_position" P) ("_position" e\<^sub>1)
###         ("_position" s\<^sub>0) ("_applC" ("_position" Val) ("_position" v))
###         ("_position" s\<^sub>1)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^fixed>eval" ("_position" P) ("_position" e\<^sub>2)
###           ("_position" s\<^sub>1)
###           ("_applC" ("_position" throw) ("_position" e'))
###           ("_position" s\<^sub>2)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval" ("_position" P)
###       ("\<^const>Expr.exp.LAss"
###         ("\<^const>Expr.exp.FAcc" ("_position" e\<^sub>1) ("_position" F)
###           ("_position" D))
###         ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0)
###       ("_applC" ("_position" throw) ("_position" e'))
###       ("_position" s\<^sub>2))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval" ("_position" P) ("_position" e\<^sub>1)
###         ("_position" s\<^sub>0) ("_applC" ("_position" Val) ("_position" v))
###         ("_position" s\<^sub>1)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^fixed>eval" ("_position" P) ("_position" e\<^sub>2)
###           ("_position" s\<^sub>1)
###           ("_applC" ("_position" throw) ("_position" e'))
###           ("_position" s\<^sub>2)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval" ("_position" P)
###       ("\<^const>Expr.exp.FAss" ("_position" e\<^sub>1) ("_position" F)
###         ("_position" D) ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0)
###       ("_applC" ("_position" throw) ("_position" e'))
###       ("_position" s\<^sub>2))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 119 of "$AFP/Jinja/J/BigStep.thy") produces 4 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval" ("_position" P) ("_position" e\<^sub>0)
###       ("_tuple" ("_position" h\<^sub>0)
###         ("_tuple_arg"
###           ("_Update" ("_position" l\<^sub>0)
###             ("_updbind" ("_position" V) ("_position" None)))))
###       ("_position" e\<^sub>1)
###       ("_tuple" ("_position" h\<^sub>1)
###         ("_tuple_arg" ("_position" l\<^sub>1)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval" ("_position" P)
###       ("\<^const>Expr.exp.Block" ("_position" V) ("_position" T)
###         ("_position" e\<^sub>0))
###       ("_tuple" ("_position" h\<^sub>0)
###         ("_tuple_arg" ("_position" l\<^sub>0)))
###       ("_position" e\<^sub>1)
###       ("_tuple" ("_position" h\<^sub>1)
###         ("_tuple_arg"
###           ("_applC" ("_position" l\<^sub>1)
###             ("\<^const>Expr.exp.LAss" ("_position" V)
###               ("_applC" ("_position" l\<^sub>0) ("_position" V)))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval" ("_position" P) ("_position" e\<^sub>0)
###       ("_tuple" ("_position" h\<^sub>0)
###         ("_tuple_arg"
###           ("_applC" ("_position" l\<^sub>0)
###             ("\<^const>Expr.exp.LAss" ("_position" V) ("_position" None)))))
###       ("_position" e\<^sub>1)
###       ("_tuple" ("_position" h\<^sub>1)
###         ("_tuple_arg" ("_position" l\<^sub>1)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval" ("_position" P)
###       ("\<^const>Expr.exp.Block" ("_position" V) ("_position" T)
###         ("_position" e\<^sub>0))
###       ("_tuple" ("_position" h\<^sub>0)
###         ("_tuple_arg" ("_position" l\<^sub>0)))
###       ("_position" e\<^sub>1)
###       ("_tuple" ("_position" h\<^sub>1)
###         ("_tuple_arg"
###           ("_applC" ("_position" l\<^sub>1)
###             ("\<^const>Expr.exp.LAss" ("_position" V)
###               ("_applC" ("_position" l\<^sub>0) ("_position" V)))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval" ("_position" P) ("_position" e\<^sub>0)
###       ("_tuple" ("_position" h\<^sub>0)
###         ("_tuple_arg"
###           ("_Update" ("_position" l\<^sub>0)
###             ("_updbind" ("_position" V) ("_position" None)))))
###       ("_position" e\<^sub>1)
###       ("_tuple" ("_position" h\<^sub>1)
###         ("_tuple_arg" ("_position" l\<^sub>1)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval" ("_position" P)
###       ("\<^const>Expr.exp.Block" ("_position" V) ("_position" T)
###         ("_position" e\<^sub>0))
###       ("_tuple" ("_position" h\<^sub>0)
###         ("_tuple_arg" ("_position" l\<^sub>0)))
###       ("_position" e\<^sub>1)
###       ("_tuple" ("_position" h\<^sub>1)
###         ("_tuple_arg"
###           ("_Update" ("_position" l\<^sub>1)
###             ("_updbind" ("_position" V)
###               ("_applC" ("_position" l\<^sub>0) ("_position" V)))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval" ("_position" P) ("_position" e\<^sub>0)
###       ("_tuple" ("_position" h\<^sub>0)
###         ("_tuple_arg"
###           ("_applC" ("_position" l\<^sub>0)
###             ("\<^const>Expr.exp.LAss" ("_position" V) ("_position" None)))))
###       ("_position" e\<^sub>1)
###       ("_tuple" ("_position" h\<^sub>1)
###         ("_tuple_arg" ("_position" l\<^sub>1)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval" ("_position" P)
###       ("\<^const>Expr.exp.Block" ("_position" V) ("_position" T)
###         ("_position" e\<^sub>0))
###       ("_tuple" ("_position" h\<^sub>0)
###         ("_tuple_arg" ("_position" l\<^sub>0)))
###       ("_position" e\<^sub>1)
###       ("_tuple" ("_position" h\<^sub>1)
###         ("_tuple_arg"
###           ("_Update" ("_position" l\<^sub>1)
###             ("_updbind" ("_position" V)
###               ("_applC" ("_position" l\<^sub>0) ("_position" V)))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 175 of "$AFP/Jinja/J/BigStep.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval" ("_position" P) ("_position" e\<^sub>1)
###         ("_position" s\<^sub>0)
###         ("_applC" ("_position" Throw) ("_position" a))
###         ("_tuple" ("_position" h\<^sub>1)
###           ("_tuple_arg" ("_position" l\<^sub>1)))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq"
###           ("_applC" ("_position" h\<^sub>1) ("_position" a))
###           ("_applC" ("_position" Some)
###             ("_tuple" ("_position" D) ("_tuple_arg" ("_position" fs))))))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>TypeRel.subcls" ("_position" P) ("_position" D)
###             ("_position" C)))
###         ("_asm"
###           ("\<^const>HOL.Trueprop"
###             ("\<^fixed>eval" ("_position" P) ("_position" e\<^sub>2)
###               ("_tuple" ("_position" h\<^sub>1)
###                 ("_tuple_arg"
###                   ("_MapUpd" ("_position" l\<^sub>1)
###                     ("_maplet" ("_position" V)
###                       ("_applC" ("_position" Addr) ("_position" a))))))
###               ("_position" e\<^sub>2')
###               ("_tuple" ("_position" h\<^sub>2)
###                 ("_tuple_arg" ("_position" l\<^sub>2)))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval" ("_position" P)
###       ("\<^const>Expr.exp.TryCatch" ("_position" e\<^sub>1) ("_position" C)
###         ("_position" V) ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0) ("_position" e\<^sub>2')
###       ("_tuple" ("_position" h\<^sub>2)
###         ("_tuple_arg"
###           ("_applC" ("_position" l\<^sub>2)
###             ("\<^const>Expr.exp.LAss" ("_position" V)
###               ("_applC" ("_position" l\<^sub>1) ("_position" V)))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval" ("_position" P) ("_position" e\<^sub>1)
###         ("_position" s\<^sub>0)
###         ("_applC" ("_position" Throw) ("_position" a))
###         ("_tuple" ("_position" h\<^sub>1)
###           ("_tuple_arg" ("_position" l\<^sub>1)))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq"
###           ("_applC" ("_position" h\<^sub>1) ("_position" a))
###           ("_applC" ("_position" Some)
###             ("_tuple" ("_position" D) ("_tuple_arg" ("_position" fs))))))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>TypeRel.subcls" ("_position" P) ("_position" D)
###             ("_position" C)))
###         ("_asm"
###           ("\<^const>HOL.Trueprop"
###             ("\<^fixed>eval" ("_position" P) ("_position" e\<^sub>2)
###               ("_tuple" ("_position" h\<^sub>1)
###                 ("_tuple_arg"
###                   ("_MapUpd" ("_position" l\<^sub>1)
###                     ("_maplet" ("_position" V)
###                       ("_applC" ("_position" Addr) ("_position" a))))))
###               ("_position" e\<^sub>2')
###               ("_tuple" ("_position" h\<^sub>2)
###                 ("_tuple_arg" ("_position" l\<^sub>2)))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval" ("_position" P)
###       ("\<^const>Expr.exp.TryCatch" ("_position" e\<^sub>1) ("_position" C)
###         ("_position" V) ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0) ("_position" e\<^sub>2')
###       ("_tuple" ("_position" h\<^sub>2)
###         ("_tuple_arg"
###           ("_Update" ("_position" l\<^sub>2)
###             ("_updbind" ("_position" V)
###               ("_applC" ("_position" l\<^sub>1) ("_position" V)))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 119 of "$AFP/Jinja/J/WellType.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>WellType.WTs" ("_position" P) ("_position" E)
###       ("\<^const>List.list.Cons" ("_position" e) ("_position" es))
###       ("\<^const>List.list.Cons" ("_position" T) ("_position" Ts)))
###     ("\<^const>WellType.WT" ("_position" P) ("_position" E) ("_position" e)
###       ("\<^const>HOL.conj" ("_position" T)
###         ("\<^const>WellType.WTs" ("_position" P) ("_position" E)
###           ("_position" es) ("_position" Ts))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>WellType.WTs" ("_position" P) ("_position" E)
###       ("\<^const>List.list.Cons" ("_position" e) ("_position" es))
###       ("\<^const>List.list.Cons" ("_position" T) ("_position" Ts)))
###     ("\<^const>HOL.conj"
###       ("\<^const>WellType.WT" ("_position" P) ("_position" E)
###         ("_position" e) ("_position" T))
###       ("\<^const>WellType.WTs" ("_position" P) ("_position" E)
###         ("_position" es) ("_position" Ts)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 122 of "$AFP/Jinja/J/WellType.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>WellType.WTs" ("_position" P) ("_position" E)
###       ("\<^const>List.list.Cons" ("_position" e) ("_position" es))
###       ("_position" Ts))
###     ("\<^const>HOL.Ex_binder" ("_idts" ("_position" U) ("_position" Us))
###       ("\<^const>HOL.conj"
###         ("\<^const>HOL.eq" ("_position" Ts)
###           ("\<^const>List.list.Cons" ("_position" U) ("_position" Us)))
###         ("\<^const>HOL.conj"
###           ("\<^const>WellType.WT" ("_position" P) ("_position" E)
###             ("_position" e) ("_position" U))
###           ("\<^const>WellType.WTs" ("_position" P) ("_position" E)
###             ("_position" es) ("_position" Us)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>WellType.WTs" ("_position" P) ("_position" E)
###       ("\<^const>List.list.Cons" ("_position" e) ("_position" es))
###       ("_position" Ts))
###     ("\<^const>HOL.Ex_binder" ("_idts" ("_position" U) ("_position" Us))
###       ("\<^const>HOL.conj"
###         ("\<^const>HOL.eq" ("_position" Ts)
###           ("\<^const>List.list.Cons" ("_position" U) ("_position" Us)))
###         ("\<^const>WellType.WT" ("_position" P) ("_position" E)
###           ("_position" e)
###           ("\<^const>HOL.conj" ("_position" U)
###             ("\<^const>WellType.WTs" ("_position" P) ("_position" E)
###               ("_position" es) ("_position" Us))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Proofs for inductive predicate(s) "eval", "evals"
### Ambiguous input (line 126 of "$AFP/Jinja/J/WellType.thy") produces 2 parse trees:
### ("\<^const>Pure.all_binder" ("_position" Ts)
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("\<^const>WellType.WTs" ("_position" P) ("_position" E)
###         ("\<^const>List.append" ("_position" es\<^sub>1)
###           ("_position" es\<^sub>2))
###         ("_position" Ts))
###       ("\<^const>HOL.Ex_binder"
###         ("_idts" ("_position" Ts\<^sub>1) ("_position" Ts\<^sub>2))
###         ("\<^const>HOL.conj"
###           ("\<^const>HOL.eq" ("_position" Ts)
###             ("\<^const>List.append" ("_position" Ts\<^sub>1)
###               ("_position" Ts\<^sub>2)))
###           ("\<^const>HOL.conj"
###             ("\<^const>WellType.WTs" ("_position" P) ("_position" E)
###               ("_position" es\<^sub>1) ("_position" Ts\<^sub>1))
###             ("\<^const>WellType.WTs" ("_position" P) ("_position" E)
###               ("_position" es\<^sub>2) ("_position" Ts\<^sub>2))))))))
### ("\<^const>Pure.all_binder" ("_position" Ts)
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("\<^const>WellType.WTs" ("_position" P) ("_position" E)
###         ("\<^const>List.append" ("_position" es\<^sub>1)
###           ("_position" es\<^sub>2))
###         ("_position" Ts))
###       ("\<^const>HOL.Ex_binder"
###         ("_idts" ("_position" Ts\<^sub>1) ("_position" Ts\<^sub>2))
###         ("\<^const>HOL.conj"
###           ("\<^const>HOL.eq" ("_position" Ts)
###             ("\<^const>List.append" ("_position" Ts\<^sub>1)
###               ("_position" Ts\<^sub>2)))
###           ("\<^const>WellType.WTs" ("_position" P) ("_position" E)
###             ("_position" es\<^sub>1)
###             ("\<^const>HOL.conj" ("_position" Ts\<^sub>1)
###               ("\<^const>WellType.WTs" ("_position" P) ("_position" E)
###                 ("_position" es\<^sub>2) ("_position" Ts\<^sub>2)))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 147 of "$AFP/Jinja/J/WellType.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>WellType.WT" ("_position" P) ("_position" E)
###       ("_applC" ("_position" Val) ("_position" v)) ("_position" T))
###     ("\<^const>HOL.eq" ("_applC" ("_position" typeof) ("_position" v))
###       ("_applC" ("_position" Some) ("_position" T)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>WellType.WT" ("_position" P) ("_position" E)
###     ("_applC" ("_position" Val) ("_position" v))
###     ("\<^const>HOL.eq" ("_position" T)
###       ("\<^const>HOL.eq" ("_applC" ("_position" typeof) ("_position" v))
###         ("_applC" ("_position" Some) ("_position" T))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ignoring duplicate safe introduction (intro!)
### typeof ?v = \<lfloor>?T\<rfloor> ==> ?P,?E \<turnstile> Val ?v :: ?T
### Ignoring duplicate safe introduction (intro!)
### typeof ?v = \<lfloor>?T\<rfloor> ==> ?P,?E \<turnstile> Val ?v :: ?T
### Ambiguous input (line 150 of "$AFP/Jinja/J/WellType.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>WellType.WT" ("_position" P) ("_position" E)
###       ("_applC" ("_position" Var) ("_position" V)) ("_position" T))
###     ("\<^const>HOL.eq" ("_applC" ("_position" E) ("_position" V))
###       ("_applC" ("_position" Some) ("_position" T)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>WellType.WT" ("_position" P) ("_position" E)
###     ("_applC" ("_position" Var) ("_position" V))
###     ("\<^const>HOL.eq" ("_position" T)
###       ("\<^const>HOL.eq" ("_applC" ("_position" E) ("_position" V))
###         ("_applC" ("_position" Some) ("_position" T))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ignoring duplicate safe introduction (intro!)
### ?E ?V = \<lfloor>?T\<rfloor> ==> ?P,?E \<turnstile> Var ?V :: ?T
### Ignoring duplicate safe introduction (intro!)
### ?E ?V = \<lfloor>?T\<rfloor> ==> ?P,?E \<turnstile> Var ?V :: ?T
### Ambiguous input (line 153 of "$AFP/Jinja/J/WellType.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>WellType.WT" ("_position" P) ("_position" E)
###       ("\<^const>Expr.exp.Seq" ("_position" e\<^sub>1)
###         ("_position" e\<^sub>2))
###       ("_position" T\<^sub>2))
###     ("\<^const>HOL.Ex_binder" ("_position" T\<^sub>1)
###       ("\<^const>HOL.conj"
###         ("\<^const>WellType.WT" ("_position" P) ("_position" E)
###           ("_position" e\<^sub>1) ("_position" T\<^sub>1))
###         ("\<^const>WellType.WT" ("_position" P) ("_position" E)
###           ("_position" e\<^sub>2) ("_position" T\<^sub>2))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>WellType.WT" ("_position" P) ("_position" E)
###     ("\<^const>Expr.exp.Seq" ("_position" e\<^sub>1)
###       ("_position" e\<^sub>2))
###     ("\<^const>HOL.eq" ("_position" T\<^sub>2)
###       ("\<^const>HOL.Ex_binder" ("_position" T\<^sub>1)
###         ("\<^const>HOL.conj"
###           ("\<^const>WellType.WT" ("_position" P) ("_position" E)
###             ("_position" e\<^sub>1) ("_position" T\<^sub>1))
###           ("\<^const>WellType.WT" ("_position" P) ("_position" E)
###             ("_position" e\<^sub>2) ("_position" T\<^sub>2)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>WellType.WT" ("_position" P) ("_position" E)
###       ("\<^const>Expr.exp.Seq" ("_position" e\<^sub>1)
###         ("_position" e\<^sub>2))
###       ("_position" T\<^sub>2))
###     ("\<^const>HOL.Ex_binder" ("_position" T\<^sub>1)
###       ("\<^const>WellType.WT" ("_position" P) ("_position" E)
###         ("_position" e\<^sub>1)
###         ("\<^const>HOL.conj" ("_position" T\<^sub>1)
###           ("\<^const>WellType.WT" ("_position" P) ("_position" E)
###             ("_position" e\<^sub>2) ("_position" T\<^sub>2)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>WellType.WT" ("_position" P) ("_position" E)
###     ("\<^const>Expr.exp.Seq" ("_position" e\<^sub>1)
###       ("_position" e\<^sub>2))
###     ("\<^const>HOL.eq" ("_position" T\<^sub>2)
###       ("\<^const>HOL.Ex_binder" ("_position" T\<^sub>1)
###         ("\<^const>WellType.WT" ("_position" P) ("_position" E)
###           ("_position" e\<^sub>1)
###           ("\<^const>HOL.conj" ("_position" T\<^sub>1)
###             ("\<^const>WellType.WT" ("_position" P) ("_position" E)
###               ("_position" e\<^sub>2) ("_position" T\<^sub>2))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
  Proving monotonicity ...
### Ambiguous input (line 168 of "$AFP/Jinja/J/WellType.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>WellType.WT" ("_position" P) ("_position" E)
###     ("\<^const>Expr.exp.FAss" ("_position" a) ("_position" F)
###       ("_position" D) ("_position" v))
###     ("_position" T)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>WellType.WT" ("_position" P) ("_position" E)
###     ("\<^const>Expr.exp.LAss"
###       ("\<^const>Expr.exp.FAcc" ("_position" a) ("_position" F)
###         ("_position" D))
###       ("_position" v))
###     ("_position" T)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "Draft.WellType"
### 0.662s elapsed time, 2.252s cpu time, 0.148s GC time
### Ambiguous input (line 204 of "$AFP/Jinja/J/BigStep.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P)
###     ("\<^const>Expr.exp.LAss"
###       ("\<^const>Expr.exp.FAcc" ("_position" e\<^sub>1) ("_position" F)
###         ("_position" D))
###       ("_position" e\<^sub>2))
###     ("_position" s) ("_position" e') ("_position" s')))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P)
###     ("\<^const>Expr.exp.FAss" ("_position" e\<^sub>1) ("_position" F)
###       ("_position" D) ("_position" e\<^sub>2))
###     ("_position" s) ("_position" e') ("_position" s')))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "Draft.BigStep"
### 2.296s elapsed time, 7.021s cpu time, 0.435s GC time
Loading theory "Draft.DefAss" (required by "Draft.TypeCompMoreTemplates" via "Draft.TypeComp" via "Draft.Compiler" via "Draft.Correctness1" via "Draft.J1WellForm" via "Draft.JWellForm")
Loading theory "Draft.J1" (required by "Draft.TypeCompMoreTemplates" via "Draft.TypeComp" via "Draft.Compiler" via "Draft.Correctness1" via "Draft.J1WellForm")
### Ambiguous input (line 25 of "$AFP/Jinja/Compiler/J1.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_Update" ("_position" max_vars)
###       ("_updbind" ("_position" V) ("_position" e)))
###     ("_applC" ("_position" max_vars) ("_position" e))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" max_vars)
###       ("\<^const>Expr.exp.LAss" ("_position" V) ("_position" e)))
###     ("_applC" ("_position" max_vars) ("_position" e))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
consts
  max_vars :: "'a exp => nat"
  max_varss :: "'a exp list => nat"
### Ambiguous input (line 86 of "$AFP/Jinja/Compiler/J1.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval\<^sub>1" ("_position" P) ("_position" e)
###         ("_position" s\<^sub>0) ("_applC" ("_position" Val) ("_position" v))
###         ("_tuple" ("_position" h) ("_tuple_arg" ("_position" ls)))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Orderings.ord_class.less" ("_position" i)
###           ("_applC" ("_position" size) ("_position" ls))))
###       ("_asm"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq" ("_position" ls')
###             ("_applC" ("_position" ls)
###               ("_list"
###                 ("\<^const>Expr.exp.LAss" ("_position" i)
###                   ("_position" v)))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval\<^sub>1" ("_position" P)
###       ("\<^const>Expr.exp.LAss" ("_position" i) ("_position" e))
###       ("_position" s\<^sub>0) ("_position" unit)
###       ("_tuple" ("_position" h) ("_tuple_arg" ("_position" ls'))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval\<^sub>1" ("_position" P) ("_position" e)
###         ("_position" s\<^sub>0) ("_applC" ("_position" Val) ("_position" v))
###         ("_tuple" ("_position" h) ("_tuple_arg" ("_position" ls)))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Orderings.ord_class.less" ("_position" i)
###           ("_applC" ("_position" size) ("_position" ls))))
###       ("_asm"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq" ("_position" ls')
###             ("_LUpdate" ("_position" ls)
###               ("_lupdbind" ("_position" i) ("_position" v))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval\<^sub>1" ("_position" P)
###       ("\<^const>Expr.exp.LAss" ("_position" i) ("_position" e))
###       ("_position" s\<^sub>0) ("_position" unit)
###       ("_tuple" ("_position" h) ("_tuple_arg" ("_position" ls'))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 72 of "$AFP/Jinja/J/DefAss.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_Update" ("_position" \<A>)
###       ("_updbind"
###         ("\<^const>Expr.exp.FAcc" ("_position" e\<^sub>1) ("_position" F)
###           ("_position" D))
###         ("_position" e\<^sub>2)))
###     ("\<^const>DefAss.hyperUn"
###       ("_applC" ("_position" \<A>) ("_position" e\<^sub>1))
###       ("_applC" ("_position" \<A>) ("_position" e\<^sub>2)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" \<A>)
###       ("\<^const>Expr.exp.FAss" ("_position" e\<^sub>1) ("_position" F)
###         ("_position" D) ("_position" e\<^sub>2)))
###     ("\<^const>DefAss.hyperUn"
###       ("_applC" ("_position" \<A>) ("_position" e\<^sub>1))
###       ("_applC" ("_position" \<A>) ("_position" e\<^sub>2)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" \<A>)
###       ("\<^const>Expr.exp.LAss"
###         ("\<^const>Expr.exp.FAcc" ("_position" e\<^sub>1) ("_position" F)
###           ("_position" D))
###         ("_position" e\<^sub>2)))
###     ("\<^const>DefAss.hyperUn"
###       ("_applC" ("_position" \<A>) ("_position" e\<^sub>1))
###       ("_applC" ("_position" \<A>) ("_position" e\<^sub>2)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 103 of "$AFP/Jinja/Compiler/J1.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval\<^sub>1" ("_position" P) ("_position" e\<^sub>1)
###         ("_position" s\<^sub>0)
###         ("_applC" ("_position" addr) ("_position" a))
###         ("_position" s\<^sub>1)))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^fixed>eval\<^sub>1" ("_position" P) ("_position" e\<^sub>2)
###           ("_position" s\<^sub>1)
###           ("_applC" ("_position" Val) ("_position" v))
###           ("_tuple" ("_position" h\<^sub>2)
###             ("_tuple_arg" ("_position" l\<^sub>2)))))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" h\<^sub>2) ("_position" a))
###             ("_applC" ("_position" Some)
###               ("_tuple" ("_position" C) ("_tuple_arg" ("_position" fs))))))
###         ("_asms"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq" ("_position" fs')
###               ("_MapUpd" ("_position" fs)
###                 ("_maplet"
###                   ("_tuple" ("_position" F) ("_tuple_arg" ("_position" D)))
###                   ("_position" v)))))
###           ("_asm"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq" ("_position" h\<^sub>2')
###                 ("_MapUpd" ("_position" h\<^sub>2)
###                   ("_maplet" ("_position" a)
###                     ("_tuple" ("_position" C)
###                       ("_tuple_arg" ("_position" fs'))))))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval\<^sub>1" ("_position" P)
###       ("\<^const>Expr.exp.LAss"
###         ("\<^const>Expr.exp.FAcc" ("_position" e\<^sub>1) ("_position" F)
###           ("_position" D))
###         ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0) ("_position" unit)
###       ("_tuple" ("_position" h\<^sub>2')
###         ("_tuple_arg" ("_position" l\<^sub>2))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval\<^sub>1" ("_position" P) ("_position" e\<^sub>1)
###         ("_position" s\<^sub>0)
###         ("_applC" ("_position" addr) ("_position" a))
###         ("_position" s\<^sub>1)))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^fixed>eval\<^sub>1" ("_position" P) ("_position" e\<^sub>2)
###           ("_position" s\<^sub>1)
###           ("_applC" ("_position" Val) ("_position" v))
###           ("_tuple" ("_position" h\<^sub>2)
###             ("_tuple_arg" ("_position" l\<^sub>2)))))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" h\<^sub>2) ("_position" a))
###             ("_applC" ("_position" Some)
###               ("_tuple" ("_position" C) ("_tuple_arg" ("_position" fs))))))
###         ("_asms"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq" ("_position" fs')
###               ("_MapUpd" ("_position" fs)
###                 ("_maplet"
###                   ("_tuple" ("_position" F) ("_tuple_arg" ("_position" D)))
###                   ("_position" v)))))
###           ("_asm"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq" ("_position" h\<^sub>2')
###                 ("_MapUpd" ("_position" h\<^sub>2)
###                   ("_maplet" ("_position" a)
###                     ("_tuple" ("_position" C)
###                       ("_tuple_arg" ("_position" fs'))))))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval\<^sub>1" ("_position" P)
###       ("\<^const>Expr.exp.FAss" ("_position" e\<^sub>1) ("_position" F)
###         ("_position" D) ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0) ("_position" unit)
###       ("_tuple" ("_position" h\<^sub>2')
###         ("_tuple_arg" ("_position" l\<^sub>2))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 107 of "$AFP/Jinja/Compiler/J1.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval\<^sub>1" ("_position" P) ("_position" e\<^sub>1)
###         ("_position" s\<^sub>0) ("_position" null) ("_position" s\<^sub>1)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^fixed>eval\<^sub>1" ("_position" P) ("_position" e\<^sub>2)
###           ("_position" s\<^sub>1)
###           ("_applC" ("_position" Val) ("_position" v))
###           ("_position" s\<^sub>2)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval\<^sub>1" ("_position" P)
###       ("\<^const>Expr.exp.LAss"
###         ("\<^const>Expr.exp.FAcc" ("_position" e\<^sub>1) ("_position" F)
###           ("_position" D))
###         ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0)
###       ("_applC" ("_position" THROW) ("_position" NullPointer))
###       ("_position" s\<^sub>2))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval\<^sub>1" ("_position" P) ("_position" e\<^sub>1)
###         ("_position" s\<^sub>0) ("_position" null) ("_position" s\<^sub>1)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^fixed>eval\<^sub>1" ("_position" P) ("_position" e\<^sub>2)
###           ("_position" s\<^sub>1)
###           ("_applC" ("_position" Val) ("_position" v))
###           ("_position" s\<^sub>2)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval\<^sub>1" ("_position" P)
###       ("\<^const>Expr.exp.FAss" ("_position" e\<^sub>1) ("_position" F)
###         ("_position" D) ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0)
###       ("_applC" ("_position" THROW) ("_position" NullPointer))
###       ("_position" s\<^sub>2))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 181 of "$AFP/Jinja/Compiler/J1.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval\<^sub>1" ("_position" P) ("_position" e\<^sub>1)
###         ("_position" s\<^sub>0)
###         ("_applC" ("_position" Throw) ("_position" a))
###         ("_tuple" ("_position" h\<^sub>1)
###           ("_tuple_arg" ("_position" ls\<^sub>1)))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq"
###           ("_applC" ("_position" h\<^sub>1) ("_position" a))
###           ("_applC" ("_position" Some)
###             ("_tuple" ("_position" D) ("_tuple_arg" ("_position" fs))))))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>TypeRel.subcls" ("_position" P) ("_position" D)
###             ("_position" C)))
###         ("_asms"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>Orderings.ord_class.less" ("_position" i)
###               ("_applC" ("_position" length) ("_position" ls\<^sub>1))))
###           ("_asm"
###             ("\<^const>HOL.Trueprop"
###               ("\<^fixed>eval\<^sub>1" ("_position" P)
###                 ("_position" e\<^sub>2)
###                 ("_tuple" ("_position" h\<^sub>1)
###                   ("_tuple_arg"
###                     ("_LUpdate" ("_position" ls\<^sub>1)
###                       ("_lupdbind" ("_position" i)
###                         ("_applC" ("_position" Addr) ("_position" a))))))
###                 ("_position" e\<^sub>2')
###                 ("_tuple" ("_position" h\<^sub>2)
###                   ("_tuple_arg" ("_position" ls\<^sub>2))))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval\<^sub>1" ("_position" P)
###       ("\<^const>Expr.exp.TryCatch" ("_position" e\<^sub>1) ("_position" C)
###         ("_position" i) ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0) ("_position" e\<^sub>2')
###       ("_tuple" ("_position" h\<^sub>2)
###         ("_tuple_arg" ("_position" ls\<^sub>2))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval\<^sub>1" ("_position" P) ("_position" e\<^sub>1)
###         ("_position" s\<^sub>0)
###         ("_applC" ("_position" Throw) ("_position" a))
###         ("_tuple" ("_position" h\<^sub>1)
###           ("_tuple_arg" ("_position" ls\<^sub>1)))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq"
###           ("_applC" ("_position" h\<^sub>1) ("_position" a))
###           ("_applC" ("_position" Some)
###             ("_tuple" ("_position" D) ("_tuple_arg" ("_position" fs))))))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>TypeRel.subcls" ("_position" P) ("_position" D)
###             ("_position" C)))
###         ("_asms"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>Orderings.ord_class.less" ("_position" i)
###               ("_applC" ("_position" length) ("_position" ls\<^sub>1))))
###           ("_asm"
###             ("\<^const>HOL.Trueprop"
###               ("\<^fixed>eval\<^sub>1" ("_position" P)
###                 ("_position" e\<^sub>2)
###                 ("_tuple" ("_position" h\<^sub>1)
###                   ("_tuple_arg"
###                     ("_applC" ("_position" ls\<^sub>1)
###                       ("_list"
###                         ("\<^const>Expr.exp.LAss" ("_position" i)
###                           ("_applC" ("_position" Addr) ("_position" a)))))))
###                 ("_position" e\<^sub>2')
###                 ("_tuple" ("_position" h\<^sub>2)
###                   ("_tuple_arg" ("_position" ls\<^sub>2))))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval\<^sub>1" ("_position" P)
###       ("\<^const>Expr.exp.TryCatch" ("_position" e\<^sub>1) ("_position" C)
###         ("_position" i) ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0) ("_position" e\<^sub>2')
###       ("_tuple" ("_position" h\<^sub>2)
###         ("_tuple_arg" ("_position" ls\<^sub>2))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 110 of "$AFP/Jinja/Compiler/J1.thy") produces 2 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval\<^sub>1" ("_position" P) ("_position" e\<^sub>1)
###       ("_position" s\<^sub>0)
###       ("_applC" ("_position" throw) ("_position" e'))
###       ("_position" s\<^sub>1)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval\<^sub>1" ("_position" P)
###       ("\<^const>Expr.exp.LAss"
###         ("\<^const>Expr.exp.FAcc" ("_position" e\<^sub>1) ("_position" F)
###           ("_position" D))
###         ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0)
###       ("_applC" ("_position" throw) ("_position" e'))
###       ("_position" s\<^sub>1))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval\<^sub>1" ("_position" P) ("_position" e\<^sub>1)
###       ("_position" s\<^sub>0)
###       ("_applC" ("_position" throw) ("_position" e'))
###       ("_position" s\<^sub>1)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval\<^sub>1" ("_position" P)
###       ("\<^const>Expr.exp.FAss" ("_position" e\<^sub>1) ("_position" F)
###         ("_position" D) ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0)
###       ("_applC" ("_position" throw) ("_position" e'))
###       ("_position" s\<^sub>1))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
consts
  \<A> :: "'a exp => 'a set option"
  \<A>s :: "'a exp list => 'a set option"
### Ambiguous input (line 113 of "$AFP/Jinja/Compiler/J1.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval\<^sub>1" ("_position" P) ("_position" e\<^sub>1)
###         ("_position" s\<^sub>0) ("_applC" ("_position" Val) ("_position" v))
###         ("_position" s\<^sub>1)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^fixed>eval\<^sub>1" ("_position" P) ("_position" e\<^sub>2)
###           ("_position" s\<^sub>1)
###           ("_applC" ("_position" throw) ("_position" e'))
###           ("_position" s\<^sub>2)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval\<^sub>1" ("_position" P)
###       ("\<^const>Expr.exp.LAss"
###         ("\<^const>Expr.exp.FAcc" ("_position" e\<^sub>1) ("_position" F)
###           ("_position" D))
###         ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0)
###       ("_applC" ("_position" throw) ("_position" e'))
###       ("_position" s\<^sub>2))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval\<^sub>1" ("_position" P) ("_position" e\<^sub>1)
###         ("_position" s\<^sub>0) ("_applC" ("_position" Val) ("_position" v))
###         ("_position" s\<^sub>1)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^fixed>eval\<^sub>1" ("_position" P) ("_position" e\<^sub>2)
###           ("_position" s\<^sub>1)
###           ("_applC" ("_position" throw) ("_position" e'))
###           ("_position" s\<^sub>2)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval\<^sub>1" ("_position" P)
###       ("\<^const>Expr.exp.FAss" ("_position" e\<^sub>1) ("_position" F)
###         ("_position" D) ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0)
###       ("_applC" ("_position" throw) ("_position" e'))
###       ("_position" s\<^sub>2))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 95 of "$AFP/Jinja/J/DefAss.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" \<D>)
###       ("_cargs"
###         ("\<^const>Expr.exp.LAss"
###           ("\<^const>Expr.exp.FAcc" ("_position" e\<^sub>1) ("_position" F)
###             ("_position" D))
###           ("_position" e\<^sub>2))
###         ("_position" A)))
###     ("\<^const>HOL.conj"
###       ("_applC" ("_position" \<D>)
###         ("_cargs" ("_position" e\<^sub>1) ("_position" A)))
###       ("_applC" ("_position" \<D>)
###         ("_cargs" ("_position" e\<^sub>2)
###           ("\<^const>DefAss.hyperUn" ("_position" A)
###             ("_applC" ("_position" \<A>) ("_position" e\<^sub>1))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" \<D>)
###       ("_cargs"
###         ("\<^const>Expr.exp.FAss" ("_position" e\<^sub>1) ("_position" F)
###           ("_position" D) ("_position" e\<^sub>2))
###         ("_position" A)))
###     ("\<^const>HOL.conj"
###       ("_applC" ("_position" \<D>)
###         ("_cargs" ("_position" e\<^sub>1) ("_position" A)))
###       ("_applC" ("_position" \<D>)
###         ("_cargs" ("_position" e\<^sub>2)
###           ("\<^const>DefAss.hyperUn" ("_position" A)
###             ("_applC" ("_position" \<A>) ("_position" e\<^sub>1))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
consts
  \<D> :: "'a exp => 'a set option => bool"
  \<D>s :: "'a exp list => 'a set option => bool"
### theory "Draft.DefAss"
### 0.213s elapsed time, 0.700s cpu time, 0.065s GC time
Loading theory "Draft.JWellForm" (required by "Draft.TypeCompMoreTemplates" via "Draft.TypeComp" via "Draft.Compiler" via "Draft.Correctness1" via "Draft.J1WellForm")
Proofs for inductive predicate(s) "eval\<^sub>1", "evals\<^sub>1"
  Proving monotonicity ...
### Ambiguous input (line 15 of "$AFP/Jinja/J/JWellForm.thy") produces 2 parse trees:
### ("\<^const>Pure.eq"
###   ("_applC" ("_position" wf_J_mdecl)
###     ("_cargs" ("_position" P) ("_position" C)))
###   ("_lambda"
###     ("_pattern" ("_position" M)
###       ("_patterns" ("_position" Ts)
###         ("_patterns" ("_position" T)
###           ("_pattern" ("_position" pns) ("_position" body)))))
###     ("\<^const>HOL.conj"
###       ("\<^const>HOL.eq" ("_applC" ("_position" length) ("_position" Ts))
###         ("_applC" ("_position" length) ("_position" pns)))
###       ("\<^const>HOL.conj"
###         ("_applC" ("_position" distinct) ("_position" pns))
###         ("\<^const>HOL.conj"
###           ("\<^const>Set.not_member" ("_position" this)
###             ("_applC" ("_position" set) ("_position" pns)))
###           ("\<^const>HOL.conj"
###             ("\<^const>HOL.Ex_binder" ("_position" T')
###               ("\<^const>HOL.conj"
###                 ("\<^const>WellType.WT" ("_position" P)
###                   ("_Map"
###                     ("_Maplets"
###                       ("_maplet" ("_position" this)
###                         ("_applC" ("_position" Class) ("_position" C)))
###                       ("_maplets" ("_position" pns) ("_position" Ts))))
###                   ("_position" body) ("_position" T'))
###                 ("\<^const>TypeRel.widen" ("_position" P) ("_position" T')
###                   ("_position" T))))
###             ("_applC" ("_position" \<D>)
###               ("_cargs" ("_position" body)
###                 ("\<^const>Option.option.Some"
###                   ("\<^const>Set.union" ("_Finset" ("_position" this))
###                     ("_applC" ("_position" set) ("_position" pns))))))))))))
### ("\<^const>Pure.eq"
###   ("_applC" ("_position" wf_J_mdecl)
###     ("_cargs" ("_position" P) ("_position" C)))
###   ("_lambda"
###     ("_pattern" ("_position" M)
###       ("_patterns" ("_position" Ts)
###         ("_patterns" ("_position" T)
###           ("_pattern" ("_position" pns) ("_position" body)))))
###     ("\<^const>HOL.conj"
###       ("\<^const>HOL.eq" ("_applC" ("_position" length) ("_position" Ts))
###         ("_applC" ("_position" length) ("_position" pns)))
###       ("\<^const>HOL.conj"
###         ("_applC" ("_position" distinct) ("_position" pns))
###         ("\<^const>HOL.conj"
###           ("\<^const>Set.not_member" ("_position" this)
###             ("_applC" ("_position" set) ("_position" pns)))
###           ("\<^const>HOL.conj"
###             ("\<^const>HOL.Ex_binder" ("_position" T')
###               ("\<^const>WellType.WT" ("_position" P)
###                 ("_Map"
###                   ("_Maplets"
###                     ("_maplet" ("_position" this)
###                       ("_applC" ("_position" Class) ("_position" C)))
###                     ("_maplets" ("_position" pns) ("_position" Ts))))
###                 ("_position" body)
###                 ("\<^const>HOL.conj" ("_position" T')
###                   ("\<^const>TypeRel.widen" ("_position" P) ("_position" T')
###                     ("_position" T)))))
###             ("_applC" ("_position" \<D>)
###               ("_cargs" ("_position" body)
###                 ("\<^const>Option.option.Some"
###                   ("\<^const>Set.union" ("_Finset" ("_position" this))
###                     ("_applC" ("_position" set) ("_position" pns))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 23 of "$AFP/Jinja/J/JWellForm.thy") produces 2 parse trees:
### ("\<^const>Pure.eq"
###   ("_applC" ("_position" wf_J_mdecl)
###     ("_cargs" ("_position" P)
###       ("_cargs" ("_position" C)
###         ("_tuple" ("_position" M)
###           ("_tuple_args" ("_position" Ts)
###             ("_tuple_args" ("_position" T)
###               ("_tuple_args" ("_position" pns)
###                 ("_tuple_arg" ("_position" body)))))))))
###   ("\<^const>HOL.conj"
###     ("\<^const>HOL.eq" ("_applC" ("_position" length) ("_position" Ts))
###       ("_applC" ("_position" length) ("_position" pns)))
###     ("\<^const>HOL.conj" ("_applC" ("_position" distinct) ("_position" pns))
###       ("\<^const>HOL.conj"
###         ("\<^const>Set.not_member" ("_position" this)
###           ("_applC" ("_position" set) ("_position" pns)))
###         ("\<^const>HOL.conj"
###           ("\<^const>HOL.Ex_binder" ("_position" T')
###             ("\<^const>WellType.WT" ("_position" P)
###               ("_Map"
###                 ("_Maplets"
###                   ("_maplet" ("_position" this)
###                     ("_applC" ("_position" Class) ("_position" C)))
###                   ("_maplets" ("_position" pns) ("_position" Ts))))
###               ("_position" body)
###               ("\<^const>HOL.conj" ("_position" T')
###                 ("\<^const>TypeRel.widen" ("_position" P) ("_position" T')
###                   ("_position" T)))))
###           ("_applC" ("_position" \<D>)
###             ("_cargs" ("_position" body)
###               ("\<^const>Option.option.Some"
###                 ("\<^const>Set.union" ("_Finset" ("_position" this))
###                   ("_applC" ("_position" set) ("_position" pns)))))))))))
### ("\<^const>Pure.eq"
###   ("_applC" ("_position" wf_J_mdecl)
###     ("_cargs" ("_position" P)
###       ("_cargs" ("_position" C)
###         ("_tuple" ("_position" M)
###           ("_tuple_args" ("_position" Ts)
###             ("_tuple_args" ("_position" T)
###               ("_tuple_args" ("_position" pns)
###                 ("_tuple_arg" ("_position" body)))))))))
###   ("\<^const>HOL.conj"
###     ("\<^const>HOL.eq" ("_applC" ("_position" length) ("_position" Ts))
###       ("_applC" ("_position" length) ("_position" pns)))
###     ("\<^const>HOL.conj" ("_applC" ("_position" distinct) ("_position" pns))
###       ("\<^const>HOL.conj"
###         ("\<^const>Set.not_member" ("_position" this)
###           ("_applC" ("_position" set) ("_position" pns)))
###         ("\<^const>HOL.conj"
###           ("\<^const>HOL.Ex_binder" ("_position" T')
###             ("\<^const>HOL.conj"
###               ("\<^const>WellType.WT" ("_position" P)
###                 ("_Map"
###                   ("_Maplets"
###                     ("_maplet" ("_position" this)
###                       ("_applC" ("_position" Class) ("_position" C)))
###                     ("_maplets" ("_position" pns) ("_position" Ts))))
###                 ("_position" body) ("_position" T'))
###               ("\<^const>TypeRel.widen" ("_position" P) ("_position" T')
###                 ("_position" T))))
###           ("_applC" ("_position" \<D>)
###             ("_cargs" ("_position" body)
###               ("\<^const>Option.option.Some"
###                 ("\<^const>Set.union" ("_Finset" ("_position" this))
###                   ("_applC" ("_position" set) ("_position" pns)))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "Draft.JWellForm"
### 0.320s elapsed time, 0.960s cpu time, 0.000s GC time
Found termination order: "{}"
### theory "Draft.J1"
### 1.058s elapsed time, 2.743s cpu time, 0.140s GC time
Loading theory "Draft.Compiler2" (required by "Draft.TypeCompMoreTemplates" via "Draft.TypeComp" via "Draft.Compiler" via "Draft.Correctness2")
Loading theory "Draft.J1WellForm" (required by "Draft.TypeCompMoreTemplates" via "Draft.TypeComp" via "Draft.Compiler" via "Draft.Correctness1")
Loading theory "Draft.Compiler1" (required by "Draft.TypeCompMoreTemplates" via "Draft.TypeComp" via "Draft.Compiler" via "Draft.Correctness1")
### Ambiguous input (line 57 of "$AFP/Jinja/Compiler/J1WellForm.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>WT\<^sub>1" ("_position" P) ("_position" E)
###         ("_position" e\<^sub>1)
###         ("_applC" ("_position" Class) ("_position" C))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>TypeRel.sees_field" ("_position" P) ("_position" C)
###           ("_position" F) ("_position" T) ("_position" D)))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^fixed>WT\<^sub>1" ("_position" P) ("_position" E)
###             ("_position" e\<^sub>2) ("_position" T')))
###         ("_asm"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>TypeRel.widen" ("_position" P) ("_position" T')
###               ("_position" T)))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>WT\<^sub>1" ("_position" P) ("_position" E)
###       ("\<^const>Expr.exp.FAss" ("_position" e\<^sub>1) ("_position" F)
###         ("_position" D) ("_position" e\<^sub>2))
###       ("_position" Void))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>WT\<^sub>1" ("_position" P) ("_position" E)
###         ("_position" e\<^sub>1)
###         ("_applC" ("_position" Class) ("_position" C))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>TypeRel.sees_field" ("_position" P) ("_position" C)
###           ("_position" F) ("_position" T) ("_position" D)))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^fixed>WT\<^sub>1" ("_position" P) ("_position" E)
###             ("_position" e\<^sub>2) ("_position" T')))
###         ("_asm"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>TypeRel.widen" ("_position" P) ("_position" T')
###               ("_position" T)))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>WT\<^sub>1" ("_position" P) ("_position" E)
###       ("\<^const>Expr.exp.LAss"
###         ("\<^const>Expr.exp.FAcc" ("_position" e\<^sub>1) ("_position" F)
###           ("_position" D))
###         ("_position" e\<^sub>2))
###       ("_position" Void))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Proofs for inductive predicate(s) "WT\<^sub>1", "WTs\<^sub>1"
  Proving monotonicity ...
### Ambiguous input (line 20 of "$AFP/Jinja/Compiler/Compiler1.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" compE\<^sub>1)
###       ("_cargs" ("_position" Vs)
###         ("\<^const>Expr.exp.FAcc" ("_position" e) ("_position" F)
###           ("_position" D))))
###     ("\<^const>Expr.exp.FAcc"
###       ("_applC" ("_position" compE\<^sub>1)
###         ("_cargs" ("_position" Vs) ("_position" e)))
###       ("_position" F) ("_position" D))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Expr.exp.FAcc"
###     ("\<^const>HOL.eq"
###       ("_applC" ("_position" compE\<^sub>1)
###         ("_cargs" ("_position" Vs)
###           ("\<^const>Expr.exp.FAcc" ("_position" e) ("_position" F)
###             ("_position" D))))
###       ("_applC" ("_position" compE\<^sub>1)
###         ("_cargs" ("_position" Vs) ("_position" e))))
###     ("_position" F) ("_position" D)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 21 of "$AFP/Jinja/Compiler/Compiler1.thy") produces 8 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" compE\<^sub>1)
###       ("_cargs" ("_position" Vs)
###         ("\<^const>Expr.exp.FAss" ("_position" e\<^sub>1) ("_position" F)
###           ("_position" D) ("_position" e\<^sub>2))))
###     ("\<^const>Expr.exp.FAss"
###       ("_applC" ("_position" compE\<^sub>1)
###         ("_cargs" ("_position" Vs) ("_position" e\<^sub>1)))
###       ("_position" F) ("_position" D)
###       ("_applC" ("_position" compE\<^sub>1)
###         ("_cargs" ("_position" Vs) ("_position" e\<^sub>2))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" compE\<^sub>1)
###       ("_cargs" ("_position" Vs)
###         ("\<^const>Expr.exp.LAss"
###           ("\<^const>Expr.exp.FAcc" ("_position" e\<^sub>1) ("_position" F)
###             ("_position" D))
###           ("_position" e\<^sub>2))))
###     ("\<^const>Expr.exp.FAss"
###       ("_applC" ("_position" compE\<^sub>1)
###         ("_cargs" ("_position" Vs) ("_position" e\<^sub>1)))
###       ("_position" F) ("_position" D)
###       ("_applC" ("_position" compE\<^sub>1)
###         ("_cargs" ("_position" Vs) ("_position" e\<^sub>2))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" compE\<^sub>1)
###       ("_cargs" ("_position" Vs)
###         ("\<^const>Expr.exp.FAss" ("_position" e\<^sub>1) ("_position" F)
###           ("_position" D) ("_position" e\<^sub>2))))
###     ("\<^const>Expr.exp.LAss"
###       ("\<^const>Expr.exp.FAcc"
###         ("_applC" ("_position" compE\<^sub>1)
###           ("_cargs" ("_position" Vs) ("_position" e\<^sub>1)))
###         ("_position" F) ("_position" D))
###       ("_applC" ("_position" compE\<^sub>1)
###         ("_cargs" ("_position" Vs) ("_position" e\<^sub>2))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" compE\<^sub>1)
###       ("_cargs" ("_position" Vs)
###         ("\<^const>Expr.exp.LAss"
###           ("\<^const>Expr.exp.FAcc" ("_position" e\<^sub>1) ("_position" F)
###             ("_position" D))
###           ("_position" e\<^sub>2))))
###     ("\<^const>Expr.exp.LAss"
###       ("\<^const>Expr.exp.FAcc"
###         ("_applC" ("_position" compE\<^sub>1)
###           ("_cargs" ("_position" Vs) ("_position" e\<^sub>1)))
###         ("_position" F) ("_position" D))
###       ("_applC" ("_position" compE\<^sub>1)
###         ("_cargs" ("_position" Vs) ("_position" e\<^sub>2))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Expr.exp.LAss"
###     ("\<^const>Expr.exp.FAcc"
###       ("\<^const>HOL.eq"
###         ("_applC" ("_position" compE\<^sub>1)
###           ("_cargs" ("_position" Vs)
###             ("\<^const>Expr.exp.LAss"
###               ("\<^const>Expr.exp.FAcc" ("_position" e\<^sub>1)
###                 ("_position" F) ("_position" D))
###               ("_position" e\<^sub>2))))
###         ("_applC" ("_position" compE\<^sub>1)
###           ("_cargs" ("_position" Vs) ("_position" e\<^sub>1))))
###       ("_position" F) ("_position" D))
###     ("_applC" ("_position" compE\<^sub>1)
###       ("_cargs" ("_position" Vs) ("_position" e\<^sub>2)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Expr.exp.FAss"
###     ("\<^const>HOL.eq"
###       ("_applC" ("_position" compE\<^sub>1)
###         ("_cargs" ("_position" Vs)
###           ("\<^const>Expr.exp.LAss"
###             ("\<^const>Expr.exp.FAcc" ("_position" e\<^sub>1)
###               ("_position" F) ("_position" D))
###             ("_position" e\<^sub>2))))
###       ("_applC" ("_position" compE\<^sub>1)
###         ("_cargs" ("_position" Vs) ("_position" e\<^sub>1))))
###     ("_position" F) ("_position" D)
###     ("_applC" ("_position" compE\<^sub>1)
###       ("_cargs" ("_position" Vs) ("_position" e\<^sub>2)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Expr.exp.LAss"
###     ("\<^const>Expr.exp.FAcc"
###       ("\<^const>HOL.eq"
###         ("_applC" ("_position" compE\<^sub>1)
###           ("_cargs" ("_position" Vs)
###             ("\<^const>Expr.exp.FAss" ("_position" e\<^sub>1)
###               ("_position" F) ("_position" D) ("_position" e\<^sub>2))))
###         ("_applC" ("_position" compE\<^sub>1)
###           ("_cargs" ("_position" Vs) ("_position" e\<^sub>1))))
###       ("_position" F) ("_position" D))
###     ("_applC" ("_position" compE\<^sub>1)
###       ("_cargs" ("_position" Vs) ("_position" e\<^sub>2)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Expr.exp.FAss"
###     ("\<^const>HOL.eq"
###       ("_applC" ("_position" compE\<^sub>1)
###         ("_cargs" ("_position" Vs)
###           ("\<^const>Expr.exp.FAss" ("_position" e\<^sub>1) ("_position" F)
###             ("_position" D) ("_position" e\<^sub>2))))
###       ("_applC" ("_position" compE\<^sub>1)
###         ("_cargs" ("_position" Vs) ("_position" e\<^sub>1))))
###     ("_position" F) ("_position" D)
###     ("_applC" ("_position" compE\<^sub>1)
###       ("_cargs" ("_position" Vs) ("_position" e\<^sub>2)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 21 of "$AFP/Jinja/Compiler/Compiler2.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_Update" ("_position" compE\<^sub>2)
###       ("_updbind" ("_position" i) ("_position" e)))
###     ("\<^const>List.append"
###       ("_applC" ("_position" compE\<^sub>2) ("_position" e))
###       ("_list"
###         ("_args" ("_applC" ("_position" Store) ("_position" i))
###           ("_applC" ("_position" Push) ("_position" Unit)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" compE\<^sub>2)
###       ("\<^const>Expr.exp.LAss" ("_position" i) ("_position" e)))
###     ("\<^const>List.append"
###       ("_applC" ("_position" compE\<^sub>2) ("_position" e))
###       ("_list"
###         ("_args" ("_applC" ("_position" Store) ("_position" i))
###           ("_applC" ("_position" Push) ("_position" Unit)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 23 of "$AFP/Jinja/Compiler/Compiler2.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_Update" ("_position" compE\<^sub>2)
###       ("_updbind"
###         ("\<^const>Expr.exp.FAcc" ("_position" e\<^sub>1) ("_position" F)
###           ("_position" D))
###         ("_position" e\<^sub>2)))
###     ("\<^const>List.append"
###       ("_applC" ("_position" compE\<^sub>2) ("_position" e\<^sub>1))
###       ("\<^const>List.append"
###         ("_applC" ("_position" compE\<^sub>2) ("_position" e\<^sub>2))
###         ("_list"
###           ("_args"
###             ("_applC" ("_position" Putfield)
###               ("_cargs" ("_position" F) ("_position" D)))
###             ("_applC" ("_position" Push) ("_position" Unit))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" compE\<^sub>2)
###       ("\<^const>Expr.exp.FAss" ("_position" e\<^sub>1) ("_position" F)
###         ("_position" D) ("_position" e\<^sub>2)))
###     ("\<^const>List.append"
###       ("_applC" ("_position" compE\<^sub>2) ("_position" e\<^sub>1))
###       ("\<^const>List.append"
###         ("_applC" ("_position" compE\<^sub>2) ("_position" e\<^sub>2))
###         ("_list"
###           ("_args"
###             ("_applC" ("_position" Putfield)
###               ("_cargs" ("_position" F) ("_position" D)))
###             ("_applC" ("_position" Push) ("_position" Unit))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" compE\<^sub>2)
###       ("\<^const>Expr.exp.LAss"
###         ("\<^const>Expr.exp.FAcc" ("_position" e\<^sub>1) ("_position" F)
###           ("_position" D))
###         ("_position" e\<^sub>2)))
###     ("\<^const>List.append"
###       ("_applC" ("_position" compE\<^sub>2) ("_position" e\<^sub>1))
###       ("\<^const>List.append"
###         ("_applC" ("_position" compE\<^sub>2) ("_position" e\<^sub>2))
###         ("_list"
###           ("_args"
###             ("_applC" ("_position" Putfield)
###               ("_cargs" ("_position" F) ("_position" D)))
###             ("_applC" ("_position" Push) ("_position" Unit))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
consts
  compE\<^sub>1 :: "char list list => char list exp => nat exp"
  compEs\<^sub>1 :: "char list list => char list exp list => nat exp list"
### Ignoring duplicate safe introduction (intro!)
### ?P,?E \<turnstile>\<^sub>1 [] [::] []
### Ignoring duplicate safe introduction (intro!)
### ?P,?E \<turnstile>\<^sub>1 [] [::] []
consts
  compE\<^sub>2 :: "nat exp => instr list"
  compEs\<^sub>2 :: "nat exp list => instr list"
### No equation for constructor "new"
### No equation for constructor "Cast"
### No equation for constructor "BinOp"
### No equation for constructor "Var"
### No equation for constructor "LAss"
### No equation for constructor "FAcc"
### No equation for constructor "FAss"
### No equation for constructor "Call"
### No equation for constructor "Block"
### No equation for constructor "Seq"
### No equation for constructor "Cond"
### No equation for constructor "While"
### No equation for constructor "TryCatch"
consts
  fin\<^sub>1 :: "char list exp => nat exp"
### Ambiguous input (line 62 of "$AFP/Jinja/Compiler/Compiler2.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" compxE\<^sub>2)
###       ("_cargs"
###         ("\<^const>Expr.exp.LAss"
###           ("\<^const>Expr.exp.FAcc" ("_position" e\<^sub>1) ("_position" F)
###             ("_position" D))
###           ("_position" e\<^sub>2))
###         ("_cargs" ("_position" pc) ("_position" d))))
###     ("\<^const>List.append"
###       ("_applC" ("_position" compxE\<^sub>2)
###         ("_cargs" ("_position" e\<^sub>1)
###           ("_cargs" ("_position" pc) ("_position" d))))
###       ("_applC" ("_position" compxE\<^sub>2)
###         ("_cargs" ("_position" e\<^sub>2)
###           ("_cargs"
###             ("\<^const>Groups.plus_class.plus" ("_position" pc)
###               ("_applC" ("_position" size)
###                 ("_applC" ("_position" compE\<^sub>2)
###                   ("_position" e\<^sub>1))))
###             ("\<^const>Groups.plus_class.plus" ("_position" d)
###               ("\<^const>Groups.one_class.one"))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" compxE\<^sub>2)
###       ("_cargs"
###         ("\<^const>Expr.exp.FAss" ("_position" e\<^sub>1) ("_position" F)
###           ("_position" D) ("_position" e\<^sub>2))
###         ("_cargs" ("_position" pc) ("_position" d))))
###     ("\<^const>List.append"
###       ("_applC" ("_position" compxE\<^sub>2)
###         ("_cargs" ("_position" e\<^sub>1)
###           ("_cargs" ("_position" pc) ("_position" d))))
###       ("_applC" ("_position" compxE\<^sub>2)
###         ("_cargs" ("_position" e\<^sub>2)
###           ("_cargs"
###             ("\<^const>Groups.plus_class.plus" ("_position" pc)
###               ("_applC" ("_position" size)
###                 ("_applC" ("_position" compE\<^sub>2)
###                   ("_position" e\<^sub>1))))
###             ("\<^const>Groups.plus_class.plus" ("_position" d)
###               ("\<^const>Groups.one_class.one"))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
locale eff
  fixes
    P :: "(char list *
           char list *
           (char list * ty) list *
           (char list * ty list * ty * 'a) list) list"
    and mxs :: "nat"
    and mxl\<^sub>0 :: "nat"
    and Ts :: "ty list"
    and T\<^sub>r :: "ty"
    and "is" :: "instr list"
    and xt :: "(nat * nat * char list * nat * nat) list"
    and mxl :: "nat"
    and
    eff\<^sub>i :: "instr => ty list * ty err list => ty list * ty err list"
    and app\<^sub>i :: "instr => nat => ty list * ty err list => bool"
    and
    eff ::
      "instr
       => nat
          => (ty list * ty err list) option
             => (nat * (ty list * ty err list) option) list"
    and app :: "instr => nat => (ty list * ty err list) option => bool"
    and
    norm_eff ::
      "instr
       => nat
          => ty list * ty err list
             => (nat * (ty list * ty err list) option) list"
    and xcpt_app :: "instr => nat => ty list * ty err list => bool"
    and
    xcpt_eff ::
      "instr
       => nat
          => ty list * ty err list
             => (nat * (ty list * ty err list) option) list"
    and mpc :: "nat"
  defines "mxl == 1 + length Ts + mxl\<^sub>0"
    and "mpc == length is"
    and "!!i \<tau>. eff\<^sub>i i \<tau> == eff\<^sub>i (i, P, \<tau>)"
    and
    "!!i pc \<tau>.
        app\<^sub>i i pc \<tau> ==
        app\<^sub>i (i, P, pc, mxs, T\<^sub>r, \<tau>)"
    and "!!i pc \<tau>. xcpt_eff i pc \<tau> == xcpt_eff i P pc \<tau> xt"
    and "!!i pc \<tau>. norm_eff i pc \<tau> == norm_eff i P pc \<tau>"
    and "!!i pc. eff i pc == eff i P pc xt"
    and
    "!!i pc \<tau>. xcpt_app i pc \<tau> == xcpt_app i P pc mxs xt \<tau>"
    and "!!i pc. app i pc == app i P mxs T\<^sub>r pc mpc xt"
### theory "Draft.Compiler1"
### 0.474s elapsed time, 1.879s cpu time, 0.204s GC time
### Ambiguous input (line 116 of "$AFP/Jinja/Compiler/J1WellForm.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>J1WellForm.WT\<^sub>1" ("_position" P) ("_position" E)
###     ("\<^const>Expr.exp.FAss" ("_position" e\<^sub>1) ("_position" F)
###       ("_position" D) ("_position" e\<^sub>2))
###     ("_position" T)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>J1WellForm.WT\<^sub>1" ("_position" P) ("_position" E)
###     ("\<^const>Expr.exp.LAss"
###       ("\<^const>Expr.exp.FAcc" ("_position" e\<^sub>1) ("_position" F)
###         ("_position" D))
###       ("_position" e\<^sub>2))
###     ("_position" T)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
consts
  compxE\<^sub>2 ::
    "nat exp => nat => nat => (nat * nat * char list * nat * nat) list"
  compxEs\<^sub>2 ::
    "nat exp list => nat => nat => (nat * nat * char list * nat * nat) list"
### Ambiguous input (line 90 of "$AFP/Jinja/Compiler/Compiler2.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_Update" ("_position" max_stack)
###       ("_updbind" ("_position" i) ("_position" e)))
###     ("_applC" ("_position" max_stack) ("_position" e))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" max_stack)
###       ("\<^const>Expr.exp.LAss" ("_position" i) ("_position" e)))
###     ("_applC" ("_position" max_stack) ("_position" e))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 92 of "$AFP/Jinja/Compiler/Compiler2.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_Update" ("_position" max_stack)
###       ("_updbind"
###         ("\<^const>Expr.exp.FAcc" ("_position" e\<^sub>1) ("_position" F)
###           ("_position" D))
###         ("_position" e\<^sub>2)))
###     ("\<^const>Groups.plus_class.plus"
###       ("_applC" ("_position" max)
###         ("_cargs" ("_applC" ("_position" max_stack) ("_position" e\<^sub>1))
###           ("_applC" ("_position" max_stack) ("_position" e\<^sub>2))))
###       ("\<^const>Groups.one_class.one"))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" max_stack)
###       ("\<^const>Expr.exp.FAss" ("_position" e\<^sub>1) ("_position" F)
###         ("_position" D) ("_position" e\<^sub>2)))
###     ("\<^const>Groups.plus_class.plus"
###       ("_applC" ("_position" max)
###         ("_cargs" ("_applC" ("_position" max_stack) ("_position" e\<^sub>1))
###           ("_applC" ("_position" max_stack) ("_position" e\<^sub>2))))
###       ("\<^const>Groups.one_class.one"))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" max_stack)
###       ("\<^const>Expr.exp.LAss"
###         ("\<^const>Expr.exp.FAcc" ("_position" e\<^sub>1) ("_position" F)
###           ("_position" D))
###         ("_position" e\<^sub>2)))
###     ("\<^const>Groups.plus_class.plus"
###       ("_applC" ("_position" max)
###         ("_cargs" ("_applC" ("_position" max_stack) ("_position" e\<^sub>1))
###           ("_applC" ("_position" max_stack) ("_position" e\<^sub>2))))
###       ("\<^const>Groups.one_class.one"))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
consts
  max_stack :: "nat exp => nat"
  max_stacks :: "nat exp list => nat"
### theory "Draft.Compiler2"
### 0.637s elapsed time, 2.511s cpu time, 0.280s GC time
Loading theory "Draft.Correctness2" (required by "Draft.TypeCompMoreTemplates" via "Draft.TypeComp" via "Draft.Compiler")
### theory "Draft.Effect"
### 6.353s elapsed time, 19.035s cpu time, 1.544s GC time
Loading theory "Draft.BVSpec" (required by "Draft.TypeCompMoreTemplates" via "Draft.TypeComp")
### theory "Draft.BVSpec"
### 0.103s elapsed time, 0.355s cpu time, 0.000s GC time
### Ambiguous input (line 182 of "$AFP/Jinja/Compiler/J1WellForm.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" \<B>)
###       ("_cargs"
###         ("\<^const>Expr.exp.LAss"
###           ("\<^const>Expr.exp.FAcc" ("_position" e\<^sub>1) ("_position" F)
###             ("_position" D))
###           ("_position" e\<^sub>2))
###         ("_position" i)))
###     ("\<^const>HOL.conj"
###       ("_applC" ("_position" \<B>)
###         ("_cargs" ("_position" e\<^sub>1) ("_position" i)))
###       ("_applC" ("_position" \<B>)
###         ("_cargs" ("_position" e\<^sub>2) ("_position" i))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" \<B>)
###       ("_cargs"
###         ("\<^const>Expr.exp.FAss" ("_position" e\<^sub>1) ("_position" F)
###           ("_position" D) ("_position" e\<^sub>2))
###         ("_position" i)))
###     ("\<^const>HOL.conj"
###       ("_applC" ("_position" \<B>)
###         ("_cargs" ("_position" e\<^sub>1) ("_position" i)))
###       ("_applC" ("_position" \<B>)
###         ("_cargs" ("_position" e\<^sub>2) ("_position" i))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
consts
  \<B> :: "nat exp => nat => bool"
  \<B>s :: "nat exp list => nat => bool"
### Ambiguous input (line 197 of "$AFP/Jinja/Compiler/J1WellForm.thy") produces 2 parse trees:
### ("\<^const>Pure.eq"
###   ("_applC" ("_position" wf_J\<^sub>1_mdecl)
###     ("_cargs" ("_position" P) ("_position" C)))
###   ("_lambda"
###     ("_pattern" ("_position" M)
###       ("_patterns" ("_position" Ts)
###         ("_patterns" ("_position" T) ("_position" body))))
###     ("\<^const>HOL.conj"
###       ("\<^const>HOL.Ex_binder" ("_position" T')
###         ("\<^const>HOL.conj"
###           ("\<^const>J1WellForm.WT\<^sub>1" ("_position" P)
###             ("\<^const>List.list.Cons"
###               ("_applC" ("_position" Class) ("_position" C))
###               ("_position" Ts))
###             ("_position" body) ("_position" T'))
###           ("\<^const>TypeRel.widen" ("_position" P) ("_position" T')
###             ("_position" T))))
###       ("\<^const>HOL.conj"
###         ("_applC" ("_position" \<D>)
###           ("_cargs" ("_position" body)
###             ("\<^const>Option.option.Some"
###               ("\<^const>Set_Interval.ord_class.atMost"
###                 ("_applC" ("_position" size) ("_position" Ts))))))
###         ("_applC" ("_position" \<B>)
###           ("_cargs" ("_position" body)
###             ("\<^const>Groups.plus_class.plus"
###               ("_applC" ("_position" size) ("_position" Ts))
###               ("\<^const>Groups.one_class.one"))))))))
### ("\<^const>Pure.eq"
###   ("_applC" ("_position" wf_J\<^sub>1_mdecl)
###     ("_cargs" ("_position" P) ("_position" C)))
###   ("_lambda"
###     ("_pattern" ("_position" M)
###       ("_patterns" ("_position" Ts)
###         ("_patterns" ("_position" T) ("_position" body))))
###     ("\<^const>HOL.conj"
###       ("\<^const>HOL.Ex_binder" ("_position" T')
###         ("\<^const>J1WellForm.WT\<^sub>1" ("_position" P)
###           ("\<^const>List.list.Cons"
###             ("_applC" ("_position" Class) ("_position" C)) ("_position" Ts))
###           ("_position" body)
###           ("\<^const>HOL.conj" ("_position" T')
###             ("\<^const>TypeRel.widen" ("_position" P) ("_position" T')
###               ("_position" T)))))
###       ("\<^const>HOL.conj"
###         ("_applC" ("_position" \<D>)
###           ("_cargs" ("_position" body)
###             ("\<^const>Option.option.Some"
###               ("\<^const>Set_Interval.ord_class.atMost"
###                 ("_applC" ("_position" size) ("_position" Ts))))))
###         ("_applC" ("_position" \<B>)
###           ("_cargs" ("_position" body)
###             ("\<^const>Groups.plus_class.plus"
###               ("_applC" ("_position" size) ("_position" Ts))
###               ("\<^const>Groups.one_class.one"))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 202 of "$AFP/Jinja/Compiler/J1WellForm.thy") produces 2 parse trees:
### ("\<^const>Pure.eq"
###   ("_applC" ("_position" wf_J\<^sub>1_mdecl)
###     ("_cargs" ("_position" P)
###       ("_cargs" ("_position" C)
###         ("_tuple" ("_position" M)
###           ("_tuple_args" ("_position" Ts)
###             ("_tuple_args" ("_position" T)
###               ("_tuple_arg" ("_position" body))))))))
###   ("\<^const>HOL.conj"
###     ("\<^const>HOL.Ex_binder" ("_position" T')
###       ("\<^const>J1WellForm.WT\<^sub>1" ("_position" P)
###         ("\<^const>List.list.Cons"
###           ("_applC" ("_position" Class) ("_position" C)) ("_position" Ts))
###         ("_position" body)
###         ("\<^const>HOL.conj" ("_position" T')
###           ("\<^const>TypeRel.widen" ("_position" P) ("_position" T')
###             ("_position" T)))))
###     ("\<^const>HOL.conj"
###       ("_applC" ("_position" \<D>)
###         ("_cargs" ("_position" body)
###           ("\<^const>Option.option.Some"
###             ("\<^const>Set_Interval.ord_class.atMost"
###               ("_applC" ("_position" size) ("_position" Ts))))))
###       ("_applC" ("_position" \<B>)
###         ("_cargs" ("_position" body)
###           ("\<^const>Groups.plus_class.plus"
###             ("_applC" ("_position" size) ("_position" Ts))
###             ("\<^const>Groups.one_class.one")))))))
### ("\<^const>Pure.eq"
###   ("_applC" ("_position" wf_J\<^sub>1_mdecl)
###     ("_cargs" ("_position" P)
###       ("_cargs" ("_position" C)
###         ("_tuple" ("_position" M)
###           ("_tuple_args" ("_position" Ts)
###             ("_tuple_args" ("_position" T)
###               ("_tuple_arg" ("_position" body))))))))
###   ("\<^const>HOL.conj"
###     ("\<^const>HOL.Ex_binder" ("_position" T')
###       ("\<^const>HOL.conj"
###         ("\<^const>J1WellForm.WT\<^sub>1" ("_position" P)
###           ("\<^const>List.list.Cons"
###             ("_applC" ("_position" Class) ("_position" C)) ("_position" Ts))
###           ("_position" body) ("_position" T'))
###         ("\<^const>TypeRel.widen" ("_position" P) ("_position" T')
###           ("_position" T))))
###     ("\<^const>HOL.conj"
###       ("_applC" ("_position" \<D>)
###         ("_cargs" ("_position" body)
###           ("\<^const>Option.option.Some"
###             ("\<^const>Set_Interval.ord_class.atMost"
###               ("_applC" ("_position" size) ("_position" Ts))))))
###       ("_applC" ("_position" \<B>)
###         ("_cargs" ("_position" body)
###           ("\<^const>Groups.plus_class.plus"
###             ("_applC" ("_position" size) ("_position" Ts))
###             ("\<^const>Groups.one_class.one")))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "Draft.J1WellForm"
### 0.818s elapsed time, 3.030s cpu time, 0.280s GC time
Loading theory "Draft.Correctness1" (required by "Draft.TypeCompMoreTemplates" via "Draft.TypeComp" via "Draft.Compiler")
### Ambiguous input (line 23 of "$AFP/Jinja/Compiler/Correctness1.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" unmod)
###       ("_cargs"
###         ("\<^const>Expr.exp.LAss"
###           ("\<^const>Expr.exp.FAcc" ("_position" e\<^sub>1) ("_position" F)
###             ("_position" D))
###           ("_position" e\<^sub>2))
###         ("_position" i)))
###     ("\<^const>HOL.conj"
###       ("_applC" ("_position" unmod)
###         ("_cargs" ("_position" e\<^sub>1) ("_position" i)))
###       ("_applC" ("_position" unmod)
###         ("_cargs" ("_position" e\<^sub>2) ("_position" i))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" unmod)
###       ("_cargs"
###         ("\<^const>Expr.exp.FAss" ("_position" e\<^sub>1) ("_position" F)
###           ("_position" D) ("_position" e\<^sub>2))
###         ("_position" i)))
###     ("\<^const>HOL.conj"
###       ("_applC" ("_position" unmod)
###         ("_cargs" ("_position" e\<^sub>1) ("_position" i)))
###       ("_applC" ("_position" unmod)
###         ("_cargs" ("_position" e\<^sub>2) ("_position" i))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
consts
  unmod :: "nat exp => nat => bool"
  unmods :: "nat exp list => nat => bool"
### Ambiguous input (line 206 of "$AFP/Jinja/Compiler/Correctness2.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.iff"
###     ("\<^fixed>dummyx" ("_position" P) ("_position" C) ("_position" M)
###       ("_position" xt) ("_position" I) ("_position" d))
###     ("\<^const>Correctness2.beforex" ("_position" P) ("_position" C)
###       ("_position" M) ("_position" xt) ("_position" I) ("_position" d))))
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>dummyx" ("_position" P) ("_position" C) ("_position" M)
###     ("\<^const>Correctness2.before"
###       ("\<^const>Fields.inverse_class.inverse_divide" ("_position" xt)
###         ("_position" I))
###       ("\<^const>HOL.iff" ("_position" d) ("_position" P)) ("_position" C)
###       ("_position" M) ("_position" xt))
###     ("_position" I) ("_position" d)))
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>dummyx" ("_position" P) ("_position" C) ("_position" M)
###     ("_position" xt)
###     ("\<^const>Correctness2.before" ("_position" I)
###       ("\<^const>HOL.iff" ("_position" d) ("_position" P)) ("_position" C)
###       ("_position" M)
###       ("\<^const>Fields.inverse_class.inverse_divide" ("_position" xt)
###         ("_position" I)))
###     ("_position" d)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 57 of "$AFP/Jinja/Compiler/Correctness1.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Set.member" ("_position" x)
###         ("_applC" ("_position" set) ("_position" xs))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Orderings.ord_class.less_eq"
###           ("_applC" ("_position" size) ("_position" xs))
###           ("_applC" ("_position" size) ("_position" ys))))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Map.map_le" ("_position" m\<^sub>1)
###         ("_MapUpd" ("_position" m\<^sub>2)
###           ("_maplets" ("_position" xs) ("_position" ys)))))
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Map.map_le"
###         ("_MapUpd" ("_position" m\<^sub>1)
###           ("_maplet" ("_position" x) ("_position" y)))
###         ("_MapUpd" ("_position" m\<^sub>2)
###           ("_maplets" ("_position" xs)
###             ("_applC" ("_position" ys)
###               ("_list"
###                 ("\<^const>Expr.exp.LAss"
###                   ("_applC" ("_position" last_index)
###                     ("_cargs" ("_position" xs) ("_position" x)))
###                   ("_position" y))))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Set.member" ("_position" x)
###         ("_applC" ("_position" set) ("_position" xs))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Orderings.ord_class.less_eq"
###           ("_applC" ("_position" size) ("_position" xs))
###           ("_applC" ("_position" size) ("_position" ys))))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Map.map_le" ("_position" m\<^sub>1)
###         ("_MapUpd" ("_position" m\<^sub>2)
###           ("_maplets" ("_position" xs) ("_position" ys)))))
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Map.map_le"
###         ("_MapUpd" ("_position" m\<^sub>1)
###           ("_maplet" ("_position" x) ("_position" y)))
###         ("_MapUpd" ("_position" m\<^sub>2)
###           ("_maplets" ("_position" xs)
###             ("_LUpdate" ("_position" ys)
###               ("_lupdbind"
###                 ("_applC" ("_position" last_index)
###                   ("_cargs" ("_position" xs) ("_position" x)))
###                 ("_position" y)))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 68 of "$AFP/Jinja/Compiler/Correctness1.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Map.map_le"
###     ("_applC" ("_position" l')
###       ("\<^const>Expr.exp.LAss" ("_position" V)
###         ("_applC" ("_position" l) ("_position" V))))
###     ("_Map" ("_maplets" ("_position" Vs) ("_position" ls')))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Map.map_le"
###     ("_Update" ("_position" l')
###       ("_updbind" ("_position" V)
###         ("_applC" ("_position" l) ("_position" V))))
###     ("_Map" ("_maplets" ("_position" Vs) ("_position" ls')))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 231 of "$AFP/Jinja/Compiler/Correctness2.thy") produces 8 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("\<^const>Set.inter"
###         ("_applC" ("_position" pcs) ("_position" xt\<^sub>1))
###         ("_applC" ("_position" pcs) ("_position" xt\<^sub>2)))
###       ("\<^const>Set.empty")))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("\<^const>Correctness2.beforex" ("_position" P) ("_position" C)
###         ("_position" M)
###         ("\<^const>List.append" ("_position" xt\<^sub>1)
###           ("_position" xt\<^sub>2))
###         ("_position" I) ("_position" d))
###       ("\<^const>Correctness2.beforex" ("_position" P) ("_position" C)
###         ("_position" M) ("_position" xt\<^sub>1)
###         ("\<^const>Correctness2.at"
###           ("\<^const>Groups.minus_class.minus" ("_position" I)
###             ("_applC" ("_position" pcs) ("_position" xt\<^sub>2)))
###           ("\<^const>HOL.conj" ("_position" d)
###             ("\<^const>HOL.conj"
###               ("\<^const>Correctness2.beforex" ("_position" P)
###                 ("_position" C) ("_position" M) ("_position" xt\<^sub>2)
###                 ("\<^const>Groups.minus_class.minus" ("_position" I)
###                   ("_applC" ("_position" pcs) ("_position" xt\<^sub>1)))
###                 ("_position" d))
###               ("_position" P)))
###           ("_position" C) ("_position" M)
###           ("\<^const>List.append" ("_position" xt\<^sub>1)
###             ("\<^const>Fields.inverse_class.inverse_divide"
###               ("_position" xt\<^sub>2) ("_position" I))))
###         ("_position" d)))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("\<^const>Set.inter"
###         ("_applC" ("_position" pcs) ("_position" xt\<^sub>1))
###         ("_applC" ("_position" pcs) ("_position" xt\<^sub>2)))
###       ("\<^const>Set.empty")))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("\<^const>Correctness2.beforex" ("_position" P) ("_position" C)
###         ("_position" M)
###         ("\<^const>List.append" ("_position" xt\<^sub>1)
###           ("_position" xt\<^sub>2))
###         ("_position" I) ("_position" d))
###       ("\<^const>HOL.conj"
###         ("\<^const>Correctness2.beforex" ("_position" P) ("_position" C)
###           ("_position" M) ("_position" xt\<^sub>1)
###           ("\<^const>Groups.minus_class.minus" ("_position" I)
###             ("_applC" ("_position" pcs) ("_position" xt\<^sub>2)))
###           ("_position" d))
###         ("\<^const>Correctness2.beforex" ("_position" P) ("_position" C)
###           ("_position" M) ("_position" xt\<^sub>2)
###           ("\<^const>Correctness2.at"
###             ("\<^const>Groups.minus_class.minus" ("_position" I)
###               ("_applC" ("_position" pcs) ("_position" xt\<^sub>1)))
###             ("\<^const>HOL.conj" ("_position" d) ("_position" P))
###             ("_position" C) ("_position" M)
###             ("\<^const>List.append" ("_position" xt\<^sub>1)
###               ("\<^const>Fields.inverse_class.inverse_divide"
###                 ("_position" xt\<^sub>2) ("_position" I))))
###           ("_position" d))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("\<^const>Set.inter"
###         ("_applC" ("_position" pcs) ("_position" xt\<^sub>1))
###         ("_applC" ("_position" pcs) ("_position" xt\<^sub>2)))
###       ("\<^const>Set.empty")))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("\<^const>Correctness2.beforex" ("_position" P) ("_position" C)
###         ("_position" M)
###         ("\<^const>List.append" ("_position" xt\<^sub>1)
###           ("_position" xt\<^sub>2))
###         ("_position" I) ("_position" d))
###       ("\<^const>Correctness2.beforex" ("_position" P) ("_position" C)
###         ("_position" M)
###         ("\<^const>Correctness2.before"
###           ("\<^const>Groups.minus_class.minus"
###             ("\<^const>Fields.inverse_class.inverse_divide"
###               ("_position" xt\<^sub>1) ("_position" I))
###             ("_applC" ("_position" pcs) ("_position" xt\<^sub>2)))
###           ("\<^const>HOL.conj" ("_position" d) ("_position" P))
###           ("_position" C) ("_position" M) ("_position" xt\<^sub>2))
###         ("\<^const>Correctness2.at"
###           ("\<^const>Groups.minus_class.minus" ("_position" I)
###             ("_applC" ("_position" pcs) ("_position" xt\<^sub>1)))
###           ("\<^const>HOL.conj" ("_position" d) ("_position" P))
###           ("_position" C) ("_position" M)
###           ("\<^const>List.append" ("_position" xt\<^sub>1)
###             ("\<^const>Fields.inverse_class.inverse_divide"
###               ("_position" xt\<^sub>2) ("_position" I))))
###         ("_position" d)))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("\<^const>Set.inter"
###         ("_applC" ("_position" pcs) ("_position" xt\<^sub>1))
###         ("_applC" ("_position" pcs) ("_position" xt\<^sub>2)))
###       ("\<^const>Set.empty")))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("\<^const>Correctness2.beforex" ("_position" P) ("_position" C)
###         ("_position" M)
###         ("\<^const>List.append" ("_position" xt\<^sub>1)
###           ("_position" xt\<^sub>2))
###         ("_position" I) ("_position" d))
###       ("\<^const>Correctness2.beforex" ("_position" P) ("_position" C)
###         ("_position" M)
###         ("\<^const>Correctness2.at"
###           ("\<^const>Groups.minus_class.minus"
###             ("\<^const>Fields.inverse_class.inverse_divide"
###               ("_position" xt\<^sub>1) ("_position" I))
###             ("_applC" ("_position" pcs) ("_position" xt\<^sub>2)))
###           ("\<^const>HOL.conj" ("_position" d)
###             ("\<^const>HOL.conj"
###               ("\<^const>Correctness2.beforex" ("_position" P)
###                 ("_position" C) ("_position" M) ("_position" xt\<^sub>2)
###                 ("\<^const>Groups.minus_class.minus" ("_position" I)
###                   ("_applC" ("_position" pcs) ("_position" xt\<^sub>1)))
###                 ("_position" d))
###               ("_position" P)))
###           ("_position" C) ("_position" M)
###           ("\<^const>List.append" ("_position" xt\<^sub>1)
###             ("_position" xt\<^sub>2)))
###         ("_position" I) ("_position" d)))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("\<^const>Set.inter"
###         ("_applC" ("_position" pcs) ("_position" xt\<^sub>1))
###         ("_applC" ("_position" pcs) ("_position" xt\<^sub>2)))
###       ("\<^const>Set.empty")))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("\<^const>Correctness2.beforex" ("_position" P) ("_position" C)
###         ("_position" M)
###         ("\<^const>List.append" ("_position" xt\<^sub>1)
###           ("_position" xt\<^sub>2))
###         ("_position" I) ("_position" d))
###       ("\<^const>HOL.conj"
###         ("\<^const>Correctness2.beforex" ("_position" P) ("_position" C)
###           ("_position" M) ("_position" xt\<^sub>1)
###           ("\<^const>Correctness2.before"
###             ("\<^const>Groups.minus_class.minus" ("_position" I)
###               ("_applC" ("_position" pcs) ("_position" xt\<^sub>2)))
###             ("\<^const>HOL.conj" ("_position" d) ("_position" P))
###             ("_position" C) ("_position" M)
###             ("\<^const>Groups.minus_class.minus"
###               ("\<^const>Fields.inverse_class.inverse_divide"
###                 ("_position" xt\<^sub>2) ("_position" I))
###               ("_applC" ("_position" pcs) ("_position" xt\<^sub>1))))
###           ("_position" d))
###         ("\<^const>Correctness2.dummyx" ("_position" P) ("_position" C)
###           ("_position" M)
###           ("\<^const>List.append" ("_position" xt\<^sub>1)
###             ("_position" xt\<^sub>2))
###           ("_position" I) ("_position" d))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("\<^const>Set.inter"
###         ("_applC" ("_position" pcs) ("_position" xt\<^sub>1))
###         ("_applC" ("_position" pcs) ("_position" xt\<^sub>2)))
###       ("\<^const>Set.empty")))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("\<^const>Correctness2.beforex" ("_position" P) ("_position" C)
###         ("_position" M)
###         ("\<^const>List.append" ("_position" xt\<^sub>1)
###           ("_position" xt\<^sub>2))
###         ("_position" I) ("_position" d))
###       ("\<^const>HOL.conj"
###         ("\<^const>Correctness2.beforex" ("_position" P) ("_position" C)
###           ("_position" M) ("_position" xt\<^sub>1)
###           ("\<^const>Groups.minus_class.minus" ("_position" I)
###             ("_applC" ("_position" pcs) ("_position" xt\<^sub>2)))
###           ("_position" d))
###         ("\<^const>HOL.conj"
###           ("\<^const>Correctness2.beforex" ("_position" P) ("_position" C)
###             ("_position" M) ("_position" xt\<^sub>2)
###             ("\<^const>Groups.minus_class.minus" ("_position" I)
###               ("_applC" ("_position" pcs) ("_position" xt\<^sub>1)))
###             ("_position" d))
###           ("\<^const>Correctness2.dummyx" ("_position" P) ("_position" C)
###             ("_position" M)
###             ("\<^const>List.append" ("_position" xt\<^sub>1)
###               ("_position" xt\<^sub>2))
###             ("_position" I) ("_position" d)))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("\<^const>Set.inter"
###         ("_applC" ("_position" pcs) ("_position" xt\<^sub>1))
###         ("_applC" ("_position" pcs) ("_position" xt\<^sub>2)))
###       ("\<^const>Set.empty")))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("\<^const>Correctness2.beforex" ("_position" P) ("_position" C)
###         ("_position" M)
###         ("\<^const>List.append" ("_position" xt\<^sub>1)
###           ("_position" xt\<^sub>2))
###         ("_position" I) ("_position" d))
###       ("\<^const>HOL.conj"
###         ("\<^const>Correctness2.beforex" ("_position" P) ("_position" C)
###           ("_position" M)
###           ("\<^const>Correctness2.before"
###             ("\<^const>Groups.minus_class.minus"
###               ("\<^const>Fields.inverse_class.inverse_divide"
###                 ("_position" xt\<^sub>1) ("_position" I))
###               ("_applC" ("_position" pcs) ("_position" xt\<^sub>2)))
###             ("\<^const>HOL.conj" ("_position" d) ("_position" P))
###             ("_position" C) ("_position" M) ("_position" xt\<^sub>2))
###           ("\<^const>Groups.minus_class.minus" ("_position" I)
###             ("_applC" ("_position" pcs) ("_position" xt\<^sub>1)))
###           ("_position" d))
###         ("\<^const>Correctness2.dummyx" ("_position" P) ("_position" C)
###           ("_position" M)
###           ("\<^const>List.append" ("_position" xt\<^sub>1)
###             ("_position" xt\<^sub>2))
###           ("_position" I) ("_position" d))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("\<^const>Set.inter"
###         ("_applC" ("_position" pcs) ("_position" xt\<^sub>1))
###         ("_applC" ("_position" pcs) ("_position" xt\<^sub>2)))
###       ("\<^const>Set.empty")))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("\<^const>Correctness2.beforex" ("_position" P) ("_position" C)
###         ("_position" M)
###         ("\<^const>List.append" ("_position" xt\<^sub>1)
###           ("_position" xt\<^sub>2))
###         ("_position" I) ("_position" d))
###       ("\<^const>HOL.conj"
###         ("\<^const>Correctness2.beforex" ("_position" P) ("_position" C)
###           ("_position" M) ("_position" xt\<^sub>1)
###           ("\<^const>Groups.minus_class.minus" ("_position" I)
###             ("_applC" ("_position" pcs) ("_position" xt\<^sub>2)))
###           ("_position" d))
###         ("\<^const>Correctness2.beforex" ("_position" P) ("_position" C)
###           ("_position" M)
###           ("\<^const>Correctness2.at"
###             ("\<^const>Groups.minus_class.minus"
###               ("\<^const>Fields.inverse_class.inverse_divide"
###                 ("_position" xt\<^sub>2) ("_position" I))
###               ("_applC" ("_position" pcs) ("_position" xt\<^sub>1)))
###             ("\<^const>HOL.conj" ("_position" d) ("_position" P))
###             ("_position" C) ("_position" M)
###             ("\<^const>List.append" ("_position" xt\<^sub>1)
###               ("_position" xt\<^sub>2)))
###           ("_position" I) ("_position" d))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "Draft.Correctness1"
### 0.324s elapsed time, 0.693s cpu time, 0.091s GC time
Found termination order: "{}"
### theory "Draft.Correctness2"
### 1.117s elapsed time, 2.025s cpu time, 0.279s GC time
Loading theory "Draft.Compiler" (required by "Draft.TypeCompMoreTemplates" via "Draft.TypeComp")
### theory "Draft.Compiler"
### 0.189s elapsed time, 0.261s cpu time, 0.000s GC time
Loading theory "Draft.TypeComp" (required by "Draft.TypeCompMoreTemplates")
locale TC0
  fixes
    P :: "(char list *
           char list *
           (char list * ty) list *
           (char list * ty list * ty * nat exp) list) list"
    and mxl :: "nat"
locale TC1
  fixes
    P :: "(char list *
           char list *
           (char list * ty) list *
           (char list * ty list * ty * nat exp) list) list"
    and mxl :: "nat"
### Ambiguous input (line 99 of "$AFP/Jinja/Compiler/TypeComp.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" compT)
###       ("_cargs" ("_position" E)
###         ("_cargs" ("_position" A)
###           ("_cargs" ("_position" ST)
###             ("\<^const>Expr.exp.FAss" ("_position" e\<^sub>1)
###               ("_position" F) ("_position" D) ("_position" e\<^sub>2))))))
###     ("_Let"
###       ("_binds"
###         ("_bind" ("_position" ST\<^sub>1)
###           ("\<^const>List.list.Cons"
###             ("_applC" ("_position" ty)
###               ("_cargs" ("_position" E) ("_position" e\<^sub>1)))
###             ("_position" ST)))
###         ("_binds"
###           ("_bind" ("_position" A\<^sub>1)
###             ("\<^const>DefAss.hyperUn" ("_position" A)
###               ("_applC" ("_position" \<A>) ("_position" e\<^sub>1))))
###           ("_bind" ("_position" A\<^sub>2)
###             ("\<^const>DefAss.hyperUn" ("_position" A\<^sub>1)
###               ("_applC" ("_position" \<A>) ("_position" e\<^sub>2))))))
###       ("\<^const>List.append"
###         ("_applC" ("_position" compT)
###           ("_cargs" ("_position" E)
###             ("_cargs" ("_position" A)
###               ("_cargs" ("_position" ST) ("_position" e\<^sub>1)))))
###         ("\<^const>List.append"
###           ("_list"
###             ("_applC" ("_position" after)
###               ("_cargs" ("_position" E)
###                 ("_cargs" ("_position" A)
###                   ("_cargs" ("_position" ST) ("_position" e\<^sub>1))))))
###           ("\<^const>List.append"
###             ("_applC" ("_position" compT)
###               ("_cargs" ("_position" E)
###                 ("_cargs" ("_position" A\<^sub>1)
###                   ("_cargs" ("_position" ST\<^sub>1)
###                     ("_position" e\<^sub>2)))))
###             ("\<^const>List.append"
###               ("_list"
###                 ("_applC" ("_position" after)
###                   ("_cargs" ("_position" E)
###                     ("_cargs" ("_position" A\<^sub>1)
###                       ("_cargs" ("_position" ST\<^sub>1)
###                         ("_position" e\<^sub>2))))))
###               ("_list"
###                 ("_applC" ("_position" ty\<^sub>i')
###                   ("_cargs" ("_position" ST)
###                     ("_cargs" ("_position" E)
###                       ("_position" A\<^sub>2))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" compT)
###       ("_cargs" ("_position" E)
###         ("_cargs" ("_position" A)
###           ("_cargs" ("_position" ST)
###             ("\<^const>Expr.exp.LAss"
###               ("\<^const>Expr.exp.FAcc" ("_position" e\<^sub>1)
###                 ("_position" F) ("_position" D))
###               ("_position" e\<^sub>2))))))
###     ("_Let"
###       ("_binds"
###         ("_bind" ("_position" ST\<^sub>1)
###           ("\<^const>List.list.Cons"
###             ("_applC" ("_position" ty)
###               ("_cargs" ("_position" E) ("_position" e\<^sub>1)))
###             ("_position" ST)))
###         ("_binds"
###           ("_bind" ("_position" A\<^sub>1)
###             ("\<^const>DefAss.hyperUn" ("_position" A)
###               ("_applC" ("_position" \<A>) ("_position" e\<^sub>1))))
###           ("_bind" ("_position" A\<^sub>2)
###             ("\<^const>DefAss.hyperUn" ("_position" A\<^sub>1)
###               ("_applC" ("_position" \<A>) ("_position" e\<^sub>2))))))
###       ("\<^const>List.append"
###         ("_applC" ("_position" compT)
###           ("_cargs" ("_position" E)
###             ("_cargs" ("_position" A)
###               ("_cargs" ("_position" ST) ("_position" e\<^sub>1)))))
###         ("\<^const>List.append"
###           ("_list"
###             ("_applC" ("_position" after)
###               ("_cargs" ("_position" E)
###                 ("_cargs" ("_position" A)
###                   ("_cargs" ("_position" ST) ("_position" e\<^sub>1))))))
###           ("\<^const>List.append"
###             ("_applC" ("_position" compT)
###               ("_cargs" ("_position" E)
###                 ("_cargs" ("_position" A\<^sub>1)
###                   ("_cargs" ("_position" ST\<^sub>1)
###                     ("_position" e\<^sub>2)))))
###             ("\<^const>List.append"
###               ("_list"
###                 ("_applC" ("_position" after)
###                   ("_cargs" ("_position" E)
###                     ("_cargs" ("_position" A\<^sub>1)
###                       ("_cargs" ("_position" ST\<^sub>1)
###                         ("_position" e\<^sub>2))))))
###               ("_list"
###                 ("_applC" ("_position" ty\<^sub>i')
###                   ("_cargs" ("_position" ST)
###                     ("_cargs" ("_position" E)
###                       ("_position" A\<^sub>2))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
consts
  compT ::
    "ty list
     => nat set option
        => ty list => nat exp => (ty list * ty err list) option list"
  compTs ::
    "ty list
     => nat set option
        => ty list => nat exp list => (ty list * ty err list) option list"
locale TC2
  fixes
    P :: "(char list *
           char list *
           (char list * ty) list *
           (char list * ty list * ty * nat exp) list) list"
    and mxl :: "nat"
    and T\<^sub>r :: "ty"
    and mxs :: "nat"
### Rewrite rule not in simpset:
### %u. ?f1 (?g1 (fst u)) (snd u) == %a. case a of (x, xa) => ?f1 (?g1 x) xa
*** Undefined fact: "wti" (line 476 of "$AFP/Jinja/Compiler/TypeComp.thy")
*** At command "thm" (line 476 of "$AFP/Jinja/Compiler/TypeComp.thy")
locale TC2
  fixes
    P :: "(char list *
           char list *
           (char list * ty) list *
           (char list * ty list * ty * nat exp) list) list"
    and mxl :: "nat"
    and T\<^sub>r :: "ty"
    and mxs :: "nat"
### theory "Draft.TypeComp"
### 1.067s elapsed time, 1.243s cpu time, 0.163s GC time
Loading theory "Draft.TypeCompMoreTemplates"
val templateLemmas =
   [("TypeComp.compE\<^sub>2_not_Nil", "compE\<^sub>2 ?e ~= []",
     template_negation
      (
         template_equation
          (template_app (template_hole 1, template_var 0), template_hole 0)
         )),
    ("TypeComp.wt_compP\<^sub>2",
     "wf_J\<^sub>1_prog ?P ==> wf_jvm_prog (compP\<^sub>2 ?P)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 3, template_hole 2),
              template_var 0)
            )],
       template_predicate
        (
           template_app
            (template_hole 1,
             template_app (template_hole 0, template_var 0))
           ))),
    ("TypeComp.wt_J2JVM", "wf_J_prog ?P ==> wf_jvm_prog (J2JVM ?P)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 3, template_hole 2),
              template_var 0)
            )],
       template_predicate
        (
           template_app
            (template_hole 1,
             template_app (template_hole 0, template_var 0))
           ))),
    ("TypeComp.is_class_type_aux",
     "is_class ?P ?C ==> is_type ?P (Class ?C)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 2, template_var 1),
              template_var 0)
            )],
       template_predicate
        (
           template_app
            (template_app (template_hole 1, template_var 1),
             template_app (template_hole 0, template_var 0))
           ))),
    ("TypeComp.fun_of_simp", "fun_of ?S ?x ?y = ((?x, ?y) : ?S)",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 2, template_var 2), template_var 1),
         template_var 0),
       template_app
        (template_app
          (template_hole 1,
           template_app
            (template_app (template_hole 0, template_var 1),
             template_var 0)),
         template_var 2))),
    ("TypeComp.pcs_shift",
     "?pc < ?n ==> ?pc ~: pcs (TypeComp.shift ?n ?xt)",
     template_implication
      ([template_inequation (less_than, template_var 2, template_var 1)],
       template_negation
        (
           template_predicate
            (
               template_app
                (template_app (template_hole 2, template_var 2),
                 template_app
                  (template_hole 1,
                   template_app
                    (template_app (template_hole 0, template_var 1),
                     template_var 0)))
               )
           ))),
    ("TypeComp.shift_compxE\<^sub>2",
     "TypeComp.shift ?pc (compxE\<^sub>2 ?e ?pc' ?d) =
      compxE\<^sub>2 ?e (?pc' + ?pc) ?d",
     template_equation
      (template_app
        (template_app (template_hole 2, template_var 3),
         template_app
          (template_app
            (template_app (template_hole 1, template_var 2),
             template_var 1),
           template_var 0)),
       template_app
        (template_app
          (template_app (template_hole 1, template_var 2),
           template_app
            (template_app (template_hole 0, template_var 1),
             template_var 3)),
         template_var 0))),
    ("TypeComp.shift_compxE\<^sub>2",
     "TypeComp.shift ?pc (compxEs\<^sub>2 ?es ?pc' ?d) =
      compxEs\<^sub>2 ?es (?pc' + ?pc) ?d",
     template_equation
      (template_app
        (template_app (template_hole 2, template_var 3),
         template_app
          (template_app
            (template_app (template_hole 1, template_var 2),
             template_var 1),
           template_var 0)),
       template_app
        (template_app
          (template_app (template_hole 1, template_var 2),
           template_app
            (template_app (template_hole 0, template_var 1),
             template_var 3)),
         template_var 0))),
    ("TypeComp.xcpt_app_pcs",
     "?pc ~: pcs ?xt ==> xcpt_app ?i ?P ?pc ?mxs ?xt ?\<tau>",
     template_implication
      ([template_negation
         (
            template_predicate
             (
                template_app
                 (template_app (template_hole 2, template_var 5),
                  template_app (template_hole 1, template_var 4))
                )
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_app
                  (template_app
                    (template_app (template_hole 0, template_var 3),
                     template_var 2),
                   template_var 5),
                 template_var 1),
               template_var 4),
             template_var 0)
           ))),
    ("TypeComp.xcpt_eff_pcs",
     "?pc ~: pcs ?xt ==> xcpt_eff ?i ?P ?pc ?\<tau> ?xt = []",
     template_implication
      ([template_negation
         (
            template_predicate
             (
                template_app
                 (template_app (template_hole 4, template_var 4),
                  template_app (template_hole 3, template_var 3))
                )
            )],
       template_equation
        (template_app
          (template_app
            (template_app
              (template_app
                (template_app (template_hole 1, template_var 2),
                 template_var 1),
               template_var 4),
             template_var 0),
           template_var 3),
         template_hole 0))),
    ("TypeComp.drop_Cons_Suc",
     "drop ?n ?xs = ?y # ?ys ==> drop (Suc ?n) ?xs = ?ys",
     template_implication
      ([template_equation
         (template_app
           (template_app (template_hole 2, template_var 3), template_var 2),
          template_app
           (template_app (template_hole 1, template_var 1),
            template_var 0))],
       template_equation
        (template_app
          (template_app
            (template_hole 2,
             template_app (template_hole 0, template_var 3)),
           template_var 2),
         template_var 0))),
    ("TypeComp.relevant_entries_shift",
     "relevant_entries ?P ?i (?pc + ?n) (TypeComp.shift ?n ?xt) =
      TypeComp.shift ?n (relevant_entries ?P ?i ?pc ?xt)",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_app (template_hole 2, template_var 4),
             template_var 3),
           template_app
            (template_app (template_hole 1, template_var 2),
             template_var 1)),
         template_app
          (template_app (template_hole 0, template_var 1), template_var 0)),
       template_app
        (template_app (template_hole 0, template_var 1),
         template_app
          (template_app
            (template_app
              (template_app (template_hole 2, template_var 4),
               template_var 3),
             template_var 2),
           template_var 0)))),
    ("TypeComp.compxE\<^sub>2_size_convs",
     "?n ~= 0 ==>
      compxE\<^sub>2 ?e ?n ?d = TypeComp.shift ?n (compxE\<^sub>2 ?e 0 ?d)",
     template_implication
      ([template_negation
         (template_equation (template_var 2, template_hole 3))],
       template_equation
        (template_app
          (template_app
            (template_app (template_hole 1, template_var 1),
             template_var 2),
           template_var 0),
         template_app
          (template_app (template_hole 0, template_var 2),
           template_app
            (template_app
              (template_app (template_hole 1, template_var 1),
               template_hole 3),
             template_var 0))))),
    ("TypeComp.compxE\<^sub>2_size_convs",
     "?n ~= 0 ==>
      compxEs\<^sub>2 ?es ?n ?d =
      TypeComp.shift ?n (compxEs\<^sub>2 ?es 0 ?d)",
     template_implication
      ([template_negation
         (template_equation (template_var 2, template_hole 3))],
       template_equation
        (template_app
          (template_app
            (template_app (template_hole 1, template_var 1),
             template_var 2),
           template_var 0),
         template_app
          (template_app (template_hole 0, template_var 2),
           template_app
            (template_app
              (template_app (template_hole 1, template_var 1),
               template_hole 3),
             template_var 0))))),
    ("TypeComp.wt_instr_appLx",
     "[| ?P,?T,?m,?mpc,?xt \<turnstile> ?i,?pc :: ?\<tau>s;
         ?pc ~: pcs ?xt' |]
      ==> ?P,?T,?m,?mpc,?xt' @ ?xt \<turnstile> ?i,?pc :: ?\<tau>s",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app
                   (template_app
                     (template_app
                       (template_app
                         (template_app (template_hole 4, template_var 8),
                          template_var 7),
                        template_var 6),
                      template_var 5),
                    template_var 4),
                  template_var 3),
                template_var 2),
              template_var 1)
            ),
        template_negation
         (
            template_predicate
             (
                template_app
                 (template_app (template_hole 2, template_var 2),
                  template_app (template_hole 1, template_var 0))
                )
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_app
                  (template_app
                    (template_app
                      (template_app
                        (template_app (template_hole 4, template_var 8),
                         template_var 7),
                       template_var 6),
                     template_var 5),
                   template_app
                    (template_app (template_hole 0, template_var 0),
                     template_var 4)),
                 template_var 3),
               template_var 2),
             template_var 1)
           ))),
    ("TypeComp.drop_mess",
     "[| Suc (length ?xs\<^sub>0) <= length ?xs;
         drop (length ?xs - Suc (length ?xs\<^sub>0)) ?xs =
         ?x # ?xs\<^sub>0 |]
      ==> drop (length ?xs - length ?xs\<^sub>0) ?xs = ?xs\<^sub>0",
     template_implication
      ([template_inequation
         (less_equals,
          template_app
           (template_hole 5,
            template_app (template_hole 4, template_var 2)),
          template_app (template_hole 4, template_var 1)),
        template_equation
         (template_app
           (template_app
             (template_hole 2,
              template_app
               (template_app
                 (template_hole 1,
                  template_app (template_hole 4, template_var 1)),
                template_app
                 (template_hole 5,
                  template_app (template_hole 4, template_var 2)))),
            template_var 1),
          template_app
           (template_app (template_hole 0, template_var 0),
            template_var 2))],
       template_equation
        (template_app
          (template_app
            (template_hole 2,
             template_app
              (template_app
                (template_hole 1,
                 template_app (template_hole 4, template_var 1)),
               template_app (template_hole 4, template_var 2))),
           template_var 1),
         template_var 2))),
    ("TypeComp.wt_instr_appL",
     "[| ?P,?T,?m,?mpc,?xt \<turnstile> ?i,?pc :: ?\<tau>s;
         ?pc < length ?\<tau>s; ?mpc <= length ?\<tau>s |]
      ==> ?P,?T,?m,?mpc +
                   length
                    ?\<tau>s',TypeComp.shift (length ?\<tau>s')
                               ?xt \<turnstile> ?i,?pc +
             length ?\<tau>s' :: ?\<tau>s' @ ?\<tau>s",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app
                   (template_app
                     (template_app
                       (template_app
                         (template_app (template_hole 6, template_var 8),
                          template_var 7),
                        template_var 6),
                      template_var 5),
                    template_var 4),
                  template_var 3),
                template_var 2),
              template_var 1)
            ),
        template_inequation
         (less_than, template_var 2,
          template_app (template_hole 4, template_var 1)),
        template_inequation
         (less_equals, template_var 5,
          template_app (template_hole 4, template_var 1))],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_app
                  (template_app
                    (template_app
                      (template_app
                        (template_app (template_hole 6, template_var 8),
                         template_var 7),
                       template_var 6),
                     template_app
                      (template_app (template_hole 2, template_var 5),
                       template_app (template_hole 4, template_var 0))),
                   template_app
                    (template_app
                      (template_hole 1,
                       template_app (template_hole 4, template_var 0)),
                     template_var 4)),
                 template_var 3),
               template_app
                (template_app (template_hole 2, template_var 2),
                 template_app (template_hole 4, template_var 0))),
             template_app
              (template_app (template_hole 0, template_var 0),
               template_var 1))
           ))),
    ("TypeComp.wt_Goto",
     "[| 0 <= int ?pc + ?i; nat (int ?pc + ?i) < length ?\<tau>s;
         length ?\<tau>s <= ?mpc;
         ?P |- ?\<tau>s ! ?pc <=?\<tau>s ! nat (int ?pc + ?i) |]
      ==> ?P,?T,?mxs,?mpc,[] \<turnstile> Goto ?i,?pc :: ?\<tau>s",
     template_implication
      ([template_inequation
         (less_equals, template_hole 11,
          template_app
           (template_app
             (template_hole 10,
              template_app (template_hole 9, template_var 6)),
            template_var 5)),
        template_inequation
         (less_than,
          template_app
           (template_hole 7,
            template_app
             (template_app
               (template_hole 10,
                template_app (template_hole 9, template_var 6)),
              template_var 5)),
          template_app (template_hole 6, template_var 4)),
        template_inequation
         (less_equals, template_app (template_hole 6, template_var 4),
          template_var 3),
        template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 4, template_var 2),
                template_app
                 (template_app (template_hole 3, template_var 4),
                  template_var 6)),
              template_app
               (template_app (template_hole 3, template_var 4),
                template_app
                 (template_hole 7,
                  template_app
                   (template_app
                     (template_hole 10,
                      template_app (template_hole 9, template_var 6)),
                    template_var 5))))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_app
                  (template_app
                    (template_app
                      (template_app
                        (template_app (template_hole 2, template_var 2),
                         template_var 1),
                       template_var 0),
                     template_var 3),
                   template_hole 1),
                 template_app (template_hole 0, template_var 5)),
               template_var 6),
             template_var 4)
           ))),
    ("TypeComp.wt_instr_appRx",
     "[| ?P,?T,?m,?mpc,?xt \<turnstile> ?is ! ?pc,?pc :: ?\<tau>s;
         ?pc < length ?is; length ?is < length ?\<tau>s;
         ?mpc <= length ?\<tau>s |]
      ==> ?P,?T,?m,?mpc,?xt @
                        TypeComp.shift (length ?is)
                         ?xt' \<turnstile> ?is ! ?pc,?pc :: ?\<tau>s",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app
                   (template_app
                     (template_app
                       (template_app
                         (template_app (template_hole 7, template_var 8),
                          template_var 7),
                        template_var 6),
                      template_var 5),
                    template_var 4),
                  template_app
                   (template_app (template_hole 6, template_var 3),
                    template_var 2)),
                template_var 2),
              template_var 1)
            ),
        template_inequation
         (less_than, template_var 2,
          template_app (template_hole 4, template_var 3)),
        template_inequation
         (less_than, template_app (template_hole 4, template_var 3),
          template_app (template_hole 3, template_var 1)),
        template_inequation
         (less_equals, template_var 5,
          template_app (template_hole 3, template_var 1))],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_app
                  (template_app
                    (template_app
                      (template_app
                        (template_app (template_hole 7, template_var 8),
                         template_var 7),
                       template_var 6),
                     template_var 5),
                   template_app
                    (template_app (template_hole 1, template_var 4),
                     template_app
                      (template_app
                        (template_hole 0,
                         template_app (template_hole 4, template_var 3)),
                       template_var 0))),
                 template_app
                  (template_app (template_hole 6, template_var 3),
                   template_var 2)),
               template_var 2),
             template_var 1)
           ))),
    ("TypeComp.wt_instr_appR",
     "[| ?P,?T,?m,?mpc,?xt \<turnstile> ?is ! ?pc,?pc :: ?\<tau>s;
         ?pc < length ?is; length ?is < length ?\<tau>s;
         ?mpc <= length ?\<tau>s; ?mpc <= ?mpc' |]
      ==> ?P,?T,?m,?mpc',?xt \<turnstile> ?is !
    ?pc,?pc :: ?\<tau>s @ ?\<tau>s'",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app
                   (template_app
                     (template_app
                       (template_app
                         (template_app (template_hole 6, template_var 9),
                          template_var 8),
                        template_var 7),
                      template_var 6),
                    template_var 5),
                  template_app
                   (template_app (template_hole 5, template_var 4),
                    template_var 3)),
                template_var 3),
              template_var 2)
            ),
        template_inequation
         (less_than, template_var 3,
          template_app (template_hole 3, template_var 4)),
        template_inequation
         (less_than, template_app (template_hole 3, template_var 4),
          template_app (template_hole 2, template_var 2)),
        template_inequation
         (less_equals, template_var 6,
          template_app (template_hole 2, template_var 2)),
        template_inequation (less_equals, template_var 6, template_var 1)],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_app
                  (template_app
                    (template_app
                      (template_app
                        (template_app (template_hole 6, template_var 9),
                         template_var 8),
                       template_var 7),
                     template_var 1),
                   template_var 5),
                 template_app
                  (template_app (template_hole 5, template_var 4),
                   template_var 3)),
               template_var 3),
             template_app
              (template_app (template_hole 0, template_var 2),
               template_var 0))
           ))),
    ("TypeComp.wt_instr_Cons",
     "[| ?P,?T,?m,?mpc - 1,[] \<turnstile> ?i,?pc - 1 :: ?\<tau>s; 0 < ?pc;
         0 < ?mpc; ?pc < length ?\<tau>s + 1; ?mpc <= length ?\<tau>s + 1 |]
      ==> ?P,?T,?m,?mpc,[] \<turnstile> ?i,?pc :: ?\<tau> # ?\<tau>s",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app
                   (template_app
                     (template_app
                       (template_app
                         (template_app (template_hole 9, template_var 7),
                          template_var 6),
                        template_var 5),
                      template_app
                       (template_app (template_hole 8, template_var 4),
                        template_hole 7)),
                    template_hole 6),
                  template_var 3),
                template_app
                 (template_app (template_hole 8, template_var 2),
                  template_hole 7)),
              template_var 1)
            ),
        template_inequation (less_than, template_hole 4, template_var 2),
        template_inequation (less_than, template_hole 4, template_var 4),
        template_inequation
         (less_than, template_var 2,
          template_app
           (template_app
             (template_hole 3,
              template_app (template_hole 2, template_var 1)),
            template_hole 7)),
        template_inequation
         (less_equals, template_var 4,
          template_app
           (template_app
             (template_hole 3,
              template_app (template_hole 2, template_var 1)),
            template_hole 7))],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_app
                  (template_app
                    (template_app
                      (template_app
                        (template_app (template_hole 9, template_var 7),
                         template_var 6),
                       template_var 5),
                     template_var 4),
                   template_hole 6),
                 template_var 3),
               template_var 2),
             template_app
              (template_app (template_hole 0, template_var 0),
               template_var 1))
           ))),
    ("TypeComp.wt_instr_append",
     "[| ?P,?T,?m,?mpc -
                  length
                   ?\<tau>s',[] \<turnstile> ?i,?pc -
          length ?\<tau>s' :: ?\<tau>s;
         length ?\<tau>s' <= ?pc; length ?\<tau>s' <= ?mpc;
         ?pc < length ?\<tau>s + length ?\<tau>s';
         ?mpc <= length ?\<tau>s + length ?\<tau>s' |]
      ==> ?P,?T,?m,?mpc,[] \<turnstile> ?i,?pc :: ?\<tau>s' @ ?\<tau>s",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app
                   (template_app
                     (template_app
                       (template_app
                         (template_app (template_hole 7, template_var 7),
                          template_var 6),
                        template_var 5),
                      template_app
                       (template_app (template_hole 6, template_var 4),
                        template_app (template_hole 5, template_var 3))),
                    template_hole 4),
                  template_var 2),
                template_app
                 (template_app (template_hole 6, template_var 1),
                  template_app (template_hole 5, template_var 3))),
              template_var 0)
            ),
        template_inequation
         (less_equals, template_app (template_hole 5, template_var 3),
          template_var 1),
        template_inequation
         (less_equals, template_app (template_hole 5, template_var 3),
          template_var 4),
        template_inequation
         (less_than, template_var 1,
          template_app
           (template_app
             (template_hole 1,
              template_app (template_hole 5, template_var 0)),
            template_app (template_hole 5, template_var 3))),
        template_inequation
         (less_equals, template_var 4,
          template_app
           (template_app
             (template_hole 1,
              template_app (template_hole 5, template_var 0)),
            template_app (template_hole 5, template_var 3)))],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_app
                  (template_app
                    (template_app
                      (template_app
                        (template_app (template_hole 7, template_var 7),
                         template_var 6),
                       template_var 5),
                     template_var 4),
                   template_hole 4),
                 template_var 2),
               template_var 1),
             template_app
              (template_app (template_hole 0, template_var 3),
               template_var 0))
           )))]:
   (string * thm * template) list
### theory "Draft.TypeCompMoreTemplates"
### 0.488s elapsed time, 0.746s cpu time, 0.106s GC time
*** Undefined fact: "wti" (line 476 of "$AFP/Jinja/Compiler/TypeComp.thy")
*** At command "thm" (line 476 of "$AFP/Jinja/Compiler/TypeComp.thy")
Exception- TOPLEVEL_ERROR raised
