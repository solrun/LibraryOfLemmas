Loading theory "Draft.Auxiliary" (required by "Draft.J1MoreTemplates" via "Draft.J1" via "Draft.BigStep" via "Draft.Expr" via "Draft.Exceptions" via "Draft.Objects" via "Draft.TypeRel" via "Draft.Decl" via "Draft.Type")
Loading theory "HOL-Library.Function_Algebras" (required by "Draft.J1MoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
Loading theory "HOL-Library.Nat_Bijection" (required by "Draft.J1MoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.Stream")
Loading theory "HOL-Library.Set_Algebras" (required by "Draft.J1MoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
instantiation
  fun :: (type, plus) plus
  plus_fun == plus :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  set :: (plus) plus
  plus_set == plus :: 'a set => 'a set => 'a set
### Ignoring duplicate safe elimination (elim!)
### [| ?x # ?xs = map ?f ?ys;
###    EX z zs. ?ys = z # zs & ?x = ?f z & ?xs = map ?f zs ==> PROP ?W |]
### ==> PROP ?W
### Ignoring duplicate safe elimination (elim!)
### [| ?x # ?xs = map ?f ?ys;
###    EX z zs. ?ys = z # zs & ?x = ?f z & ?xs = map ?f zs ==> PROP ?W |]
### ==> PROP ?W
instantiation
  fun :: (type, zero) zero
  zero_fun == zero_class.zero :: 'a => 'b
instantiation
  set :: (times) times
  times_set == times :: 'a set => 'a set => 'a set
instantiation
  fun :: (type, times) times
  times_fun == times :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  set :: (zero) zero
  zero_set == zero_class.zero :: 'a set
instantiation
  fun :: (type, one) one
  one_fun == one_class.one :: 'a => 'b
instantiation
  set :: (one) one
  one_set == one_class.one :: 'a set
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
### theory "HOL-Library.Function_Algebras"
### 0.122s elapsed time, 0.502s cpu time, 0.037s GC time
Loading theory "HOL-Library.Transitive_Closure_Table" (required by "Draft.J1MoreTemplates" via "Draft.J1" via "Draft.BigStep" via "Draft.Expr" via "Draft.Exceptions" via "Draft.Objects" via "Draft.TypeRel")
Proofs for inductive predicate(s) "rtrancl_path"
  Proving monotonicity ...
### theory "Draft.Auxiliary"
### 0.177s elapsed time, 0.723s cpu time, 0.037s GC time
Loading theory "Draft.Type" (required by "Draft.J1MoreTemplates" via "Draft.J1" via "Draft.BigStep" via "Draft.Expr" via "Draft.Exceptions" via "Draft.Objects" via "Draft.TypeRel" via "Draft.Decl")
Proofs for inductive predicate(s) "rtrancl_tab"
  Proving monotonicity ...
Found termination order: "size_list size <*mlex*> {}"
### theory "HOL-Library.Set_Algebras"
### 0.256s elapsed time, 1.035s cpu time, 0.037s GC time
Loading theory "HOL-Library.Tree" (required by "Draft.J1MoreTemplates" via "Draft.ExtrEqs" via "Draft.Templates")
### theory "HOL-Library.Nat_Bijection"
### 0.309s elapsed time, 1.230s cpu time, 0.110s GC time
Loading theory "HOL-Library.Stream" (required by "Draft.J1MoreTemplates" via "Draft.ExtrEqs")
### theory "HOL-Library.Transitive_Closure_Table"
### 0.266s elapsed time, 1.051s cpu time, 0.073s GC time
Loading theory "HOL-Library.BigO" (required by "Draft.J1MoreTemplates" via "Draft.ExtrEqs")
consts
  shift :: "'a list => 'a stream => 'a stream"
Proofs for coinductive predicate(s) "streamsp"
  Proving monotonicity ...
consts
  left :: "'a tree => 'a tree"
consts
  right :: "'a tree => 'a tree"
consts
  snth :: "'a stream => nat => 'a"
consts
  stake :: "nat => 'a stream => 'a list"
consts
  sdrop :: "nat => 'a stream => 'a stream"
Found termination order: "size <*mlex*> {}"
### theory "Draft.Type"
### 0.710s elapsed time, 2.790s cpu time, 0.278s GC time
Loading theory "Draft.Decl" (required by "Draft.J1MoreTemplates" via "Draft.J1" via "Draft.BigStep" via "Draft.Expr" via "Draft.Exceptions" via "Draft.Objects" via "Draft.TypeRel")
consts
  sfilter :: "('a => bool) => 'a stream => 'a stream"
Found termination order: "size <*mlex*> {}"
consts
  cycle :: "'a list => 'a stream"
### theory "Draft.Decl"
### 0.072s elapsed time, 0.288s cpu time, 0.000s GC time
Loading theory "Draft.TypeRel" (required by "Draft.J1MoreTemplates" via "Draft.J1" via "Draft.BigStep" via "Draft.Expr" via "Draft.Exceptions" via "Draft.Objects")
consts
  siterate :: "('a => 'a) => 'a => 'a stream"
Found termination order: "size <*mlex*> {}"
consts
  flat :: "'a list stream => 'a stream"
class height = type +
  fixes height :: "'a => nat"
instantiation
  tree :: (type) height
  height_tree == height :: 'a tree => nat
consts
  sinterleave :: "'a stream => 'a stream => 'a stream"
consts
  szip :: "'a stream => 'b stream => ('a * 'b) stream"
Found termination order: "size <*mlex*> {}"
consts
  smap2 :: "('a => 'b => 'c) => 'a stream => 'b stream => 'c stream"
Proofs for inductive predicate(s) "subcls1p"
  Proving monotonicity ...
### theory "HOL-Library.Stream"
### 1.055s elapsed time, 4.016s cpu time, 0.853s GC time
Found termination order: "size <*mlex*> {}"
### theory "HOL-Library.BigO"
### 1.020s elapsed time, 3.847s cpu time, 0.890s GC time
consts
  supercls_lst :: "'m prog => char list list => bool"
Proofs for inductive predicate(s) "widen"
Found termination order: "size <*mlex*> {}"
  Proving monotonicity ...
Proofs for inductive predicate(s) "Methods"
Found termination order: "size <*mlex*> {}"
  Proving monotonicity ...
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Proofs for inductive predicate(s) "Fields"
  Proving monotonicity ...
Found termination order: "size <*mlex*> {}"
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
### theory "Draft.TypeRel"
### 0.908s elapsed time, 2.518s cpu time, 0.675s GC time
Loading theory "Draft.Value" (required by "Draft.J1MoreTemplates" via "Draft.J1" via "Draft.BigStep" via "Draft.Expr" via "Draft.Exceptions" via "Draft.Objects")
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
### No equation for constructor "Unit"
### No equation for constructor "Null"
### No equation for constructor "Bool"
### No equation for constructor "Addr"
consts
  the_Intg :: "val => int"
### theory "HOL-Library.Tree"
### 1.966s elapsed time, 6.055s cpu time, 1.059s GC time
Loading theory "Draft.Templates" (required by "Draft.J1MoreTemplates" via "Draft.ExtrEqs")
### No equation for constructor "Unit"
### No equation for constructor "Null"
### No equation for constructor "Bool"
### No equation for constructor "Intg"
consts
  the_Addr :: "val => nat"
consts
  default_val :: "ty => val"
### theory "Draft.Value"
### 0.362s elapsed time, 0.773s cpu time, 0.107s GC time
Loading theory "Draft.Objects" (required by "Draft.J1MoreTemplates" via "Draft.J1" via "Draft.BigStep" via "Draft.Expr" via "Draft.Exceptions")
datatype template_term
=
     t_empty
   | template_app of template_term * template_term
   | template_hole of int
   | template_var of int
datatype sign
= equals | greater_equals | greater_than | less_equals | less_than
datatype template
=
     template_bimplication of template * template
   | template_dunno
   | template_equation of template_term * template_term
   | template_implication of template list * template
   | template_inequation of sign * template_term * template_term
   | template_negation of template
   | template_predicate of template_term
constructor t_empty: template_term
constructor template_app: template_term * template_term -> template_term
constructor template_hole: int -> template_term
constructor template_var: int -> template_term
constructor equals: sign
constructor greater_equals: sign
constructor greater_than: sign
constructor less_equals: sign
constructor less_than: sign
constructor template_bimplication: template * template -> template
constructor template_dunno: template
constructor template_equation: template_term * template_term -> template
constructor template_implication: template list * template -> template
constructor template_inequation:
   sign * template_term * template_term -> template
constructor template_negation: template -> template
constructor template_predicate: template_term -> template
val vfs = fn: term -> (indexname * typ) list * (string * typ) list
val indexOf = fn: ''a list -> ''a -> int -> int
val has_eq = fn: term -> bool
val term2template = fn:
   (indexname * typ) list -> (string * typ) list -> term -> template_term
val lemma2predicate = fn: term -> term -> template
val makeTemplatewithContext = fn: term -> term -> template
val lemma2template = fn: term -> template
val thm2template = fn: thm -> template
val tterm2string = fn: template_term -> string
val template2string = fn: template -> string
val t = "height ?t <= size ?t": thm
val th =
   Const ("HOL.Trueprop", "bool => prop") $
     (Const ("Orderings.ord_class.less_eq", "nat => nat => bool") $
       (Const ("Tree.height_class.height", "?'a tree => nat") $
         Var (("t", 0), "?'a tree")) $
       (Const ("Nat.size_class.size", "?'a tree => nat") $
         Var (("t", 0), "?'a tree"))):
   term
### theory "Draft.Templates"
### 0.052s elapsed time, 0.106s cpu time, 0.000s GC time
Loading theory "Draft.ExtrEqs" (required by "Draft.J1MoreTemplates")
consts
  typeof_h :: "heap => val => ty option"
Proofs for inductive predicate(s) "iprog"
  Proving monotonicity ...
### theory "Draft.Objects"
### 0.469s elapsed time, 0.982s cpu time, 0.105s GC time
Loading theory "Draft.Exceptions" (required by "Draft.J1MoreTemplates" via "Draft.J1" via "Draft.BigStep" via "Draft.Expr")
val eqpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Var (("_dummy_", 2), "?'a"))
       ):
   term Find_Theorems.criterion
val badeqpattern = Pattern (Const ("Pure.eq", "?'a => ?'a => prop")):
   term Find_Theorems.criterion
val undefpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Const ("HOL.undefined", "?'a"))
       ):
   term Find_Theorems.criterion
val thmpattern =
   Pattern
    (Const ("HOL.Trueprop", "bool => prop") $ Var (("_dummy_", 1), "bool")):
   term Find_Theorems.criterion
val badnames =
   ["*nitpick*", "*Nitpick*", "*full_exhaustive*", "*_def*", "Enum.finite*",
    "*Quickcheck*", "ATP*", "*Nunchaku*", "*Code*", "*BNF*", "*SMT*",
    "*.*.*"]:
   string list
val unwanted_names =
   [(false, Name "*nitpick*"), (false, Name "*Nitpick*"),
    (false, Name "*full_exhaustive*"), (false, Name "*_def*"),
    (false, Name "Enum.finite*"), (false, Name "*Quickcheck*"),
    (false, Name "ATP*"), (false, Name "*Nunchaku*"),
    (false, Name "*Code*"), (false, Name "*BNF*"), (false, Name "*SMT*"),
    (false, Name "*.*.*")]:
   (bool * term Find_Theorems.criterion) list
val has_vars = fn: term -> bool
val get_all_eqs = fn: string -> Proof.context -> (string * thm) list
val get_all_thms = fn: string -> Proof.context -> (string * thm) list
val get_noneq_thms = fn: string -> Proof.context -> (string * thm) list
val template_eqs = fn:
   string -> Proof.context -> (string * thm * template) list
val template_thms = fn:
   string -> Proof.context -> (string * thm * template) list
### theory "Draft.ExtrEqs"
### 0.527s elapsed time, 1.102s cpu time, 0.105s GC time
### theory "Draft.Exceptions"
### 0.137s elapsed time, 0.233s cpu time, 0.000s GC time
Loading theory "Draft.Expr" (required by "Draft.J1MoreTemplates" via "Draft.J1" via "Draft.BigStep")
Loading theory "Draft.State" (required by "Draft.J1MoreTemplates" via "Draft.J1" via "Draft.BigStep")
Loading theory "Draft.SystemClasses" (required by "Draft.J1MoreTemplates" via "Draft.J1" via "Draft.BigStep" via "Draft.WWellForm" via "Draft.WellForm")
### theory "Draft.State"
### 0.033s elapsed time, 0.097s cpu time, 0.000s GC time
### theory "Draft.SystemClasses"
### 0.076s elapsed time, 0.206s cpu time, 0.050s GC time
Loading theory "Draft.WellForm" (required by "Draft.J1MoreTemplates" via "Draft.J1" via "Draft.BigStep" via "Draft.WWellForm")
### theory "Draft.WellForm"
### 0.241s elapsed time, 0.505s cpu time, 0.057s GC time
Found termination order: "{}"
### Ambiguous input (line 129 of "$AFP/JinjaDCI/J/Expr.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_Update" ("_position" fv)
###       ("_updbind"
###         ("\<^const>Expr.exp.FAcc" ("_position" e\<^sub>1) ("_position" F)
###           ("_position" D))
###         ("_position" e\<^sub>2)))
###     ("\<^const>Set.union"
###       ("_applC" ("_position" fv) ("_position" e\<^sub>1))
###       ("_applC" ("_position" fv) ("_position" e\<^sub>2)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" fv)
###       ("\<^const>Expr.exp.FAss" ("_position" e\<^sub>1) ("_position" F)
###         ("_position" D) ("_position" e\<^sub>2)))
###     ("\<^const>Set.union"
###       ("_applC" ("_position" fv) ("_position" e\<^sub>1))
###       ("_applC" ("_position" fv) ("_position" e\<^sub>2)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" fv)
###       ("\<^const>Expr.exp.LAss"
###         ("\<^const>Expr.exp.FAcc" ("_position" e\<^sub>1) ("_position" F)
###           ("_position" D))
###         ("_position" e\<^sub>2)))
###     ("\<^const>Set.union"
###       ("_applC" ("_position" fv) ("_position" e\<^sub>1))
###       ("_applC" ("_position" fv) ("_position" e\<^sub>2)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 130 of "$AFP/JinjaDCI/J/Expr.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_Update" ("_position" fv)
###       ("_updbind"
###         ("\<^const>Expr.exp.SFAcc" ("_position" C) ("_position" F)
###           ("_position" D))
###         ("_position" e\<^sub>2)))
###     ("_applC" ("_position" fv) ("_position" e\<^sub>2))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" fv)
###       ("\<^const>Expr.exp.SFAss" ("_position" C) ("_position" F)
###         ("_position" D) ("_position" e\<^sub>2)))
###     ("_applC" ("_position" fv) ("_position" e\<^sub>2))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" fv)
###       ("\<^const>Expr.exp.LAss"
###         ("\<^const>Expr.exp.SFAcc" ("_position" C) ("_position" F)
###           ("_position" D))
###         ("_position" e\<^sub>2)))
###     ("_applC" ("_position" fv) ("_position" e\<^sub>2))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
consts
  fv :: "char list exp => char list set"
  fvs :: "char list exp list => char list set"
Found termination order: "{}"
### Ambiguous input (line 161 of "$AFP/JinjaDCI/J/Expr.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" lass_val_of)
###       ("\<^const>Expr.exp.LAss" ("_position" V)
###         ("_applC" ("_position" Val) ("_position" v))))
###     ("_applC" ("_position" Some)
###       ("_tuple" ("_position" V) ("_tuple_arg" ("_position" v))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_Update" ("_position" lass_val_of)
###       ("_updbind" ("_position" V)
###         ("_applC" ("_position" Val) ("_position" v))))
###     ("_applC" ("_position" Some)
###       ("_tuple" ("_position" V) ("_tuple_arg" ("_position" v))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Found termination order: "{}"
Found termination order: "size_list size <*mlex*> {}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
### Ambiguous input (line 252 of "$AFP/JinjaDCI/J/Expr.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_Update" ("_position" sub_RI)
###       ("_updbind"
###         ("\<^const>Expr.exp.FAcc" ("_position" e\<^sub>1) ("_position" F)
###           ("_position" D))
###         ("_position" e\<^sub>2)))
###     ("\<^const>HOL.disj"
###       ("_applC" ("_position" sub_RI) ("_position" e\<^sub>1))
###       ("_applC" ("_position" sub_RI) ("_position" e\<^sub>2)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" sub_RI)
###       ("\<^const>Expr.exp.FAss" ("_position" e\<^sub>1) ("_position" F)
###         ("_position" D) ("_position" e\<^sub>2)))
###     ("\<^const>HOL.disj"
###       ("_applC" ("_position" sub_RI) ("_position" e\<^sub>1))
###       ("_applC" ("_position" sub_RI) ("_position" e\<^sub>2)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" sub_RI)
###       ("\<^const>Expr.exp.LAss"
###         ("\<^const>Expr.exp.FAcc" ("_position" e\<^sub>1) ("_position" F)
###           ("_position" D))
###         ("_position" e\<^sub>2)))
###     ("\<^const>HOL.disj"
###       ("_applC" ("_position" sub_RI) ("_position" e\<^sub>1))
###       ("_applC" ("_position" sub_RI) ("_position" e\<^sub>2)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 253 of "$AFP/JinjaDCI/J/Expr.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_Update" ("_position" sub_RI)
###       ("_updbind"
###         ("\<^const>Expr.exp.SFAcc" ("_position" C) ("_position" F)
###           ("_position" D))
###         ("_position" e\<^sub>2)))
###     ("_applC" ("_position" sub_RI) ("_position" e\<^sub>2))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" sub_RI)
###       ("\<^const>Expr.exp.SFAss" ("_position" C) ("_position" F)
###         ("_position" D) ("_position" e\<^sub>2)))
###     ("_applC" ("_position" sub_RI) ("_position" e\<^sub>2))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" sub_RI)
###       ("\<^const>Expr.exp.LAss"
###         ("\<^const>Expr.exp.SFAcc" ("_position" C) ("_position" F)
###           ("_position" D))
###         ("_position" e\<^sub>2)))
###     ("_applC" ("_position" sub_RI) ("_position" e\<^sub>2))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
consts
  sub_RI :: "'a exp => bool"
  sub_RIs :: "'a exp list => bool"
### Ambiguous input (line 295 of "$AFP/JinjaDCI/J/Expr.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" not_init)
###       ("_cargs" ("_position" C')
###         ("\<^const>Expr.exp.FAss" ("_position" e\<^sub>1) ("_position" F)
###           ("_position" D) ("_position" e\<^sub>2))))
###     ("\<^const>HOL.conj"
###       ("_applC" ("_position" not_init)
###         ("_cargs" ("_position" C') ("_position" e\<^sub>1)))
###       ("_applC" ("_position" not_init)
###         ("_cargs" ("_position" C') ("_position" e\<^sub>2))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" not_init)
###       ("_cargs" ("_position" C')
###         ("\<^const>Expr.exp.LAss"
###           ("\<^const>Expr.exp.FAcc" ("_position" e\<^sub>1) ("_position" F)
###             ("_position" D))
###           ("_position" e\<^sub>2))))
###     ("\<^const>HOL.conj"
###       ("_applC" ("_position" not_init)
###         ("_cargs" ("_position" C') ("_position" e\<^sub>1)))
###       ("_applC" ("_position" not_init)
###         ("_cargs" ("_position" C') ("_position" e\<^sub>2))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 296 of "$AFP/JinjaDCI/J/Expr.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" not_init)
###       ("_cargs" ("_position" C')
###         ("\<^const>Expr.exp.SFAss" ("_position" C) ("_position" F)
###           ("_position" D) ("_position" e\<^sub>2))))
###     ("_applC" ("_position" not_init)
###       ("_cargs" ("_position" C') ("_position" e\<^sub>2)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" not_init)
###       ("_cargs" ("_position" C')
###         ("\<^const>Expr.exp.LAss"
###           ("\<^const>Expr.exp.SFAcc" ("_position" C) ("_position" F)
###             ("_position" D))
###           ("_position" e\<^sub>2))))
###     ("_applC" ("_position" not_init)
###       ("_cargs" ("_position" C') ("_position" e\<^sub>2)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
consts
  not_init :: "char list => 'a exp => bool"
  not_inits :: "char list => 'a exp list => bool"
### Ambiguous input (line 336 of "$AFP/JinjaDCI/J/Expr.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_Update" ("_position" subexp)
###       ("_updbind"
###         ("\<^const>Expr.exp.FAcc" ("_position" e\<^sub>1) ("_position" F)
###           ("_position" D))
###         ("_position" e\<^sub>2)))
###     ("\<^const>Set.union"
###       ("\<^const>Set.union"
###         ("_Finset"
###           ("_args" ("_position" e\<^sub>1) ("_position" e\<^sub>2)))
###         ("_applC" ("_position" subexp) ("_position" e\<^sub>1)))
###       ("_applC" ("_position" subexp) ("_position" e\<^sub>2)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" subexp)
###       ("\<^const>Expr.exp.FAss" ("_position" e\<^sub>1) ("_position" F)
###         ("_position" D) ("_position" e\<^sub>2)))
###     ("\<^const>Set.union"
###       ("\<^const>Set.union"
###         ("_Finset"
###           ("_args" ("_position" e\<^sub>1) ("_position" e\<^sub>2)))
###         ("_applC" ("_position" subexp) ("_position" e\<^sub>1)))
###       ("_applC" ("_position" subexp) ("_position" e\<^sub>2)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" subexp)
###       ("\<^const>Expr.exp.LAss"
###         ("\<^const>Expr.exp.FAcc" ("_position" e\<^sub>1) ("_position" F)
###           ("_position" D))
###         ("_position" e\<^sub>2)))
###     ("\<^const>Set.union"
###       ("\<^const>Set.union"
###         ("_Finset"
###           ("_args" ("_position" e\<^sub>1) ("_position" e\<^sub>2)))
###         ("_applC" ("_position" subexp) ("_position" e\<^sub>1)))
###       ("_applC" ("_position" subexp) ("_position" e\<^sub>2)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 337 of "$AFP/JinjaDCI/J/Expr.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_Update" ("_position" subexp)
###       ("_updbind"
###         ("\<^const>Expr.exp.SFAcc" ("_position" C) ("_position" F)
###           ("_position" D))
###         ("_position" e\<^sub>2)))
###     ("\<^const>Set.union" ("_Finset" ("_position" e\<^sub>2))
###       ("_applC" ("_position" subexp) ("_position" e\<^sub>2)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" subexp)
###       ("\<^const>Expr.exp.SFAss" ("_position" C) ("_position" F)
###         ("_position" D) ("_position" e\<^sub>2)))
###     ("\<^const>Set.union" ("_Finset" ("_position" e\<^sub>2))
###       ("_applC" ("_position" subexp) ("_position" e\<^sub>2)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" subexp)
###       ("\<^const>Expr.exp.LAss"
###         ("\<^const>Expr.exp.SFAcc" ("_position" C) ("_position" F)
###           ("_position" D))
###         ("_position" e\<^sub>2)))
###     ("\<^const>Set.union" ("_Finset" ("_position" e\<^sub>2))
###       ("_applC" ("_position" subexp) ("_position" e\<^sub>2)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
consts
  subexp :: "'a exp => 'a exp set"
  subexps :: "'a exp list => 'a exp set"
### theory "Draft.Expr"
### 7.387s elapsed time, 9.982s cpu time, 2.639s GC time
Loading theory "Draft.WWellForm" (required by "Draft.J1MoreTemplates" via "Draft.J1" via "Draft.BigStep")
### theory "Draft.WWellForm"
### 0.152s elapsed time, 0.199s cpu time, 0.000s GC time
Loading theory "Draft.BigStep" (required by "Draft.J1MoreTemplates" via "Draft.J1")
### Ambiguous input (line 157 of "$AFP/JinjaDCI/J/BigStep.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval" ("_position" P) ("_position" e\<^sub>1)
###         ("_position" s\<^sub>0)
###         ("_applC" ("_position" addr) ("_position" a))
###         ("_position" s\<^sub>1)))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^fixed>eval" ("_position" P) ("_position" e\<^sub>2)
###           ("_position" s\<^sub>1)
###           ("_applC" ("_position" Val) ("_position" v))
###           ("_tuple" ("_position" h\<^sub>2)
###             ("_tuple_args" ("_position" l\<^sub>2)
###               ("_tuple_arg" ("_position" sh\<^sub>2))))))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" h\<^sub>2) ("_position" a))
###             ("_applC" ("_position" Some)
###               ("_tuple" ("_position" C) ("_tuple_arg" ("_position" fs))))))
###         ("_asm"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.Not"
###               ("\<^const>HOL.Ex_binder"
###                 ("_idts" ("_position" b) ("_position" t))
###                 ("\<^const>TypeRel.has_field" ("_position" P)
###                   ("_position" C) ("_position" F) ("_position" b)
###                   ("_position" t) ("_position" D)))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval" ("_position" P)
###       ("\<^const>Expr.exp.LAss"
###         ("\<^const>Expr.exp.FAcc" ("_position" e\<^sub>1) ("_position" F)
###           ("_position" D))
###         ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0)
###       ("_applC" ("_position" THROW) ("_position" NoSuchFieldError))
###       ("_tuple" ("_position" h\<^sub>2)
###         ("_tuple_args" ("_position" l\<^sub>2)
###           ("_tuple_arg" ("_position" sh\<^sub>2)))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval" ("_position" P) ("_position" e\<^sub>1)
###         ("_position" s\<^sub>0)
###         ("_applC" ("_position" addr) ("_position" a))
###         ("_position" s\<^sub>1)))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^fixed>eval" ("_position" P) ("_position" e\<^sub>2)
###           ("_position" s\<^sub>1)
###           ("_applC" ("_position" Val) ("_position" v))
###           ("_tuple" ("_position" h\<^sub>2)
###             ("_tuple_args" ("_position" l\<^sub>2)
###               ("_tuple_arg" ("_position" sh\<^sub>2))))))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" h\<^sub>2) ("_position" a))
###             ("_applC" ("_position" Some)
###               ("_tuple" ("_position" C) ("_tuple_arg" ("_position" fs))))))
###         ("_asm"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.Not"
###               ("\<^const>HOL.Ex_binder"
###                 ("_idts" ("_position" b) ("_position" t))
###                 ("\<^const>TypeRel.has_field" ("_position" P)
###                   ("_position" C) ("_position" F) ("_position" b)
###                   ("_position" t) ("_position" D)))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval" ("_position" P)
###       ("\<^const>Expr.exp.FAss" ("_position" e\<^sub>1) ("_position" F)
###         ("_position" D) ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0)
###       ("_applC" ("_position" THROW) ("_position" NoSuchFieldError))
###       ("_tuple" ("_position" h\<^sub>2)
###         ("_tuple_args" ("_position" l\<^sub>2)
###           ("_tuple_arg" ("_position" sh\<^sub>2)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 268 of "$AFP/JinjaDCI/J/BigStep.thy") produces 4 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval" ("_position" P) ("_position" e\<^sub>0)
###       ("_tuple" ("_position" h\<^sub>0)
###         ("_tuple_args"
###           ("_Update" ("_position" l\<^sub>0)
###             ("_updbind" ("_position" V) ("_position" None)))
###           ("_tuple_arg" ("_position" sh\<^sub>0))))
###       ("_position" e\<^sub>1)
###       ("_tuple" ("_position" h\<^sub>1)
###         ("_tuple_args" ("_position" l\<^sub>1)
###           ("_tuple_arg" ("_position" sh\<^sub>1))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval" ("_position" P)
###       ("\<^const>Expr.exp.Block" ("_position" V) ("_position" T)
###         ("_position" e\<^sub>0))
###       ("_tuple" ("_position" h\<^sub>0)
###         ("_tuple_args" ("_position" l\<^sub>0)
###           ("_tuple_arg" ("_position" sh\<^sub>0))))
###       ("_position" e\<^sub>1)
###       ("_tuple" ("_position" h\<^sub>1)
###         ("_tuple_args"
###           ("_applC" ("_position" l\<^sub>1)
###             ("\<^const>Expr.exp.LAss" ("_position" V)
###               ("_applC" ("_position" l\<^sub>0) ("_position" V))))
###           ("_tuple_arg" ("_position" sh\<^sub>1)))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval" ("_position" P) ("_position" e\<^sub>0)
###       ("_tuple" ("_position" h\<^sub>0)
###         ("_tuple_args"
###           ("_applC" ("_position" l\<^sub>0)
###             ("\<^const>Expr.exp.LAss" ("_position" V) ("_position" None)))
###           ("_tuple_arg" ("_position" sh\<^sub>0))))
###       ("_position" e\<^sub>1)
###       ("_tuple" ("_position" h\<^sub>1)
###         ("_tuple_args" ("_position" l\<^sub>1)
###           ("_tuple_arg" ("_position" sh\<^sub>1))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval" ("_position" P)
###       ("\<^const>Expr.exp.Block" ("_position" V) ("_position" T)
###         ("_position" e\<^sub>0))
###       ("_tuple" ("_position" h\<^sub>0)
###         ("_tuple_args" ("_position" l\<^sub>0)
###           ("_tuple_arg" ("_position" sh\<^sub>0))))
###       ("_position" e\<^sub>1)
###       ("_tuple" ("_position" h\<^sub>1)
###         ("_tuple_args"
###           ("_applC" ("_position" l\<^sub>1)
###             ("\<^const>Expr.exp.LAss" ("_position" V)
###               ("_applC" ("_position" l\<^sub>0) ("_position" V))))
###           ("_tuple_arg" ("_position" sh\<^sub>1)))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval" ("_position" P) ("_position" e\<^sub>0)
###       ("_tuple" ("_position" h\<^sub>0)
###         ("_tuple_args"
###           ("_Update" ("_position" l\<^sub>0)
###             ("_updbind" ("_position" V) ("_position" None)))
###           ("_tuple_arg" ("_position" sh\<^sub>0))))
###       ("_position" e\<^sub>1)
###       ("_tuple" ("_position" h\<^sub>1)
###         ("_tuple_args" ("_position" l\<^sub>1)
###           ("_tuple_arg" ("_position" sh\<^sub>1))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval" ("_position" P)
###       ("\<^const>Expr.exp.Block" ("_position" V) ("_position" T)
###         ("_position" e\<^sub>0))
###       ("_tuple" ("_position" h\<^sub>0)
###         ("_tuple_args" ("_position" l\<^sub>0)
###           ("_tuple_arg" ("_position" sh\<^sub>0))))
###       ("_position" e\<^sub>1)
###       ("_tuple" ("_position" h\<^sub>1)
###         ("_tuple_args"
###           ("_Update" ("_position" l\<^sub>1)
###             ("_updbind" ("_position" V)
###               ("_applC" ("_position" l\<^sub>0) ("_position" V))))
###           ("_tuple_arg" ("_position" sh\<^sub>1)))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval" ("_position" P) ("_position" e\<^sub>0)
###       ("_tuple" ("_position" h\<^sub>0)
###         ("_tuple_args"
###           ("_applC" ("_position" l\<^sub>0)
###             ("\<^const>Expr.exp.LAss" ("_position" V) ("_position" None)))
###           ("_tuple_arg" ("_position" sh\<^sub>0))))
###       ("_position" e\<^sub>1)
###       ("_tuple" ("_position" h\<^sub>1)
###         ("_tuple_args" ("_position" l\<^sub>1)
###           ("_tuple_arg" ("_position" sh\<^sub>1))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval" ("_position" P)
###       ("\<^const>Expr.exp.Block" ("_position" V) ("_position" T)
###         ("_position" e\<^sub>0))
###       ("_tuple" ("_position" h\<^sub>0)
###         ("_tuple_args" ("_position" l\<^sub>0)
###           ("_tuple_arg" ("_position" sh\<^sub>0))))
###       ("_position" e\<^sub>1)
###       ("_tuple" ("_position" h\<^sub>1)
###         ("_tuple_args"
###           ("_Update" ("_position" l\<^sub>1)
###             ("_updbind" ("_position" V)
###               ("_applC" ("_position" l\<^sub>0) ("_position" V))))
###           ("_tuple_arg" ("_position" sh\<^sub>1)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 162 of "$AFP/JinjaDCI/J/BigStep.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval" ("_position" P) ("_position" e\<^sub>1)
###         ("_position" s\<^sub>0)
###         ("_applC" ("_position" addr) ("_position" a))
###         ("_position" s\<^sub>1)))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^fixed>eval" ("_position" P) ("_position" e\<^sub>2)
###           ("_position" s\<^sub>1)
###           ("_applC" ("_position" Val) ("_position" v))
###           ("_tuple" ("_position" h\<^sub>2)
###             ("_tuple_args" ("_position" l\<^sub>2)
###               ("_tuple_arg" ("_position" sh\<^sub>2))))))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" h\<^sub>2) ("_position" a))
###             ("_applC" ("_position" Some)
###               ("_tuple" ("_position" C) ("_tuple_arg" ("_position" fs))))))
###         ("_asm"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>TypeRel.has_field" ("_position" P) ("_position" C)
###               ("_position" F) ("_position" Static) ("_position" t)
###               ("_position" D)))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval" ("_position" P)
###       ("\<^const>Expr.exp.LAss"
###         ("\<^const>Expr.exp.FAcc" ("_position" e\<^sub>1) ("_position" F)
###           ("_position" D))
###         ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0)
###       ("_applC" ("_position" THROW)
###         ("_position" IncompatibleClassChangeError))
###       ("_tuple" ("_position" h\<^sub>2)
###         ("_tuple_args" ("_position" l\<^sub>2)
###           ("_tuple_arg" ("_position" sh\<^sub>2)))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval" ("_position" P) ("_position" e\<^sub>1)
###         ("_position" s\<^sub>0)
###         ("_applC" ("_position" addr) ("_position" a))
###         ("_position" s\<^sub>1)))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^fixed>eval" ("_position" P) ("_position" e\<^sub>2)
###           ("_position" s\<^sub>1)
###           ("_applC" ("_position" Val) ("_position" v))
###           ("_tuple" ("_position" h\<^sub>2)
###             ("_tuple_args" ("_position" l\<^sub>2)
###               ("_tuple_arg" ("_position" sh\<^sub>2))))))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" h\<^sub>2) ("_position" a))
###             ("_applC" ("_position" Some)
###               ("_tuple" ("_position" C) ("_tuple_arg" ("_position" fs))))))
###         ("_asm"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>TypeRel.has_field" ("_position" P) ("_position" C)
###               ("_position" F) ("_position" Static) ("_position" t)
###               ("_position" D)))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval" ("_position" P)
###       ("\<^const>Expr.exp.FAss" ("_position" e\<^sub>1) ("_position" F)
###         ("_position" D) ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0)
###       ("_applC" ("_position" THROW)
###         ("_position" IncompatibleClassChangeError))
###       ("_tuple" ("_position" h\<^sub>2)
###         ("_tuple_args" ("_position" l\<^sub>2)
###           ("_tuple_arg" ("_position" sh\<^sub>2)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 139 of "$AFP/JinjaDCI/J/BigStep.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval" ("_position" P) ("_position" e\<^sub>1)
###         ("_position" s\<^sub>0)
###         ("_applC" ("_position" addr) ("_position" a))
###         ("_position" s\<^sub>1)))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^fixed>eval" ("_position" P) ("_position" e\<^sub>2)
###           ("_position" s\<^sub>1)
###           ("_applC" ("_position" Val) ("_position" v))
###           ("_tuple" ("_position" h\<^sub>2)
###             ("_tuple_args" ("_position" l\<^sub>2)
###               ("_tuple_arg" ("_position" sh\<^sub>2))))))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" h\<^sub>2) ("_position" a))
###             ("_applC" ("_position" Some)
###               ("_tuple" ("_position" C) ("_tuple_arg" ("_position" fs))))))
###         ("_asms"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>TypeRel.has_field" ("_position" P) ("_position" C)
###               ("_position" F) ("_position" NonStatic) ("_position" t)
###               ("_position" D)))
###           ("_asms"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq" ("_position" fs')
###                 ("_MapUpd" ("_position" fs)
###                   ("_maplet"
###                     ("_tuple" ("_position" F)
###                       ("_tuple_arg" ("_position" D)))
###                     ("_position" v)))))
###             ("_asm"
###               ("\<^const>HOL.Trueprop"
###                 ("\<^const>HOL.eq" ("_position" h\<^sub>2')
###                   ("_MapUpd" ("_position" h\<^sub>2)
###                     ("_maplet" ("_position" a)
###                       ("_tuple" ("_position" C)
###                         ("_tuple_arg" ("_position" fs')))))))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval" ("_position" P)
###       ("\<^const>Expr.exp.LAss"
###         ("\<^const>Expr.exp.FAcc" ("_position" e\<^sub>1) ("_position" F)
###           ("_position" D))
###         ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0) ("_position" unit)
###       ("_tuple" ("_position" h\<^sub>2')
###         ("_tuple_args" ("_position" l\<^sub>2)
###           ("_tuple_arg" ("_position" sh\<^sub>2)))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval" ("_position" P) ("_position" e\<^sub>1)
###         ("_position" s\<^sub>0)
###         ("_applC" ("_position" addr) ("_position" a))
###         ("_position" s\<^sub>1)))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^fixed>eval" ("_position" P) ("_position" e\<^sub>2)
###           ("_position" s\<^sub>1)
###           ("_applC" ("_position" Val) ("_position" v))
###           ("_tuple" ("_position" h\<^sub>2)
###             ("_tuple_args" ("_position" l\<^sub>2)
###               ("_tuple_arg" ("_position" sh\<^sub>2))))))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" h\<^sub>2) ("_position" a))
###             ("_applC" ("_position" Some)
###               ("_tuple" ("_position" C) ("_tuple_arg" ("_position" fs))))))
###         ("_asms"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>TypeRel.has_field" ("_position" P) ("_position" C)
###               ("_position" F) ("_position" NonStatic) ("_position" t)
###               ("_position" D)))
###           ("_asms"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq" ("_position" fs')
###                 ("_MapUpd" ("_position" fs)
###                   ("_maplet"
###                     ("_tuple" ("_position" F)
###                       ("_tuple_arg" ("_position" D)))
###                     ("_position" v)))))
###             ("_asm"
###               ("\<^const>HOL.Trueprop"
###                 ("\<^const>HOL.eq" ("_position" h\<^sub>2')
###                   ("_MapUpd" ("_position" h\<^sub>2)
###                     ("_maplet" ("_position" a)
###                       ("_tuple" ("_position" C)
###                         ("_tuple_arg" ("_position" fs')))))))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval" ("_position" P)
###       ("\<^const>Expr.exp.FAss" ("_position" e\<^sub>1) ("_position" F)
###         ("_position" D) ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0) ("_position" unit)
###       ("_tuple" ("_position" h\<^sub>2')
###         ("_tuple_args" ("_position" l\<^sub>2)
###           ("_tuple_arg" ("_position" sh\<^sub>2)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 167 of "$AFP/JinjaDCI/J/BigStep.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval" ("_position" P) ("_position" e\<^sub>2)
###         ("_position" s\<^sub>0) ("_applC" ("_position" Val) ("_position" v))
###         ("_tuple" ("_position" h\<^sub>1)
###           ("_tuple_args" ("_position" l\<^sub>1)
###             ("_tuple_arg" ("_position" sh\<^sub>1))))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>TypeRel.has_field" ("_position" P) ("_position" C)
###           ("_position" F) ("_position" Static) ("_position" t)
###           ("_position" D)))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" sh\<^sub>1) ("_position" D))
###             ("_applC" ("_position" Some)
###               ("_tuple" ("_position" sfs)
###                 ("_tuple_arg" ("_position" Done))))))
###         ("_asms"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq" ("_position" sfs')
###               ("_MapUpd" ("_position" sfs)
###                 ("_maplet" ("_position" F) ("_position" v)))))
###           ("_asm"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq" ("_position" sh\<^sub>1')
###                 ("_MapUpd" ("_position" sh\<^sub>1)
###                   ("_maplet" ("_position" D)
###                     ("_tuple" ("_position" sfs')
###                       ("_tuple_arg" ("_position" Done))))))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval" ("_position" P)
###       ("\<^const>Expr.exp.LAss"
###         ("\<^const>Expr.exp.SFAcc" ("_position" C) ("_position" F)
###           ("_position" D))
###         ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0) ("_position" unit)
###       ("_tuple" ("_position" h\<^sub>1)
###         ("_tuple_args" ("_position" l\<^sub>1)
###           ("_tuple_arg" ("_position" sh\<^sub>1')))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval" ("_position" P) ("_position" e\<^sub>2)
###         ("_position" s\<^sub>0) ("_applC" ("_position" Val) ("_position" v))
###         ("_tuple" ("_position" h\<^sub>1)
###           ("_tuple_args" ("_position" l\<^sub>1)
###             ("_tuple_arg" ("_position" sh\<^sub>1))))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>TypeRel.has_field" ("_position" P) ("_position" C)
###           ("_position" F) ("_position" Static) ("_position" t)
###           ("_position" D)))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" sh\<^sub>1) ("_position" D))
###             ("_applC" ("_position" Some)
###               ("_tuple" ("_position" sfs)
###                 ("_tuple_arg" ("_position" Done))))))
###         ("_asms"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq" ("_position" sfs')
###               ("_MapUpd" ("_position" sfs)
###                 ("_maplet" ("_position" F) ("_position" v)))))
###           ("_asm"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq" ("_position" sh\<^sub>1')
###                 ("_MapUpd" ("_position" sh\<^sub>1)
###                   ("_maplet" ("_position" D)
###                     ("_tuple" ("_position" sfs')
###                       ("_tuple_arg" ("_position" Done))))))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval" ("_position" P)
###       ("\<^const>Expr.exp.SFAss" ("_position" C) ("_position" F)
###         ("_position" D) ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0) ("_position" unit)
###       ("_tuple" ("_position" h\<^sub>1)
###         ("_tuple_args" ("_position" l\<^sub>1)
###           ("_tuple_arg" ("_position" sh\<^sub>1')))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 145 of "$AFP/JinjaDCI/J/BigStep.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval" ("_position" P) ("_position" e\<^sub>1)
###         ("_position" s\<^sub>0) ("_position" null) ("_position" s\<^sub>1)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^fixed>eval" ("_position" P) ("_position" e\<^sub>2)
###           ("_position" s\<^sub>1)
###           ("_applC" ("_position" Val) ("_position" v))
###           ("_position" s\<^sub>2)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval" ("_position" P)
###       ("\<^const>Expr.exp.LAss"
###         ("\<^const>Expr.exp.FAcc" ("_position" e\<^sub>1) ("_position" F)
###           ("_position" D))
###         ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0)
###       ("_applC" ("_position" THROW) ("_position" NullPointer))
###       ("_position" s\<^sub>2))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval" ("_position" P) ("_position" e\<^sub>1)
###         ("_position" s\<^sub>0) ("_position" null) ("_position" s\<^sub>1)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^fixed>eval" ("_position" P) ("_position" e\<^sub>2)
###           ("_position" s\<^sub>1)
###           ("_applC" ("_position" Val) ("_position" v))
###           ("_position" s\<^sub>2)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval" ("_position" P)
###       ("\<^const>Expr.exp.FAss" ("_position" e\<^sub>1) ("_position" F)
###         ("_position" D) ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0)
###       ("_applC" ("_position" THROW) ("_position" NullPointer))
###       ("_position" s\<^sub>2))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 149 of "$AFP/JinjaDCI/J/BigStep.thy") produces 2 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval" ("_position" P) ("_position" e\<^sub>1)
###       ("_position" s\<^sub>0)
###       ("_applC" ("_position" throw) ("_position" e'))
###       ("_position" s\<^sub>1)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval" ("_position" P)
###       ("\<^const>Expr.exp.LAss"
###         ("\<^const>Expr.exp.FAcc" ("_position" e\<^sub>1) ("_position" F)
###           ("_position" D))
###         ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0)
###       ("_applC" ("_position" throw) ("_position" e'))
###       ("_position" s\<^sub>1))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval" ("_position" P) ("_position" e\<^sub>1)
###       ("_position" s\<^sub>0)
###       ("_applC" ("_position" throw) ("_position" e'))
###       ("_position" s\<^sub>1)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval" ("_position" P)
###       ("\<^const>Expr.exp.FAss" ("_position" e\<^sub>1) ("_position" F)
###         ("_position" D) ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0)
###       ("_applC" ("_position" throw) ("_position" e'))
###       ("_position" s\<^sub>1))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 324 of "$AFP/JinjaDCI/J/BigStep.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval" ("_position" P) ("_position" e\<^sub>1)
###         ("_position" s\<^sub>0)
###         ("_applC" ("_position" Throw) ("_position" a))
###         ("_tuple" ("_position" h\<^sub>1)
###           ("_tuple_args" ("_position" l\<^sub>1)
###             ("_tuple_arg" ("_position" sh\<^sub>1))))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq"
###           ("_applC" ("_position" h\<^sub>1) ("_position" a))
###           ("_applC" ("_position" Some)
###             ("_tuple" ("_position" D) ("_tuple_arg" ("_position" fs))))))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>TypeRel.subcls" ("_position" P) ("_position" D)
###             ("_position" C)))
###         ("_asm"
###           ("\<^const>HOL.Trueprop"
###             ("\<^fixed>eval" ("_position" P) ("_position" e\<^sub>2)
###               ("_tuple" ("_position" h\<^sub>1)
###                 ("_tuple_args"
###                   ("_MapUpd" ("_position" l\<^sub>1)
###                     ("_maplet" ("_position" V)
###                       ("_applC" ("_position" Addr) ("_position" a))))
###                   ("_tuple_arg" ("_position" sh\<^sub>1))))
###               ("_position" e\<^sub>2')
###               ("_tuple" ("_position" h\<^sub>2)
###                 ("_tuple_args" ("_position" l\<^sub>2)
###                   ("_tuple_arg" ("_position" sh\<^sub>2))))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval" ("_position" P)
###       ("\<^const>Expr.exp.TryCatch" ("_position" e\<^sub>1) ("_position" C)
###         ("_position" V) ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0) ("_position" e\<^sub>2')
###       ("_tuple" ("_position" h\<^sub>2)
###         ("_tuple_args"
###           ("_applC" ("_position" l\<^sub>2)
###             ("\<^const>Expr.exp.LAss" ("_position" V)
###               ("_applC" ("_position" l\<^sub>1) ("_position" V))))
###           ("_tuple_arg" ("_position" sh\<^sub>2)))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval" ("_position" P) ("_position" e\<^sub>1)
###         ("_position" s\<^sub>0)
###         ("_applC" ("_position" Throw) ("_position" a))
###         ("_tuple" ("_position" h\<^sub>1)
###           ("_tuple_args" ("_position" l\<^sub>1)
###             ("_tuple_arg" ("_position" sh\<^sub>1))))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq"
###           ("_applC" ("_position" h\<^sub>1) ("_position" a))
###           ("_applC" ("_position" Some)
###             ("_tuple" ("_position" D) ("_tuple_arg" ("_position" fs))))))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>TypeRel.subcls" ("_position" P) ("_position" D)
###             ("_position" C)))
###         ("_asm"
###           ("\<^const>HOL.Trueprop"
###             ("\<^fixed>eval" ("_position" P) ("_position" e\<^sub>2)
###               ("_tuple" ("_position" h\<^sub>1)
###                 ("_tuple_args"
###                   ("_MapUpd" ("_position" l\<^sub>1)
###                     ("_maplet" ("_position" V)
###                       ("_applC" ("_position" Addr) ("_position" a))))
###                   ("_tuple_arg" ("_position" sh\<^sub>1))))
###               ("_position" e\<^sub>2')
###               ("_tuple" ("_position" h\<^sub>2)
###                 ("_tuple_args" ("_position" l\<^sub>2)
###                   ("_tuple_arg" ("_position" sh\<^sub>2))))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval" ("_position" P)
###       ("\<^const>Expr.exp.TryCatch" ("_position" e\<^sub>1) ("_position" C)
###         ("_position" V) ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0) ("_position" e\<^sub>2')
###       ("_tuple" ("_position" h\<^sub>2)
###         ("_tuple_args"
###           ("_Update" ("_position" l\<^sub>2)
###             ("_updbind" ("_position" V)
###               ("_applC" ("_position" l\<^sub>1) ("_position" V))))
###           ("_tuple_arg" ("_position" sh\<^sub>2)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 153 of "$AFP/JinjaDCI/J/BigStep.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval" ("_position" P) ("_position" e\<^sub>1)
###         ("_position" s\<^sub>0) ("_applC" ("_position" Val) ("_position" v))
###         ("_position" s\<^sub>1)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^fixed>eval" ("_position" P) ("_position" e\<^sub>2)
###           ("_position" s\<^sub>1)
###           ("_applC" ("_position" throw) ("_position" e'))
###           ("_position" s\<^sub>2)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval" ("_position" P)
###       ("\<^const>Expr.exp.LAss"
###         ("\<^const>Expr.exp.FAcc" ("_position" e\<^sub>1) ("_position" F)
###           ("_position" D))
###         ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0)
###       ("_applC" ("_position" throw) ("_position" e'))
###       ("_position" s\<^sub>2))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval" ("_position" P) ("_position" e\<^sub>1)
###         ("_position" s\<^sub>0) ("_applC" ("_position" Val) ("_position" v))
###         ("_position" s\<^sub>1)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^fixed>eval" ("_position" P) ("_position" e\<^sub>2)
###           ("_position" s\<^sub>1)
###           ("_applC" ("_position" throw) ("_position" e'))
###           ("_position" s\<^sub>2)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval" ("_position" P)
###       ("\<^const>Expr.exp.FAss" ("_position" e\<^sub>1) ("_position" F)
###         ("_position" D) ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0)
###       ("_applC" ("_position" throw) ("_position" e'))
###       ("_position" s\<^sub>2))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 173 of "$AFP/JinjaDCI/J/BigStep.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval" ("_position" P) ("_position" e\<^sub>2)
###         ("_position" s\<^sub>0) ("_applC" ("_position" Val) ("_position" v))
###         ("_tuple" ("_position" h\<^sub>1)
###           ("_tuple_args" ("_position" l\<^sub>1)
###             ("_tuple_arg" ("_position" sh\<^sub>1))))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>TypeRel.has_field" ("_position" P) ("_position" C)
###           ("_position" F) ("_position" Static) ("_position" t)
###           ("_position" D)))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("_Not_Ex" ("_position" sfs)
###             ("\<^const>HOL.eq"
###               ("_applC" ("_position" sh\<^sub>1) ("_position" D))
###               ("_applC" ("_position" Some)
###                 ("_tuple" ("_position" sfs)
###                   ("_tuple_arg" ("_position" Done)))))))
###         ("_asms"
###           ("\<^const>HOL.Trueprop"
###             ("\<^fixed>eval" ("_position" P)
###               ("\<^const>Expr.exp.INIT" ("_position" D)
###                 ("_list" ("_position" D)) ("_position" False)
###                 ("_position" unit))
###               ("_tuple" ("_position" h\<^sub>1)
###                 ("_tuple_args" ("_position" l\<^sub>1)
###                   ("_tuple_arg" ("_position" sh\<^sub>1))))
###               ("_applC" ("_position" Val) ("_position" v'))
###               ("_tuple" ("_position" h')
###                 ("_tuple_args" ("_position" l')
###                   ("_tuple_arg" ("_position" sh'))))))
###           ("_asms"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq"
###                 ("_applC" ("_position" sh') ("_position" D))
###                 ("_applC" ("_position" Some)
###                   ("_tuple" ("_position" sfs)
###                     ("_tuple_arg" ("_position" i))))))
###             ("_asms"
###               ("\<^const>HOL.Trueprop"
###                 ("\<^const>HOL.eq" ("_position" sfs')
###                   ("_MapUpd" ("_position" sfs)
###                     ("_maplet" ("_position" F) ("_position" v)))))
###               ("_asm"
###                 ("\<^const>HOL.Trueprop"
###                   ("\<^const>HOL.eq" ("_position" sh'')
###                     ("_MapUpd" ("_position" sh')
###                       ("_maplet" ("_position" D)
###                         ("_tuple" ("_position" sfs')
###                           ("_tuple_arg" ("_position" i))))))))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval" ("_position" P)
###       ("\<^const>Expr.exp.LAss"
###         ("\<^const>Expr.exp.SFAcc" ("_position" C) ("_position" F)
###           ("_position" D))
###         ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0) ("_position" unit)
###       ("_tuple" ("_position" h')
###         ("_tuple_args" ("_position" l')
###           ("_tuple_arg" ("_position" sh'')))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval" ("_position" P) ("_position" e\<^sub>2)
###         ("_position" s\<^sub>0) ("_applC" ("_position" Val) ("_position" v))
###         ("_tuple" ("_position" h\<^sub>1)
###           ("_tuple_args" ("_position" l\<^sub>1)
###             ("_tuple_arg" ("_position" sh\<^sub>1))))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>TypeRel.has_field" ("_position" P) ("_position" C)
###           ("_position" F) ("_position" Static) ("_position" t)
###           ("_position" D)))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("_Not_Ex" ("_position" sfs)
###             ("\<^const>HOL.eq"
###               ("_applC" ("_position" sh\<^sub>1) ("_position" D))
###               ("_applC" ("_position" Some)
###                 ("_tuple" ("_position" sfs)
###                   ("_tuple_arg" ("_position" Done)))))))
###         ("_asms"
###           ("\<^const>HOL.Trueprop"
###             ("\<^fixed>eval" ("_position" P)
###               ("\<^const>Expr.exp.INIT" ("_position" D)
###                 ("_list" ("_position" D)) ("_position" False)
###                 ("_position" unit))
###               ("_tuple" ("_position" h\<^sub>1)
###                 ("_tuple_args" ("_position" l\<^sub>1)
###                   ("_tuple_arg" ("_position" sh\<^sub>1))))
###               ("_applC" ("_position" Val) ("_position" v'))
###               ("_tuple" ("_position" h')
###                 ("_tuple_args" ("_position" l')
###                   ("_tuple_arg" ("_position" sh'))))))
###           ("_asms"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq"
###                 ("_applC" ("_position" sh') ("_position" D))
###                 ("_applC" ("_position" Some)
###                   ("_tuple" ("_position" sfs)
###                     ("_tuple_arg" ("_position" i))))))
###             ("_asms"
###               ("\<^const>HOL.Trueprop"
###                 ("\<^const>HOL.eq" ("_position" sfs')
###                   ("_MapUpd" ("_position" sfs)
###                     ("_maplet" ("_position" F) ("_position" v)))))
###               ("_asm"
###                 ("\<^const>HOL.Trueprop"
###                   ("\<^const>HOL.eq" ("_position" sh'')
###                     ("_MapUpd" ("_position" sh')
###                       ("_maplet" ("_position" D)
###                         ("_tuple" ("_position" sfs')
###                           ("_tuple_arg" ("_position" i))))))))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval" ("_position" P)
###       ("\<^const>Expr.exp.SFAss" ("_position" C) ("_position" F)
###         ("_position" D) ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0) ("_position" unit)
###       ("_tuple" ("_position" h')
###         ("_tuple_args" ("_position" l')
###           ("_tuple_arg" ("_position" sh'')))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 181 of "$AFP/JinjaDCI/J/BigStep.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval" ("_position" P) ("_position" e\<^sub>2)
###         ("_position" s\<^sub>0) ("_applC" ("_position" Val) ("_position" v))
###         ("_tuple" ("_position" h\<^sub>1)
###           ("_tuple_args" ("_position" l\<^sub>1)
###             ("_tuple_arg" ("_position" sh\<^sub>1))))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>TypeRel.has_field" ("_position" P) ("_position" C)
###           ("_position" F) ("_position" Static) ("_position" t)
###           ("_position" D)))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("_Not_Ex" ("_position" sfs)
###             ("\<^const>HOL.eq"
###               ("_applC" ("_position" sh\<^sub>1) ("_position" D))
###               ("_applC" ("_position" Some)
###                 ("_tuple" ("_position" sfs)
###                   ("_tuple_arg" ("_position" Done)))))))
###         ("_asm"
###           ("\<^const>HOL.Trueprop"
###             ("\<^fixed>eval" ("_position" P)
###               ("\<^const>Expr.exp.INIT" ("_position" D)
###                 ("_list" ("_position" D)) ("_position" False)
###                 ("_position" unit))
###               ("_tuple" ("_position" h\<^sub>1)
###                 ("_tuple_args" ("_position" l\<^sub>1)
###                   ("_tuple_arg" ("_position" sh\<^sub>1))))
###               ("_applC" ("_position" throw) ("_position" a))
###               ("_position" s')))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval" ("_position" P)
###       ("\<^const>Expr.exp.LAss"
###         ("\<^const>Expr.exp.SFAcc" ("_position" C) ("_position" F)
###           ("_position" D))
###         ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0) ("_applC" ("_position" throw) ("_position" a))
###       ("_position" s'))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval" ("_position" P) ("_position" e\<^sub>2)
###         ("_position" s\<^sub>0) ("_applC" ("_position" Val) ("_position" v))
###         ("_tuple" ("_position" h\<^sub>1)
###           ("_tuple_args" ("_position" l\<^sub>1)
###             ("_tuple_arg" ("_position" sh\<^sub>1))))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>TypeRel.has_field" ("_position" P) ("_position" C)
###           ("_position" F) ("_position" Static) ("_position" t)
###           ("_position" D)))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("_Not_Ex" ("_position" sfs)
###             ("\<^const>HOL.eq"
###               ("_applC" ("_position" sh\<^sub>1) ("_position" D))
###               ("_applC" ("_position" Some)
###                 ("_tuple" ("_position" sfs)
###                   ("_tuple_arg" ("_position" Done)))))))
###         ("_asm"
###           ("\<^const>HOL.Trueprop"
###             ("\<^fixed>eval" ("_position" P)
###               ("\<^const>Expr.exp.INIT" ("_position" D)
###                 ("_list" ("_position" D)) ("_position" False)
###                 ("_position" unit))
###               ("_tuple" ("_position" h\<^sub>1)
###                 ("_tuple_args" ("_position" l\<^sub>1)
###                   ("_tuple_arg" ("_position" sh\<^sub>1))))
###               ("_applC" ("_position" throw) ("_position" a))
###               ("_position" s')))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval" ("_position" P)
###       ("\<^const>Expr.exp.SFAss" ("_position" C) ("_position" F)
###         ("_position" D) ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0) ("_applC" ("_position" throw) ("_position" a))
###       ("_position" s'))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 187 of "$AFP/JinjaDCI/J/BigStep.thy") produces 2 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval" ("_position" P) ("_position" e\<^sub>2)
###       ("_position" s\<^sub>0)
###       ("_applC" ("_position" throw) ("_position" e'))
###       ("_position" s\<^sub>2)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval" ("_position" P)
###       ("\<^const>Expr.exp.LAss"
###         ("\<^const>Expr.exp.SFAcc" ("_position" C) ("_position" F)
###           ("_position" D))
###         ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0)
###       ("_applC" ("_position" throw) ("_position" e'))
###       ("_position" s\<^sub>2))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval" ("_position" P) ("_position" e\<^sub>2)
###       ("_position" s\<^sub>0)
###       ("_applC" ("_position" throw) ("_position" e'))
###       ("_position" s\<^sub>2)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval" ("_position" P)
###       ("\<^const>Expr.exp.SFAss" ("_position" C) ("_position" F)
###         ("_position" D) ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0)
###       ("_applC" ("_position" throw) ("_position" e'))
###       ("_position" s\<^sub>2))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 191 of "$AFP/JinjaDCI/J/BigStep.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval" ("_position" P) ("_position" e\<^sub>2)
###         ("_position" s\<^sub>0) ("_applC" ("_position" Val) ("_position" v))
###         ("_tuple" ("_position" h\<^sub>2)
###           ("_tuple_args" ("_position" l\<^sub>2)
###             ("_tuple_arg" ("_position" sh\<^sub>2))))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.Not"
###           ("\<^const>HOL.Ex_binder"
###             ("_idts" ("_position" b) ("_position" t))
###             ("\<^const>TypeRel.has_field" ("_position" P) ("_position" C)
###               ("_position" F) ("_position" b) ("_position" t)
###               ("_position" D)))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval" ("_position" P)
###       ("\<^const>Expr.exp.LAss"
###         ("\<^const>Expr.exp.SFAcc" ("_position" C) ("_position" F)
###           ("_position" D))
###         ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0)
###       ("_applC" ("_position" THROW) ("_position" NoSuchFieldError))
###       ("_tuple" ("_position" h\<^sub>2)
###         ("_tuple_args" ("_position" l\<^sub>2)
###           ("_tuple_arg" ("_position" sh\<^sub>2)))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval" ("_position" P) ("_position" e\<^sub>2)
###         ("_position" s\<^sub>0) ("_applC" ("_position" Val) ("_position" v))
###         ("_tuple" ("_position" h\<^sub>2)
###           ("_tuple_args" ("_position" l\<^sub>2)
###             ("_tuple_arg" ("_position" sh\<^sub>2))))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.Not"
###           ("\<^const>HOL.Ex_binder"
###             ("_idts" ("_position" b) ("_position" t))
###             ("\<^const>TypeRel.has_field" ("_position" P) ("_position" C)
###               ("_position" F) ("_position" b) ("_position" t)
###               ("_position" D)))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval" ("_position" P)
###       ("\<^const>Expr.exp.SFAss" ("_position" C) ("_position" F)
###         ("_position" D) ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0)
###       ("_applC" ("_position" THROW) ("_position" NoSuchFieldError))
###       ("_tuple" ("_position" h\<^sub>2)
###         ("_tuple_args" ("_position" l\<^sub>2)
###           ("_tuple_arg" ("_position" sh\<^sub>2)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 196 of "$AFP/JinjaDCI/J/BigStep.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval" ("_position" P) ("_position" e\<^sub>2)
###         ("_position" s\<^sub>0) ("_applC" ("_position" Val) ("_position" v))
###         ("_tuple" ("_position" h\<^sub>2)
###           ("_tuple_args" ("_position" l\<^sub>2)
###             ("_tuple_arg" ("_position" sh\<^sub>2))))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>TypeRel.has_field" ("_position" P) ("_position" C)
###           ("_position" F) ("_position" NonStatic) ("_position" t)
###           ("_position" D)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval" ("_position" P)
###       ("\<^const>Expr.exp.LAss"
###         ("\<^const>Expr.exp.SFAcc" ("_position" C) ("_position" F)
###           ("_position" D))
###         ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0)
###       ("_applC" ("_position" THROW)
###         ("_position" IncompatibleClassChangeError))
###       ("_tuple" ("_position" h\<^sub>2)
###         ("_tuple_args" ("_position" l\<^sub>2)
###           ("_tuple_arg" ("_position" sh\<^sub>2)))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval" ("_position" P) ("_position" e\<^sub>2)
###         ("_position" s\<^sub>0) ("_applC" ("_position" Val) ("_position" v))
###         ("_tuple" ("_position" h\<^sub>2)
###           ("_tuple_args" ("_position" l\<^sub>2)
###             ("_tuple_arg" ("_position" sh\<^sub>2))))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>TypeRel.has_field" ("_position" P) ("_position" C)
###           ("_position" F) ("_position" NonStatic) ("_position" t)
###           ("_position" D)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval" ("_position" P)
###       ("\<^const>Expr.exp.SFAss" ("_position" C) ("_position" F)
###         ("_position" D) ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0)
###       ("_applC" ("_position" THROW)
###         ("_position" IncompatibleClassChangeError))
###       ("_tuple" ("_position" h\<^sub>2)
###         ("_tuple_args" ("_position" l\<^sub>2)
###           ("_tuple_arg" ("_position" sh\<^sub>2)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Proofs for inductive predicate(s) "eval", "evals"
  Proving monotonicity ...
### Ambiguous input (line 416 of "$AFP/JinjaDCI/J/BigStep.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P)
###     ("\<^const>Expr.exp.LAss"
###       ("\<^const>Expr.exp.FAcc" ("_position" e\<^sub>1) ("_position" F)
###         ("_position" D))
###       ("_position" e\<^sub>2))
###     ("_position" s) ("_position" e') ("_position" s')))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P)
###     ("\<^const>Expr.exp.FAss" ("_position" e\<^sub>1) ("_position" F)
###       ("_position" D) ("_position" e\<^sub>2))
###     ("_position" s) ("_position" e') ("_position" s')))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 417 of "$AFP/JinjaDCI/J/BigStep.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P)
###     ("\<^const>Expr.exp.LAss"
###       ("\<^const>Expr.exp.SFAcc" ("_position" C) ("_position" F)
###         ("_position" D))
###       ("_position" e\<^sub>2))
###     ("_position" s) ("_position" e') ("_position" s')))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P)
###     ("\<^const>Expr.exp.SFAss" ("_position" C) ("_position" F)
###       ("_position" D) ("_position" e\<^sub>2))
###     ("_position" s) ("_position" e') ("_position" s')))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "Draft.BigStep"
### 5.776s elapsed time, 8.354s cpu time, 0.537s GC time
Loading theory "Draft.J1" (required by "Draft.J1MoreTemplates")
### Ambiguous input (line 41 of "$AFP/JinjaDCI/Compiler/J1.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_Update" ("_position" max_vars)
###       ("_updbind" ("_position" V) ("_position" e)))
###     ("_applC" ("_position" max_vars) ("_position" e))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" max_vars)
###       ("\<^const>Expr.exp.LAss" ("_position" V) ("_position" e)))
###     ("_applC" ("_position" max_vars) ("_position" e))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
consts
  max_vars :: "'a exp => nat"
  max_varss :: "'a exp list => nat"
### Ambiguous input (line 120 of "$AFP/JinjaDCI/Compiler/J1.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval\<^sub>1" ("_position" P) ("_position" e)
###         ("_position" s\<^sub>0) ("_applC" ("_position" Val) ("_position" v))
###         ("_tuple" ("_position" h)
###           ("_tuple_args" ("_position" ls)
###             ("_tuple_arg" ("_position" sh))))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Orderings.ord_class.less" ("_position" i)
###           ("_applC" ("_position" size) ("_position" ls))))
###       ("_asm"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq" ("_position" ls')
###             ("_applC" ("_position" ls)
###               ("_list"
###                 ("\<^const>Expr.exp.LAss" ("_position" i)
###                   ("_position" v)))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval\<^sub>1" ("_position" P)
###       ("\<^const>Expr.exp.LAss" ("_position" i) ("_position" e))
###       ("_position" s\<^sub>0) ("_position" unit)
###       ("_tuple" ("_position" h)
###         ("_tuple_args" ("_position" ls')
###           ("_tuple_arg" ("_position" sh)))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval\<^sub>1" ("_position" P) ("_position" e)
###         ("_position" s\<^sub>0) ("_applC" ("_position" Val) ("_position" v))
###         ("_tuple" ("_position" h)
###           ("_tuple_args" ("_position" ls)
###             ("_tuple_arg" ("_position" sh))))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Orderings.ord_class.less" ("_position" i)
###           ("_applC" ("_position" size) ("_position" ls))))
###       ("_asm"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq" ("_position" ls')
###             ("_LUpdate" ("_position" ls)
###               ("_lupdbind" ("_position" i) ("_position" v))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval\<^sub>1" ("_position" P)
###       ("\<^const>Expr.exp.LAss" ("_position" i) ("_position" e))
###       ("_position" s\<^sub>0) ("_position" unit)
###       ("_tuple" ("_position" h)
###         ("_tuple_args" ("_position" ls')
###           ("_tuple_arg" ("_position" sh)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 184 of "$AFP/JinjaDCI/Compiler/J1.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval\<^sub>1" ("_position" P) ("_position" e\<^sub>1)
###         ("_position" s\<^sub>0)
###         ("_applC" ("_position" addr) ("_position" a))
###         ("_position" s\<^sub>1)))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^fixed>eval\<^sub>1" ("_position" P) ("_position" e\<^sub>2)
###           ("_position" s\<^sub>1)
###           ("_applC" ("_position" Val) ("_position" v))
###           ("_tuple" ("_position" h\<^sub>2)
###             ("_tuple_args" ("_position" l\<^sub>2)
###               ("_tuple_arg" ("_position" sh\<^sub>2))))))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" h\<^sub>2) ("_position" a))
###             ("_applC" ("_position" Some)
###               ("_tuple" ("_position" C) ("_tuple_arg" ("_position" fs))))))
###         ("_asm"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.Not"
###               ("\<^const>HOL.Ex_binder"
###                 ("_idts" ("_position" b) ("_position" t))
###                 ("\<^const>TypeRel.has_field" ("_position" P)
###                   ("_position" C) ("_position" F) ("_position" b)
###                   ("_position" t) ("_position" D)))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval\<^sub>1" ("_position" P)
###       ("\<^const>Expr.exp.LAss"
###         ("\<^const>Expr.exp.FAcc" ("_position" e\<^sub>1) ("_position" F)
###           ("_position" D))
###         ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0)
###       ("_applC" ("_position" THROW) ("_position" NoSuchFieldError))
###       ("_tuple" ("_position" h\<^sub>2)
###         ("_tuple_args" ("_position" l\<^sub>2)
###           ("_tuple_arg" ("_position" sh\<^sub>2)))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval\<^sub>1" ("_position" P) ("_position" e\<^sub>1)
###         ("_position" s\<^sub>0)
###         ("_applC" ("_position" addr) ("_position" a))
###         ("_position" s\<^sub>1)))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^fixed>eval\<^sub>1" ("_position" P) ("_position" e\<^sub>2)
###           ("_position" s\<^sub>1)
###           ("_applC" ("_position" Val) ("_position" v))
###           ("_tuple" ("_position" h\<^sub>2)
###             ("_tuple_args" ("_position" l\<^sub>2)
###               ("_tuple_arg" ("_position" sh\<^sub>2))))))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" h\<^sub>2) ("_position" a))
###             ("_applC" ("_position" Some)
###               ("_tuple" ("_position" C) ("_tuple_arg" ("_position" fs))))))
###         ("_asm"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.Not"
###               ("\<^const>HOL.Ex_binder"
###                 ("_idts" ("_position" b) ("_position" t))
###                 ("\<^const>TypeRel.has_field" ("_position" P)
###                   ("_position" C) ("_position" F) ("_position" b)
###                   ("_position" t) ("_position" D)))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval\<^sub>1" ("_position" P)
###       ("\<^const>Expr.exp.FAss" ("_position" e\<^sub>1) ("_position" F)
###         ("_position" D) ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0)
###       ("_applC" ("_position" THROW) ("_position" NoSuchFieldError))
###       ("_tuple" ("_position" h\<^sub>2)
###         ("_tuple_args" ("_position" l\<^sub>2)
###           ("_tuple_arg" ("_position" sh\<^sub>2)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 188 of "$AFP/JinjaDCI/Compiler/J1.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval\<^sub>1" ("_position" P) ("_position" e\<^sub>1)
###         ("_position" s\<^sub>0)
###         ("_applC" ("_position" addr) ("_position" a))
###         ("_position" s\<^sub>1)))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^fixed>eval\<^sub>1" ("_position" P) ("_position" e\<^sub>2)
###           ("_position" s\<^sub>1)
###           ("_applC" ("_position" Val) ("_position" v))
###           ("_tuple" ("_position" h\<^sub>2)
###             ("_tuple_args" ("_position" l\<^sub>2)
###               ("_tuple_arg" ("_position" sh\<^sub>2))))))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" h\<^sub>2) ("_position" a))
###             ("_applC" ("_position" Some)
###               ("_tuple" ("_position" C) ("_tuple_arg" ("_position" fs))))))
###         ("_asm"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>TypeRel.has_field" ("_position" P) ("_position" C)
###               ("_position" F) ("_position" Static) ("_position" t)
###               ("_position" D)))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval\<^sub>1" ("_position" P)
###       ("\<^const>Expr.exp.LAss"
###         ("\<^const>Expr.exp.FAcc" ("_position" e\<^sub>1) ("_position" F)
###           ("_position" D))
###         ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0)
###       ("_applC" ("_position" THROW)
###         ("_position" IncompatibleClassChangeError))
###       ("_tuple" ("_position" h\<^sub>2)
###         ("_tuple_args" ("_position" l\<^sub>2)
###           ("_tuple_arg" ("_position" sh\<^sub>2)))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval\<^sub>1" ("_position" P) ("_position" e\<^sub>1)
###         ("_position" s\<^sub>0)
###         ("_applC" ("_position" addr) ("_position" a))
###         ("_position" s\<^sub>1)))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^fixed>eval\<^sub>1" ("_position" P) ("_position" e\<^sub>2)
###           ("_position" s\<^sub>1)
###           ("_applC" ("_position" Val) ("_position" v))
###           ("_tuple" ("_position" h\<^sub>2)
###             ("_tuple_args" ("_position" l\<^sub>2)
###               ("_tuple_arg" ("_position" sh\<^sub>2))))))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" h\<^sub>2) ("_position" a))
###             ("_applC" ("_position" Some)
###               ("_tuple" ("_position" C) ("_tuple_arg" ("_position" fs))))))
###         ("_asm"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>TypeRel.has_field" ("_position" P) ("_position" C)
###               ("_position" F) ("_position" Static) ("_position" t)
###               ("_position" D)))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval\<^sub>1" ("_position" P)
###       ("\<^const>Expr.exp.FAss" ("_position" e\<^sub>1) ("_position" F)
###         ("_position" D) ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0)
###       ("_applC" ("_position" THROW)
###         ("_position" IncompatibleClassChangeError))
###       ("_tuple" ("_position" h\<^sub>2)
###         ("_tuple_args" ("_position" l\<^sub>2)
###           ("_tuple_arg" ("_position" sh\<^sub>2)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 170 of "$AFP/JinjaDCI/Compiler/J1.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval\<^sub>1" ("_position" P) ("_position" e\<^sub>1)
###         ("_position" s\<^sub>0)
###         ("_applC" ("_position" addr) ("_position" a))
###         ("_position" s\<^sub>1)))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^fixed>eval\<^sub>1" ("_position" P) ("_position" e\<^sub>2)
###           ("_position" s\<^sub>1)
###           ("_applC" ("_position" Val) ("_position" v))
###           ("_tuple" ("_position" h\<^sub>2)
###             ("_tuple_args" ("_position" l\<^sub>2)
###               ("_tuple_arg" ("_position" sh\<^sub>2))))))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" h\<^sub>2) ("_position" a))
###             ("_applC" ("_position" Some)
###               ("_tuple" ("_position" C) ("_tuple_arg" ("_position" fs))))))
###         ("_asms"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>TypeRel.has_field" ("_position" P) ("_position" C)
###               ("_position" F) ("_position" NonStatic) ("_position" t)
###               ("_position" D)))
###           ("_asms"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq" ("_position" fs')
###                 ("_MapUpd" ("_position" fs)
###                   ("_maplet"
###                     ("_tuple" ("_position" F)
###                       ("_tuple_arg" ("_position" D)))
###                     ("_position" v)))))
###             ("_asm"
###               ("\<^const>HOL.Trueprop"
###                 ("\<^const>HOL.eq" ("_position" h\<^sub>2')
###                   ("_MapUpd" ("_position" h\<^sub>2)
###                     ("_maplet" ("_position" a)
###                       ("_tuple" ("_position" C)
###                         ("_tuple_arg" ("_position" fs')))))))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval\<^sub>1" ("_position" P)
###       ("\<^const>Expr.exp.LAss"
###         ("\<^const>Expr.exp.FAcc" ("_position" e\<^sub>1) ("_position" F)
###           ("_position" D))
###         ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0) ("_position" unit)
###       ("_tuple" ("_position" h\<^sub>2')
###         ("_tuple_args" ("_position" l\<^sub>2)
###           ("_tuple_arg" ("_position" sh\<^sub>2)))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval\<^sub>1" ("_position" P) ("_position" e\<^sub>1)
###         ("_position" s\<^sub>0)
###         ("_applC" ("_position" addr) ("_position" a))
###         ("_position" s\<^sub>1)))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^fixed>eval\<^sub>1" ("_position" P) ("_position" e\<^sub>2)
###           ("_position" s\<^sub>1)
###           ("_applC" ("_position" Val) ("_position" v))
###           ("_tuple" ("_position" h\<^sub>2)
###             ("_tuple_args" ("_position" l\<^sub>2)
###               ("_tuple_arg" ("_position" sh\<^sub>2))))))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" h\<^sub>2) ("_position" a))
###             ("_applC" ("_position" Some)
###               ("_tuple" ("_position" C) ("_tuple_arg" ("_position" fs))))))
###         ("_asms"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>TypeRel.has_field" ("_position" P) ("_position" C)
###               ("_position" F) ("_position" NonStatic) ("_position" t)
###               ("_position" D)))
###           ("_asms"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq" ("_position" fs')
###                 ("_MapUpd" ("_position" fs)
###                   ("_maplet"
###                     ("_tuple" ("_position" F)
###                       ("_tuple_arg" ("_position" D)))
###                     ("_position" v)))))
###             ("_asm"
###               ("\<^const>HOL.Trueprop"
###                 ("\<^const>HOL.eq" ("_position" h\<^sub>2')
###                   ("_MapUpd" ("_position" h\<^sub>2)
###                     ("_maplet" ("_position" a)
###                       ("_tuple" ("_position" C)
###                         ("_tuple_arg" ("_position" fs')))))))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval\<^sub>1" ("_position" P)
###       ("\<^const>Expr.exp.FAss" ("_position" e\<^sub>1) ("_position" F)
###         ("_position" D) ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0) ("_position" unit)
###       ("_tuple" ("_position" h\<^sub>2')
###         ("_tuple_args" ("_position" l\<^sub>2)
###           ("_tuple_arg" ("_position" sh\<^sub>2)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 193 of "$AFP/JinjaDCI/Compiler/J1.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval\<^sub>1" ("_position" P) ("_position" e\<^sub>2)
###         ("_position" s\<^sub>0) ("_applC" ("_position" Val) ("_position" v))
###         ("_tuple" ("_position" h\<^sub>1)
###           ("_tuple_args" ("_position" l\<^sub>1)
###             ("_tuple_arg" ("_position" sh\<^sub>1))))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>TypeRel.has_field" ("_position" P) ("_position" C)
###           ("_position" F) ("_position" Static) ("_position" t)
###           ("_position" D)))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" sh\<^sub>1) ("_position" D))
###             ("_applC" ("_position" Some)
###               ("_tuple" ("_position" sfs)
###                 ("_tuple_arg" ("_position" Done))))))
###         ("_asms"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq" ("_position" sfs')
###               ("_MapUpd" ("_position" sfs)
###                 ("_maplet" ("_position" F) ("_position" v)))))
###           ("_asm"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq" ("_position" sh\<^sub>1')
###                 ("_MapUpd" ("_position" sh\<^sub>1)
###                   ("_maplet" ("_position" D)
###                     ("_tuple" ("_position" sfs')
###                       ("_tuple_arg" ("_position" Done))))))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval\<^sub>1" ("_position" P)
###       ("\<^const>Expr.exp.LAss"
###         ("\<^const>Expr.exp.SFAcc" ("_position" C) ("_position" F)
###           ("_position" D))
###         ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0) ("_position" unit)
###       ("_tuple" ("_position" h\<^sub>1)
###         ("_tuple_args" ("_position" l\<^sub>1)
###           ("_tuple_arg" ("_position" sh\<^sub>1')))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval\<^sub>1" ("_position" P) ("_position" e\<^sub>2)
###         ("_position" s\<^sub>0) ("_applC" ("_position" Val) ("_position" v))
###         ("_tuple" ("_position" h\<^sub>1)
###           ("_tuple_args" ("_position" l\<^sub>1)
###             ("_tuple_arg" ("_position" sh\<^sub>1))))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>TypeRel.has_field" ("_position" P) ("_position" C)
###           ("_position" F) ("_position" Static) ("_position" t)
###           ("_position" D)))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" sh\<^sub>1) ("_position" D))
###             ("_applC" ("_position" Some)
###               ("_tuple" ("_position" sfs)
###                 ("_tuple_arg" ("_position" Done))))))
###         ("_asms"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq" ("_position" sfs')
###               ("_MapUpd" ("_position" sfs)
###                 ("_maplet" ("_position" F) ("_position" v)))))
###           ("_asm"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq" ("_position" sh\<^sub>1')
###                 ("_MapUpd" ("_position" sh\<^sub>1)
###                   ("_maplet" ("_position" D)
###                     ("_tuple" ("_position" sfs')
###                       ("_tuple_arg" ("_position" Done))))))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval\<^sub>1" ("_position" P)
###       ("\<^const>Expr.exp.SFAss" ("_position" C) ("_position" F)
###         ("_position" D) ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0) ("_position" unit)
###       ("_tuple" ("_position" h\<^sub>1)
###         ("_tuple_args" ("_position" l\<^sub>1)
###           ("_tuple_arg" ("_position" sh\<^sub>1')))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 175 of "$AFP/JinjaDCI/Compiler/J1.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval\<^sub>1" ("_position" P) ("_position" e\<^sub>1)
###         ("_position" s\<^sub>0) ("_position" null) ("_position" s\<^sub>1)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^fixed>eval\<^sub>1" ("_position" P) ("_position" e\<^sub>2)
###           ("_position" s\<^sub>1)
###           ("_applC" ("_position" Val) ("_position" v))
###           ("_position" s\<^sub>2)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval\<^sub>1" ("_position" P)
###       ("\<^const>Expr.exp.LAss"
###         ("\<^const>Expr.exp.FAcc" ("_position" e\<^sub>1) ("_position" F)
###           ("_position" D))
###         ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0)
###       ("_applC" ("_position" THROW) ("_position" NullPointer))
###       ("_position" s\<^sub>2))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval\<^sub>1" ("_position" P) ("_position" e\<^sub>1)
###         ("_position" s\<^sub>0) ("_position" null) ("_position" s\<^sub>1)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^fixed>eval\<^sub>1" ("_position" P) ("_position" e\<^sub>2)
###           ("_position" s\<^sub>1)
###           ("_applC" ("_position" Val) ("_position" v))
###           ("_position" s\<^sub>2)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval\<^sub>1" ("_position" P)
###       ("\<^const>Expr.exp.FAss" ("_position" e\<^sub>1) ("_position" F)
###         ("_position" D) ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0)
###       ("_applC" ("_position" THROW) ("_position" NullPointer))
###       ("_position" s\<^sub>2))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 178 of "$AFP/JinjaDCI/Compiler/J1.thy") produces 2 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval\<^sub>1" ("_position" P) ("_position" e\<^sub>1)
###       ("_position" s\<^sub>0)
###       ("_applC" ("_position" throw) ("_position" e'))
###       ("_position" s\<^sub>1)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval\<^sub>1" ("_position" P)
###       ("\<^const>Expr.exp.LAss"
###         ("\<^const>Expr.exp.FAcc" ("_position" e\<^sub>1) ("_position" F)
###           ("_position" D))
###         ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0)
###       ("_applC" ("_position" throw) ("_position" e'))
###       ("_position" s\<^sub>1))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval\<^sub>1" ("_position" P) ("_position" e\<^sub>1)
###       ("_position" s\<^sub>0)
###       ("_applC" ("_position" throw) ("_position" e'))
###       ("_position" s\<^sub>1)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval\<^sub>1" ("_position" P)
###       ("\<^const>Expr.exp.FAss" ("_position" e\<^sub>1) ("_position" F)
###         ("_position" D) ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0)
###       ("_applC" ("_position" throw) ("_position" e'))
###       ("_position" s\<^sub>1))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 181 of "$AFP/JinjaDCI/Compiler/J1.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval\<^sub>1" ("_position" P) ("_position" e\<^sub>1)
###         ("_position" s\<^sub>0) ("_applC" ("_position" Val) ("_position" v))
###         ("_position" s\<^sub>1)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^fixed>eval\<^sub>1" ("_position" P) ("_position" e\<^sub>2)
###           ("_position" s\<^sub>1)
###           ("_applC" ("_position" throw) ("_position" e'))
###           ("_position" s\<^sub>2)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval\<^sub>1" ("_position" P)
###       ("\<^const>Expr.exp.LAss"
###         ("\<^const>Expr.exp.FAcc" ("_position" e\<^sub>1) ("_position" F)
###           ("_position" D))
###         ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0)
###       ("_applC" ("_position" throw) ("_position" e'))
###       ("_position" s\<^sub>2))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval\<^sub>1" ("_position" P) ("_position" e\<^sub>1)
###         ("_position" s\<^sub>0) ("_applC" ("_position" Val) ("_position" v))
###         ("_position" s\<^sub>1)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^fixed>eval\<^sub>1" ("_position" P) ("_position" e\<^sub>2)
###           ("_position" s\<^sub>1)
###           ("_applC" ("_position" throw) ("_position" e'))
###           ("_position" s\<^sub>2)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval\<^sub>1" ("_position" P)
###       ("\<^const>Expr.exp.FAss" ("_position" e\<^sub>1) ("_position" F)
###         ("_position" D) ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0)
###       ("_applC" ("_position" throw) ("_position" e'))
###       ("_position" s\<^sub>2))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 198 of "$AFP/JinjaDCI/Compiler/J1.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval\<^sub>1" ("_position" P) ("_position" e\<^sub>2)
###         ("_position" s\<^sub>0) ("_applC" ("_position" Val) ("_position" v))
###         ("_tuple" ("_position" h\<^sub>1)
###           ("_tuple_args" ("_position" l\<^sub>1)
###             ("_tuple_arg" ("_position" sh\<^sub>1))))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>TypeRel.has_field" ("_position" P) ("_position" C)
###           ("_position" F) ("_position" Static) ("_position" t)
###           ("_position" D)))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("_Not_Ex" ("_position" sfs)
###             ("\<^const>HOL.eq"
###               ("_applC" ("_position" sh\<^sub>1) ("_position" D))
###               ("_applC" ("_position" Some)
###                 ("_tuple" ("_position" sfs)
###                   ("_tuple_arg" ("_position" Done)))))))
###         ("_asms"
###           ("\<^const>HOL.Trueprop"
###             ("\<^fixed>eval\<^sub>1" ("_position" P)
###               ("\<^const>Expr.exp.INIT" ("_position" D)
###                 ("_list" ("_position" D)) ("_position" False)
###                 ("_position" unit))
###               ("_tuple" ("_position" h\<^sub>1)
###                 ("_tuple_args" ("_position" l\<^sub>1)
###                   ("_tuple_arg" ("_position" sh\<^sub>1))))
###               ("_applC" ("_position" Val) ("_position" v'))
###               ("_tuple" ("_position" h')
###                 ("_tuple_args" ("_position" l')
###                   ("_tuple_arg" ("_position" sh'))))))
###           ("_asms"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq"
###                 ("_applC" ("_position" sh') ("_position" D))
###                 ("_applC" ("_position" Some)
###                   ("_tuple" ("_position" sfs)
###                     ("_tuple_arg" ("_position" i))))))
###             ("_asms"
###               ("\<^const>HOL.Trueprop"
###                 ("\<^const>HOL.eq" ("_position" sfs')
###                   ("_MapUpd" ("_position" sfs)
###                     ("_maplet" ("_position" F) ("_position" v)))))
###               ("_asm"
###                 ("\<^const>HOL.Trueprop"
###                   ("\<^const>HOL.eq" ("_position" sh'')
###                     ("_MapUpd" ("_position" sh')
###                       ("_maplet" ("_position" D)
###                         ("_tuple" ("_position" sfs')
###                           ("_tuple_arg" ("_position" i))))))))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval\<^sub>1" ("_position" P)
###       ("\<^const>Expr.exp.LAss"
###         ("\<^const>Expr.exp.SFAcc" ("_position" C) ("_position" F)
###           ("_position" D))
###         ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0) ("_position" unit)
###       ("_tuple" ("_position" h')
###         ("_tuple_args" ("_position" l')
###           ("_tuple_arg" ("_position" sh'')))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval\<^sub>1" ("_position" P) ("_position" e\<^sub>2)
###         ("_position" s\<^sub>0) ("_applC" ("_position" Val) ("_position" v))
###         ("_tuple" ("_position" h\<^sub>1)
###           ("_tuple_args" ("_position" l\<^sub>1)
###             ("_tuple_arg" ("_position" sh\<^sub>1))))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>TypeRel.has_field" ("_position" P) ("_position" C)
###           ("_position" F) ("_position" Static) ("_position" t)
###           ("_position" D)))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("_Not_Ex" ("_position" sfs)
###             ("\<^const>HOL.eq"
###               ("_applC" ("_position" sh\<^sub>1) ("_position" D))
###               ("_applC" ("_position" Some)
###                 ("_tuple" ("_position" sfs)
###                   ("_tuple_arg" ("_position" Done)))))))
###         ("_asms"
###           ("\<^const>HOL.Trueprop"
###             ("\<^fixed>eval\<^sub>1" ("_position" P)
###               ("\<^const>Expr.exp.INIT" ("_position" D)
###                 ("_list" ("_position" D)) ("_position" False)
###                 ("_position" unit))
###               ("_tuple" ("_position" h\<^sub>1)
###                 ("_tuple_args" ("_position" l\<^sub>1)
###                   ("_tuple_arg" ("_position" sh\<^sub>1))))
###               ("_applC" ("_position" Val) ("_position" v'))
###               ("_tuple" ("_position" h')
###                 ("_tuple_args" ("_position" l')
###                   ("_tuple_arg" ("_position" sh'))))))
###           ("_asms"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq"
###                 ("_applC" ("_position" sh') ("_position" D))
###                 ("_applC" ("_position" Some)
###                   ("_tuple" ("_position" sfs)
###                     ("_tuple_arg" ("_position" i))))))
###             ("_asms"
###               ("\<^const>HOL.Trueprop"
###                 ("\<^const>HOL.eq" ("_position" sfs')
###                   ("_MapUpd" ("_position" sfs)
###                     ("_maplet" ("_position" F) ("_position" v)))))
###               ("_asm"
###                 ("\<^const>HOL.Trueprop"
###                   ("\<^const>HOL.eq" ("_position" sh'')
###                     ("_MapUpd" ("_position" sh')
###                       ("_maplet" ("_position" D)
###                         ("_tuple" ("_position" sfs')
###                           ("_tuple_arg" ("_position" i))))))))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval\<^sub>1" ("_position" P)
###       ("\<^const>Expr.exp.SFAss" ("_position" C) ("_position" F)
###         ("_position" D) ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0) ("_position" unit)
###       ("_tuple" ("_position" h')
###         ("_tuple_args" ("_position" l')
###           ("_tuple_arg" ("_position" sh'')))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 327 of "$AFP/JinjaDCI/Compiler/J1.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval\<^sub>1" ("_position" P) ("_position" e\<^sub>1)
###         ("_position" s\<^sub>0)
###         ("_applC" ("_position" Throw) ("_position" a))
###         ("_tuple" ("_position" h\<^sub>1)
###           ("_tuple_args" ("_position" ls\<^sub>1)
###             ("_tuple_arg" ("_position" sh\<^sub>1))))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq"
###           ("_applC" ("_position" h\<^sub>1) ("_position" a))
###           ("_applC" ("_position" Some)
###             ("_tuple" ("_position" D) ("_tuple_arg" ("_position" fs))))))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>TypeRel.subcls" ("_position" P) ("_position" D)
###             ("_position" C)))
###         ("_asms"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>Orderings.ord_class.less" ("_position" i)
###               ("_applC" ("_position" length) ("_position" ls\<^sub>1))))
###           ("_asm"
###             ("\<^const>HOL.Trueprop"
###               ("\<^fixed>eval\<^sub>1" ("_position" P)
###                 ("_position" e\<^sub>2)
###                 ("_tuple" ("_position" h\<^sub>1)
###                   ("_tuple_args"
###                     ("_LUpdate" ("_position" ls\<^sub>1)
###                       ("_lupdbind" ("_position" i)
###                         ("_applC" ("_position" Addr) ("_position" a))))
###                     ("_tuple_arg" ("_position" sh\<^sub>1))))
###                 ("_position" e\<^sub>2')
###                 ("_tuple" ("_position" h\<^sub>2)
###                   ("_tuple_args" ("_position" ls\<^sub>2)
###                     ("_tuple_arg" ("_position" sh\<^sub>2)))))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval\<^sub>1" ("_position" P)
###       ("\<^const>Expr.exp.TryCatch" ("_position" e\<^sub>1) ("_position" C)
###         ("_position" i) ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0) ("_position" e\<^sub>2')
###       ("_tuple" ("_position" h\<^sub>2)
###         ("_tuple_args" ("_position" ls\<^sub>2)
###           ("_tuple_arg" ("_position" sh\<^sub>2)))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval\<^sub>1" ("_position" P) ("_position" e\<^sub>1)
###         ("_position" s\<^sub>0)
###         ("_applC" ("_position" Throw) ("_position" a))
###         ("_tuple" ("_position" h\<^sub>1)
###           ("_tuple_args" ("_position" ls\<^sub>1)
###             ("_tuple_arg" ("_position" sh\<^sub>1))))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq"
###           ("_applC" ("_position" h\<^sub>1) ("_position" a))
###           ("_applC" ("_position" Some)
###             ("_tuple" ("_position" D) ("_tuple_arg" ("_position" fs))))))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>TypeRel.subcls" ("_position" P) ("_position" D)
###             ("_position" C)))
###         ("_asms"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>Orderings.ord_class.less" ("_position" i)
###               ("_applC" ("_position" length) ("_position" ls\<^sub>1))))
###           ("_asm"
###             ("\<^const>HOL.Trueprop"
###               ("\<^fixed>eval\<^sub>1" ("_position" P)
###                 ("_position" e\<^sub>2)
###                 ("_tuple" ("_position" h\<^sub>1)
###                   ("_tuple_args"
###                     ("_applC" ("_position" ls\<^sub>1)
###                       ("_list"
###                         ("\<^const>Expr.exp.LAss" ("_position" i)
###                           ("_applC" ("_position" Addr) ("_position" a)))))
###                     ("_tuple_arg" ("_position" sh\<^sub>1))))
###                 ("_position" e\<^sub>2')
###                 ("_tuple" ("_position" h\<^sub>2)
###                   ("_tuple_args" ("_position" ls\<^sub>2)
###                     ("_tuple_arg" ("_position" sh\<^sub>2)))))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval\<^sub>1" ("_position" P)
###       ("\<^const>Expr.exp.TryCatch" ("_position" e\<^sub>1) ("_position" C)
###         ("_position" i) ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0) ("_position" e\<^sub>2')
###       ("_tuple" ("_position" h\<^sub>2)
###         ("_tuple_args" ("_position" ls\<^sub>2)
###           ("_tuple_arg" ("_position" sh\<^sub>2)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 205 of "$AFP/JinjaDCI/Compiler/J1.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval\<^sub>1" ("_position" P) ("_position" e\<^sub>2)
###         ("_position" s\<^sub>0) ("_applC" ("_position" Val) ("_position" v))
###         ("_tuple" ("_position" h\<^sub>1)
###           ("_tuple_args" ("_position" l\<^sub>1)
###             ("_tuple_arg" ("_position" sh\<^sub>1))))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>TypeRel.has_field" ("_position" P) ("_position" C)
###           ("_position" F) ("_position" Static) ("_position" t)
###           ("_position" D)))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("_Not_Ex" ("_position" sfs)
###             ("\<^const>HOL.eq"
###               ("_applC" ("_position" sh\<^sub>1) ("_position" D))
###               ("_applC" ("_position" Some)
###                 ("_tuple" ("_position" sfs)
###                   ("_tuple_arg" ("_position" Done)))))))
###         ("_asm"
###           ("\<^const>HOL.Trueprop"
###             ("\<^fixed>eval\<^sub>1" ("_position" P)
###               ("\<^const>Expr.exp.INIT" ("_position" D)
###                 ("_list" ("_position" D)) ("_position" False)
###                 ("_position" unit))
###               ("_tuple" ("_position" h\<^sub>1)
###                 ("_tuple_args" ("_position" l\<^sub>1)
###                   ("_tuple_arg" ("_position" sh\<^sub>1))))
###               ("_applC" ("_position" throw) ("_position" a))
###               ("_position" s')))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval\<^sub>1" ("_position" P)
###       ("\<^const>Expr.exp.LAss"
###         ("\<^const>Expr.exp.SFAcc" ("_position" C) ("_position" F)
###           ("_position" D))
###         ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0) ("_applC" ("_position" throw) ("_position" a))
###       ("_position" s'))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval\<^sub>1" ("_position" P) ("_position" e\<^sub>2)
###         ("_position" s\<^sub>0) ("_applC" ("_position" Val) ("_position" v))
###         ("_tuple" ("_position" h\<^sub>1)
###           ("_tuple_args" ("_position" l\<^sub>1)
###             ("_tuple_arg" ("_position" sh\<^sub>1))))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>TypeRel.has_field" ("_position" P) ("_position" C)
###           ("_position" F) ("_position" Static) ("_position" t)
###           ("_position" D)))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("_Not_Ex" ("_position" sfs)
###             ("\<^const>HOL.eq"
###               ("_applC" ("_position" sh\<^sub>1) ("_position" D))
###               ("_applC" ("_position" Some)
###                 ("_tuple" ("_position" sfs)
###                   ("_tuple_arg" ("_position" Done)))))))
###         ("_asm"
###           ("\<^const>HOL.Trueprop"
###             ("\<^fixed>eval\<^sub>1" ("_position" P)
###               ("\<^const>Expr.exp.INIT" ("_position" D)
###                 ("_list" ("_position" D)) ("_position" False)
###                 ("_position" unit))
###               ("_tuple" ("_position" h\<^sub>1)
###                 ("_tuple_args" ("_position" l\<^sub>1)
###                   ("_tuple_arg" ("_position" sh\<^sub>1))))
###               ("_applC" ("_position" throw) ("_position" a))
###               ("_position" s')))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval\<^sub>1" ("_position" P)
###       ("\<^const>Expr.exp.SFAss" ("_position" C) ("_position" F)
###         ("_position" D) ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0) ("_applC" ("_position" throw) ("_position" a))
###       ("_position" s'))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 210 of "$AFP/JinjaDCI/Compiler/J1.thy") produces 2 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval\<^sub>1" ("_position" P) ("_position" e\<^sub>2)
###       ("_position" s\<^sub>0)
###       ("_applC" ("_position" throw) ("_position" e'))
###       ("_position" s\<^sub>2)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval\<^sub>1" ("_position" P)
###       ("\<^const>Expr.exp.LAss"
###         ("\<^const>Expr.exp.SFAcc" ("_position" C) ("_position" F)
###           ("_position" D))
###         ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0)
###       ("_applC" ("_position" throw) ("_position" e'))
###       ("_position" s\<^sub>2))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval\<^sub>1" ("_position" P) ("_position" e\<^sub>2)
###       ("_position" s\<^sub>0)
###       ("_applC" ("_position" throw) ("_position" e'))
###       ("_position" s\<^sub>2)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval\<^sub>1" ("_position" P)
###       ("\<^const>Expr.exp.SFAss" ("_position" C) ("_position" F)
###         ("_position" D) ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0)
###       ("_applC" ("_position" throw) ("_position" e'))
###       ("_position" s\<^sub>2))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 213 of "$AFP/JinjaDCI/Compiler/J1.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval\<^sub>1" ("_position" P) ("_position" e\<^sub>2)
###         ("_position" s\<^sub>0) ("_applC" ("_position" Val) ("_position" v))
###         ("_tuple" ("_position" h\<^sub>2)
###           ("_tuple_args" ("_position" l\<^sub>2)
###             ("_tuple_arg" ("_position" sh\<^sub>2))))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.Not"
###           ("\<^const>HOL.Ex_binder"
###             ("_idts" ("_position" b) ("_position" t))
###             ("\<^const>TypeRel.has_field" ("_position" P) ("_position" C)
###               ("_position" F) ("_position" b) ("_position" t)
###               ("_position" D)))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval\<^sub>1" ("_position" P)
###       ("\<^const>Expr.exp.LAss"
###         ("\<^const>Expr.exp.SFAcc" ("_position" C) ("_position" F)
###           ("_position" D))
###         ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0)
###       ("_applC" ("_position" THROW) ("_position" NoSuchFieldError))
###       ("_tuple" ("_position" h\<^sub>2)
###         ("_tuple_args" ("_position" l\<^sub>2)
###           ("_tuple_arg" ("_position" sh\<^sub>2)))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval\<^sub>1" ("_position" P) ("_position" e\<^sub>2)
###         ("_position" s\<^sub>0) ("_applC" ("_position" Val) ("_position" v))
###         ("_tuple" ("_position" h\<^sub>2)
###           ("_tuple_args" ("_position" l\<^sub>2)
###             ("_tuple_arg" ("_position" sh\<^sub>2))))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.Not"
###           ("\<^const>HOL.Ex_binder"
###             ("_idts" ("_position" b) ("_position" t))
###             ("\<^const>TypeRel.has_field" ("_position" P) ("_position" C)
###               ("_position" F) ("_position" b) ("_position" t)
###               ("_position" D)))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval\<^sub>1" ("_position" P)
###       ("\<^const>Expr.exp.SFAss" ("_position" C) ("_position" F)
###         ("_position" D) ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0)
###       ("_applC" ("_position" THROW) ("_position" NoSuchFieldError))
###       ("_tuple" ("_position" h\<^sub>2)
###         ("_tuple_args" ("_position" l\<^sub>2)
###           ("_tuple_arg" ("_position" sh\<^sub>2)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 217 of "$AFP/JinjaDCI/Compiler/J1.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval\<^sub>1" ("_position" P) ("_position" e\<^sub>2)
###         ("_position" s\<^sub>0) ("_applC" ("_position" Val) ("_position" v))
###         ("_tuple" ("_position" h\<^sub>2)
###           ("_tuple_args" ("_position" l\<^sub>2)
###             ("_tuple_arg" ("_position" sh\<^sub>2))))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>TypeRel.has_field" ("_position" P) ("_position" C)
###           ("_position" F) ("_position" NonStatic) ("_position" t)
###           ("_position" D)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval\<^sub>1" ("_position" P)
###       ("\<^const>Expr.exp.LAss"
###         ("\<^const>Expr.exp.SFAcc" ("_position" C) ("_position" F)
###           ("_position" D))
###         ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0)
###       ("_applC" ("_position" THROW)
###         ("_position" IncompatibleClassChangeError))
###       ("_tuple" ("_position" h\<^sub>2)
###         ("_tuple_args" ("_position" l\<^sub>2)
###           ("_tuple_arg" ("_position" sh\<^sub>2)))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval\<^sub>1" ("_position" P) ("_position" e\<^sub>2)
###         ("_position" s\<^sub>0) ("_applC" ("_position" Val) ("_position" v))
###         ("_tuple" ("_position" h\<^sub>2)
###           ("_tuple_args" ("_position" l\<^sub>2)
###             ("_tuple_arg" ("_position" sh\<^sub>2))))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>TypeRel.has_field" ("_position" P) ("_position" C)
###           ("_position" F) ("_position" NonStatic) ("_position" t)
###           ("_position" D)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval\<^sub>1" ("_position" P)
###       ("\<^const>Expr.exp.SFAss" ("_position" C) ("_position" F)
###         ("_position" D) ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0)
###       ("_applC" ("_position" THROW)
###         ("_position" IncompatibleClassChangeError))
###       ("_tuple" ("_position" h\<^sub>2)
###         ("_tuple_args" ("_position" l\<^sub>2)
###           ("_tuple_arg" ("_position" sh\<^sub>2)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Proofs for inductive predicate(s) "eval\<^sub>1", "evals\<^sub>1"
  Proving monotonicity ...
### Ambiguous input (line 411 of "$AFP/JinjaDCI/Compiler/J1.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>J1.eval\<^sub>1" ("_position" P)
###     ("\<^const>Expr.exp.LAss"
###       ("\<^const>Expr.exp.FAcc" ("_position" e\<^sub>1) ("_position" F)
###         ("_position" D))
###       ("_position" e\<^sub>2))
###     ("_position" s) ("_position" e') ("_position" s')))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>J1.eval\<^sub>1" ("_position" P)
###     ("\<^const>Expr.exp.FAss" ("_position" e\<^sub>1) ("_position" F)
###       ("_position" D) ("_position" e\<^sub>2))
###     ("_position" s) ("_position" e') ("_position" s')))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 412 of "$AFP/JinjaDCI/Compiler/J1.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>J1.eval\<^sub>1" ("_position" P)
###     ("\<^const>Expr.exp.LAss"
###       ("\<^const>Expr.exp.SFAcc" ("_position" C) ("_position" F)
###         ("_position" D))
###       ("_position" e\<^sub>2))
###     ("_position" s) ("_position" e') ("_position" s')))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>J1.eval\<^sub>1" ("_position" P)
###     ("\<^const>Expr.exp.SFAss" ("_position" C) ("_position" F)
###       ("_position" D) ("_position" e\<^sub>2))
###     ("_position" s) ("_position" e') ("_position" s')))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "Draft.J1"
### 5.609s elapsed time, 8.376s cpu time, 0.597s GC time
Loading theory "Draft.J1MoreTemplates"
val templateLemmas =
   [("J1.eval\<^sub>1_final",
     "?P \<turnstile>\<^sub>1 \<langle>?e,?s\<rangle> \<Rightarrow>
                              \<langle>?e',?s'\<rangle> ==>
      final ?e'",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app
                   (template_app (template_hole 1, template_var 4),
                    template_var 3),
                  template_var 2),
                template_var 1),
              template_var 0)
            )],
       template_predicate
        (template_app (template_hole 0, template_var 1)))),
    ("J1.evals\<^sub>1_final",
     "?P \<turnstile>\<^sub>1 \<langle>?es,?s\<rangle> [\<Rightarrow>]
                              \<langle>?es',?s'\<rangle> ==>
      finals ?es'",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app
                   (template_app (template_hole 1, template_var 4),
                    template_var 3),
                  template_var 2),
                template_var 1),
              template_var 0)
            )],
       template_predicate
        (template_app (template_hole 0, template_var 1)))),
    ("J1.evals\<^sub>1_preserves_elen",
     "?P \<turnstile>\<^sub>1 \<langle>?es,?s\<rangle> [\<Rightarrow>]
                              \<langle>?es',?s'\<rangle> ==>
      length ?es = length ?es'",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app
                   (template_app (template_hole 2, template_var 4),
                    template_var 3),
                  template_var 2),
                template_var 1),
              template_var 0)
            )],
       template_equation
        (template_app (template_hole 0, template_var 3),
         template_app (template_hole 0, template_var 1)))),
    ("J1.eval\<^sub>1_hext",
     "?P \<turnstile>\<^sub>1 \<langle>?e,
                               (?h, ?l, ?sh)\<rangle> \<Rightarrow>
                              \<langle>?e',(?h', ?l', ?sh')\<rangle> ==>
      ?h \<unlhd> ?h'",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app
                   (template_app (template_hole 3, template_var 8),
                    template_var 7),
                  template_app
                   (template_app (template_hole 2, template_var 6),
                    template_app
                     (template_app (template_hole 1, template_var 5),
                      template_var 4))),
                template_var 3),
              template_app
               (template_app (template_hole 2, template_var 2),
                template_app
                 (template_app (template_hole 1, template_var 1),
                  template_var 0)))
            )],
       template_predicate
        (
           template_app
            (template_app (template_hole 0, template_var 6), template_var 2)
           ))),
    ("J1.evals\<^sub>1_hext",
     "?P \<turnstile>\<^sub>1 \<langle>?es,
                               (?h, ?l, ?sh)\<rangle> [\<Rightarrow>]
                              \<langle>?es',(?h', ?l', ?sh')\<rangle> ==>
      ?h \<unlhd> ?h'",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app
                   (template_app (template_hole 3, template_var 8),
                    template_var 7),
                  template_app
                   (template_app (template_hole 2, template_var 6),
                    template_app
                     (template_app (template_hole 1, template_var 5),
                      template_var 4))),
                template_var 3),
              template_app
               (template_app (template_hole 2, template_var 2),
                template_app
                 (template_app (template_hole 1, template_var 1),
                  template_var 0)))
            )],
       template_predicate
        (
           template_app
            (template_app (template_hole 0, template_var 6), template_var 2)
           ))),
    ("J1.eval\<^sub>1_final_same",
     "[| ?P \<turnstile>\<^sub>1 \<langle>?e,?s\<rangle> \<Rightarrow>
                                 \<langle>?e',?s'\<rangle>;
         final ?e |]
      ==> ?e = ?e' & ?s = ?s'",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app
                   (template_app (template_hole 4, template_var 4),
                    template_var 3),
                  template_var 2),
                template_var 1),
              template_var 0)
            ),
        template_predicate
         (template_app (template_hole 3, template_var 3))],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 2,
               template_app
                (template_app (template_hole 1, template_var 3),
                 template_var 1)),
             template_app
              (template_app (template_hole 0, template_var 2),
               template_var 0))
           ))),
    ("J1.eval\<^sub>1_preserves_len",
     "?P \<turnstile>\<^sub>1 \<langle>?e\<^sub>0,
                               (?h\<^sub>0, ?ls\<^sub>0,
                                ?sh\<^sub>0)\<rangle> \<Rightarrow>
                              \<langle>?e\<^sub>1,
                               (?h\<^sub>1, ?ls\<^sub>1,
                                ?sh\<^sub>1)\<rangle> ==>
      length ?ls\<^sub>0 = length ?ls\<^sub>1",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app
                   (template_app (template_hole 4, template_var 8),
                    template_var 7),
                  template_app
                   (template_app (template_hole 3, template_var 6),
                    template_app
                     (template_app (template_hole 2, template_var 5),
                      template_var 4))),
                template_var 3),
              template_app
               (template_app (template_hole 3, template_var 2),
                template_app
                 (template_app (template_hole 2, template_var 1),
                  template_var 0)))
            )],
       template_equation
        (template_app (template_hole 0, template_var 5),
         template_app (template_hole 0, template_var 1)))),
    ("J1.evals\<^sub>1_preserves_len",
     "?P \<turnstile>\<^sub>1 \<langle>?es\<^sub>0,
                               (?h\<^sub>0, ?ls\<^sub>0,
                                ?sh\<^sub>0)\<rangle> [\<Rightarrow>]
                              \<langle>?es\<^sub>1,
                               (?h\<^sub>1, ?ls\<^sub>1,
                                ?sh\<^sub>1)\<rangle> ==>
      length ?ls\<^sub>0 = length ?ls\<^sub>1",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app
                   (template_app (template_hole 4, template_var 8),
                    template_var 7),
                  template_app
                   (template_app (template_hole 3, template_var 6),
                    template_app
                     (template_app (template_hole 2, template_var 5),
                      template_var 4))),
                template_var 3),
              template_app
               (template_app (template_hole 3, template_var 2),
                template_app
                 (template_app (template_hole 2, template_var 1),
                  template_var 0)))
            )],
       template_equation
        (template_app (template_hole 0, template_var 5),
         template_app (template_hole 0, template_var 1)))),
    ("J1.clinit\<^sub>1_loc_pres",
     "?P \<turnstile>\<^sub>1 \<langle>?C\<^sub>0\<bullet>\<^sub>sclinit([]),
                               (?h, ?l, ?sh)\<rangle> \<Rightarrow>
                              \<langle>?e',(?h', ?l', ?sh')\<rangle> ==>
      ?l = ?l'",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app
                   (template_app (template_hole 6, template_var 8),
                    template_app
                     (template_app
                       (template_app (template_hole 5, template_var 7),
                        template_hole 4),
                      template_hole 3)),
                  template_app
                   (template_app (template_hole 2, template_var 6),
                    template_app
                     (template_app (template_hole 1, template_var 5),
                      template_var 4))),
                template_var 3),
              template_app
               (template_app (template_hole 2, template_var 2),
                template_app
                 (template_app (template_hole 1, template_var 1),
                  template_var 0)))
            )],
       template_equation (template_var 5, template_var 1))),
    ("J1.evals\<^sub>1_cases",
     "[| ?P \<turnstile>\<^sub>1 \<langle>[],?s\<rangle> [\<Rightarrow>]
                                 \<langle>?e',?s'\<rangle>;
         [| ?e' = []; ?s' = ?s |] ==> ?Pa |]
      ==> ?Pa",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app
                   (template_app (template_hole 3, template_var 4),
                    template_hole 2),
                  template_var 3),
                template_var 2),
              template_var 1)
            ),
        template_implication
         ([template_equation (template_var 2, template_hole 2)],
          template_implication
           ([template_equation (template_var 1, template_var 3)],
            template_predicate (template_var 0)))],
       template_predicate (template_var 0))),
    ("J1.eval\<^sub>1_cases",
     "[| ?P \<turnstile>\<^sub>1 \<langle>{?V:?T; ?e\<^sub>1},
                                  ?s\<rangle> \<Rightarrow>
                                 \<langle>?e',?s'\<rangle>;
         ?P \<turnstile>\<^sub>1 \<langle>?e\<^sub>1,
                                  ?s\<rangle> \<Rightarrow>
                                 \<langle>?e',?s'\<rangle> ==>
         ?Pa |]
      ==> ?Pa",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app
                   (template_app (template_hole 1, template_var 7),
                    template_app
                     (template_app
                       (template_app (template_hole 0, template_var 6),
                        template_var 5),
                      template_var 4)),
                  template_var 3),
                template_var 2),
              template_var 1)
            ),
        template_implication
         ([template_predicate
            (
               template_app
                (template_app
                  (template_app
                    (template_app
                      (template_app (template_hole 1, template_var 7),
                       template_var 4),
                     template_var 3),
                   template_var 2),
                 template_var 1)
               )],
          template_predicate (template_var 0))],
       template_predicate (template_var 0))),
    ("J1.init\<^sub>1_same_loc",
     "?P \<turnstile>\<^sub>1 \<langle>INIT ?C (?Cs,?b) \<leftarrow> unit,
                               (?h, ?l, ?sh)\<rangle> \<Rightarrow>
                              \<langle>?e',(?h', ?l', ?sh')\<rangle> ==>
      ?l = ?l'",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app
                   (template_app (template_hole 6, template_var 10),
                    template_app
                     (template_app
                       (template_app
                         (template_app (template_hole 5, template_var 9),
                          template_var 8),
                        template_var 7),
                      template_app (template_hole 4, template_hole 3))),
                  template_app
                   (template_app (template_hole 2, template_var 6),
                    template_app
                     (template_app (template_hole 1, template_var 5),
                      template_var 4))),
                template_var 3),
              template_app
               (template_app (template_hole 2, template_var 2),
                template_app
                 (template_app (template_hole 1, template_var 1),
                  template_var 0)))
            )],
       template_equation (template_var 5, template_var 1))),
    ("J1.eval\<^sub>1_cases",
     "[| ?P \<turnstile>\<^sub>1 \<langle>Val ?v,?s\<rangle> \<Rightarrow>
                                 \<langle>?e',?s'\<rangle>;
         [| ?e' = Val ?v; ?s' = ?s |] ==> ?Pa |]
      ==> ?Pa",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app
                   (template_app (template_hole 3, template_var 5),
                    template_app (template_hole 2, template_var 4)),
                  template_var 3),
                template_var 2),
              template_var 1)
            ),
        template_implication
         ([template_equation
            (template_var 2,
             template_app (template_hole 2, template_var 4))],
          template_implication
           ([template_equation (template_var 1, template_var 3)],
            template_predicate (template_var 0)))],
       template_predicate (template_var 0))),
    ("J1.rinit\<^sub>1_throw",
     "?P\<^sub>1 \<turnstile>\<^sub>1 \<langle>RI (?D,Throw
                 ?xa) ; ?Cs \<leftarrow> ?e,
 (?h, ?l, ?sh)\<rangle> \<Rightarrow>
\<langle>?e',(?h', ?l', ?sh')\<rangle> ==>
      ?e' = Throw ?xa",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app
                   (template_app (template_hole 7, template_var 11),
                    template_app
                     (template_app
                       (template_app
                         (template_app (template_hole 6, template_var 10),
                          template_app
                           (template_hole 5,
                            template_app
                             (template_hole 4,
                              template_app
                               (template_hole 3, template_var 9)))),
                        template_var 8),
                      template_var 7)),
                  template_app
                   (template_app (template_hole 2, template_var 6),
                    template_app
                     (template_app (template_hole 1, template_var 5),
                      template_var 4))),
                template_var 3),
              template_app
               (template_app (template_hole 2, template_var 2),
                template_app
                 (template_app (template_hole 1, template_var 1),
                  template_var 0)))
            )],
       template_equation
        (template_var 3,
         template_app
          (template_hole 5,
           template_app
            (template_hole 4,
             template_app (template_hole 3, template_var 9)))))),
    ("J1.rinit\<^sub>1_throwE",
     "?P \<turnstile>\<^sub>1 \<langle>RI (?C,throw
         ?e) ; ?Cs \<leftarrow> ?e\<^sub>0,
                               ?s\<rangle> \<Rightarrow>
                              \<langle>?e',?s'\<rangle> ==>
      EX a s\<^sub>t.
         ?e' = throw a &
         ?P \<turnstile>\<^sub>1 \<langle>throw ?e,?s\<rangle> \<Rightarrow>
                                 \<langle>throw a,s\<^sub>t\<rangle>",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app
                   (template_app (template_hole 6, template_var 7),
                    template_app
                     (template_app
                       (template_app
                         (template_app (template_hole 5, template_var 6),
                          template_app (template_hole 4, template_var 5)),
                        template_var 4),
                      template_var 3)),
                  template_var 2),
                template_var 1),
              template_var 0)
            )],
       template_predicate (template_app (template_hole 3, t_empty)))),
    ("J1.eval\<^sub>1_cases",
     "[| ?P \<turnstile>\<^sub>1 \<langle>Var ?v,?s\<rangle> \<Rightarrow>
                                 \<langle>?e',?s'\<rangle>;
         !!ls h sh.
            [| ?s = (h, ls, sh); ?e' = Val (ls ! ?v); ?s' = (h, ls, sh);
               ?v < length ls |]
            ==> ?Pa |]
      ==> ?Pa",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app
                   (template_app (template_hole 12, template_var 5),
                    template_app (template_hole 11, template_var 4)),
                  template_var 3),
                template_var 2),
              template_var 1)
            ),
        template_predicate (template_app (template_hole 10, t_empty))],
       template_predicate (template_var 0))),
    ("J1.eval\<^sub>1_cases",
     "[| ?P \<turnstile>\<^sub>1 \<langle>?e\<^sub>1;; ?e\<^sub>2,
                                  ?s\<rangle> \<Rightarrow>
                                 \<langle>?e',?s'\<rangle>;
         !!v s\<^sub>1.
            [| ?P \<turnstile>\<^sub>1 \<langle>?e\<^sub>1,
  ?s\<rangle> \<Rightarrow>
 \<langle>Val v,s\<^sub>1\<rangle>;
               ?P \<turnstile>\<^sub>1 \<langle>?e\<^sub>2,
  s\<^sub>1\<rangle> \<Rightarrow>
 \<langle>?e',?s'\<rangle> |]
            ==> ?Pa;
         !!e. [| ?e' = throw e;
                 ?P \<turnstile>\<^sub>1 \<langle>?e\<^sub>1,
    ?s\<rangle> \<Rightarrow>
   \<langle>throw e,?s'\<rangle> |]
              ==> ?Pa |]
      ==> ?Pa",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app
                   (template_app (template_hole 7, template_var 6),
                    template_app
                     (template_app (template_hole 6, template_var 5),
                      template_var 4)),
                  template_var 3),
                template_var 2),
              template_var 1)
            ),
        template_predicate (template_app (template_hole 5, t_empty)),
        template_predicate (template_app (template_hole 2, t_empty))],
       template_predicate (template_var 0))),
    ("J1.init\<^sub>1_ri\<^sub>1_same_loc",
     "[| ?P \<turnstile>\<^sub>1 \<langle>?e,
                                  (?h, ?l, ?sh)\<rangle> \<Rightarrow>
                                 \<langle>?e',(?h', ?l', ?sh')\<rangle>;
         ?e = INIT ?C (?Cs,?b) \<leftarrow> unit |
         ?e = ?C\<bullet>\<^sub>s?M([]) |
         ?e = RI (?C,Throw ?a) ; ?Cs \<leftarrow> unit |
         ?e =
         RI (?C,?C\<bullet>\<^sub>sclinit([])) ; ?Cs \<leftarrow> unit |]
      ==> ?l = ?l'",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app
                   (template_app (template_hole 14, template_var 13),
                    template_var 12),
                  template_app
                   (template_app (template_hole 13, template_var 11),
                    template_app
                     (template_app (template_hole 12, template_var 10),
                      template_var 9))),
                template_var 8),
              template_app
               (template_app (template_hole 13, template_var 7),
                template_app
                 (template_app (template_hole 12, template_var 6),
                  template_var 5)))
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_hole 11,
                template_app
                 (template_app (template_hole 10, template_var 12),
                  template_app
                   (template_app
                     (template_app
                       (template_app (template_hole 9, template_var 4),
                        template_var 3),
                      template_var 2),
                    template_app (template_hole 8, template_hole 7)))),
              template_app
               (template_app
                 (template_hole 11,
                  template_app
                   (template_app (template_hole 10, template_var 12),
                    template_app
                     (template_app
                       (template_app (template_hole 6, template_var 4),
                        template_var 1),
                      template_hole 5))),
                template_app
                 (template_app
                   (template_hole 11,
                    template_app
                     (template_app (template_hole 10, template_var 12),
                      template_app
                       (template_app
                         (template_app
                           (template_app (template_hole 4, template_var 4),
                            template_app
                             (template_hole 3,
                              template_app
                               (template_hole 8,
                                template_app
                                 (template_hole 2, template_var 0)))),
                          template_var 3),
                        template_app (template_hole 8, template_hole 7)))),
                  template_app
                   (template_app (template_hole 10, template_var 12),
                    template_app
                     (template_app
                       (template_app
                         (template_app (template_hole 4, template_var 4),
                          template_app
                           (template_app
                             (template_app
                               (template_hole 6, template_var 4),
                              template_hole 1),
                            template_hole 5)),
                        template_var 3),
                      template_app (template_hole 8, template_hole 7))))))
            )],
       template_equation (template_var 10, template_var 6))),
    ("J1.evals\<^sub>1_cases",
     "[| ?P \<turnstile>\<^sub>1 \<langle>?e # ?es,
                                  ?s\<rangle> [\<Rightarrow>]
                                 \<langle>?e',?s'\<rangle>;
         !!v s\<^sub>1 es'.
            [| ?e' = Val v # es';
               ?P \<turnstile>\<^sub>1 \<langle>?e,?s\<rangle> \<Rightarrow>
 \<langle>Val v,s\<^sub>1\<rangle>;
               ?P \<turnstile>\<^sub>1 \<langle>?es,
  s\<^sub>1\<rangle> [\<Rightarrow>]
 \<langle>es',?s'\<rangle> |]
            ==> ?Pa;
         !!e'. [| ?e' = throw e' # ?es;
                  ?P \<turnstile>\<^sub>1 \<langle>?e,
     ?s\<rangle> \<Rightarrow>
    \<langle>throw e',?s'\<rangle> |]
               ==> ?Pa |]
      ==> ?Pa",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app
                   (template_app (template_hole 9, template_var 6),
                    template_app
                     (template_app (template_hole 8, template_var 5),
                      template_var 4)),
                  template_var 3),
                template_var 2),
              template_var 1)
            ),
        template_predicate (template_app (template_hole 7, t_empty)),
        template_predicate (template_app (template_hole 1, t_empty))],
       template_predicate (template_var 0))),
    ("J1.eval\<^sub>1_cases",
     "[| ?P \<turnstile>\<^sub>1 \<langle>throw ?e,?s\<rangle> \<Rightarrow>
                                 \<langle>?e',?s'\<rangle>;
         !!a. [| ?e' = Throw a;
                 ?P \<turnstile>\<^sub>1 \<langle>?e,
    ?s\<rangle> \<Rightarrow>
   \<langle>addr a,?s'\<rangle> |]
              ==> ?Pa;
         [| ?e' = THROW NullPointer;
            ?P \<turnstile>\<^sub>1 \<langle>?e,?s\<rangle> \<Rightarrow>
                                    \<langle>null,?s'\<rangle> |]
         ==> ?Pa;
         !!e'. [| ?e' = throw e';
                  ?P \<turnstile>\<^sub>1 \<langle>?e,
     ?s\<rangle> \<Rightarrow>
    \<langle>throw e',?s'\<rangle> |]
               ==> ?Pa |]
      ==> ?Pa",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app
                   (template_app (template_hole 9, template_var 5),
                    template_app (template_hole 8, template_var 4)),
                  template_var 3),
                template_var 2),
              template_var 1)
            ),
        template_predicate (template_app (template_hole 7, t_empty)),
        template_implication
         ([template_equation
            (template_var 2,
             template_app
              (template_hole 8,
               template_app
                (template_hole 5,
                 template_app
                  (template_hole 4,
                   template_app (template_hole 3, template_hole 2)))))],
          template_implication
           ([template_predicate
              (
                 template_app
                  (template_app
                    (template_app
                      (template_app
                        (template_app (template_hole 9, template_var 5),
                         template_var 4),
                       template_var 3),
                     template_app (template_hole 5, template_hole 1)),
                   template_var 1)
                 )],
            template_predicate (template_var 0))),
        template_predicate (template_app (template_hole 0, t_empty))],
       template_predicate (template_var 0))),
    ("J1.eval\<^sub>1_cases",
     "[| ?P \<turnstile>\<^sub>1 \<langle>if (?e) ?e\<^sub>1
                                  else ?e\<^sub>2,?s\<rangle> \<Rightarrow>
                                 \<langle>?e',?s'\<rangle>;
         !!s\<^sub>1.
            [| ?P \<turnstile>\<^sub>1 \<langle>?e,?s\<rangle> \<Rightarrow>
 \<langle>true,s\<^sub>1\<rangle>;
               ?P \<turnstile>\<^sub>1 \<langle>?e\<^sub>1,
  s\<^sub>1\<rangle> \<Rightarrow>
 \<langle>?e',?s'\<rangle> |]
            ==> ?Pa;
         !!s\<^sub>1.
            [| ?P \<turnstile>\<^sub>1 \<langle>?e,?s\<rangle> \<Rightarrow>
 \<langle>false,s\<^sub>1\<rangle>;
               ?P \<turnstile>\<^sub>1 \<langle>?e\<^sub>2,
  s\<^sub>1\<rangle> \<Rightarrow>
 \<langle>?e',?s'\<rangle> |]
            ==> ?Pa;
         !!e'. [| ?e' = throw e';
                  ?P \<turnstile>\<^sub>1 \<langle>?e,
     ?s\<rangle> \<Rightarrow>
    \<langle>throw e',?s'\<rangle> |]
               ==> ?Pa |]
      ==> ?Pa",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app
                   (template_app (template_hole 9, template_var 7),
                    template_app
                     (template_app
                       (template_app (template_hole 8, template_var 6),
                        template_var 5),
                      template_var 4)),
                  template_var 3),
                template_var 2),
              template_var 1)
            ),
        template_predicate (template_app (template_hole 7, t_empty)),
        template_predicate (template_app (template_hole 7, t_empty)),
        template_predicate (template_app (template_hole 2, t_empty))],
       template_predicate (template_var 0))),
    ("J1.eval\<^sub>1_cases",
     "[| ?P \<turnstile>\<^sub>1 \<langle>?V:=?e,?s\<rangle> \<Rightarrow>
                                 \<langle>?e',?s'\<rangle>;
         !!v h ls sh.
            [| ?e' = unit; ?s' = (h, ls[?V := v], sh);
               ?P \<turnstile>\<^sub>1 \<langle>?e,?s\<rangle> \<Rightarrow>
 \<langle>Val v,(h, ls, sh)\<rangle>;
               ?V < length ls |]
            ==> ?Pa;
         !!e'. [| ?e' = throw e';
                  ?P \<turnstile>\<^sub>1 \<langle>?e,
     ?s\<rangle> \<Rightarrow>
    \<langle>throw e',?s'\<rangle> |]
               ==> ?Pa |]
      ==> ?Pa",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app
                   (template_app (template_hole 16, template_var 6),
                    template_app
                     (template_app (template_hole 15, template_var 5),
                      template_var 4)),
                  template_var 3),
                template_var 2),
              template_var 1)
            ),
        template_predicate (template_app (template_hole 14, t_empty)),
        template_predicate (template_app (template_hole 1, t_empty))],
       template_predicate (template_var 0))),
    ("J1.eval\<^sub>1_cases",
     "[| ?P \<turnstile>\<^sub>1 \<langle>?e\<^sub>1 \<guillemotleft>?bop\<guillemotright> ?e\<^sub>2,
                                  ?s\<rangle> \<Rightarrow>
                                 \<langle>?e',?s'\<rangle>;
         !!v\<^sub>1 s\<^sub>1 v\<^sub>2 v.
            [| ?e' = Val v;
               ?P \<turnstile>\<^sub>1 \<langle>?e\<^sub>1,
  ?s\<rangle> \<Rightarrow>
 \<langle>Val v\<^sub>1,s\<^sub>1\<rangle>;
               ?P \<turnstile>\<^sub>1 \<langle>?e\<^sub>2,
  s\<^sub>1\<rangle> \<Rightarrow>
 \<langle>Val v\<^sub>2,?s'\<rangle>;
               binop (?bop, v\<^sub>1, v\<^sub>2) = \<lfloor>v\<rfloor> |]
            ==> ?Pa;
         !!e. [| ?e' = throw e;
                 ?P \<turnstile>\<^sub>1 \<langle>?e\<^sub>1,
    ?s\<rangle> \<Rightarrow>
   \<langle>throw e,?s'\<rangle> |]
              ==> ?Pa;
         !!v\<^sub>1 s\<^sub>1 e.
            [| ?e' = throw e;
               ?P \<turnstile>\<^sub>1 \<langle>?e\<^sub>1,
  ?s\<rangle> \<Rightarrow>
 \<langle>Val v\<^sub>1,s\<^sub>1\<rangle>;
               ?P \<turnstile>\<^sub>1 \<langle>?e\<^sub>2,
  s\<^sub>1\<rangle> \<Rightarrow>
 \<langle>throw e,?s'\<rangle> |]
            ==> ?Pa |]
      ==> ?Pa",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app
                   (template_app (template_hole 12, template_var 7),
                    template_app
                     (template_app
                       (template_app (template_hole 11, template_var 6),
                        template_var 5),
                      template_var 4)),
                  template_var 3),
                template_var 2),
              template_var 1)
            ),
        template_predicate (template_app (template_hole 10, t_empty)),
        template_predicate (template_app (template_hole 1, t_empty)),
        template_predicate (template_app (template_hole 10, t_empty))],
       template_predicate (template_var 0))),
    ("J1.eval\<^sub>1_cases",
     "[| ?P \<turnstile>\<^sub>1 \<langle>while (?b) ?c,
                                  ?s\<rangle> \<Rightarrow>
                                 \<langle>?e',?s'\<rangle>;
         [| ?e' = unit;
            ?P \<turnstile>\<^sub>1 \<langle>?b,?s\<rangle> \<Rightarrow>
                                    \<langle>false,?s'\<rangle> |]
         ==> ?Pa;
         !!s\<^sub>1 v\<^sub>1 s\<^sub>2.
            [| ?P \<turnstile>\<^sub>1 \<langle>?b,?s\<rangle> \<Rightarrow>
 \<langle>true,s\<^sub>1\<rangle>;
               ?P \<turnstile>\<^sub>1 \<langle>?c,
  s\<^sub>1\<rangle> \<Rightarrow>
 \<langle>Val v\<^sub>1,s\<^sub>2\<rangle>;
               ?P \<turnstile>\<^sub>1 \<langle>while (?b) ?c,
  s\<^sub>2\<rangle> \<Rightarrow>
 \<langle>?e',?s'\<rangle> |]
            ==> ?Pa;
         !!e'. [| ?e' = throw e';
                  ?P \<turnstile>\<^sub>1 \<langle>?b,
     ?s\<rangle> \<Rightarrow>
    \<langle>throw e',?s'\<rangle> |]
               ==> ?Pa;
         !!s\<^sub>1 e'.
            [| ?e' = throw e';
               ?P \<turnstile>\<^sub>1 \<langle>?b,?s\<rangle> \<Rightarrow>
 \<langle>true,s\<^sub>1\<rangle>;
               ?P \<turnstile>\<^sub>1 \<langle>?c,
  s\<^sub>1\<rangle> \<Rightarrow>
 \<langle>throw e',?s'\<rangle> |]
            ==> ?Pa |]
      ==> ?Pa",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app
                   (template_app (template_hole 11, template_var 6),
                    template_app
                     (template_app (template_hole 10, template_var 5),
                      template_var 4)),
                  template_var 3),
                template_var 2),
              template_var 1)
            ),
        template_implication
         ([template_equation
            (template_var 2,
             template_app (template_hole 8, template_hole 7))],
          template_implication
           ([template_predicate
              (
                 template_app
                  (template_app
                    (template_app
                      (template_app
                        (template_app (template_hole 11, template_var 6),
                         template_var 5),
                       template_var 3),
                     template_app
                      (template_hole 8,
                       template_app (template_hole 6, template_hole 5))),
                   template_var 1)
                 )],
            template_predicate (template_var 0))),
        template_predicate (template_app (template_hole 4, t_empty)),
        template_predicate (template_app (template_hole 1, t_empty)),
        template_predicate (template_app (template_hole 4, t_empty))],
       template_predicate (template_var 0))),
    ("J1.eval\<^sub>1_cases",
     "[| ?P \<turnstile>\<^sub>1 \<langle>Cast ?C ?e,
                                  ?s\<rangle> \<Rightarrow>
                                 \<langle>?e',?s'\<rangle>;
         !!a h l sh D fs.
            [| ?e' = addr a; ?s' = (h, l, sh);
               ?P \<turnstile>\<^sub>1 \<langle>?e,?s\<rangle> \<Rightarrow>
 \<langle>addr a,(h, l, sh)\<rangle>;
               h a = \<lfloor>(D, fs)\<rfloor>;
               ?P \<turnstile> D \<preceq>\<^sup>* ?C |]
            ==> ?Pa;
         [| ?e' = null;
            ?P \<turnstile>\<^sub>1 \<langle>?e,?s\<rangle> \<Rightarrow>
                                    \<langle>null,?s'\<rangle> |]
         ==> ?Pa;
         !!a h l sh D fs.
            [| ?e' = THROW ClassCast; ?s' = (h, l, sh);
               ?P \<turnstile>\<^sub>1 \<langle>?e,?s\<rangle> \<Rightarrow>
 \<langle>addr a,(h, l, sh)\<rangle>;
               h a = \<lfloor>(D, fs)\<rfloor>; (D, ?C) ~: (subcls1 ?P)^* |]
            ==> ?Pa;
         !!e'. [| ?e' = throw e';
                  ?P \<turnstile>\<^sub>1 \<langle>?e,
     ?s\<rangle> \<Rightarrow>
    \<langle>throw e',?s'\<rangle> |]
               ==> ?Pa |]
      ==> ?Pa",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app
                   (template_app (template_hole 26, template_var 6),
                    template_app
                     (template_app (template_hole 25, template_var 5),
                      template_var 4)),
                  template_var 3),
                template_var 2),
              template_var 1)
            ),
        template_predicate (template_app (template_hole 24, t_empty)),
        template_implication
         ([template_equation
            (template_var 2,
             template_app (template_hole 17, template_hole 5))],
          template_implication
           ([template_predicate
              (
                 template_app
                  (template_app
                    (template_app
                      (template_app
                        (template_app (template_hole 26, template_var 6),
                         template_var 4),
                       template_var 3),
                     template_app (template_hole 17, template_hole 5)),
                   template_var 1)
                 )],
            template_predicate (template_var 0))),
        template_predicate (template_app (template_hole 24, t_empty)),
        template_predicate (template_app (template_hole 0, t_empty))],
       template_predicate (template_var 0))),
    ("J1.eval\<^sub>1_cases",
     "[| ?P \<turnstile>\<^sub>1 \<langle>try ?e\<^sub>1
                                  catch(?C ?V) ?e\<^sub>2,
                                  ?s\<rangle> \<Rightarrow>
                                 \<langle>?e',?s'\<rangle>;
         !!v\<^sub>1.
            [| ?e' = Val v\<^sub>1;
               ?P \<turnstile>\<^sub>1 \<langle>?e\<^sub>1,
  ?s\<rangle> \<Rightarrow>
 \<langle>Val v\<^sub>1,?s'\<rangle> |]
            ==> ?Pa;
         !!a h\<^sub>1 ls\<^sub>1 sh\<^sub>1 D fs h\<^sub>2 ls\<^sub>2
            sh\<^sub>2.
            [| ?s' = (h\<^sub>2, ls\<^sub>2, sh\<^sub>2);
               ?P \<turnstile>\<^sub>1 \<langle>?e\<^sub>1,
  ?s\<rangle> \<Rightarrow>
 \<langle>Throw a,(h\<^sub>1, ls\<^sub>1, sh\<^sub>1)\<rangle>;
               h\<^sub>1 a = \<lfloor>(D, fs)\<rfloor>;
               ?P \<turnstile> D \<preceq>\<^sup>* ?C;
               ?V < length ls\<^sub>1;
               ?P \<turnstile>\<^sub>1 \<langle>?e\<^sub>2,
  (h\<^sub>1, ls\<^sub>1[?V := Addr a], sh\<^sub>1)\<rangle> \<Rightarrow>
 \<langle>?e',(h\<^sub>2, ls\<^sub>2, sh\<^sub>2)\<rangle> |]
            ==> ?Pa;
         !!a h\<^sub>1 ls\<^sub>1 sh\<^sub>1 D fs.
            [| ?e' = Throw a; ?s' = (h\<^sub>1, ls\<^sub>1, sh\<^sub>1);
               ?P \<turnstile>\<^sub>1 \<langle>?e\<^sub>1,
  ?s\<rangle> \<Rightarrow>
 \<langle>Throw a,(h\<^sub>1, ls\<^sub>1, sh\<^sub>1)\<rangle>;
               h\<^sub>1 a = \<lfloor>(D, fs)\<rfloor>;
               (D, ?C) ~: (subcls1 ?P)^* |]
            ==> ?Pa |]
      ==> ?Pa",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app
                   (template_app (template_hole 26, template_var 8),
                    template_app
                     (template_app
                       (template_app
                         (template_app (template_hole 25, template_var 7),
                          template_var 6),
                        template_var 5),
                      template_var 4)),
                  template_var 3),
                template_var 2),
              template_var 1)
            ),
        template_predicate (template_app (template_hole 24, t_empty)),
        template_predicate (template_app (template_hole 21, t_empty)),
        template_predicate (template_app (template_hole 21, t_empty))],
       template_predicate (template_var 0))),
    ("J1.eval\<^sub>1_cases",
     "[| ?P \<turnstile>\<^sub>1 \<langle>RI (?C,?e) ; ?Cs \<leftarrow> ?e\<^sub>0,
                                  ?s\<rangle> \<Rightarrow>
                                 \<langle>?e',?s'\<rangle>;
         !!v h' l' sh' sfs i.
            [| ?P \<turnstile>\<^sub>1 \<langle>?e,?s\<rangle> \<Rightarrow>
 \<langle>Val v,(h', l', sh')\<rangle>;
               sh' ?C = \<lfloor>(sfs, i)\<rfloor>;
               ?P \<turnstile>\<^sub>1 \<langle>INIT (if ?Cs = [] then ?C
                else last ?Cs) (?Cs,True) \<leftarrow> ?e\<^sub>0,
  (h', l', sh'(?C |-> (sfs, Done)))\<rangle> \<Rightarrow>
 \<langle>?e',?s'\<rangle> |]
            ==> ?Pa;
         !!a h' l' sh' sfs i D Cs.
            [| ?Cs = D # Cs;
               ?P \<turnstile>\<^sub>1 \<langle>?e,?s\<rangle> \<Rightarrow>
 \<langle>throw a,(h', l', sh')\<rangle>;
               sh' ?C = \<lfloor>(sfs, i)\<rfloor>;
               ?P \<turnstile>\<^sub>1 \<langle>RI (D,throw
                 a) ; Cs \<leftarrow> ?e\<^sub>0,
  (h', l', sh'(?C |-> (sfs, Error)))\<rangle> \<Rightarrow>
 \<langle>?e',?s'\<rangle> |]
            ==> ?Pa;
         !!a h' l' sh' sfs i.
            [| ?Cs = []; ?e' = throw a;
               ?s' = (h', l', sh'(?C |-> (sfs, Error)));
               ?P \<turnstile>\<^sub>1 \<langle>?e,?s\<rangle> \<Rightarrow>
 \<langle>throw a,(h', l', sh')\<rangle>;
               sh' ?C = \<lfloor>(sfs, i)\<rfloor> |]
            ==> ?Pa |]
      ==> ?Pa",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app
                   (template_app (template_hole 29, template_var 8),
                    template_app
                     (template_app
                       (template_app
                         (template_app (template_hole 28, template_var 7),
                          template_var 6),
                        template_var 5),
                      template_var 4)),
                  template_var 3),
                template_var 2),
              template_var 1)
            ),
        template_predicate (template_app (template_hole 27, t_empty)),
        template_predicate (template_app (template_hole 7, t_empty)),
        template_predicate (template_app (template_hole 7, t_empty))],
       template_predicate (template_var 0))),
    ("J1.eval\<^sub>1_cases",
     "[| ?P \<turnstile>\<^sub>1 \<langle>?e\<bullet>?F{?D},
                                  ?s\<rangle> \<Rightarrow>
                                 \<langle>?e',?s'\<rangle>;
         !!a h ls sh C fs t v.
            [| ?e' = Val v; ?s' = (h, ls, sh);
               ?P \<turnstile>\<^sub>1 \<langle>?e,?s\<rangle> \<Rightarrow>
 \<langle>addr a,(h, ls, sh)\<rangle>;
               h a = \<lfloor>(C, fs)\<rfloor>;
               ?P \<turnstile> C has ?F,NonStatic:t in ?D;
               fs (?F, ?D) = \<lfloor>v\<rfloor> |]
            ==> ?Pa;
         [| ?e' = THROW NullPointer;
            ?P \<turnstile>\<^sub>1 \<langle>?e,?s\<rangle> \<Rightarrow>
                                    \<langle>null,?s'\<rangle> |]
         ==> ?Pa;
         !!e'. [| ?e' = throw e';
                  ?P \<turnstile>\<^sub>1 \<langle>?e,
     ?s\<rangle> \<Rightarrow>
    \<langle>throw e',?s'\<rangle> |]
               ==> ?Pa;
         !!a h ls sh C fs.
            [| ?e' = THROW NoSuchFieldError; ?s' = (h, ls, sh);
               ?P \<turnstile>\<^sub>1 \<langle>?e,?s\<rangle> \<Rightarrow>
 \<langle>addr a,(h, ls, sh)\<rangle>;
               h a = \<lfloor>(C, fs)\<rfloor>;
               ALL b t. ~ ?P \<turnstile> C has ?F,b:t in ?D |]
            ==> ?Pa;
         !!a h ls sh C fs t.
            [| ?e' = THROW IncompatibleClassChangeError; ?s' = (h, ls, sh);
               ?P \<turnstile>\<^sub>1 \<langle>?e,?s\<rangle> \<Rightarrow>
 \<langle>addr a,(h, ls, sh)\<rangle>;
               h a = \<lfloor>(C, fs)\<rfloor>;
               ?P \<turnstile> C has ?F,Static:t in ?D |]
            ==> ?Pa |]
      ==> ?Pa",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app
                   (template_app (template_hole 34, template_var 7),
                    template_app
                     (template_app
                       (template_app (template_hole 33, template_var 6),
                        template_var 5),
                      template_var 4)),
                  template_var 3),
                template_var 2),
              template_var 1)
            ),
        template_predicate (template_app (template_hole 32, t_empty)),
        template_implication
         ([template_equation
            (template_var 2,
             template_app
              (template_hole 10,
               template_app
                (template_hole 23,
                 template_app
                  (template_hole 19,
                   template_app (template_hole 9, template_hole 8)))))],
          template_implication
           ([template_predicate
              (
                 template_app
                  (template_app
                    (template_app
                      (template_app
                        (template_app (template_hole 34, template_var 7),
                         template_var 6),
                       template_var 3),
                     template_app (template_hole 23, template_hole 7)),
                   template_var 1)
                 )],
            template_predicate (template_var 0))),
        template_predicate (template_app (template_hole 6, t_empty)),
        template_predicate (template_app (template_hole 32, t_empty)),
        template_predicate (template_app (template_hole 32, t_empty))],
       template_predicate (template_var 0))),
    ("J1.eval\<^sub>1_cases",
     "[| ?P \<turnstile>\<^sub>1 \<langle>?C\<bullet>\<^sub>s?F{?D},
                                  ?s\<rangle> \<Rightarrow>
                                 \<langle>?e',?s'\<rangle>;
         !!t sh sfs v h ls.
            [| ?s = (h, ls, sh); ?e' = Val v; ?s' = (h, ls, sh);
               ?P \<turnstile> ?C has ?F,Static:t in ?D;
               sh ?D = \<lfloor>(sfs, Done)\<rfloor>;
               sfs ?F = \<lfloor>v\<rfloor> |]
            ==> ?Pa;
         !!t sh h ls v' h' ls' sh' sfs i v.
            [| ?s = (h, ls, sh); ?e' = Val v; ?s' = (h', ls', sh');
               ?P \<turnstile> ?C has ?F,Static:t in ?D;
               ALL sfs. sh ?D ~= \<lfloor>(sfs, Done)\<rfloor>;
               ?P \<turnstile>\<^sub>1 \<langle>INIT ?D ([?D],False) \<leftarrow> unit,
  (h, ls, sh)\<rangle> \<Rightarrow>
 \<langle>Val v',(h', ls', sh')\<rangle>;
               sh' ?D = \<lfloor>(sfs, i)\<rfloor>;
               sfs ?F = \<lfloor>v\<rfloor> |]
            ==> ?Pa;
         !!t sh h ls a.
            [| ?s = (h, ls, sh); ?e' = throw a;
               ?P \<turnstile> ?C has ?F,Static:t in ?D;
               ALL sfs. sh ?D ~= \<lfloor>(sfs, Done)\<rfloor>;
               ?P \<turnstile>\<^sub>1 \<langle>INIT ?D ([?D],False) \<leftarrow> unit,
  (h, ls, sh)\<rangle> \<Rightarrow>
 \<langle>throw a,?s'\<rangle> |]
            ==> ?Pa;
         [| ?e' = THROW NoSuchFieldError; ?s' = ?s;
            ALL b t. ~ ?P \<turnstile> ?C has ?F,b:t in ?D |]
         ==> ?Pa;
         !!t. [| ?e' = THROW IncompatibleClassChangeError; ?s' = ?s;
                 ?P \<turnstile> ?C has ?F,NonStatic:t in ?D |]
              ==> ?Pa |]
      ==> ?Pa",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app
                   (template_app (template_hole 37, template_var 7),
                    template_app
                     (template_app
                       (template_app (template_hole 36, template_var 6),
                        template_var 5),
                      template_var 4)),
                  template_var 3),
                template_var 2),
              template_var 1)
            ),
        template_predicate (template_app (template_hole 35, t_empty)),
        template_predicate (template_app (template_hole 35, t_empty)),
        template_predicate (template_app (template_hole 35, t_empty)),
        template_implication
         ([template_equation
            (template_var 2,
             template_app
              (template_hole 7,
               template_app
                (template_hole 25,
                 template_app
                  (template_hole 6,
                   template_app (template_hole 5, template_hole 4)))))],
          template_implication
           ([template_equation (template_var 1, template_var 3)],
            template_implication
             ([template_predicate
                (template_app (template_hole 3, t_empty))],
              template_predicate (template_var 0)))),
        template_predicate (template_app (template_hole 35, t_empty))],
       template_predicate (template_var 0))),
    ("J1.eval\<^sub>1_cases",
     "[| ?P \<turnstile>\<^sub>1 \<langle>?e\<^sub>1\<bullet>?F{?D} := ?e\<^sub>2,
                                  ?s\<rangle> \<Rightarrow>
                                 \<langle>?e',?s'\<rangle>;
         !!a s\<^sub>1 v h\<^sub>2 l\<^sub>2 sh\<^sub>2 C fs t.
            [| ?e' = unit;
               ?s' =
               (h\<^sub>2(a |-> (C, fs((?F, ?D) |-> v))), l\<^sub>2,
                sh\<^sub>2);
               ?P \<turnstile>\<^sub>1 \<langle>?e\<^sub>1,
  ?s\<rangle> \<Rightarrow>
 \<langle>addr a,s\<^sub>1\<rangle>;
               ?P \<turnstile>\<^sub>1 \<langle>?e\<^sub>2,
  s\<^sub>1\<rangle> \<Rightarrow>
 \<langle>Val v,(h\<^sub>2, l\<^sub>2, sh\<^sub>2)\<rangle>;
               h\<^sub>2 a = \<lfloor>(C, fs)\<rfloor>;
               ?P \<turnstile> C has ?F,NonStatic:t in ?D |]
            ==> ?Pa;
         !!s\<^sub>1 v.
            [| ?e' = THROW NullPointer;
               ?P \<turnstile>\<^sub>1 \<langle>?e\<^sub>1,
  ?s\<rangle> \<Rightarrow>
 \<langle>null,s\<^sub>1\<rangle>;
               ?P \<turnstile>\<^sub>1 \<langle>?e\<^sub>2,
  s\<^sub>1\<rangle> \<Rightarrow>
 \<langle>Val v,?s'\<rangle> |]
            ==> ?Pa;
         !!e'. [| ?e' = throw e';
                  ?P \<turnstile>\<^sub>1 \<langle>?e\<^sub>1,
     ?s\<rangle> \<Rightarrow>
    \<langle>throw e',?s'\<rangle> |]
               ==> ?Pa;
         !!v s\<^sub>1 e'.
            [| ?e' = throw e';
               ?P \<turnstile>\<^sub>1 \<langle>?e\<^sub>1,
  ?s\<rangle> \<Rightarrow>
 \<langle>Val v,s\<^sub>1\<rangle>;
               ?P \<turnstile>\<^sub>1 \<langle>?e\<^sub>2,
  s\<^sub>1\<rangle> \<Rightarrow>
 \<langle>throw e',?s'\<rangle> |]
            ==> ?Pa;
         !!a s\<^sub>1 v h\<^sub>2 l\<^sub>2 sh\<^sub>2 C fs.
            [| ?e' = THROW NoSuchFieldError;
               ?s' = (h\<^sub>2, l\<^sub>2, sh\<^sub>2);
               ?P \<turnstile>\<^sub>1 \<langle>?e\<^sub>1,
  ?s\<rangle> \<Rightarrow>
 \<langle>addr a,s\<^sub>1\<rangle>;
               ?P \<turnstile>\<^sub>1 \<langle>?e\<^sub>2,
  s\<^sub>1\<rangle> \<Rightarrow>
 \<langle>Val v,(h\<^sub>2, l\<^sub>2, sh\<^sub>2)\<rangle>;
               h\<^sub>2 a = \<lfloor>(C, fs)\<rfloor>;
               ALL b t. ~ ?P \<turnstile> C has ?F,b:t in ?D |]
            ==> ?Pa;
         !!a s\<^sub>1 v h\<^sub>2 l\<^sub>2 sh\<^sub>2 C fs t.
            [| ?e' = THROW IncompatibleClassChangeError;
               ?s' = (h\<^sub>2, l\<^sub>2, sh\<^sub>2);
               ?P \<turnstile>\<^sub>1 \<langle>?e\<^sub>1,
  ?s\<rangle> \<Rightarrow>
 \<langle>addr a,s\<^sub>1\<rangle>;
               ?P \<turnstile>\<^sub>1 \<langle>?e\<^sub>2,
  s\<^sub>1\<rangle> \<Rightarrow>
 \<langle>Val v,(h\<^sub>2, l\<^sub>2, sh\<^sub>2)\<rangle>;
               h\<^sub>2 a = \<lfloor>(C, fs)\<rfloor>;
               ?P \<turnstile> C has ?F,Static:t in ?D |]
            ==> ?Pa |]
      ==> ?Pa",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app
                   (template_app (template_hole 37, template_var 8),
                    template_app
                     (template_app
                       (template_app
                         (template_app (template_hole 36, template_var 7),
                          template_var 6),
                        template_var 5),
                      template_var 4)),
                  template_var 3),
                template_var 2),
              template_var 1)
            ),
        template_predicate (template_app (template_hole 35, t_empty)),
        template_predicate (template_app (template_hole 34, t_empty)),
        template_predicate (template_app (template_hole 6, t_empty)),
        template_predicate (template_app (template_hole 33, t_empty)),
        template_predicate (template_app (template_hole 35, t_empty)),
        template_predicate (template_app (template_hole 35, t_empty))],
       template_predicate (template_var 0))),
    ("J1.eval\<^sub>1_cases",
     "[| ?P \<turnstile>\<^sub>1 \<langle>new ?C,?s\<rangle> \<Rightarrow>
                                 \<langle>?e',?s'\<rangle>;
         !!sh sfs h a FDTs l.
            [| ?s = (h, l, sh); ?e' = addr a;
               ?s' = (h(a |-> blank ?P ?C), l, sh);
               sh ?C = \<lfloor>(sfs, Done)\<rfloor>;
               new_Addr h = \<lfloor>a\<rfloor>;
               ?P \<turnstile> ?C has_fields FDTs |]
            ==> ?Pa;
         !!sh sfs h l.
            [| ?s = (h, l, sh); ?e' = THROW OutOfMemory; ?s' = (h, l, sh);
               sh ?C = \<lfloor>(sfs, Done)\<rfloor>; new_Addr h = None |]
            ==> ?Pa;
         !!sh h l v' h' l' sh' a FDTs.
            [| ?s = (h, l, sh); ?e' = addr a;
               ?s' = (h'(a |-> blank ?P ?C), l', sh');
               ALL sfs. sh ?C ~= \<lfloor>(sfs, Done)\<rfloor>;
               ?P \<turnstile>\<^sub>1 \<langle>INIT ?C ([?C],False) \<leftarrow> unit,
  (h, l, sh)\<rangle> \<Rightarrow>
 \<langle>Val v',(h', l', sh')\<rangle>;
               new_Addr h' = \<lfloor>a\<rfloor>;
               ?P \<turnstile> ?C has_fields FDTs |]
            ==> ?Pa;
         !!sh h l v' h' l' sh'.
            [| ?s = (h, l, sh); ?e' = THROW OutOfMemory;
               ?s' = (h', l', sh');
               ALL sfs. sh ?C ~= \<lfloor>(sfs, Done)\<rfloor>;
               ?P \<turnstile>\<^sub>1 \<langle>INIT ?C ([?C],False) \<leftarrow> unit,
  (h, l, sh)\<rangle> \<Rightarrow>
 \<langle>Val v',(h', l', sh')\<rangle>;
               new_Addr h' = None; is_class ?P ?C |]
            ==> ?Pa;
         !!sh h l a.
            [| ?s = (h, l, sh); ?e' = throw a;
               ALL sfs. sh ?C ~= \<lfloor>(sfs, Done)\<rfloor>;
               ?P \<turnstile>\<^sub>1 \<langle>INIT ?C ([?C],False) \<leftarrow> unit,
  (h, l, sh)\<rangle> \<Rightarrow>
 \<langle>throw a,?s'\<rangle>;
               is_class ?P ?C |]
            ==> ?Pa |]
      ==> ?Pa",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app
                   (template_app (template_hole 38, template_var 5),
                    template_app (template_hole 37, template_var 4)),
                  template_var 3),
                template_var 2),
              template_var 1)
            ),
        template_predicate (template_app (template_hole 36, t_empty)),
        template_predicate (template_app (template_hole 36, t_empty)),
        template_predicate (template_app (template_hole 36, t_empty)),
        template_predicate (template_app (template_hole 36, t_empty)),
        template_predicate (template_app (template_hole 36, t_empty))],
       template_predicate (template_var 0))),
    ("J1.eval\<^sub>1_cases",
     "[| ?P \<turnstile>\<^sub>1 \<langle>?C\<bullet>\<^sub>s?F{?D} := ?e\<^sub>2,
                                  ?s\<rangle> \<Rightarrow>
                                 \<langle>?e',?s'\<rangle>;
         !!v h\<^sub>1 l\<^sub>1 sh\<^sub>1 t sfs.
            [| ?e' = unit;
               ?s' =
               (h\<^sub>1, l\<^sub>1, sh\<^sub>1(?D |->
                (sfs(?F |-> v), Done)));
               ?P \<turnstile>\<^sub>1 \<langle>?e\<^sub>2,
  ?s\<rangle> \<Rightarrow>
 \<langle>Val v,(h\<^sub>1, l\<^sub>1, sh\<^sub>1)\<rangle>;
               ?P \<turnstile> ?C has ?F,Static:t in ?D;
               sh\<^sub>1 ?D = \<lfloor>(sfs, Done)\<rfloor> |]
            ==> ?Pa;
         !!v h\<^sub>1 l\<^sub>1 sh\<^sub>1 t v' h' l' sh' sfs i.
            [| ?e' = unit; ?s' = (h', l', sh'(?D |-> (sfs(?F |-> v), i)));
               ?P \<turnstile>\<^sub>1 \<langle>?e\<^sub>2,
  ?s\<rangle> \<Rightarrow>
 \<langle>Val v,(h\<^sub>1, l\<^sub>1, sh\<^sub>1)\<rangle>;
               ?P \<turnstile> ?C has ?F,Static:t in ?D;
               ALL sfs. sh\<^sub>1 ?D ~= \<lfloor>(sfs, Done)\<rfloor>;
               ?P \<turnstile>\<^sub>1 \<langle>INIT ?D ([?D],False) \<leftarrow> unit,
  (h\<^sub>1, l\<^sub>1, sh\<^sub>1)\<rangle> \<Rightarrow>
 \<langle>Val v',(h', l', sh')\<rangle>;
               sh' ?D = \<lfloor>(sfs, i)\<rfloor> |]
            ==> ?Pa;
         !!v h\<^sub>1 l\<^sub>1 sh\<^sub>1 t a.
            [| ?e' = throw a;
               ?P \<turnstile>\<^sub>1 \<langle>?e\<^sub>2,
  ?s\<rangle> \<Rightarrow>
 \<langle>Val v,(h\<^sub>1, l\<^sub>1, sh\<^sub>1)\<rangle>;
               ?P \<turnstile> ?C has ?F,Static:t in ?D;
               ALL sfs. sh\<^sub>1 ?D ~= \<lfloor>(sfs, Done)\<rfloor>;
               ?P \<turnstile>\<^sub>1 \<langle>INIT ?D ([?D],False) \<leftarrow> unit,
  (h\<^sub>1, l\<^sub>1, sh\<^sub>1)\<rangle> \<Rightarrow>
 \<langle>throw a,?s'\<rangle> |]
            ==> ?Pa;
         !!e'. [| ?e' = throw e';
                  ?P \<turnstile>\<^sub>1 \<langle>?e\<^sub>2,
     ?s\<rangle> \<Rightarrow>
    \<langle>throw e',?s'\<rangle> |]
               ==> ?Pa;
         !!v h\<^sub>2 l\<^sub>2 sh\<^sub>2.
            [| ?e' = THROW NoSuchFieldError;
               ?s' = (h\<^sub>2, l\<^sub>2, sh\<^sub>2);
               ?P \<turnstile>\<^sub>1 \<langle>?e\<^sub>2,
  ?s\<rangle> \<Rightarrow>
 \<langle>Val v,(h\<^sub>2, l\<^sub>2, sh\<^sub>2)\<rangle>;
               ALL b t. ~ ?P \<turnstile> ?C has ?F,b:t in ?D |]
            ==> ?Pa;
         !!v h\<^sub>2 l\<^sub>2 sh\<^sub>2 t.
            [| ?e' = THROW IncompatibleClassChangeError;
               ?s' = (h\<^sub>2, l\<^sub>2, sh\<^sub>2);
               ?P \<turnstile>\<^sub>1 \<langle>?e\<^sub>2,
  ?s\<rangle> \<Rightarrow>
 \<langle>Val v,(h\<^sub>2, l\<^sub>2, sh\<^sub>2)\<rangle>;
               ?P \<turnstile> ?C has ?F,NonStatic:t in ?D |]
            ==> ?Pa |]
      ==> ?Pa",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app
                   (template_app (template_hole 38, template_var 8),
                    template_app
                     (template_app
                       (template_app
                         (template_app (template_hole 37, template_var 7),
                          template_var 6),
                        template_var 5),
                      template_var 4)),
                  template_var 3),
                template_var 2),
              template_var 1)
            ),
        template_predicate (template_app (template_hole 36, t_empty)),
        template_predicate (template_app (template_hole 36, t_empty)),
        template_predicate (template_app (template_hole 36, t_empty)),
        template_predicate (template_app (template_hole 8, t_empty)),
        template_predicate (template_app (template_hole 36, t_empty)),
        template_predicate (template_app (template_hole 36, t_empty))],
       template_predicate (template_var 0))),
    ("J1.eval\<^sub>1_cases",
     "[| ?P \<turnstile>\<^sub>1 \<langle>?e\<bullet>?M(?es),
                                  ?s\<rangle> \<Rightarrow>
                                 \<langle>?e',?s'\<rangle>;
         !!e'. [| ?e' = throw e';
                  ?P \<turnstile>\<^sub>1 \<langle>?e,
     ?s\<rangle> \<Rightarrow>
    \<langle>throw e',?s'\<rangle> |]
               ==> ?Pa;
         !!s\<^sub>1 vs.
            [| ?e' = THROW NullPointer;
               ?P \<turnstile>\<^sub>1 \<langle>?e,?s\<rangle> \<Rightarrow>
 \<langle>null,s\<^sub>1\<rangle>;
               ?P \<turnstile>\<^sub>1 \<langle>?es,
  s\<^sub>1\<rangle> [\<Rightarrow>]
 \<langle>map Val vs,?s'\<rangle> |]
            ==> ?Pa;
         !!a s\<^sub>1 vs h\<^sub>2 ls\<^sub>2 sh\<^sub>2 C fs Ts T body D
            h\<^sub>3 ls\<^sub>3 sh\<^sub>3.
            [| ?s' = (h\<^sub>3, ls\<^sub>2, sh\<^sub>3);
               ?P \<turnstile>\<^sub>1 \<langle>?e,?s\<rangle> \<Rightarrow>
 \<langle>addr a,s\<^sub>1\<rangle>;
               ?P \<turnstile>\<^sub>1 \<langle>?es,
  s\<^sub>1\<rangle> [\<Rightarrow>]
 \<langle>map Val vs,(h\<^sub>2, ls\<^sub>2, sh\<^sub>2)\<rangle>;
               h\<^sub>2 a = \<lfloor>(C, fs)\<rfloor>;
               ?P \<turnstile> C sees ?M, NonStatic :  Ts\<rightarrow>T = body in D;
               length vs = length Ts;
               ?P \<turnstile>\<^sub>1 \<langle>body,
  (h\<^sub>2, Addr a # vs @ replicate (max_vars body) undefined,
   sh\<^sub>2)\<rangle> \<Rightarrow>
 \<langle>?e',(h\<^sub>3, ls\<^sub>3, sh\<^sub>3)\<rangle> |]
            ==> ?Pa;
         !!v s\<^sub>1 vs ex es\<^sub>2.
            [| ?e' = throw ex;
               ?P \<turnstile>\<^sub>1 \<langle>?e,?s\<rangle> \<Rightarrow>
 \<langle>Val v,s\<^sub>1\<rangle>;
               ?P \<turnstile>\<^sub>1 \<langle>?es,
  s\<^sub>1\<rangle> [\<Rightarrow>]
 \<langle>map Val vs @ throw ex # es\<^sub>2,?s'\<rangle> |]
            ==> ?Pa;
         !!a s\<^sub>1 vs h\<^sub>2 ls\<^sub>2 sh\<^sub>2 C fs.
            [| ?e' = THROW NoSuchMethodError;
               ?s' = (h\<^sub>2, ls\<^sub>2, sh\<^sub>2);
               ?P \<turnstile>\<^sub>1 \<langle>?e,?s\<rangle> \<Rightarrow>
 \<langle>addr a,s\<^sub>1\<rangle>;
               ?P \<turnstile>\<^sub>1 \<langle>?es,
  s\<^sub>1\<rangle> [\<Rightarrow>]
 \<langle>map Val vs,(h\<^sub>2, ls\<^sub>2, sh\<^sub>2)\<rangle>;
               h\<^sub>2 a = \<lfloor>(C, fs)\<rfloor>;
               ALL b Ts T body x.
                  ~ ?P \<turnstile> C sees ?M, b :  Ts\<rightarrow>T = body in x |]
            ==> ?Pa;
         !!a s\<^sub>1 vs h\<^sub>2 ls\<^sub>2 sh\<^sub>2 C fs Ts T body D.
            [| ?e' = THROW IncompatibleClassChangeError;
               ?s' = (h\<^sub>2, ls\<^sub>2, sh\<^sub>2);
               ?P \<turnstile>\<^sub>1 \<langle>?e,?s\<rangle> \<Rightarrow>
 \<langle>addr a,s\<^sub>1\<rangle>;
               ?P \<turnstile>\<^sub>1 \<langle>?es,
  s\<^sub>1\<rangle> [\<Rightarrow>]
 \<langle>map Val vs,(h\<^sub>2, ls\<^sub>2, sh\<^sub>2)\<rangle>;
               h\<^sub>2 a = \<lfloor>(C, fs)\<rfloor>;
               ?P \<turnstile> C sees ?M, Static :  Ts\<rightarrow>T = body in D |]
            ==> ?Pa |]
      ==> ?Pa",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app
                   (template_app (template_hole 49, template_var 7),
                    template_app
                     (template_app
                       (template_app (template_hole 48, template_var 6),
                        template_var 5),
                      template_var 4)),
                  template_var 3),
                template_var 2),
              template_var 1)
            ),
        template_predicate (template_app (template_hole 47, t_empty)),
        template_predicate (template_app (template_hole 44, t_empty)),
        template_predicate (template_app (template_hole 35, t_empty)),
        template_predicate (template_app (template_hole 12, t_empty)),
        template_predicate (template_app (template_hole 35, t_empty)),
        template_predicate (template_app (template_hole 35, t_empty))],
       template_predicate (template_var 0))),
    ("J1.eval\<^sub>1_cases",
     "[| ?P \<turnstile>\<^sub>1 \<langle>?C\<bullet>\<^sub>s?M(?es),
                                  ?s\<rangle> \<Rightarrow>
                                 \<langle>?e',?s'\<rangle>;
         !!vs ex es\<^sub>2.
            [| ?e' = throw ex;
               ?P \<turnstile>\<^sub>1 \<langle>?es,
  ?s\<rangle> [\<Rightarrow>]
 \<langle>map Val vs @ throw ex # es\<^sub>2,?s'\<rangle> |]
            ==> ?Pa;
         !!vs. [| ?e' = THROW NoSuchMethodError;
                  ?P \<turnstile>\<^sub>1 \<langle>?es,
     ?s\<rangle> [\<Rightarrow>]
    \<langle>map Val vs,?s'\<rangle>;
                  ALL b Ts T body x.
                     ~ ?P \<turnstile> ?C sees ?M, b :  Ts\<rightarrow>T = body in x |]
               ==> ?Pa;
         !!vs Ts T body D.
            [| ?e' = THROW IncompatibleClassChangeError;
               ?P \<turnstile>\<^sub>1 \<langle>?es,
  ?s\<rangle> [\<Rightarrow>]
 \<langle>map Val vs,?s'\<rangle>;
               ?P \<turnstile> ?C sees ?M, NonStatic :  Ts\<rightarrow>T = body in D |]
            ==> ?Pa;
         !!vs h\<^sub>1 ls\<^sub>1 sh\<^sub>1 Ts T body D a.
            [| ?e' = throw a;
               ?P \<turnstile>\<^sub>1 \<langle>?es,
  ?s\<rangle> [\<Rightarrow>]
 \<langle>map Val vs,(h\<^sub>1, ls\<^sub>1, sh\<^sub>1)\<rangle>;
               ?P \<turnstile> ?C sees ?M, Static :  Ts\<rightarrow>T = body in D;
               ALL sfs. sh\<^sub>1 D ~= \<lfloor>(sfs, Done)\<rfloor>;
               ?M ~= clinit;
               ?P \<turnstile>\<^sub>1 \<langle>INIT D ([D],False) \<leftarrow> unit,
  (h\<^sub>1, ls\<^sub>1, sh\<^sub>1)\<rangle> \<Rightarrow>
 \<langle>throw a,?s'\<rangle> |]
            ==> ?Pa;
         !!vs h\<^sub>1 ls\<^sub>1 sh\<^sub>1 Ts T body D v' h\<^sub>2
            ls\<^sub>2 sh\<^sub>2 h\<^sub>3 ls\<^sub>3 sh\<^sub>3.
            [| ?s' = (h\<^sub>3, ls\<^sub>2, sh\<^sub>3);
               ?P \<turnstile>\<^sub>1 \<langle>?es,
  ?s\<rangle> [\<Rightarrow>]
 \<langle>map Val vs,(h\<^sub>1, ls\<^sub>1, sh\<^sub>1)\<rangle>;
               ?P \<turnstile> ?C sees ?M, Static :  Ts\<rightarrow>T = body in D;
               ALL sfs. sh\<^sub>1 D ~= \<lfloor>(sfs, Done)\<rfloor>;
               ?M ~= clinit;
               ?P \<turnstile>\<^sub>1 \<langle>INIT D ([D],False) \<leftarrow> unit,
  (h\<^sub>1, ls\<^sub>1, sh\<^sub>1)\<rangle> \<Rightarrow>
 \<langle>Val v',(h\<^sub>2, ls\<^sub>2, sh\<^sub>2)\<rangle>;
               length vs = length Ts;
               ?P \<turnstile>\<^sub>1 \<langle>body,
  (h\<^sub>2, vs @ replicate (max_vars body) undefined,
   sh\<^sub>2)\<rangle> \<Rightarrow>
 \<langle>?e',(h\<^sub>3, ls\<^sub>3, sh\<^sub>3)\<rangle> |]
            ==> ?Pa;
         !!vs h\<^sub>2 ls\<^sub>2 sh\<^sub>2 Ts T body D sfs h\<^sub>3
            ls\<^sub>3 sh\<^sub>3.
            [| ?s' = (h\<^sub>3, ls\<^sub>2, sh\<^sub>3);
               ?P \<turnstile>\<^sub>1 \<langle>?es,
  ?s\<rangle> [\<Rightarrow>]
 \<langle>map Val vs,(h\<^sub>2, ls\<^sub>2, sh\<^sub>2)\<rangle>;
               ?P \<turnstile> ?C sees ?M, Static :  Ts\<rightarrow>T = body in D;
               sh\<^sub>2 D = \<lfloor>(sfs, Done)\<rfloor> |
               ?M = clinit &
               sh\<^sub>2 D = \<lfloor>(sfs, Processing)\<rfloor>;
               length vs = length Ts;
               ?P \<turnstile>\<^sub>1 \<langle>body,
  (h\<^sub>2, vs @ replicate (max_vars body) undefined,
   sh\<^sub>2)\<rangle> \<Rightarrow>
 \<langle>?e',(h\<^sub>3, ls\<^sub>3, sh\<^sub>3)\<rangle> |]
            ==> ?Pa |]
      ==> ?Pa",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app
                   (template_app (template_hole 56, template_var 7),
                    template_app
                     (template_app
                       (template_app (template_hole 55, template_var 6),
                        template_var 5),
                      template_var 4)),
                  template_var 3),
                template_var 2),
              template_var 1)
            ),
        template_predicate (template_app (template_hole 54, t_empty)),
        template_predicate (template_app (template_hole 54, t_empty)),
        template_predicate (template_app (template_hole 54, t_empty)),
        template_predicate (template_app (template_hole 54, t_empty)),
        template_predicate (template_app (template_hole 54, t_empty)),
        template_predicate (template_app (template_hole 54, t_empty))],
       template_predicate (template_var 0))),
    ("J1.eval\<^sub>1_cases",
     "[| ?P \<turnstile>\<^sub>1 \<langle>INIT ?C (?Cs,?b) \<leftarrow> ?e,
                                  ?s\<rangle> \<Rightarrow>
                                 \<langle>?e',?s'\<rangle>;
         [| ?Cs = [];
            ?P \<turnstile>\<^sub>1 \<langle>?e,?s\<rangle> \<Rightarrow>
                                    \<langle>?e',?s'\<rangle> |]
         ==> ?Pa;
         !!sh C Cs h l.
            [| ?s = (h, l, sh); sh C = None;
               ?P \<turnstile>\<^sub>1 \<langle>INIT ?C (C #
                   Cs,False) \<leftarrow> ?e,
  (h, l, sh(C |-> (sblank ?P C, Prepared)))\<rangle> \<Rightarrow>
 \<langle>?e',?s'\<rangle>;
               ?Cs = C # Cs; ~ ?b |]
            ==> ?Pa;
         !!sh C sfs Cs h l.
            [| ?s = (h, l, sh); sh C = \<lfloor>(sfs, Done)\<rfloor>;
               ?P \<turnstile>\<^sub>1 \<langle>INIT ?C (Cs,True) \<leftarrow> ?e,
  (h, l, sh)\<rangle> \<Rightarrow>
 \<langle>?e',?s'\<rangle>;
               ?Cs = C # Cs; ~ ?b |]
            ==> ?Pa;
         !!sh C sfs Cs h l.
            [| ?s = (h, l, sh); sh C = \<lfloor>(sfs, Processing)\<rfloor>;
               ?P \<turnstile>\<^sub>1 \<langle>INIT ?C (Cs,True) \<leftarrow> ?e,
  (h, l, sh)\<rangle> \<Rightarrow>
 \<langle>?e',?s'\<rangle>;
               ?Cs = C # Cs; ~ ?b |]
            ==> ?Pa;
         !!sh C sfs Cs h l.
            [| ?s = (h, l, sh); sh C = \<lfloor>(sfs, Error)\<rfloor>;
               ?P \<turnstile>\<^sub>1 \<langle>RI (C,THROW
                 NoClassDefFoundError) ; Cs \<leftarrow> ?e,
  (h, l, sh)\<rangle> \<Rightarrow>
 \<langle>?e',?s'\<rangle>;
               ?Cs = C # Cs; ~ ?b |]
            ==> ?Pa;
         !!sh sfs Cs h l.
            [| ?s = (h, l, sh);
               sh Object = \<lfloor>(sfs, Prepared)\<rfloor>;
               ?P \<turnstile>\<^sub>1 \<langle>INIT ?C (Object #
                   Cs,True) \<leftarrow> ?e,
  (h, l, sh(Object |-> (sfs, Processing)))\<rangle> \<Rightarrow>
 \<langle>?e',?s'\<rangle>;
               ?Cs = Object # Cs; ~ ?b |]
            ==> ?Pa;
         !!sh C sfs D r Cs h l.
            [| ?s = (h, l, sh); sh C = \<lfloor>(sfs, Prepared)\<rfloor>;
               C ~= Object; class ?P C = \<lfloor>(D, r)\<rfloor>;
               ?P \<turnstile>\<^sub>1 \<langle>INIT ?C (D #
                   C # Cs,False) \<leftarrow> ?e,
  (h, l, sh(C |-> (sfs, Processing)))\<rangle> \<Rightarrow>
 \<langle>?e',?s'\<rangle>;
               ?Cs = C # Cs; ~ ?b |]
            ==> ?Pa;
         !!C Cs h l sh.
            [| ?s = (h, l, sh);
               ?P \<turnstile>\<^sub>1 \<langle>RI (C,C\<bullet>\<^sub>sclinit([])) ; Cs \<leftarrow> ?e,
  (h, l, sh)\<rangle> \<Rightarrow>
 \<langle>?e',?s'\<rangle>;
               ?Cs = C # Cs; ?b |]
            ==> ?Pa |]
      ==> ?Pa",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app
                   (template_app (template_hole 42, template_var 8),
                    template_app
                     (template_app
                       (template_app
                         (template_app (template_hole 41, template_var 7),
                          template_var 6),
                        template_var 5),
                      template_var 4)),
                  template_var 3),
                template_var 2),
              template_var 1)
            ),
        template_implication
         ([template_equation (template_var 6, template_hole 39)],
          template_implication
           ([template_predicate
              (
                 template_app
                  (template_app
                    (template_app
                      (template_app
                        (template_app (template_hole 42, template_var 8),
                         template_var 4),
                       template_var 3),
                     template_var 2),
                   template_var 1)
                 )],
            template_predicate (template_var 0))),
        template_predicate (template_app (template_hole 38, t_empty)),
        template_predicate (template_app (template_hole 38, t_empty)),
        template_predicate (template_app (template_hole 38, t_empty)),
        template_predicate (template_app (template_hole 38, t_empty)),
        template_predicate (template_app (template_hole 38, t_empty)),
        template_predicate (template_app (template_hole 38, t_empty)),
        template_predicate (template_app (template_hole 37, t_empty))],
       template_predicate (template_var 0))),
    ("J1.eval\<^sub>1_evals\<^sub>1_inducts",
     "[| ?P \<turnstile>\<^sub>1 \<langle>?x1a,
                                  (?x2a, ?x2b, ?x2c)\<rangle> \<Rightarrow>
                                 \<langle>?x3a,(?x4a, ?x4b, ?x4c)\<rangle>;
         !!sh C sfs h a FDTs h' l.
            [| sh C = \<lfloor>(sfs, Done)\<rfloor>;
               new_Addr h = \<lfloor>a\<rfloor>;
               ?P \<turnstile> C has_fields FDTs;
               h' = h(a |-> blank ?P C) |]
            ==> ?P1.0 (new C) h l sh (addr a) h' l sh;
         !!sh C sfs h l.
            [| sh C = \<lfloor>(sfs, Done)\<rfloor>; new_Addr h = None |]
            ==> ?P1.0 (new C) h l sh (THROW OutOfMemory) h l sh;
         !!sh C h l v' h' l' sh' a FDTs h''.
            [| \<nexists>sfs. sh C = \<lfloor>(sfs, Done)\<rfloor>;
               ?P \<turnstile>\<^sub>1 \<langle>INIT C ([C],False) \<leftarrow> unit,
  (h, l, sh)\<rangle> \<Rightarrow>
 \<langle>Val v',(h', l', sh')\<rangle>;
               ?P1.0 (INIT C ([C],False) \<leftarrow> unit) h l sh (Val v')
                h' l' sh';
               new_Addr h' = \<lfloor>a\<rfloor>;
               ?P \<turnstile> C has_fields FDTs;
               h'' = h'(a |-> blank ?P C) |]
            ==> ?P1.0 (new C) h l sh (addr a) h'' l' sh';
         !!sh C h l v' h' l' sh'.
            [| \<nexists>sfs. sh C = \<lfloor>(sfs, Done)\<rfloor>;
               ?P \<turnstile>\<^sub>1 \<langle>INIT C ([C],False) \<leftarrow> unit,
  (h, l, sh)\<rangle> \<Rightarrow>
 \<langle>Val v',(h', l', sh')\<rangle>;
               ?P1.0 (INIT C ([C],False) \<leftarrow> unit) h l sh (Val v')
                h' l' sh';
               new_Addr h' = None; is_class ?P C |]
            ==> ?P1.0 (new C) h l sh (THROW OutOfMemory) h' l' sh';
         !!sh C h l a aa ab b.
            [| \<nexists>sfs. sh C = \<lfloor>(sfs, Done)\<rfloor>;
               ?P \<turnstile>\<^sub>1 \<langle>INIT C ([C],False) \<leftarrow> unit,
  (h, l, sh)\<rangle> \<Rightarrow>
 \<langle>throw a,(aa, ab, b)\<rangle>;
               ?P1.0 (INIT C ([C],False) \<leftarrow> unit) h l sh (throw a)
                aa ab b;
               is_class ?P C |]
            ==> ?P1.0 (new C) h l sh (throw a) aa ab b;
         !!e a aa b ab h l sh D fs C.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>addr ab,(h, l, sh)\<rangle>;
               ?P1.0 e a aa b (addr ab) h l sh;
               h ab = \<lfloor>(D, fs)\<rfloor>;
               ?P \<turnstile> D \<preceq>\<^sup>* C |]
            ==> ?P1.0 (Cast C e) a aa b (addr ab) h l sh;
         !!e a aa b ab ac ba C.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>null,(ab, ac, ba)\<rangle>;
               ?P1.0 e a aa b null ab ac ba |]
            ==> ?P1.0 (Cast C e) a aa b null ab ac ba;
         !!e a aa b ab h l sh D fs C.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>addr ab,(h, l, sh)\<rangle>;
               ?P1.0 e a aa b (addr ab) h l sh;
               h ab = \<lfloor>(D, fs)\<rfloor>; (D, C) ~: (subcls1 ?P)^* |]
            ==> ?P1.0 (Cast C e) a aa b (THROW ClassCast) h l sh;
         !!e a aa b e' ab ac ba C.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>throw e',(ab, ac, ba)\<rangle>;
               ?P1.0 e a aa b (throw e') ab ac ba |]
            ==> ?P1.0 (Cast C e) a aa b (throw e') ab ac ba;
         !!v a aa b. ?P1.0 (Val v) a aa b (Val v) a aa b;
         !!e\<^sub>1 a aa b v\<^sub>1 ab ac ba e\<^sub>2 v\<^sub>2 ad ae bb
            bop v.
            [| ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>1,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>Val v\<^sub>1,(ab, ac, ba)\<rangle>;
               ?P1.0 e\<^sub>1 a aa b (Val v\<^sub>1) ab ac ba;
               ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>2,
  (ab, ac, ba)\<rangle> \<Rightarrow>
 \<langle>Val v\<^sub>2,(ad, ae, bb)\<rangle>;
               ?P1.0 e\<^sub>2 ab ac ba (Val v\<^sub>2) ad ae bb;
               binop (bop, v\<^sub>1, v\<^sub>2) = \<lfloor>v\<rfloor> |]
            ==> ?P1.0
                 (e\<^sub>1 \<guillemotleft>bop\<guillemotright> e\<^sub>2)
                 a aa b (Val v) ad ae bb;
         !!e\<^sub>1 a aa b e ab ac ba bop e\<^sub>2.
            [| ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>1,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>throw e,(ab, ac, ba)\<rangle>;
               ?P1.0 e\<^sub>1 a aa b (throw e) ab ac ba |]
            ==> ?P1.0
                 (e\<^sub>1 \<guillemotleft>bop\<guillemotright> e\<^sub>2)
                 a aa b (throw e) ab ac ba;
         !!e\<^sub>1 a aa b v\<^sub>1 ab ac ba e\<^sub>2 e ad ae bb bop.
            [| ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>1,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>Val v\<^sub>1,(ab, ac, ba)\<rangle>;
               ?P1.0 e\<^sub>1 a aa b (Val v\<^sub>1) ab ac ba;
               ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>2,
  (ab, ac, ba)\<rangle> \<Rightarrow>
 \<langle>throw e,(ad, ae, bb)\<rangle>;
               ?P1.0 e\<^sub>2 ab ac ba (throw e) ad ae bb |]
            ==> ?P1.0
                 (e\<^sub>1 \<guillemotleft>bop\<guillemotright> e\<^sub>2)
                 a aa b (throw e) ad ae bb;
         !!ls i v h sh.
            [| ls ! i = v; i < length ls |]
            ==> ?P1.0 (Var i) h ls sh (Val v) h ls sh;
         !!e a aa b v h ls sh i ls'.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>Val v,(h, ls, sh)\<rangle>;
               ?P1.0 e a aa b (Val v) h ls sh; i < length ls;
               ls' = ls[i := v] |]
            ==> ?P1.0 (i:=e) a aa b unit h ls' sh;
         !!e a aa b e' ab ac ba i.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>throw e',(ab, ac, ba)\<rangle>;
               ?P1.0 e a aa b (throw e') ab ac ba |]
            ==> ?P1.0 (i:=e) a aa b (throw e') ab ac ba;
         !!e a aa b ab h ls sh C fs F t D v.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>addr ab,(h, ls, sh)\<rangle>;
               ?P1.0 e a aa b (addr ab) h ls sh;
               h ab = \<lfloor>(C, fs)\<rfloor>;
               ?P \<turnstile> C has F,NonStatic:t in D;
               fs (F, D) = \<lfloor>v\<rfloor> |]
            ==> ?P1.0 (e\<bullet>F{D}) a aa b (Val v) h ls sh;
         !!e a aa b ab ac ba F D.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>null,(ab, ac, ba)\<rangle>;
               ?P1.0 e a aa b null ab ac ba |]
            ==> ?P1.0 (e\<bullet>F{D}) a aa b (THROW NullPointer) ab ac ba;
         !!e a aa b e' ab ac ba F D.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>throw e',(ab, ac, ba)\<rangle>;
               ?P1.0 e a aa b (throw e') ab ac ba |]
            ==> ?P1.0 (e\<bullet>F{D}) a aa b (throw e') ab ac ba;
         !!e a aa b ab h ls sh C fs F D.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>addr ab,(h, ls, sh)\<rangle>;
               ?P1.0 e a aa b (addr ab) h ls sh;
               h ab = \<lfloor>(C, fs)\<rfloor>;
               \<nexists>b t. ?P \<turnstile> C has F,b:t in D |]
            ==> ?P1.0 (e\<bullet>F{D}) a aa b (THROW NoSuchFieldError) h ls
                 sh;
         !!e a aa b ab h ls sh C fs F t D.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>addr ab,(h, ls, sh)\<rangle>;
               ?P1.0 e a aa b (addr ab) h ls sh;
               h ab = \<lfloor>(C, fs)\<rfloor>;
               ?P \<turnstile> C has F,Static:t in D |]
            ==> ?P1.0 (e\<bullet>F{D}) a aa b
                 (THROW IncompatibleClassChangeError) h ls sh;
         !!C F t D sh sfs v h ls.
            [| ?P \<turnstile> C has F,Static:t in D;
               sh D = \<lfloor>(sfs, Done)\<rfloor>;
               sfs F = \<lfloor>v\<rfloor> |]
            ==> ?P1.0 (C\<bullet>\<^sub>sF{D}) h ls sh (Val v) h ls sh;
         !!C F t D sh h ls v' h' ls' sh' sfs i v.
            [| ?P \<turnstile> C has F,Static:t in D;
               \<nexists>sfs. sh D = \<lfloor>(sfs, Done)\<rfloor>;
               ?P \<turnstile>\<^sub>1 \<langle>INIT D ([D],False) \<leftarrow> unit,
  (h, ls, sh)\<rangle> \<Rightarrow>
 \<langle>Val v',(h', ls', sh')\<rangle>;
               ?P1.0 (INIT D ([D],False) \<leftarrow> unit) h ls sh (Val v')
                h' ls' sh';
               sh' D = \<lfloor>(sfs, i)\<rfloor>;
               sfs F = \<lfloor>v\<rfloor> |]
            ==> ?P1.0 (C\<bullet>\<^sub>sF{D}) h ls sh (Val v) h' ls' sh';
         !!C F t D sh h ls a aa ab b.
            [| ?P \<turnstile> C has F,Static:t in D;
               \<nexists>sfs. sh D = \<lfloor>(sfs, Done)\<rfloor>;
               ?P \<turnstile>\<^sub>1 \<langle>INIT D ([D],False) \<leftarrow> unit,
  (h, ls, sh)\<rangle> \<Rightarrow>
 \<langle>throw a,(aa, ab, b)\<rangle>;
               ?P1.0 (INIT D ([D],False) \<leftarrow> unit) h ls sh
                (throw a) aa ab b |]
            ==> ?P1.0 (C\<bullet>\<^sub>sF{D}) h ls sh (throw a) aa ab b;
         !!C F D a aa b.
            \<nexists>b t. ?P \<turnstile> C has F,b:t in D ==>
            ?P1.0 (C\<bullet>\<^sub>sF{D}) a aa b (THROW NoSuchFieldError) a
             aa b;
         !!C F t D a aa b.
            ?P \<turnstile> C has F,NonStatic:t in D ==>
            ?P1.0 (C\<bullet>\<^sub>sF{D}) a aa b
             (THROW IncompatibleClassChangeError) a aa b;
         !!e\<^sub>1 a aa b ab ac ad ba e\<^sub>2 v h\<^sub>2 l\<^sub>2
            sh\<^sub>2 C fs F t D fs' h\<^sub>2'.
            [| ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>1,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>addr ab,(ac, ad, ba)\<rangle>;
               ?P1.0 e\<^sub>1 a aa b (addr ab) ac ad ba;
               ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>2,
  (ac, ad, ba)\<rangle> \<Rightarrow>
 \<langle>Val v,(h\<^sub>2, l\<^sub>2, sh\<^sub>2)\<rangle>;
               ?P1.0 e\<^sub>2 ac ad ba (Val v) h\<^sub>2 l\<^sub>2
                sh\<^sub>2;
               h\<^sub>2 ab = \<lfloor>(C, fs)\<rfloor>;
               ?P \<turnstile> C has F,NonStatic:t in D;
               fs' = fs((F, D) |-> v);
               h\<^sub>2' = h\<^sub>2(ab |-> (C, fs')) |]
            ==> ?P1.0 (e\<^sub>1\<bullet>F{D} := e\<^sub>2) a aa b unit
                 h\<^sub>2' l\<^sub>2 sh\<^sub>2;
         !!e\<^sub>1 a aa b ab ac ba e\<^sub>2 v ad ae bb F D.
            [| ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>1,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>null,(ab, ac, ba)\<rangle>;
               ?P1.0 e\<^sub>1 a aa b null ab ac ba;
               ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>2,
  (ab, ac, ba)\<rangle> \<Rightarrow>
 \<langle>Val v,(ad, ae, bb)\<rangle>;
               ?P1.0 e\<^sub>2 ab ac ba (Val v) ad ae bb |]
            ==> ?P1.0 (e\<^sub>1\<bullet>F{D} := e\<^sub>2) a aa b
                 (THROW NullPointer) ad ae bb;
         !!e\<^sub>1 a aa b e' ab ac ba F D e\<^sub>2.
            [| ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>1,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>throw e',(ab, ac, ba)\<rangle>;
               ?P1.0 e\<^sub>1 a aa b (throw e') ab ac ba |]
            ==> ?P1.0 (e\<^sub>1\<bullet>F{D} := e\<^sub>2) a aa b
                 (throw e') ab ac ba;
         !!e\<^sub>1 a aa b v ab ac ba e\<^sub>2 e' ad ae bb F D.
            [| ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>1,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>Val v,(ab, ac, ba)\<rangle>;
               ?P1.0 e\<^sub>1 a aa b (Val v) ab ac ba;
               ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>2,
  (ab, ac, ba)\<rangle> \<Rightarrow>
 \<langle>throw e',(ad, ae, bb)\<rangle>;
               ?P1.0 e\<^sub>2 ab ac ba (throw e') ad ae bb |]
            ==> ?P1.0 (e\<^sub>1\<bullet>F{D} := e\<^sub>2) a aa b
                 (throw e') ad ae bb;
         !!e\<^sub>1 a aa b ab ac ad ba e\<^sub>2 v h\<^sub>2 l\<^sub>2
            sh\<^sub>2 C fs F D.
            [| ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>1,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>addr ab,(ac, ad, ba)\<rangle>;
               ?P1.0 e\<^sub>1 a aa b (addr ab) ac ad ba;
               ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>2,
  (ac, ad, ba)\<rangle> \<Rightarrow>
 \<langle>Val v,(h\<^sub>2, l\<^sub>2, sh\<^sub>2)\<rangle>;
               ?P1.0 e\<^sub>2 ac ad ba (Val v) h\<^sub>2 l\<^sub>2
                sh\<^sub>2;
               h\<^sub>2 ab = \<lfloor>(C, fs)\<rfloor>;
               \<nexists>b t. ?P \<turnstile> C has F,b:t in D |]
            ==> ?P1.0 (e\<^sub>1\<bullet>F{D} := e\<^sub>2) a aa b
                 (THROW NoSuchFieldError) h\<^sub>2 l\<^sub>2 sh\<^sub>2;
         !!e\<^sub>1 a aa b ab ac ad ba e\<^sub>2 v h\<^sub>2 l\<^sub>2
            sh\<^sub>2 C fs F t D.
            [| ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>1,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>addr ab,(ac, ad, ba)\<rangle>;
               ?P1.0 e\<^sub>1 a aa b (addr ab) ac ad ba;
               ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>2,
  (ac, ad, ba)\<rangle> \<Rightarrow>
 \<langle>Val v,(h\<^sub>2, l\<^sub>2, sh\<^sub>2)\<rangle>;
               ?P1.0 e\<^sub>2 ac ad ba (Val v) h\<^sub>2 l\<^sub>2
                sh\<^sub>2;
               h\<^sub>2 ab = \<lfloor>(C, fs)\<rfloor>;
               ?P \<turnstile> C has F,Static:t in D |]
            ==> ?P1.0 (e\<^sub>1\<bullet>F{D} := e\<^sub>2) a aa b
                 (THROW IncompatibleClassChangeError) h\<^sub>2 l\<^sub>2
                 sh\<^sub>2;
         !!e\<^sub>2 a aa b v h\<^sub>1 l\<^sub>1 sh\<^sub>1 C F t D sfs
            sfs' sh\<^sub>1'.
            [| ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>2,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>Val v,(h\<^sub>1, l\<^sub>1, sh\<^sub>1)\<rangle>;
               ?P1.0 e\<^sub>2 a aa b (Val v) h\<^sub>1 l\<^sub>1
                sh\<^sub>1;
               ?P \<turnstile> C has F,Static:t in D;
               sh\<^sub>1 D = \<lfloor>(sfs, Done)\<rfloor>;
               sfs' = sfs(F |-> v);
               sh\<^sub>1' = sh\<^sub>1(D |-> (sfs', Done)) |]
            ==> ?P1.0 (C\<bullet>\<^sub>sF{D} := e\<^sub>2) a aa b unit
                 h\<^sub>1 l\<^sub>1 sh\<^sub>1';
         !!e\<^sub>2 a aa b v h\<^sub>1 l\<^sub>1 sh\<^sub>1 C F t D v' h'
            l' sh' sfs i sfs' sh''.
            [| ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>2,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>Val v,(h\<^sub>1, l\<^sub>1, sh\<^sub>1)\<rangle>;
               ?P1.0 e\<^sub>2 a aa b (Val v) h\<^sub>1 l\<^sub>1
                sh\<^sub>1;
               ?P \<turnstile> C has F,Static:t in D;
               \<nexists>sfs. sh\<^sub>1 D = \<lfloor>(sfs, Done)\<rfloor>;
               ?P \<turnstile>\<^sub>1 \<langle>INIT D ([D],False) \<leftarrow> unit,
  (h\<^sub>1, l\<^sub>1, sh\<^sub>1)\<rangle> \<Rightarrow>
 \<langle>Val v',(h', l', sh')\<rangle>;
               ?P1.0 (INIT D ([D],False) \<leftarrow> unit) h\<^sub>1
                l\<^sub>1 sh\<^sub>1 (Val v') h' l' sh';
               sh' D = \<lfloor>(sfs, i)\<rfloor>; sfs' = sfs(F |-> v);
               sh'' = sh'(D |-> (sfs', i)) |]
            ==> ?P1.0 (C\<bullet>\<^sub>sF{D} := e\<^sub>2) a aa b unit h'
                 l' sh'';
         !!e\<^sub>2 a aa b v h\<^sub>1 l\<^sub>1 sh\<^sub>1 C F t D ab ac
            ad ba.
            [| ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>2,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>Val v,(h\<^sub>1, l\<^sub>1, sh\<^sub>1)\<rangle>;
               ?P1.0 e\<^sub>2 a aa b (Val v) h\<^sub>1 l\<^sub>1
                sh\<^sub>1;
               ?P \<turnstile> C has F,Static:t in D;
               \<nexists>sfs. sh\<^sub>1 D = \<lfloor>(sfs, Done)\<rfloor>;
               ?P \<turnstile>\<^sub>1 \<langle>INIT D ([D],False) \<leftarrow> unit,
  (h\<^sub>1, l\<^sub>1, sh\<^sub>1)\<rangle> \<Rightarrow>
 \<langle>throw ab,(ac, ad, ba)\<rangle>;
               ?P1.0 (INIT D ([D],False) \<leftarrow> unit) h\<^sub>1
                l\<^sub>1 sh\<^sub>1 (throw ab) ac ad ba |]
            ==> ?P1.0 (C\<bullet>\<^sub>sF{D} := e\<^sub>2) a aa b
                 (throw ab) ac ad ba;
         !!e\<^sub>2 a aa b e' ab ac ba C F D.
            [| ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>2,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>throw e',(ab, ac, ba)\<rangle>;
               ?P1.0 e\<^sub>2 a aa b (throw e') ab ac ba |]
            ==> ?P1.0 (C\<bullet>\<^sub>sF{D} := e\<^sub>2) a aa b
                 (throw e') ab ac ba;
         !!e\<^sub>2 a aa b v h\<^sub>2 l\<^sub>2 sh\<^sub>2 C F D.
            [| ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>2,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>Val v,(h\<^sub>2, l\<^sub>2, sh\<^sub>2)\<rangle>;
               ?P1.0 e\<^sub>2 a aa b (Val v) h\<^sub>2 l\<^sub>2
                sh\<^sub>2;
               \<nexists>b t. ?P \<turnstile> C has F,b:t in D |]
            ==> ?P1.0 (C\<bullet>\<^sub>sF{D} := e\<^sub>2) a aa b
                 (THROW NoSuchFieldError) h\<^sub>2 l\<^sub>2 sh\<^sub>2;
         !!e\<^sub>2 a aa b v h\<^sub>2 l\<^sub>2 sh\<^sub>2 C F t D.
            [| ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>2,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>Val v,(h\<^sub>2, l\<^sub>2, sh\<^sub>2)\<rangle>;
               ?P1.0 e\<^sub>2 a aa b (Val v) h\<^sub>2 l\<^sub>2
                sh\<^sub>2;
               ?P \<turnstile> C has F,NonStatic:t in D |]
            ==> ?P1.0 (C\<bullet>\<^sub>sF{D} := e\<^sub>2) a aa b
                 (THROW IncompatibleClassChangeError) h\<^sub>2 l\<^sub>2
                 sh\<^sub>2;
         !!e a aa b e' ab ac ba M es.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>throw e',(ab, ac, ba)\<rangle>;
               ?P1.0 e a aa b (throw e') ab ac ba |]
            ==> ?P1.0 (e\<bullet>M(es)) a aa b (throw e') ab ac ba;
         !!e a aa b ab ac ba es vs ad ae bb M.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>null,(ab, ac, ba)\<rangle>;
               ?P1.0 e a aa b null ab ac ba;
               ?P \<turnstile>\<^sub>1 \<langle>es,
  (ab, ac, ba)\<rangle> [\<Rightarrow>]
 \<langle>map Val vs,(ad, ae, bb)\<rangle>;
               ?P2.0 es ab ac ba (map Val vs) ad ae bb |]
            ==> ?P1.0 (e\<bullet>M(es)) a aa b (THROW NullPointer) ad ae bb;
         !!e a aa b ab ac ad ba es vs h\<^sub>2 ls\<^sub>2 sh\<^sub>2 C fs M
            Ts T body D ls\<^sub>2' e' h\<^sub>3 ls\<^sub>3 sh\<^sub>3.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>addr ab,(ac, ad, ba)\<rangle>;
               ?P1.0 e a aa b (addr ab) ac ad ba;
               ?P \<turnstile>\<^sub>1 \<langle>es,
  (ac, ad, ba)\<rangle> [\<Rightarrow>]
 \<langle>map Val vs,(h\<^sub>2, ls\<^sub>2, sh\<^sub>2)\<rangle>;
               ?P2.0 es ac ad ba (map Val vs) h\<^sub>2 ls\<^sub>2
                sh\<^sub>2;
               h\<^sub>2 ab = \<lfloor>(C, fs)\<rfloor>;
               ?P \<turnstile> C sees M, NonStatic :  Ts\<rightarrow>T = body in D;
               length vs = length Ts;
               ls\<^sub>2' =
               Addr ab # vs @ replicate (max_vars body) undefined;
               ?P \<turnstile>\<^sub>1 \<langle>body,
  (h\<^sub>2, ls\<^sub>2', sh\<^sub>2)\<rangle> \<Rightarrow>
 \<langle>e',(h\<^sub>3, ls\<^sub>3, sh\<^sub>3)\<rangle>;
               ?P1.0 body h\<^sub>2 ls\<^sub>2' sh\<^sub>2 e' h\<^sub>3
                ls\<^sub>3 sh\<^sub>3 |]
            ==> ?P1.0 (e\<bullet>M(es)) a aa b e' h\<^sub>3 ls\<^sub>2
                 sh\<^sub>3;
         !!e a aa b v ab ac ba es es' ad ae bb vs ex es\<^sub>2 M.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>Val v,(ab, ac, ba)\<rangle>;
               ?P1.0 e a aa b (Val v) ab ac ba;
               ?P \<turnstile>\<^sub>1 \<langle>es,
  (ab, ac, ba)\<rangle> [\<Rightarrow>]
 \<langle>es',(ad, ae, bb)\<rangle>;
               ?P2.0 es ab ac ba es' ad ae bb;
               es' = map Val vs @ throw ex # es\<^sub>2 |]
            ==> ?P1.0 (e\<bullet>M(es)) a aa b (throw ex) ad ae bb;
         !!e a aa b ab ac ad ba ps vs h\<^sub>2 ls\<^sub>2 sh\<^sub>2 C fs
            M. [| ?P \<turnstile>\<^sub>1 \<langle>e,
     (a, aa, b)\<rangle> \<Rightarrow>
    \<langle>addr ab,(ac, ad, ba)\<rangle>;
                  ?P1.0 e a aa b (addr ab) ac ad ba;
                  ?P \<turnstile>\<^sub>1 \<langle>ps,
     (ac, ad, ba)\<rangle> [\<Rightarrow>]
    \<langle>map Val vs,(h\<^sub>2, ls\<^sub>2, sh\<^sub>2)\<rangle>;
                  ?P2.0 ps ac ad ba (map Val vs) h\<^sub>2 ls\<^sub>2
                   sh\<^sub>2;
                  h\<^sub>2 ab = \<lfloor>(C, fs)\<rfloor>;
                  \<nexists>b Ts T body. Ex (Method ?P C M b Ts T body) |]
               ==> ?P1.0 (e\<bullet>M(ps)) a aa b (THROW NoSuchMethodError)
                    h\<^sub>2 ls\<^sub>2 sh\<^sub>2;
         !!e a aa b ab ac ad ba ps vs h\<^sub>2 ls\<^sub>2 sh\<^sub>2 C fs M
            Ts T body D.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>addr ab,(ac, ad, ba)\<rangle>;
               ?P1.0 e a aa b (addr ab) ac ad ba;
               ?P \<turnstile>\<^sub>1 \<langle>ps,
  (ac, ad, ba)\<rangle> [\<Rightarrow>]
 \<langle>map Val vs,(h\<^sub>2, ls\<^sub>2, sh\<^sub>2)\<rangle>;
               ?P2.0 ps ac ad ba (map Val vs) h\<^sub>2 ls\<^sub>2
                sh\<^sub>2;
               h\<^sub>2 ab = \<lfloor>(C, fs)\<rfloor>;
               ?P \<turnstile> C sees M, Static :  Ts\<rightarrow>T = body in D |]
            ==> ?P1.0 (e\<bullet>M(ps)) a aa b
                 (THROW IncompatibleClassChangeError) h\<^sub>2 ls\<^sub>2
                 sh\<^sub>2;
         !!es a aa b es' ab ac ba vs ex es\<^sub>2 C M.
            [| ?P \<turnstile>\<^sub>1 \<langle>es,
  (a, aa, b)\<rangle> [\<Rightarrow>]
 \<langle>es',(ab, ac, ba)\<rangle>;
               ?P2.0 es a aa b es' ab ac ba;
               es' = map Val vs @ throw ex # es\<^sub>2 |]
            ==> ?P1.0 (C\<bullet>\<^sub>sM(es)) a aa b (throw ex) ab ac ba;
         !!ps a aa b vs ab ac ba C M.
            [| ?P \<turnstile>\<^sub>1 \<langle>ps,
  (a, aa, b)\<rangle> [\<Rightarrow>]
 \<langle>map Val vs,(ab, ac, ba)\<rangle>;
               ?P2.0 ps a aa b (map Val vs) ab ac ba;
               \<nexists>b Ts T body. Ex (Method ?P C M b Ts T body) |]
            ==> ?P1.0 (C\<bullet>\<^sub>sM(ps)) a aa b
                 (THROW NoSuchMethodError) ab ac ba;
         !!ps a aa b vs ab ac ba C M Ts T body D.
            [| ?P \<turnstile>\<^sub>1 \<langle>ps,
  (a, aa, b)\<rangle> [\<Rightarrow>]
 \<langle>map Val vs,(ab, ac, ba)\<rangle>;
               ?P2.0 ps a aa b (map Val vs) ab ac ba;
               ?P \<turnstile> C sees M, NonStatic :  Ts\<rightarrow>T = body in D |]
            ==> ?P1.0 (C\<bullet>\<^sub>sM(ps)) a aa b
                 (THROW IncompatibleClassChangeError) ab ac ba;
         !!ps a aa b vs h\<^sub>1 ls\<^sub>1 sh\<^sub>1 C M Ts T body D ab
            ac ad ba.
            [| ?P \<turnstile>\<^sub>1 \<langle>ps,
  (a, aa, b)\<rangle> [\<Rightarrow>]
 \<langle>map Val vs,(h\<^sub>1, ls\<^sub>1, sh\<^sub>1)\<rangle>;
               ?P2.0 ps a aa b (map Val vs) h\<^sub>1 ls\<^sub>1 sh\<^sub>1;
               ?P \<turnstile> C sees M, Static :  Ts\<rightarrow>T = body in D;
               \<nexists>sfs. sh\<^sub>1 D = \<lfloor>(sfs, Done)\<rfloor>;
               M ~= clinit;
               ?P \<turnstile>\<^sub>1 \<langle>INIT D ([D],False) \<leftarrow> unit,
  (h\<^sub>1, ls\<^sub>1, sh\<^sub>1)\<rangle> \<Rightarrow>
 \<langle>throw ab,(ac, ad, ba)\<rangle>;
               ?P1.0 (INIT D ([D],False) \<leftarrow> unit) h\<^sub>1
                ls\<^sub>1 sh\<^sub>1 (throw ab) ac ad ba |]
            ==> ?P1.0 (C\<bullet>\<^sub>sM(ps)) a aa b (throw ab) ac ad ba;
         !!ps a aa b vs h\<^sub>1 ls\<^sub>1 sh\<^sub>1 C M Ts T body D v'
            h\<^sub>2 ls\<^sub>2 sh\<^sub>2 ls\<^sub>2' e' h\<^sub>3
            ls\<^sub>3 sh\<^sub>3.
            [| ?P \<turnstile>\<^sub>1 \<langle>ps,
  (a, aa, b)\<rangle> [\<Rightarrow>]
 \<langle>map Val vs,(h\<^sub>1, ls\<^sub>1, sh\<^sub>1)\<rangle>;
               ?P2.0 ps a aa b (map Val vs) h\<^sub>1 ls\<^sub>1 sh\<^sub>1;
               ?P \<turnstile> C sees M, Static :  Ts\<rightarrow>T = body in D;
               \<nexists>sfs. sh\<^sub>1 D = \<lfloor>(sfs, Done)\<rfloor>;
               M ~= clinit;
               ?P \<turnstile>\<^sub>1 \<langle>INIT D ([D],False) \<leftarrow> unit,
  (h\<^sub>1, ls\<^sub>1, sh\<^sub>1)\<rangle> \<Rightarrow>
 \<langle>Val v',(h\<^sub>2, ls\<^sub>2, sh\<^sub>2)\<rangle>;
               ?P1.0 (INIT D ([D],False) \<leftarrow> unit) h\<^sub>1
                ls\<^sub>1 sh\<^sub>1 (Val v') h\<^sub>2 ls\<^sub>2
                sh\<^sub>2;
               length vs = length Ts;
               ls\<^sub>2' = vs @ replicate (max_vars body) undefined;
               ?P \<turnstile>\<^sub>1 \<langle>body,
  (h\<^sub>2, ls\<^sub>2', sh\<^sub>2)\<rangle> \<Rightarrow>
 \<langle>e',(h\<^sub>3, ls\<^sub>3, sh\<^sub>3)\<rangle>;
               ?P1.0 body h\<^sub>2 ls\<^sub>2' sh\<^sub>2 e' h\<^sub>3
                ls\<^sub>3 sh\<^sub>3 |]
            ==> ?P1.0 (C\<bullet>\<^sub>sM(ps)) a aa b e' h\<^sub>3
                 ls\<^sub>2 sh\<^sub>3;
         !!ps a aa b vs h\<^sub>2 ls\<^sub>2 sh\<^sub>2 C M Ts T body D sfs
            ls\<^sub>2' e' h\<^sub>3 ls\<^sub>3 sh\<^sub>3.
            [| ?P \<turnstile>\<^sub>1 \<langle>ps,
  (a, aa, b)\<rangle> [\<Rightarrow>]
 \<langle>map Val vs,(h\<^sub>2, ls\<^sub>2, sh\<^sub>2)\<rangle>;
               ?P2.0 ps a aa b (map Val vs) h\<^sub>2 ls\<^sub>2 sh\<^sub>2;
               ?P \<turnstile> C sees M, Static :  Ts\<rightarrow>T = body in D;
               sh\<^sub>2 D = \<lfloor>(sfs, Done)\<rfloor> |
               M = clinit &
               sh\<^sub>2 D = \<lfloor>(sfs, Processing)\<rfloor>;
               length vs = length Ts;
               ls\<^sub>2' = vs @ replicate (max_vars body) undefined;
               ?P \<turnstile>\<^sub>1 \<langle>body,
  (h\<^sub>2, ls\<^sub>2', sh\<^sub>2)\<rangle> \<Rightarrow>
 \<langle>e',(h\<^sub>3, ls\<^sub>3, sh\<^sub>3)\<rangle>;
               ?P1.0 body h\<^sub>2 ls\<^sub>2' sh\<^sub>2 e' h\<^sub>3
                ls\<^sub>3 sh\<^sub>3 |]
            ==> ?P1.0 (C\<bullet>\<^sub>sM(ps)) a aa b e' h\<^sub>3
                 ls\<^sub>2 sh\<^sub>3;
         !!e a aa b e' ab ac ba i T.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>e',(ab, ac, ba)\<rangle>;
               ?P1.0 e a aa b e' ab ac ba |]
            ==> ?P1.0 {i:T; e} a aa b e' ab ac ba;
         !!e\<^sub>0 a aa b v ab ac ba e\<^sub>1 e\<^sub>2 ad ae bb.
            [| ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>0,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>Val v,(ab, ac, ba)\<rangle>;
               ?P1.0 e\<^sub>0 a aa b (Val v) ab ac ba;
               ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>1,
  (ab, ac, ba)\<rangle> \<Rightarrow>
 \<langle>e\<^sub>2,(ad, ae, bb)\<rangle>;
               ?P1.0 e\<^sub>1 ab ac ba e\<^sub>2 ad ae bb |]
            ==> ?P1.0 (e\<^sub>0;; e\<^sub>1) a aa b e\<^sub>2 ad ae bb;
         !!e\<^sub>0 a aa b e ab ac ba e\<^sub>1.
            [| ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>0,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>throw e,(ab, ac, ba)\<rangle>;
               ?P1.0 e\<^sub>0 a aa b (throw e) ab ac ba |]
            ==> ?P1.0 (e\<^sub>0;; e\<^sub>1) a aa b (throw e) ab ac ba;
         !!e a aa b ab ac ba e\<^sub>1 e' ad ae bb e\<^sub>2.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>true,(ab, ac, ba)\<rangle>;
               ?P1.0 e a aa b true ab ac ba;
               ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>1,
  (ab, ac, ba)\<rangle> \<Rightarrow>
 \<langle>e',(ad, ae, bb)\<rangle>;
               ?P1.0 e\<^sub>1 ab ac ba e' ad ae bb |]
            ==> ?P1.0 (if (e) e\<^sub>1 else e\<^sub>2) a aa b e' ad ae bb;
         !!e a aa b ab ac ba e\<^sub>2 e' ad ae bb e\<^sub>1.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>false,(ab, ac, ba)\<rangle>;
               ?P1.0 e a aa b false ab ac ba;
               ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>2,
  (ab, ac, ba)\<rangle> \<Rightarrow>
 \<langle>e',(ad, ae, bb)\<rangle>;
               ?P1.0 e\<^sub>2 ab ac ba e' ad ae bb |]
            ==> ?P1.0 (if (e) e\<^sub>1 else e\<^sub>2) a aa b e' ad ae bb;
         !!e a aa b e' ab ac ba e\<^sub>1 e\<^sub>2.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>throw e',(ab, ac, ba)\<rangle>;
               ?P1.0 e a aa b (throw e') ab ac ba |]
            ==> ?P1.0 (if (e) e\<^sub>1 else e\<^sub>2) a aa b (throw e') ab
                 ac ba;
         !!e a aa b ab ac ba c.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>false,(ab, ac, ba)\<rangle>;
               ?P1.0 e a aa b false ab ac ba |]
            ==> ?P1.0 (while (e) c) a aa b unit ab ac ba;
         !!e a aa b ab ac ba c v\<^sub>1 ad ae bb e\<^sub>3 af ag bc.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>true,(ab, ac, ba)\<rangle>;
               ?P1.0 e a aa b true ab ac ba;
               ?P \<turnstile>\<^sub>1 \<langle>c,
  (ab, ac, ba)\<rangle> \<Rightarrow>
 \<langle>Val v\<^sub>1,(ad, ae, bb)\<rangle>;
               ?P1.0 c ab ac ba (Val v\<^sub>1) ad ae bb;
               ?P \<turnstile>\<^sub>1 \<langle>while (e) c,
  (ad, ae, bb)\<rangle> \<Rightarrow>
 \<langle>e\<^sub>3,(af, ag, bc)\<rangle>;
               ?P1.0 (while (e) c) ad ae bb e\<^sub>3 af ag bc |]
            ==> ?P1.0 (while (e) c) a aa b e\<^sub>3 af ag bc;
         !!e a aa b e' ab ac ba c.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>throw e',(ab, ac, ba)\<rangle>;
               ?P1.0 e a aa b (throw e') ab ac ba |]
            ==> ?P1.0 (while (e) c) a aa b (throw e') ab ac ba;
         !!e a aa b ab ac ba c e' ad ae bb.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>true,(ab, ac, ba)\<rangle>;
               ?P1.0 e a aa b true ab ac ba;
               ?P \<turnstile>\<^sub>1 \<langle>c,
  (ab, ac, ba)\<rangle> \<Rightarrow>
 \<langle>throw e',(ad, ae, bb)\<rangle>;
               ?P1.0 c ab ac ba (throw e') ad ae bb |]
            ==> ?P1.0 (while (e) c) a aa b (throw e') ad ae bb;
         !!e a aa b ab ac ad ba.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>addr ab,(ac, ad, ba)\<rangle>;
               ?P1.0 e a aa b (addr ab) ac ad ba |]
            ==> ?P1.0 (throw e) a aa b (Throw ab) ac ad ba;
         !!e a aa b ab ac ba.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>null,(ab, ac, ba)\<rangle>;
               ?P1.0 e a aa b null ab ac ba |]
            ==> ?P1.0 (throw e) a aa b (THROW NullPointer) ab ac ba;
         !!e a aa b e' ab ac ba.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>throw e',(ab, ac, ba)\<rangle>;
               ?P1.0 e a aa b (throw e') ab ac ba |]
            ==> ?P1.0 (throw e) a aa b (throw e') ab ac ba;
         !!e\<^sub>1 a aa b v\<^sub>1 ab ac ba C i e\<^sub>2.
            [| ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>1,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>Val v\<^sub>1,(ab, ac, ba)\<rangle>;
               ?P1.0 e\<^sub>1 a aa b (Val v\<^sub>1) ab ac ba |]
            ==> ?P1.0 (try e\<^sub>1 catch(C i) e\<^sub>2) a aa b
                 (Val v\<^sub>1) ab ac ba;
         !!e\<^sub>1 a aa b ab h\<^sub>1 ls\<^sub>1 sh\<^sub>1 D fs C i
            e\<^sub>2 e\<^sub>2' h\<^sub>2 ls\<^sub>2 sh\<^sub>2.
            [| ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>1,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>Throw ab,(h\<^sub>1, ls\<^sub>1, sh\<^sub>1)\<rangle>;
               ?P1.0 e\<^sub>1 a aa b (Throw ab) h\<^sub>1 ls\<^sub>1
                sh\<^sub>1;
               h\<^sub>1 ab = \<lfloor>(D, fs)\<rfloor>;
               ?P \<turnstile> D \<preceq>\<^sup>* C; i < length ls\<^sub>1;
               ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>2,
  (h\<^sub>1, ls\<^sub>1[i := Addr ab], sh\<^sub>1)\<rangle> \<Rightarrow>
 \<langle>e\<^sub>2',(h\<^sub>2, ls\<^sub>2, sh\<^sub>2)\<rangle>;
               ?P1.0 e\<^sub>2 h\<^sub>1 (ls\<^sub>1[i := Addr ab])
                sh\<^sub>1 e\<^sub>2' h\<^sub>2 ls\<^sub>2 sh\<^sub>2 |]
            ==> ?P1.0 (try e\<^sub>1 catch(C i) e\<^sub>2) a aa b e\<^sub>2'
                 h\<^sub>2 ls\<^sub>2 sh\<^sub>2;
         !!e\<^sub>1 a aa b ab h\<^sub>1 ls\<^sub>1 sh\<^sub>1 D fs C i
            e\<^sub>2.
            [| ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>1,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>Throw ab,(h\<^sub>1, ls\<^sub>1, sh\<^sub>1)\<rangle>;
               ?P1.0 e\<^sub>1 a aa b (Throw ab) h\<^sub>1 ls\<^sub>1
                sh\<^sub>1;
               h\<^sub>1 ab = \<lfloor>(D, fs)\<rfloor>;
               (D, C) ~: (subcls1 ?P)^* |]
            ==> ?P1.0 (try e\<^sub>1 catch(C i) e\<^sub>2) a aa b (Throw ab)
                 h\<^sub>1 ls\<^sub>1 sh\<^sub>1;
         !!a aa b. ?P2.0 [] a aa b [] a aa b;
         !!e a aa b v ab ac ba es es' ad ae bb.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>Val v,(ab, ac, ba)\<rangle>;
               ?P1.0 e a aa b (Val v) ab ac ba;
               ?P \<turnstile>\<^sub>1 \<langle>es,
  (ab, ac, ba)\<rangle> [\<Rightarrow>]
 \<langle>es',(ad, ae, bb)\<rangle>;
               ?P2.0 es ab ac ba es' ad ae bb |]
            ==> ?P2.0 (e # es) a aa b (Val v # es') ad ae bb;
         !!e a aa b e' ab ac ba es.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>throw e',(ab, ac, ba)\<rangle>;
               ?P1.0 e a aa b (throw e') ab ac ba |]
            ==> ?P2.0 (e # es) a aa b (throw e' # es) ab ac ba;
         !!e a aa b e' ab ac ba C bb.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>e',(ab, ac, ba)\<rangle>;
               ?P1.0 e a aa b e' ab ac ba |]
            ==> ?P1.0 (INIT C ([],bb) \<leftarrow> e) a aa b e' ab ac ba;
         !!sh C C' Cs e h l e' a aa b.
            [| sh C = None;
               ?P \<turnstile>\<^sub>1 \<langle>INIT C' (C #
                   Cs,False) \<leftarrow> e,
  (h, l, sh(C |-> (sblank ?P C, Prepared)))\<rangle> \<Rightarrow>
 \<langle>e',(a, aa, b)\<rangle>;
               ?P1.0 (INIT C' (C # Cs,False) \<leftarrow> e) h l
                (sh(C |-> (sblank ?P C, Prepared))) e' a aa b |]
            ==> ?P1.0 (INIT C' (C # Cs,False) \<leftarrow> e) h l sh e' a aa
                 b;
         !!sh C sfs C' Cs e h l e' a aa b.
            [| sh C = \<lfloor>(sfs, Done)\<rfloor>;
               ?P \<turnstile>\<^sub>1 \<langle>INIT C' (Cs,True) \<leftarrow> e,
  (h, l, sh)\<rangle> \<Rightarrow>
 \<langle>e',(a, aa, b)\<rangle>;
               ?P1.0 (INIT C' (Cs,True) \<leftarrow> e) h l sh e' a aa b |]
            ==> ?P1.0 (INIT C' (C # Cs,False) \<leftarrow> e) h l sh e' a aa
                 b;
         !!sh C sfs C' Cs e h l e' a aa b.
            [| sh C = \<lfloor>(sfs, Processing)\<rfloor>;
               ?P \<turnstile>\<^sub>1 \<langle>INIT C' (Cs,True) \<leftarrow> e,
  (h, l, sh)\<rangle> \<Rightarrow>
 \<langle>e',(a, aa, b)\<rangle>;
               ?P1.0 (INIT C' (Cs,True) \<leftarrow> e) h l sh e' a aa b |]
            ==> ?P1.0 (INIT C' (C # Cs,False) \<leftarrow> e) h l sh e' a aa
                 b;
         !!sh C sfs Cs e h l e' a aa b C'.
            [| sh C = \<lfloor>(sfs, Error)\<rfloor>;
               ?P \<turnstile>\<^sub>1 \<langle>RI (C,THROW
                 NoClassDefFoundError) ; Cs \<leftarrow> e,
  (h, l, sh)\<rangle> \<Rightarrow>
 \<langle>e',(a, aa, b)\<rangle>;
               ?P1.0 (RI (C,THROW NoClassDefFoundError) ; Cs \<leftarrow> e)
                h l sh e' a aa b |]
            ==> ?P1.0 (INIT C' (C # Cs,False) \<leftarrow> e) h l sh e' a aa
                 b;
         !!sh C sfs sh' C' Cs e h l e' a aa b.
            [| sh C = \<lfloor>(sfs, Prepared)\<rfloor>; C = Object;
               sh' = sh(C |-> (sfs, Processing));
               ?P \<turnstile>\<^sub>1 \<langle>INIT C' (C #
                   Cs,True) \<leftarrow> e,
  (h, l, sh')\<rangle> \<Rightarrow>
 \<langle>e',(a, aa, b)\<rangle>;
               ?P1.0 (INIT C' (C # Cs,True) \<leftarrow> e) h l sh' e' a aa
                b |]
            ==> ?P1.0 (INIT C' (C # Cs,False) \<leftarrow> e) h l sh e' a aa
                 b;
         !!sh C sfs D a b sh' C' Cs e h l e' aa ab ba.
            [| sh C = \<lfloor>(sfs, Prepared)\<rfloor>; C ~= Object;
               class ?P C = \<lfloor>(D, a, b)\<rfloor>;
               sh' = sh(C |-> (sfs, Processing));
               ?P \<turnstile>\<^sub>1 \<langle>INIT C' (D #
                   C # Cs,False) \<leftarrow> e,
  (h, l, sh')\<rangle> \<Rightarrow>
 \<langle>e',(aa, ab, ba)\<rangle>;
               ?P1.0 (INIT C' (D # C # Cs,False) \<leftarrow> e) h l sh' e'
                aa ab ba |]
            ==> ?P1.0 (INIT C' (C # Cs,False) \<leftarrow> e) h l sh e' aa
                 ab ba;
         !!C Cs e h l sh e' a aa b C'.
            [| ?P \<turnstile>\<^sub>1 \<langle>RI (C,C\<bullet>\<^sub>sclinit([])) ; Cs \<leftarrow> e,
  (h, l, sh)\<rangle> \<Rightarrow>
 \<langle>e',(a, aa, b)\<rangle>;
               ?P1.0
                (RI (C,C\<bullet>\<^sub>sclinit([])) ; Cs \<leftarrow> e) h
                l sh e' a aa b |]
            ==> ?P1.0 (INIT C' (C # Cs,True) \<leftarrow> e) h l sh e' a aa
                 b;
         !!e a aa b v h' l' sh' C sfs i sh'' C' Cs e' e\<^sub>1 ab ac ba.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>Val v,(h', l', sh')\<rangle>;
               ?P1.0 e a aa b (Val v) h' l' sh';
               sh' C = \<lfloor>(sfs, i)\<rfloor>;
               sh'' = sh'(C |-> (sfs, Done)); C' = last (C # Cs);
               ?P \<turnstile>\<^sub>1 \<langle>INIT C' (Cs,True) \<leftarrow> e',
  (h', l', sh'')\<rangle> \<Rightarrow>
 \<langle>e\<^sub>1,(ab, ac, ba)\<rangle>;
               ?P1.0 (INIT C' (Cs,True) \<leftarrow> e') h' l' sh''
                e\<^sub>1 ab ac ba |]
            ==> ?P1.0 (RI (C,e) ; Cs \<leftarrow> e') a aa b e\<^sub>1 ab ac
                 ba;
         !!e a aa b ab h' l' sh' C sfs i sh'' D Cs e' e\<^sub>1 ac ad ba.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>throw ab,(h', l', sh')\<rangle>;
               ?P1.0 e a aa b (throw ab) h' l' sh';
               sh' C = \<lfloor>(sfs, i)\<rfloor>;
               sh'' = sh'(C |-> (sfs, Error));
               ?P \<turnstile>\<^sub>1 \<langle>RI (D,throw
                 ab) ; Cs \<leftarrow> e',
  (h', l', sh'')\<rangle> \<Rightarrow>
 \<langle>e\<^sub>1,(ac, ad, ba)\<rangle>;
               ?P1.0 (RI (D,throw ab) ; Cs \<leftarrow> e') h' l' sh''
                e\<^sub>1 ac ad ba |]
            ==> ?P1.0 (RI (C,e) ; D # Cs \<leftarrow> e') a aa b e\<^sub>1
                 ac ad ba;
         !!e a aa b ab h' l' sh' C sfs i sh'' e'.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>throw ab,(h', l', sh')\<rangle>;
               ?P1.0 e a aa b (throw ab) h' l' sh';
               sh' C = \<lfloor>(sfs, i)\<rfloor>;
               sh'' = sh'(C |-> (sfs, Error)) |]
            ==> ?P1.0 (RI (C,e) ; [] \<leftarrow> e') a aa b (throw ab) h'
                 l' sh'' |]
      ==> ?P1.0 ?x1a ?x2a ?x2b ?x2c ?x3a ?x4a ?x4b ?x4c",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app
                   (template_app (template_hole 134, template_var 10),
                    template_var 9),
                  template_app
                   (template_app (template_hole 133, template_var 8),
                    template_app
                     (template_app (template_hole 132, template_var 7),
                      template_var 6))),
                template_var 5),
              template_app
               (template_app (template_hole 133, template_var 4),
                template_app
                 (template_app (template_hole 132, template_var 3),
                  template_var 2)))
            ),
        template_predicate (template_app (template_hole 131, t_empty)),
        template_predicate (template_app (template_hole 131, t_empty)),
        template_predicate (template_app (template_hole 131, t_empty)),
        template_predicate (template_app (template_hole 131, t_empty)),
        template_predicate (template_app (template_hole 131, t_empty)),
        template_predicate (template_app (template_hole 96, t_empty)),
        template_predicate (template_app (template_hole 96, t_empty)),
        template_predicate (template_app (template_hole 96, t_empty)),
        template_predicate (template_app (template_hole 96, t_empty)),
        template_predicate (template_app (template_hole 105, t_empty)),
        template_predicate (template_app (template_hole 96, t_empty)),
        template_predicate (template_app (template_hole 96, t_empty)),
        template_predicate (template_app (template_hole 96, t_empty)),
        template_predicate (template_app (template_hole 125, t_empty)),
        template_predicate (template_app (template_hole 96, t_empty)),
        template_predicate (template_app (template_hole 96, t_empty)),
        template_predicate (template_app (template_hole 96, t_empty)),
        template_predicate (template_app (template_hole 96, t_empty)),
        template_predicate (template_app (template_hole 96, t_empty)),
        template_predicate (template_app (template_hole 96, t_empty)),
        template_predicate (template_app (template_hole 96, t_empty)),
        template_predicate (template_app (template_hole 130, t_empty)),
        template_predicate (template_app (template_hole 130, t_empty)),
        template_predicate (template_app (template_hole 130, t_empty)),
        template_predicate (template_app (template_hole 130, t_empty)),
        template_predicate (template_app (template_hole 130, t_empty)),
        template_predicate (template_app (template_hole 96, t_empty)),
        template_predicate (template_app (template_hole 96, t_empty)),
        template_predicate (template_app (template_hole 96, t_empty)),
        template_predicate (template_app (template_hole 96, t_empty)),
        template_predicate (template_app (template_hole 96, t_empty)),
        template_predicate (template_app (template_hole 96, t_empty)),
        template_predicate (template_app (template_hole 96, t_empty)),
        template_predicate (template_app (template_hole 96, t_empty)),
        template_predicate (template_app (template_hole 96, t_empty)),
        template_predicate (template_app (template_hole 96, t_empty)),
        template_predicate (template_app (template_hole 96, t_empty)),
        template_predicate (template_app (template_hole 96, t_empty)),
        template_predicate (template_app (template_hole 96, t_empty)),
        template_predicate (template_app (template_hole 96, t_empty)),
        template_predicate (template_app (template_hole 96, t_empty)),
        template_predicate (template_app (template_hole 96, t_empty)),
        template_predicate (template_app (template_hole 96, t_empty)),
        template_predicate (template_app (template_hole 96, t_empty)),
        template_predicate (template_app (template_hole 50, t_empty)),
        template_predicate (template_app (template_hole 50, t_empty)),
        template_predicate (template_app (template_hole 50, t_empty)),
        template_predicate (template_app (template_hole 50, t_empty)),
        template_predicate (template_app (template_hole 50, t_empty)),
        template_predicate (template_app (template_hole 50, t_empty)),
        template_predicate (template_app (template_hole 96, t_empty)),
        template_predicate (template_app (template_hole 96, t_empty)),
        template_predicate (template_app (template_hole 96, t_empty)),
        template_predicate (template_app (template_hole 96, t_empty)),
        template_predicate (template_app (template_hole 96, t_empty)),
        template_predicate (template_app (template_hole 96, t_empty)),
        template_predicate (template_app (template_hole 96, t_empty)),
        template_predicate (template_app (template_hole 96, t_empty)),
        template_predicate (template_app (template_hole 96, t_empty)),
        template_predicate (template_app (template_hole 96, t_empty)),
        template_predicate (template_app (template_hole 96, t_empty)),
        template_predicate (template_app (template_hole 96, t_empty)),
        template_predicate (template_app (template_hole 96, t_empty)),
        template_predicate (template_app (template_hole 96, t_empty)),
        template_predicate (template_app (template_hole 96, t_empty)),
        template_predicate (template_app (template_hole 96, t_empty)),
        template_predicate (template_app (template_hole 128, t_empty)),
        template_predicate (template_app (template_hole 96, t_empty)),
        template_predicate (template_app (template_hole 96, t_empty)),
        template_predicate (template_app (template_hole 96, t_empty)),
        template_predicate (template_app (template_hole 131, t_empty)),
        template_predicate (template_app (template_hole 131, t_empty)),
        template_predicate (template_app (template_hole 131, t_empty)),
        template_predicate (template_app (template_hole 131, t_empty)),
        template_predicate (template_app (template_hole 131, t_empty)),
        template_predicate (template_app (template_hole 131, t_empty)),
        template_predicate (template_app (template_hole 130, t_empty)),
        template_predicate (template_app (template_hole 96, t_empty)),
        template_predicate (template_app (template_hole 96, t_empty)),
        template_predicate (template_app (template_hole 96, t_empty))],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_app
                  (template_app
                    (template_app
                      (template_app
                        (template_app (template_var 1, template_var 9),
                         template_var 8),
                       template_var 7),
                     template_var 6),
                   template_var 5),
                 template_var 4),
               template_var 3),
             template_var 2)
           ))),
    ("J1.eval\<^sub>1_evals\<^sub>1_inducts",
     "[| ?P \<turnstile>\<^sub>1 \<langle>?x5a,
                                  (?x6a, ?x6b,
                                   ?x6c)\<rangle> [\<Rightarrow>]
                                 \<langle>?x7a,(?x8a, ?x8b, ?x8c)\<rangle>;
         !!sh C sfs h a FDTs h' l.
            [| sh C = \<lfloor>(sfs, Done)\<rfloor>;
               new_Addr h = \<lfloor>a\<rfloor>;
               ?P \<turnstile> C has_fields FDTs;
               h' = h(a |-> blank ?P C) |]
            ==> ?P1.0 (new C) h l sh (addr a) h' l sh;
         !!sh C sfs h l.
            [| sh C = \<lfloor>(sfs, Done)\<rfloor>; new_Addr h = None |]
            ==> ?P1.0 (new C) h l sh (THROW OutOfMemory) h l sh;
         !!sh C h l v' h' l' sh' a FDTs h''.
            [| \<nexists>sfs. sh C = \<lfloor>(sfs, Done)\<rfloor>;
               ?P \<turnstile>\<^sub>1 \<langle>INIT C ([C],False) \<leftarrow> unit,
  (h, l, sh)\<rangle> \<Rightarrow>
 \<langle>Val v',(h', l', sh')\<rangle>;
               ?P1.0 (INIT C ([C],False) \<leftarrow> unit) h l sh (Val v')
                h' l' sh';
               new_Addr h' = \<lfloor>a\<rfloor>;
               ?P \<turnstile> C has_fields FDTs;
               h'' = h'(a |-> blank ?P C) |]
            ==> ?P1.0 (new C) h l sh (addr a) h'' l' sh';
         !!sh C h l v' h' l' sh'.
            [| \<nexists>sfs. sh C = \<lfloor>(sfs, Done)\<rfloor>;
               ?P \<turnstile>\<^sub>1 \<langle>INIT C ([C],False) \<leftarrow> unit,
  (h, l, sh)\<rangle> \<Rightarrow>
 \<langle>Val v',(h', l', sh')\<rangle>;
               ?P1.0 (INIT C ([C],False) \<leftarrow> unit) h l sh (Val v')
                h' l' sh';
               new_Addr h' = None; is_class ?P C |]
            ==> ?P1.0 (new C) h l sh (THROW OutOfMemory) h' l' sh';
         !!sh C h l a aa ab b.
            [| \<nexists>sfs. sh C = \<lfloor>(sfs, Done)\<rfloor>;
               ?P \<turnstile>\<^sub>1 \<langle>INIT C ([C],False) \<leftarrow> unit,
  (h, l, sh)\<rangle> \<Rightarrow>
 \<langle>throw a,(aa, ab, b)\<rangle>;
               ?P1.0 (INIT C ([C],False) \<leftarrow> unit) h l sh (throw a)
                aa ab b;
               is_class ?P C |]
            ==> ?P1.0 (new C) h l sh (throw a) aa ab b;
         !!e a aa b ab h l sh D fs C.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>addr ab,(h, l, sh)\<rangle>;
               ?P1.0 e a aa b (addr ab) h l sh;
               h ab = \<lfloor>(D, fs)\<rfloor>;
               ?P \<turnstile> D \<preceq>\<^sup>* C |]
            ==> ?P1.0 (Cast C e) a aa b (addr ab) h l sh;
         !!e a aa b ab ac ba C.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>null,(ab, ac, ba)\<rangle>;
               ?P1.0 e a aa b null ab ac ba |]
            ==> ?P1.0 (Cast C e) a aa b null ab ac ba;
         !!e a aa b ab h l sh D fs C.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>addr ab,(h, l, sh)\<rangle>;
               ?P1.0 e a aa b (addr ab) h l sh;
               h ab = \<lfloor>(D, fs)\<rfloor>; (D, C) ~: (subcls1 ?P)^* |]
            ==> ?P1.0 (Cast C e) a aa b (THROW ClassCast) h l sh;
         !!e a aa b e' ab ac ba C.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>throw e',(ab, ac, ba)\<rangle>;
               ?P1.0 e a aa b (throw e') ab ac ba |]
            ==> ?P1.0 (Cast C e) a aa b (throw e') ab ac ba;
         !!v a aa b. ?P1.0 (Val v) a aa b (Val v) a aa b;
         !!e\<^sub>1 a aa b v\<^sub>1 ab ac ba e\<^sub>2 v\<^sub>2 ad ae bb
            bop v.
            [| ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>1,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>Val v\<^sub>1,(ab, ac, ba)\<rangle>;
               ?P1.0 e\<^sub>1 a aa b (Val v\<^sub>1) ab ac ba;
               ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>2,
  (ab, ac, ba)\<rangle> \<Rightarrow>
 \<langle>Val v\<^sub>2,(ad, ae, bb)\<rangle>;
               ?P1.0 e\<^sub>2 ab ac ba (Val v\<^sub>2) ad ae bb;
               binop (bop, v\<^sub>1, v\<^sub>2) = \<lfloor>v\<rfloor> |]
            ==> ?P1.0
                 (e\<^sub>1 \<guillemotleft>bop\<guillemotright> e\<^sub>2)
                 a aa b (Val v) ad ae bb;
         !!e\<^sub>1 a aa b e ab ac ba bop e\<^sub>2.
            [| ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>1,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>throw e,(ab, ac, ba)\<rangle>;
               ?P1.0 e\<^sub>1 a aa b (throw e) ab ac ba |]
            ==> ?P1.0
                 (e\<^sub>1 \<guillemotleft>bop\<guillemotright> e\<^sub>2)
                 a aa b (throw e) ab ac ba;
         !!e\<^sub>1 a aa b v\<^sub>1 ab ac ba e\<^sub>2 e ad ae bb bop.
            [| ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>1,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>Val v\<^sub>1,(ab, ac, ba)\<rangle>;
               ?P1.0 e\<^sub>1 a aa b (Val v\<^sub>1) ab ac ba;
               ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>2,
  (ab, ac, ba)\<rangle> \<Rightarrow>
 \<langle>throw e,(ad, ae, bb)\<rangle>;
               ?P1.0 e\<^sub>2 ab ac ba (throw e) ad ae bb |]
            ==> ?P1.0
                 (e\<^sub>1 \<guillemotleft>bop\<guillemotright> e\<^sub>2)
                 a aa b (throw e) ad ae bb;
         !!ls i v h sh.
            [| ls ! i = v; i < length ls |]
            ==> ?P1.0 (Var i) h ls sh (Val v) h ls sh;
         !!e a aa b v h ls sh i ls'.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>Val v,(h, ls, sh)\<rangle>;
               ?P1.0 e a aa b (Val v) h ls sh; i < length ls;
               ls' = ls[i := v] |]
            ==> ?P1.0 (i:=e) a aa b unit h ls' sh;
         !!e a aa b e' ab ac ba i.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>throw e',(ab, ac, ba)\<rangle>;
               ?P1.0 e a aa b (throw e') ab ac ba |]
            ==> ?P1.0 (i:=e) a aa b (throw e') ab ac ba;
         !!e a aa b ab h ls sh C fs F t D v.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>addr ab,(h, ls, sh)\<rangle>;
               ?P1.0 e a aa b (addr ab) h ls sh;
               h ab = \<lfloor>(C, fs)\<rfloor>;
               ?P \<turnstile> C has F,NonStatic:t in D;
               fs (F, D) = \<lfloor>v\<rfloor> |]
            ==> ?P1.0 (e\<bullet>F{D}) a aa b (Val v) h ls sh;
         !!e a aa b ab ac ba F D.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>null,(ab, ac, ba)\<rangle>;
               ?P1.0 e a aa b null ab ac ba |]
            ==> ?P1.0 (e\<bullet>F{D}) a aa b (THROW NullPointer) ab ac ba;
         !!e a aa b e' ab ac ba F D.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>throw e',(ab, ac, ba)\<rangle>;
               ?P1.0 e a aa b (throw e') ab ac ba |]
            ==> ?P1.0 (e\<bullet>F{D}) a aa b (throw e') ab ac ba;
         !!e a aa b ab h ls sh C fs F D.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>addr ab,(h, ls, sh)\<rangle>;
               ?P1.0 e a aa b (addr ab) h ls sh;
               h ab = \<lfloor>(C, fs)\<rfloor>;
               \<nexists>b t. ?P \<turnstile> C has F,b:t in D |]
            ==> ?P1.0 (e\<bullet>F{D}) a aa b (THROW NoSuchFieldError) h ls
                 sh;
         !!e a aa b ab h ls sh C fs F t D.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>addr ab,(h, ls, sh)\<rangle>;
               ?P1.0 e a aa b (addr ab) h ls sh;
               h ab = \<lfloor>(C, fs)\<rfloor>;
               ?P \<turnstile> C has F,Static:t in D |]
            ==> ?P1.0 (e\<bullet>F{D}) a aa b
                 (THROW IncompatibleClassChangeError) h ls sh;
         !!C F t D sh sfs v h ls.
            [| ?P \<turnstile> C has F,Static:t in D;
               sh D = \<lfloor>(sfs, Done)\<rfloor>;
               sfs F = \<lfloor>v\<rfloor> |]
            ==> ?P1.0 (C\<bullet>\<^sub>sF{D}) h ls sh (Val v) h ls sh;
         !!C F t D sh h ls v' h' ls' sh' sfs i v.
            [| ?P \<turnstile> C has F,Static:t in D;
               \<nexists>sfs. sh D = \<lfloor>(sfs, Done)\<rfloor>;
               ?P \<turnstile>\<^sub>1 \<langle>INIT D ([D],False) \<leftarrow> unit,
  (h, ls, sh)\<rangle> \<Rightarrow>
 \<langle>Val v',(h', ls', sh')\<rangle>;
               ?P1.0 (INIT D ([D],False) \<leftarrow> unit) h ls sh (Val v')
                h' ls' sh';
               sh' D = \<lfloor>(sfs, i)\<rfloor>;
               sfs F = \<lfloor>v\<rfloor> |]
            ==> ?P1.0 (C\<bullet>\<^sub>sF{D}) h ls sh (Val v) h' ls' sh';
         !!C F t D sh h ls a aa ab b.
            [| ?P \<turnstile> C has F,Static:t in D;
               \<nexists>sfs. sh D = \<lfloor>(sfs, Done)\<rfloor>;
               ?P \<turnstile>\<^sub>1 \<langle>INIT D ([D],False) \<leftarrow> unit,
  (h, ls, sh)\<rangle> \<Rightarrow>
 \<langle>throw a,(aa, ab, b)\<rangle>;
               ?P1.0 (INIT D ([D],False) \<leftarrow> unit) h ls sh
                (throw a) aa ab b |]
            ==> ?P1.0 (C\<bullet>\<^sub>sF{D}) h ls sh (throw a) aa ab b;
         !!C F D a aa b.
            \<nexists>b t. ?P \<turnstile> C has F,b:t in D ==>
            ?P1.0 (C\<bullet>\<^sub>sF{D}) a aa b (THROW NoSuchFieldError) a
             aa b;
         !!C F t D a aa b.
            ?P \<turnstile> C has F,NonStatic:t in D ==>
            ?P1.0 (C\<bullet>\<^sub>sF{D}) a aa b
             (THROW IncompatibleClassChangeError) a aa b;
         !!e\<^sub>1 a aa b ab ac ad ba e\<^sub>2 v h\<^sub>2 l\<^sub>2
            sh\<^sub>2 C fs F t D fs' h\<^sub>2'.
            [| ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>1,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>addr ab,(ac, ad, ba)\<rangle>;
               ?P1.0 e\<^sub>1 a aa b (addr ab) ac ad ba;
               ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>2,
  (ac, ad, ba)\<rangle> \<Rightarrow>
 \<langle>Val v,(h\<^sub>2, l\<^sub>2, sh\<^sub>2)\<rangle>;
               ?P1.0 e\<^sub>2 ac ad ba (Val v) h\<^sub>2 l\<^sub>2
                sh\<^sub>2;
               h\<^sub>2 ab = \<lfloor>(C, fs)\<rfloor>;
               ?P \<turnstile> C has F,NonStatic:t in D;
               fs' = fs((F, D) |-> v);
               h\<^sub>2' = h\<^sub>2(ab |-> (C, fs')) |]
            ==> ?P1.0 (e\<^sub>1\<bullet>F{D} := e\<^sub>2) a aa b unit
                 h\<^sub>2' l\<^sub>2 sh\<^sub>2;
         !!e\<^sub>1 a aa b ab ac ba e\<^sub>2 v ad ae bb F D.
            [| ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>1,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>null,(ab, ac, ba)\<rangle>;
               ?P1.0 e\<^sub>1 a aa b null ab ac ba;
               ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>2,
  (ab, ac, ba)\<rangle> \<Rightarrow>
 \<langle>Val v,(ad, ae, bb)\<rangle>;
               ?P1.0 e\<^sub>2 ab ac ba (Val v) ad ae bb |]
            ==> ?P1.0 (e\<^sub>1\<bullet>F{D} := e\<^sub>2) a aa b
                 (THROW NullPointer) ad ae bb;
         !!e\<^sub>1 a aa b e' ab ac ba F D e\<^sub>2.
            [| ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>1,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>throw e',(ab, ac, ba)\<rangle>;
               ?P1.0 e\<^sub>1 a aa b (throw e') ab ac ba |]
            ==> ?P1.0 (e\<^sub>1\<bullet>F{D} := e\<^sub>2) a aa b
                 (throw e') ab ac ba;
         !!e\<^sub>1 a aa b v ab ac ba e\<^sub>2 e' ad ae bb F D.
            [| ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>1,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>Val v,(ab, ac, ba)\<rangle>;
               ?P1.0 e\<^sub>1 a aa b (Val v) ab ac ba;
               ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>2,
  (ab, ac, ba)\<rangle> \<Rightarrow>
 \<langle>throw e',(ad, ae, bb)\<rangle>;
               ?P1.0 e\<^sub>2 ab ac ba (throw e') ad ae bb |]
            ==> ?P1.0 (e\<^sub>1\<bullet>F{D} := e\<^sub>2) a aa b
                 (throw e') ad ae bb;
         !!e\<^sub>1 a aa b ab ac ad ba e\<^sub>2 v h\<^sub>2 l\<^sub>2
            sh\<^sub>2 C fs F D.
            [| ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>1,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>addr ab,(ac, ad, ba)\<rangle>;
               ?P1.0 e\<^sub>1 a aa b (addr ab) ac ad ba;
               ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>2,
  (ac, ad, ba)\<rangle> \<Rightarrow>
 \<langle>Val v,(h\<^sub>2, l\<^sub>2, sh\<^sub>2)\<rangle>;
               ?P1.0 e\<^sub>2 ac ad ba (Val v) h\<^sub>2 l\<^sub>2
                sh\<^sub>2;
               h\<^sub>2 ab = \<lfloor>(C, fs)\<rfloor>;
               \<nexists>b t. ?P \<turnstile> C has F,b:t in D |]
            ==> ?P1.0 (e\<^sub>1\<bullet>F{D} := e\<^sub>2) a aa b
                 (THROW NoSuchFieldError) h\<^sub>2 l\<^sub>2 sh\<^sub>2;
         !!e\<^sub>1 a aa b ab ac ad ba e\<^sub>2 v h\<^sub>2 l\<^sub>2
            sh\<^sub>2 C fs F t D.
            [| ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>1,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>addr ab,(ac, ad, ba)\<rangle>;
               ?P1.0 e\<^sub>1 a aa b (addr ab) ac ad ba;
               ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>2,
  (ac, ad, ba)\<rangle> \<Rightarrow>
 \<langle>Val v,(h\<^sub>2, l\<^sub>2, sh\<^sub>2)\<rangle>;
               ?P1.0 e\<^sub>2 ac ad ba (Val v) h\<^sub>2 l\<^sub>2
                sh\<^sub>2;
               h\<^sub>2 ab = \<lfloor>(C, fs)\<rfloor>;
               ?P \<turnstile> C has F,Static:t in D |]
            ==> ?P1.0 (e\<^sub>1\<bullet>F{D} := e\<^sub>2) a aa b
                 (THROW IncompatibleClassChangeError) h\<^sub>2 l\<^sub>2
                 sh\<^sub>2;
         !!e\<^sub>2 a aa b v h\<^sub>1 l\<^sub>1 sh\<^sub>1 C F t D sfs
            sfs' sh\<^sub>1'.
            [| ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>2,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>Val v,(h\<^sub>1, l\<^sub>1, sh\<^sub>1)\<rangle>;
               ?P1.0 e\<^sub>2 a aa b (Val v) h\<^sub>1 l\<^sub>1
                sh\<^sub>1;
               ?P \<turnstile> C has F,Static:t in D;
               sh\<^sub>1 D = \<lfloor>(sfs, Done)\<rfloor>;
               sfs' = sfs(F |-> v);
               sh\<^sub>1' = sh\<^sub>1(D |-> (sfs', Done)) |]
            ==> ?P1.0 (C\<bullet>\<^sub>sF{D} := e\<^sub>2) a aa b unit
                 h\<^sub>1 l\<^sub>1 sh\<^sub>1';
         !!e\<^sub>2 a aa b v h\<^sub>1 l\<^sub>1 sh\<^sub>1 C F t D v' h'
            l' sh' sfs i sfs' sh''.
            [| ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>2,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>Val v,(h\<^sub>1, l\<^sub>1, sh\<^sub>1)\<rangle>;
               ?P1.0 e\<^sub>2 a aa b (Val v) h\<^sub>1 l\<^sub>1
                sh\<^sub>1;
               ?P \<turnstile> C has F,Static:t in D;
               \<nexists>sfs. sh\<^sub>1 D = \<lfloor>(sfs, Done)\<rfloor>;
               ?P \<turnstile>\<^sub>1 \<langle>INIT D ([D],False) \<leftarrow> unit,
  (h\<^sub>1, l\<^sub>1, sh\<^sub>1)\<rangle> \<Rightarrow>
 \<langle>Val v',(h', l', sh')\<rangle>;
               ?P1.0 (INIT D ([D],False) \<leftarrow> unit) h\<^sub>1
                l\<^sub>1 sh\<^sub>1 (Val v') h' l' sh';
               sh' D = \<lfloor>(sfs, i)\<rfloor>; sfs' = sfs(F |-> v);
               sh'' = sh'(D |-> (sfs', i)) |]
            ==> ?P1.0 (C\<bullet>\<^sub>sF{D} := e\<^sub>2) a aa b unit h'
                 l' sh'';
         !!e\<^sub>2 a aa b v h\<^sub>1 l\<^sub>1 sh\<^sub>1 C F t D ab ac
            ad ba.
            [| ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>2,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>Val v,(h\<^sub>1, l\<^sub>1, sh\<^sub>1)\<rangle>;
               ?P1.0 e\<^sub>2 a aa b (Val v) h\<^sub>1 l\<^sub>1
                sh\<^sub>1;
               ?P \<turnstile> C has F,Static:t in D;
               \<nexists>sfs. sh\<^sub>1 D = \<lfloor>(sfs, Done)\<rfloor>;
               ?P \<turnstile>\<^sub>1 \<langle>INIT D ([D],False) \<leftarrow> unit,
  (h\<^sub>1, l\<^sub>1, sh\<^sub>1)\<rangle> \<Rightarrow>
 \<langle>throw ab,(ac, ad, ba)\<rangle>;
               ?P1.0 (INIT D ([D],False) \<leftarrow> unit) h\<^sub>1
                l\<^sub>1 sh\<^sub>1 (throw ab) ac ad ba |]
            ==> ?P1.0 (C\<bullet>\<^sub>sF{D} := e\<^sub>2) a aa b
                 (throw ab) ac ad ba;
         !!e\<^sub>2 a aa b e' ab ac ba C F D.
            [| ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>2,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>throw e',(ab, ac, ba)\<rangle>;
               ?P1.0 e\<^sub>2 a aa b (throw e') ab ac ba |]
            ==> ?P1.0 (C\<bullet>\<^sub>sF{D} := e\<^sub>2) a aa b
                 (throw e') ab ac ba;
         !!e\<^sub>2 a aa b v h\<^sub>2 l\<^sub>2 sh\<^sub>2 C F D.
            [| ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>2,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>Val v,(h\<^sub>2, l\<^sub>2, sh\<^sub>2)\<rangle>;
               ?P1.0 e\<^sub>2 a aa b (Val v) h\<^sub>2 l\<^sub>2
                sh\<^sub>2;
               \<nexists>b t. ?P \<turnstile> C has F,b:t in D |]
            ==> ?P1.0 (C\<bullet>\<^sub>sF{D} := e\<^sub>2) a aa b
                 (THROW NoSuchFieldError) h\<^sub>2 l\<^sub>2 sh\<^sub>2;
         !!e\<^sub>2 a aa b v h\<^sub>2 l\<^sub>2 sh\<^sub>2 C F t D.
            [| ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>2,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>Val v,(h\<^sub>2, l\<^sub>2, sh\<^sub>2)\<rangle>;
               ?P1.0 e\<^sub>2 a aa b (Val v) h\<^sub>2 l\<^sub>2
                sh\<^sub>2;
               ?P \<turnstile> C has F,NonStatic:t in D |]
            ==> ?P1.0 (C\<bullet>\<^sub>sF{D} := e\<^sub>2) a aa b
                 (THROW IncompatibleClassChangeError) h\<^sub>2 l\<^sub>2
                 sh\<^sub>2;
         !!e a aa b e' ab ac ba M es.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>throw e',(ab, ac, ba)\<rangle>;
               ?P1.0 e a aa b (throw e') ab ac ba |]
            ==> ?P1.0 (e\<bullet>M(es)) a aa b (throw e') ab ac ba;
         !!e a aa b ab ac ba es vs ad ae bb M.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>null,(ab, ac, ba)\<rangle>;
               ?P1.0 e a aa b null ab ac ba;
               ?P \<turnstile>\<^sub>1 \<langle>es,
  (ab, ac, ba)\<rangle> [\<Rightarrow>]
 \<langle>map Val vs,(ad, ae, bb)\<rangle>;
               ?P2.0 es ab ac ba (map Val vs) ad ae bb |]
            ==> ?P1.0 (e\<bullet>M(es)) a aa b (THROW NullPointer) ad ae bb;
         !!e a aa b ab ac ad ba es vs h\<^sub>2 ls\<^sub>2 sh\<^sub>2 C fs M
            Ts T body D ls\<^sub>2' e' h\<^sub>3 ls\<^sub>3 sh\<^sub>3.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>addr ab,(ac, ad, ba)\<rangle>;
               ?P1.0 e a aa b (addr ab) ac ad ba;
               ?P \<turnstile>\<^sub>1 \<langle>es,
  (ac, ad, ba)\<rangle> [\<Rightarrow>]
 \<langle>map Val vs,(h\<^sub>2, ls\<^sub>2, sh\<^sub>2)\<rangle>;
               ?P2.0 es ac ad ba (map Val vs) h\<^sub>2 ls\<^sub>2
                sh\<^sub>2;
               h\<^sub>2 ab = \<lfloor>(C, fs)\<rfloor>;
               ?P \<turnstile> C sees M, NonStatic :  Ts\<rightarrow>T = body in D;
               length vs = length Ts;
               ls\<^sub>2' =
               Addr ab # vs @ replicate (max_vars body) undefined;
               ?P \<turnstile>\<^sub>1 \<langle>body,
  (h\<^sub>2, ls\<^sub>2', sh\<^sub>2)\<rangle> \<Rightarrow>
 \<langle>e',(h\<^sub>3, ls\<^sub>3, sh\<^sub>3)\<rangle>;
               ?P1.0 body h\<^sub>2 ls\<^sub>2' sh\<^sub>2 e' h\<^sub>3
                ls\<^sub>3 sh\<^sub>3 |]
            ==> ?P1.0 (e\<bullet>M(es)) a aa b e' h\<^sub>3 ls\<^sub>2
                 sh\<^sub>3;
         !!e a aa b v ab ac ba es es' ad ae bb vs ex es\<^sub>2 M.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>Val v,(ab, ac, ba)\<rangle>;
               ?P1.0 e a aa b (Val v) ab ac ba;
               ?P \<turnstile>\<^sub>1 \<langle>es,
  (ab, ac, ba)\<rangle> [\<Rightarrow>]
 \<langle>es',(ad, ae, bb)\<rangle>;
               ?P2.0 es ab ac ba es' ad ae bb;
               es' = map Val vs @ throw ex # es\<^sub>2 |]
            ==> ?P1.0 (e\<bullet>M(es)) a aa b (throw ex) ad ae bb;
         !!e a aa b ab ac ad ba ps vs h\<^sub>2 ls\<^sub>2 sh\<^sub>2 C fs
            M. [| ?P \<turnstile>\<^sub>1 \<langle>e,
     (a, aa, b)\<rangle> \<Rightarrow>
    \<langle>addr ab,(ac, ad, ba)\<rangle>;
                  ?P1.0 e a aa b (addr ab) ac ad ba;
                  ?P \<turnstile>\<^sub>1 \<langle>ps,
     (ac, ad, ba)\<rangle> [\<Rightarrow>]
    \<langle>map Val vs,(h\<^sub>2, ls\<^sub>2, sh\<^sub>2)\<rangle>;
                  ?P2.0 ps ac ad ba (map Val vs) h\<^sub>2 ls\<^sub>2
                   sh\<^sub>2;
                  h\<^sub>2 ab = \<lfloor>(C, fs)\<rfloor>;
                  \<nexists>b Ts T body. Ex (Method ?P C M b Ts T body) |]
               ==> ?P1.0 (e\<bullet>M(ps)) a aa b (THROW NoSuchMethodError)
                    h\<^sub>2 ls\<^sub>2 sh\<^sub>2;
         !!e a aa b ab ac ad ba ps vs h\<^sub>2 ls\<^sub>2 sh\<^sub>2 C fs M
            Ts T body D.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>addr ab,(ac, ad, ba)\<rangle>;
               ?P1.0 e a aa b (addr ab) ac ad ba;
               ?P \<turnstile>\<^sub>1 \<langle>ps,
  (ac, ad, ba)\<rangle> [\<Rightarrow>]
 \<langle>map Val vs,(h\<^sub>2, ls\<^sub>2, sh\<^sub>2)\<rangle>;
               ?P2.0 ps ac ad ba (map Val vs) h\<^sub>2 ls\<^sub>2
                sh\<^sub>2;
               h\<^sub>2 ab = \<lfloor>(C, fs)\<rfloor>;
               ?P \<turnstile> C sees M, Static :  Ts\<rightarrow>T = body in D |]
            ==> ?P1.0 (e\<bullet>M(ps)) a aa b
                 (THROW IncompatibleClassChangeError) h\<^sub>2 ls\<^sub>2
                 sh\<^sub>2;
         !!es a aa b es' ab ac ba vs ex es\<^sub>2 C M.
            [| ?P \<turnstile>\<^sub>1 \<langle>es,
  (a, aa, b)\<rangle> [\<Rightarrow>]
 \<langle>es',(ab, ac, ba)\<rangle>;
               ?P2.0 es a aa b es' ab ac ba;
               es' = map Val vs @ throw ex # es\<^sub>2 |]
            ==> ?P1.0 (C\<bullet>\<^sub>sM(es)) a aa b (throw ex) ab ac ba;
         !!ps a aa b vs ab ac ba C M.
            [| ?P \<turnstile>\<^sub>1 \<langle>ps,
  (a, aa, b)\<rangle> [\<Rightarrow>]
 \<langle>map Val vs,(ab, ac, ba)\<rangle>;
               ?P2.0 ps a aa b (map Val vs) ab ac ba;
               \<nexists>b Ts T body. Ex (Method ?P C M b Ts T body) |]
            ==> ?P1.0 (C\<bullet>\<^sub>sM(ps)) a aa b
                 (THROW NoSuchMethodError) ab ac ba;
         !!ps a aa b vs ab ac ba C M Ts T body D.
            [| ?P \<turnstile>\<^sub>1 \<langle>ps,
  (a, aa, b)\<rangle> [\<Rightarrow>]
 \<langle>map Val vs,(ab, ac, ba)\<rangle>;
               ?P2.0 ps a aa b (map Val vs) ab ac ba;
               ?P \<turnstile> C sees M, NonStatic :  Ts\<rightarrow>T = body in D |]
            ==> ?P1.0 (C\<bullet>\<^sub>sM(ps)) a aa b
                 (THROW IncompatibleClassChangeError) ab ac ba;
         !!ps a aa b vs h\<^sub>1 ls\<^sub>1 sh\<^sub>1 C M Ts T body D ab
            ac ad ba.
            [| ?P \<turnstile>\<^sub>1 \<langle>ps,
  (a, aa, b)\<rangle> [\<Rightarrow>]
 \<langle>map Val vs,(h\<^sub>1, ls\<^sub>1, sh\<^sub>1)\<rangle>;
               ?P2.0 ps a aa b (map Val vs) h\<^sub>1 ls\<^sub>1 sh\<^sub>1;
               ?P \<turnstile> C sees M, Static :  Ts\<rightarrow>T = body in D;
               \<nexists>sfs. sh\<^sub>1 D = \<lfloor>(sfs, Done)\<rfloor>;
               M ~= clinit;
               ?P \<turnstile>\<^sub>1 \<langle>INIT D ([D],False) \<leftarrow> unit,
  (h\<^sub>1, ls\<^sub>1, sh\<^sub>1)\<rangle> \<Rightarrow>
 \<langle>throw ab,(ac, ad, ba)\<rangle>;
               ?P1.0 (INIT D ([D],False) \<leftarrow> unit) h\<^sub>1
                ls\<^sub>1 sh\<^sub>1 (throw ab) ac ad ba |]
            ==> ?P1.0 (C\<bullet>\<^sub>sM(ps)) a aa b (throw ab) ac ad ba;
         !!ps a aa b vs h\<^sub>1 ls\<^sub>1 sh\<^sub>1 C M Ts T body D v'
            h\<^sub>2 ls\<^sub>2 sh\<^sub>2 ls\<^sub>2' e' h\<^sub>3
            ls\<^sub>3 sh\<^sub>3.
            [| ?P \<turnstile>\<^sub>1 \<langle>ps,
  (a, aa, b)\<rangle> [\<Rightarrow>]
 \<langle>map Val vs,(h\<^sub>1, ls\<^sub>1, sh\<^sub>1)\<rangle>;
               ?P2.0 ps a aa b (map Val vs) h\<^sub>1 ls\<^sub>1 sh\<^sub>1;
               ?P \<turnstile> C sees M, Static :  Ts\<rightarrow>T = body in D;
               \<nexists>sfs. sh\<^sub>1 D = \<lfloor>(sfs, Done)\<rfloor>;
               M ~= clinit;
               ?P \<turnstile>\<^sub>1 \<langle>INIT D ([D],False) \<leftarrow> unit,
  (h\<^sub>1, ls\<^sub>1, sh\<^sub>1)\<rangle> \<Rightarrow>
 \<langle>Val v',(h\<^sub>2, ls\<^sub>2, sh\<^sub>2)\<rangle>;
               ?P1.0 (INIT D ([D],False) \<leftarrow> unit) h\<^sub>1
                ls\<^sub>1 sh\<^sub>1 (Val v') h\<^sub>2 ls\<^sub>2
                sh\<^sub>2;
               length vs = length Ts;
               ls\<^sub>2' = vs @ replicate (max_vars body) undefined;
               ?P \<turnstile>\<^sub>1 \<langle>body,
  (h\<^sub>2, ls\<^sub>2', sh\<^sub>2)\<rangle> \<Rightarrow>
 \<langle>e',(h\<^sub>3, ls\<^sub>3, sh\<^sub>3)\<rangle>;
               ?P1.0 body h\<^sub>2 ls\<^sub>2' sh\<^sub>2 e' h\<^sub>3
                ls\<^sub>3 sh\<^sub>3 |]
            ==> ?P1.0 (C\<bullet>\<^sub>sM(ps)) a aa b e' h\<^sub>3
                 ls\<^sub>2 sh\<^sub>3;
         !!ps a aa b vs h\<^sub>2 ls\<^sub>2 sh\<^sub>2 C M Ts T body D sfs
            ls\<^sub>2' e' h\<^sub>3 ls\<^sub>3 sh\<^sub>3.
            [| ?P \<turnstile>\<^sub>1 \<langle>ps,
  (a, aa, b)\<rangle> [\<Rightarrow>]
 \<langle>map Val vs,(h\<^sub>2, ls\<^sub>2, sh\<^sub>2)\<rangle>;
               ?P2.0 ps a aa b (map Val vs) h\<^sub>2 ls\<^sub>2 sh\<^sub>2;
               ?P \<turnstile> C sees M, Static :  Ts\<rightarrow>T = body in D;
               sh\<^sub>2 D = \<lfloor>(sfs, Done)\<rfloor> |
               M = clinit &
               sh\<^sub>2 D = \<lfloor>(sfs, Processing)\<rfloor>;
               length vs = length Ts;
               ls\<^sub>2' = vs @ replicate (max_vars body) undefined;
               ?P \<turnstile>\<^sub>1 \<langle>body,
  (h\<^sub>2, ls\<^sub>2', sh\<^sub>2)\<rangle> \<Rightarrow>
 \<langle>e',(h\<^sub>3, ls\<^sub>3, sh\<^sub>3)\<rangle>;
               ?P1.0 body h\<^sub>2 ls\<^sub>2' sh\<^sub>2 e' h\<^sub>3
                ls\<^sub>3 sh\<^sub>3 |]
            ==> ?P1.0 (C\<bullet>\<^sub>sM(ps)) a aa b e' h\<^sub>3
                 ls\<^sub>2 sh\<^sub>3;
         !!e a aa b e' ab ac ba i T.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>e',(ab, ac, ba)\<rangle>;
               ?P1.0 e a aa b e' ab ac ba |]
            ==> ?P1.0 {i:T; e} a aa b e' ab ac ba;
         !!e\<^sub>0 a aa b v ab ac ba e\<^sub>1 e\<^sub>2 ad ae bb.
            [| ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>0,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>Val v,(ab, ac, ba)\<rangle>;
               ?P1.0 e\<^sub>0 a aa b (Val v) ab ac ba;
               ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>1,
  (ab, ac, ba)\<rangle> \<Rightarrow>
 \<langle>e\<^sub>2,(ad, ae, bb)\<rangle>;
               ?P1.0 e\<^sub>1 ab ac ba e\<^sub>2 ad ae bb |]
            ==> ?P1.0 (e\<^sub>0;; e\<^sub>1) a aa b e\<^sub>2 ad ae bb;
         !!e\<^sub>0 a aa b e ab ac ba e\<^sub>1.
            [| ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>0,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>throw e,(ab, ac, ba)\<rangle>;
               ?P1.0 e\<^sub>0 a aa b (throw e) ab ac ba |]
            ==> ?P1.0 (e\<^sub>0;; e\<^sub>1) a aa b (throw e) ab ac ba;
         !!e a aa b ab ac ba e\<^sub>1 e' ad ae bb e\<^sub>2.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>true,(ab, ac, ba)\<rangle>;
               ?P1.0 e a aa b true ab ac ba;
               ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>1,
  (ab, ac, ba)\<rangle> \<Rightarrow>
 \<langle>e',(ad, ae, bb)\<rangle>;
               ?P1.0 e\<^sub>1 ab ac ba e' ad ae bb |]
            ==> ?P1.0 (if (e) e\<^sub>1 else e\<^sub>2) a aa b e' ad ae bb;
         !!e a aa b ab ac ba e\<^sub>2 e' ad ae bb e\<^sub>1.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>false,(ab, ac, ba)\<rangle>;
               ?P1.0 e a aa b false ab ac ba;
               ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>2,
  (ab, ac, ba)\<rangle> \<Rightarrow>
 \<langle>e',(ad, ae, bb)\<rangle>;
               ?P1.0 e\<^sub>2 ab ac ba e' ad ae bb |]
            ==> ?P1.0 (if (e) e\<^sub>1 else e\<^sub>2) a aa b e' ad ae bb;
         !!e a aa b e' ab ac ba e\<^sub>1 e\<^sub>2.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>throw e',(ab, ac, ba)\<rangle>;
               ?P1.0 e a aa b (throw e') ab ac ba |]
            ==> ?P1.0 (if (e) e\<^sub>1 else e\<^sub>2) a aa b (throw e') ab
                 ac ba;
         !!e a aa b ab ac ba c.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>false,(ab, ac, ba)\<rangle>;
               ?P1.0 e a aa b false ab ac ba |]
            ==> ?P1.0 (while (e) c) a aa b unit ab ac ba;
         !!e a aa b ab ac ba c v\<^sub>1 ad ae bb e\<^sub>3 af ag bc.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>true,(ab, ac, ba)\<rangle>;
               ?P1.0 e a aa b true ab ac ba;
               ?P \<turnstile>\<^sub>1 \<langle>c,
  (ab, ac, ba)\<rangle> \<Rightarrow>
 \<langle>Val v\<^sub>1,(ad, ae, bb)\<rangle>;
               ?P1.0 c ab ac ba (Val v\<^sub>1) ad ae bb;
               ?P \<turnstile>\<^sub>1 \<langle>while (e) c,
  (ad, ae, bb)\<rangle> \<Rightarrow>
 \<langle>e\<^sub>3,(af, ag, bc)\<rangle>;
               ?P1.0 (while (e) c) ad ae bb e\<^sub>3 af ag bc |]
            ==> ?P1.0 (while (e) c) a aa b e\<^sub>3 af ag bc;
         !!e a aa b e' ab ac ba c.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>throw e',(ab, ac, ba)\<rangle>;
               ?P1.0 e a aa b (throw e') ab ac ba |]
            ==> ?P1.0 (while (e) c) a aa b (throw e') ab ac ba;
         !!e a aa b ab ac ba c e' ad ae bb.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>true,(ab, ac, ba)\<rangle>;
               ?P1.0 e a aa b true ab ac ba;
               ?P \<turnstile>\<^sub>1 \<langle>c,
  (ab, ac, ba)\<rangle> \<Rightarrow>
 \<langle>throw e',(ad, ae, bb)\<rangle>;
               ?P1.0 c ab ac ba (throw e') ad ae bb |]
            ==> ?P1.0 (while (e) c) a aa b (throw e') ad ae bb;
         !!e a aa b ab ac ad ba.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>addr ab,(ac, ad, ba)\<rangle>;
               ?P1.0 e a aa b (addr ab) ac ad ba |]
            ==> ?P1.0 (throw e) a aa b (Throw ab) ac ad ba;
         !!e a aa b ab ac ba.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>null,(ab, ac, ba)\<rangle>;
               ?P1.0 e a aa b null ab ac ba |]
            ==> ?P1.0 (throw e) a aa b (THROW NullPointer) ab ac ba;
         !!e a aa b e' ab ac ba.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>throw e',(ab, ac, ba)\<rangle>;
               ?P1.0 e a aa b (throw e') ab ac ba |]
            ==> ?P1.0 (throw e) a aa b (throw e') ab ac ba;
         !!e\<^sub>1 a aa b v\<^sub>1 ab ac ba C i e\<^sub>2.
            [| ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>1,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>Val v\<^sub>1,(ab, ac, ba)\<rangle>;
               ?P1.0 e\<^sub>1 a aa b (Val v\<^sub>1) ab ac ba |]
            ==> ?P1.0 (try e\<^sub>1 catch(C i) e\<^sub>2) a aa b
                 (Val v\<^sub>1) ab ac ba;
         !!e\<^sub>1 a aa b ab h\<^sub>1 ls\<^sub>1 sh\<^sub>1 D fs C i
            e\<^sub>2 e\<^sub>2' h\<^sub>2 ls\<^sub>2 sh\<^sub>2.
            [| ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>1,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>Throw ab,(h\<^sub>1, ls\<^sub>1, sh\<^sub>1)\<rangle>;
               ?P1.0 e\<^sub>1 a aa b (Throw ab) h\<^sub>1 ls\<^sub>1
                sh\<^sub>1;
               h\<^sub>1 ab = \<lfloor>(D, fs)\<rfloor>;
               ?P \<turnstile> D \<preceq>\<^sup>* C; i < length ls\<^sub>1;
               ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>2,
  (h\<^sub>1, ls\<^sub>1[i := Addr ab], sh\<^sub>1)\<rangle> \<Rightarrow>
 \<langle>e\<^sub>2',(h\<^sub>2, ls\<^sub>2, sh\<^sub>2)\<rangle>;
               ?P1.0 e\<^sub>2 h\<^sub>1 (ls\<^sub>1[i := Addr ab])
                sh\<^sub>1 e\<^sub>2' h\<^sub>2 ls\<^sub>2 sh\<^sub>2 |]
            ==> ?P1.0 (try e\<^sub>1 catch(C i) e\<^sub>2) a aa b e\<^sub>2'
                 h\<^sub>2 ls\<^sub>2 sh\<^sub>2;
         !!e\<^sub>1 a aa b ab h\<^sub>1 ls\<^sub>1 sh\<^sub>1 D fs C i
            e\<^sub>2.
            [| ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>1,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>Throw ab,(h\<^sub>1, ls\<^sub>1, sh\<^sub>1)\<rangle>;
               ?P1.0 e\<^sub>1 a aa b (Throw ab) h\<^sub>1 ls\<^sub>1
                sh\<^sub>1;
               h\<^sub>1 ab = \<lfloor>(D, fs)\<rfloor>;
               (D, C) ~: (subcls1 ?P)^* |]
            ==> ?P1.0 (try e\<^sub>1 catch(C i) e\<^sub>2) a aa b (Throw ab)
                 h\<^sub>1 ls\<^sub>1 sh\<^sub>1;
         !!a aa b. ?P2.0 [] a aa b [] a aa b;
         !!e a aa b v ab ac ba es es' ad ae bb.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>Val v,(ab, ac, ba)\<rangle>;
               ?P1.0 e a aa b (Val v) ab ac ba;
               ?P \<turnstile>\<^sub>1 \<langle>es,
  (ab, ac, ba)\<rangle> [\<Rightarrow>]
 \<langle>es',(ad, ae, bb)\<rangle>;
               ?P2.0 es ab ac ba es' ad ae bb |]
            ==> ?P2.0 (e # es) a aa b (Val v # es') ad ae bb;
         !!e a aa b e' ab ac ba es.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>throw e',(ab, ac, ba)\<rangle>;
               ?P1.0 e a aa b (throw e') ab ac ba |]
            ==> ?P2.0 (e # es) a aa b (throw e' # es) ab ac ba;
         !!e a aa b e' ab ac ba C bb.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>e',(ab, ac, ba)\<rangle>;
               ?P1.0 e a aa b e' ab ac ba |]
            ==> ?P1.0 (INIT C ([],bb) \<leftarrow> e) a aa b e' ab ac ba;
         !!sh C C' Cs e h l e' a aa b.
            [| sh C = None;
               ?P \<turnstile>\<^sub>1 \<langle>INIT C' (C #
                   Cs,False) \<leftarrow> e,
  (h, l, sh(C |-> (sblank ?P C, Prepared)))\<rangle> \<Rightarrow>
 \<langle>e',(a, aa, b)\<rangle>;
               ?P1.0 (INIT C' (C # Cs,False) \<leftarrow> e) h l
                (sh(C |-> (sblank ?P C, Prepared))) e' a aa b |]
            ==> ?P1.0 (INIT C' (C # Cs,False) \<leftarrow> e) h l sh e' a aa
                 b;
         !!sh C sfs C' Cs e h l e' a aa b.
            [| sh C = \<lfloor>(sfs, Done)\<rfloor>;
               ?P \<turnstile>\<^sub>1 \<langle>INIT C' (Cs,True) \<leftarrow> e,
  (h, l, sh)\<rangle> \<Rightarrow>
 \<langle>e',(a, aa, b)\<rangle>;
               ?P1.0 (INIT C' (Cs,True) \<leftarrow> e) h l sh e' a aa b |]
            ==> ?P1.0 (INIT C' (C # Cs,False) \<leftarrow> e) h l sh e' a aa
                 b;
         !!sh C sfs C' Cs e h l e' a aa b.
            [| sh C = \<lfloor>(sfs, Processing)\<rfloor>;
               ?P \<turnstile>\<^sub>1 \<langle>INIT C' (Cs,True) \<leftarrow> e,
  (h, l, sh)\<rangle> \<Rightarrow>
 \<langle>e',(a, aa, b)\<rangle>;
               ?P1.0 (INIT C' (Cs,True) \<leftarrow> e) h l sh e' a aa b |]
            ==> ?P1.0 (INIT C' (C # Cs,False) \<leftarrow> e) h l sh e' a aa
                 b;
         !!sh C sfs Cs e h l e' a aa b C'.
            [| sh C = \<lfloor>(sfs, Error)\<rfloor>;
               ?P \<turnstile>\<^sub>1 \<langle>RI (C,THROW
                 NoClassDefFoundError) ; Cs \<leftarrow> e,
  (h, l, sh)\<rangle> \<Rightarrow>
 \<langle>e',(a, aa, b)\<rangle>;
               ?P1.0 (RI (C,THROW NoClassDefFoundError) ; Cs \<leftarrow> e)
                h l sh e' a aa b |]
            ==> ?P1.0 (INIT C' (C # Cs,False) \<leftarrow> e) h l sh e' a aa
                 b;
         !!sh C sfs sh' C' Cs e h l e' a aa b.
            [| sh C = \<lfloor>(sfs, Prepared)\<rfloor>; C = Object;
               sh' = sh(C |-> (sfs, Processing));
               ?P \<turnstile>\<^sub>1 \<langle>INIT C' (C #
                   Cs,True) \<leftarrow> e,
  (h, l, sh')\<rangle> \<Rightarrow>
 \<langle>e',(a, aa, b)\<rangle>;
               ?P1.0 (INIT C' (C # Cs,True) \<leftarrow> e) h l sh' e' a aa
                b |]
            ==> ?P1.0 (INIT C' (C # Cs,False) \<leftarrow> e) h l sh e' a aa
                 b;
         !!sh C sfs D a b sh' C' Cs e h l e' aa ab ba.
            [| sh C = \<lfloor>(sfs, Prepared)\<rfloor>; C ~= Object;
               class ?P C = \<lfloor>(D, a, b)\<rfloor>;
               sh' = sh(C |-> (sfs, Processing));
               ?P \<turnstile>\<^sub>1 \<langle>INIT C' (D #
                   C # Cs,False) \<leftarrow> e,
  (h, l, sh')\<rangle> \<Rightarrow>
 \<langle>e',(aa, ab, ba)\<rangle>;
               ?P1.0 (INIT C' (D # C # Cs,False) \<leftarrow> e) h l sh' e'
                aa ab ba |]
            ==> ?P1.0 (INIT C' (C # Cs,False) \<leftarrow> e) h l sh e' aa
                 ab ba;
         !!C Cs e h l sh e' a aa b C'.
            [| ?P \<turnstile>\<^sub>1 \<langle>RI (C,C\<bullet>\<^sub>sclinit([])) ; Cs \<leftarrow> e,
  (h, l, sh)\<rangle> \<Rightarrow>
 \<langle>e',(a, aa, b)\<rangle>;
               ?P1.0
                (RI (C,C\<bullet>\<^sub>sclinit([])) ; Cs \<leftarrow> e) h
                l sh e' a aa b |]
            ==> ?P1.0 (INIT C' (C # Cs,True) \<leftarrow> e) h l sh e' a aa
                 b;
         !!e a aa b v h' l' sh' C sfs i sh'' C' Cs e' e\<^sub>1 ab ac ba.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>Val v,(h', l', sh')\<rangle>;
               ?P1.0 e a aa b (Val v) h' l' sh';
               sh' C = \<lfloor>(sfs, i)\<rfloor>;
               sh'' = sh'(C |-> (sfs, Done)); C' = last (C # Cs);
               ?P \<turnstile>\<^sub>1 \<langle>INIT C' (Cs,True) \<leftarrow> e',
  (h', l', sh'')\<rangle> \<Rightarrow>
 \<langle>e\<^sub>1,(ab, ac, ba)\<rangle>;
               ?P1.0 (INIT C' (Cs,True) \<leftarrow> e') h' l' sh''
                e\<^sub>1 ab ac ba |]
            ==> ?P1.0 (RI (C,e) ; Cs \<leftarrow> e') a aa b e\<^sub>1 ab ac
                 ba;
         !!e a aa b ab h' l' sh' C sfs i sh'' D Cs e' e\<^sub>1 ac ad ba.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>throw ab,(h', l', sh')\<rangle>;
               ?P1.0 e a aa b (throw ab) h' l' sh';
               sh' C = \<lfloor>(sfs, i)\<rfloor>;
               sh'' = sh'(C |-> (sfs, Error));
               ?P \<turnstile>\<^sub>1 \<langle>RI (D,throw
                 ab) ; Cs \<leftarrow> e',
  (h', l', sh'')\<rangle> \<Rightarrow>
 \<langle>e\<^sub>1,(ac, ad, ba)\<rangle>;
               ?P1.0 (RI (D,throw ab) ; Cs \<leftarrow> e') h' l' sh''
                e\<^sub>1 ac ad ba |]
            ==> ?P1.0 (RI (C,e) ; D # Cs \<leftarrow> e') a aa b e\<^sub>1
                 ac ad ba;
         !!e a aa b ab h' l' sh' C sfs i sh'' e'.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>throw ab,(h', l', sh')\<rangle>;
               ?P1.0 e a aa b (throw ab) h' l' sh';
               sh' C = \<lfloor>(sfs, i)\<rfloor>;
               sh'' = sh'(C |-> (sfs, Error)) |]
            ==> ?P1.0 (RI (C,e) ; [] \<leftarrow> e') a aa b (throw ab) h'
                 l' sh'' |]
      ==> ?P2.0 ?x5a ?x6a ?x6b ?x6c ?x7a ?x8a ?x8b ?x8c",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app
                   (template_app (template_hole 134, template_var 10),
                    template_var 9),
                  template_app
                   (template_app (template_hole 133, template_var 8),
                    template_app
                     (template_app (template_hole 132, template_var 7),
                      template_var 6))),
                template_var 5),
              template_app
               (template_app (template_hole 133, template_var 4),
                template_app
                 (template_app (template_hole 132, template_var 3),
                  template_var 2)))
            ),
        template_predicate (template_app (template_hole 131, t_empty)),
        template_predicate (template_app (template_hole 131, t_empty)),
        template_predicate (template_app (template_hole 131, t_empty)),
        template_predicate (template_app (template_hole 131, t_empty)),
        template_predicate (template_app (template_hole 131, t_empty)),
        template_predicate (template_app (template_hole 95, t_empty)),
        template_predicate (template_app (template_hole 95, t_empty)),
        template_predicate (template_app (template_hole 95, t_empty)),
        template_predicate (template_app (template_hole 95, t_empty)),
        template_predicate (template_app (template_hole 105, t_empty)),
        template_predicate (template_app (template_hole 95, t_empty)),
        template_predicate (template_app (template_hole 95, t_empty)),
        template_predicate (template_app (template_hole 95, t_empty)),
        template_predicate (template_app (template_hole 125, t_empty)),
        template_predicate (template_app (template_hole 95, t_empty)),
        template_predicate (template_app (template_hole 95, t_empty)),
        template_predicate (template_app (template_hole 95, t_empty)),
        template_predicate (template_app (template_hole 95, t_empty)),
        template_predicate (template_app (template_hole 95, t_empty)),
        template_predicate (template_app (template_hole 95, t_empty)),
        template_predicate (template_app (template_hole 95, t_empty)),
        template_predicate (template_app (template_hole 130, t_empty)),
        template_predicate (template_app (template_hole 130, t_empty)),
        template_predicate (template_app (template_hole 130, t_empty)),
        template_predicate (template_app (template_hole 130, t_empty)),
        template_predicate (template_app (template_hole 130, t_empty)),
        template_predicate (template_app (template_hole 95, t_empty)),
        template_predicate (template_app (template_hole 95, t_empty)),
        template_predicate (template_app (template_hole 95, t_empty)),
        template_predicate (template_app (template_hole 95, t_empty)),
        template_predicate (template_app (template_hole 95, t_empty)),
        template_predicate (template_app (template_hole 95, t_empty)),
        template_predicate (template_app (template_hole 95, t_empty)),
        template_predicate (template_app (template_hole 95, t_empty)),
        template_predicate (template_app (template_hole 95, t_empty)),
        template_predicate (template_app (template_hole 95, t_empty)),
        template_predicate (template_app (template_hole 95, t_empty)),
        template_predicate (template_app (template_hole 95, t_empty)),
        template_predicate (template_app (template_hole 95, t_empty)),
        template_predicate (template_app (template_hole 95, t_empty)),
        template_predicate (template_app (template_hole 95, t_empty)),
        template_predicate (template_app (template_hole 95, t_empty)),
        template_predicate (template_app (template_hole 95, t_empty)),
        template_predicate (template_app (template_hole 95, t_empty)),
        template_predicate (template_app (template_hole 49, t_empty)),
        template_predicate (template_app (template_hole 49, t_empty)),
        template_predicate (template_app (template_hole 49, t_empty)),
        template_predicate (template_app (template_hole 49, t_empty)),
        template_predicate (template_app (template_hole 49, t_empty)),
        template_predicate (template_app (template_hole 49, t_empty)),
        template_predicate (template_app (template_hole 95, t_empty)),
        template_predicate (template_app (template_hole 95, t_empty)),
        template_predicate (template_app (template_hole 95, t_empty)),
        template_predicate (template_app (template_hole 95, t_empty)),
        template_predicate (template_app (template_hole 95, t_empty)),
        template_predicate (template_app (template_hole 95, t_empty)),
        template_predicate (template_app (template_hole 95, t_empty)),
        template_predicate (template_app (template_hole 95, t_empty)),
        template_predicate (template_app (template_hole 95, t_empty)),
        template_predicate (template_app (template_hole 95, t_empty)),
        template_predicate (template_app (template_hole 95, t_empty)),
        template_predicate (template_app (template_hole 95, t_empty)),
        template_predicate (template_app (template_hole 95, t_empty)),
        template_predicate (template_app (template_hole 95, t_empty)),
        template_predicate (template_app (template_hole 95, t_empty)),
        template_predicate (template_app (template_hole 95, t_empty)),
        template_predicate (template_app (template_hole 128, t_empty)),
        template_predicate (template_app (template_hole 95, t_empty)),
        template_predicate (template_app (template_hole 95, t_empty)),
        template_predicate (template_app (template_hole 95, t_empty)),
        template_predicate (template_app (template_hole 131, t_empty)),
        template_predicate (template_app (template_hole 131, t_empty)),
        template_predicate (template_app (template_hole 131, t_empty)),
        template_predicate (template_app (template_hole 131, t_empty)),
        template_predicate (template_app (template_hole 131, t_empty)),
        template_predicate (template_app (template_hole 131, t_empty)),
        template_predicate (template_app (template_hole 130, t_empty)),
        template_predicate (template_app (template_hole 95, t_empty)),
        template_predicate (template_app (template_hole 95, t_empty)),
        template_predicate (template_app (template_hole 95, t_empty))],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_app
                  (template_app
                    (template_app
                      (template_app
                        (template_app (template_var 0, template_var 9),
                         template_var 8),
                       template_var 7),
                     template_var 6),
                   template_var 5),
                 template_var 4),
               template_var 3),
             template_var 2)
           ))),
    ("J1.eval\<^sub>1_evals\<^sub>1_induct",
     "[| !!sh C sfs h a FDTs h' l.
            [| sh C = \<lfloor>(sfs, Done)\<rfloor>;
               new_Addr h = \<lfloor>a\<rfloor>;
               ?P \<turnstile> C has_fields FDTs;
               h' = h(a |-> blank ?P C) |]
            ==> ?P1.0 (new C) h l sh (addr a) h' l sh;
         !!sh C sfs h l.
            [| sh C = \<lfloor>(sfs, Done)\<rfloor>; new_Addr h = None |]
            ==> ?P1.0 (new C) h l sh (THROW OutOfMemory) h l sh;
         !!sh C h l v' h' l' sh' a FDTs h''.
            [| \<nexists>sfs. sh C = \<lfloor>(sfs, Done)\<rfloor>;
               ?P \<turnstile>\<^sub>1 \<langle>INIT C ([C],False) \<leftarrow> unit,
  (h, l, sh)\<rangle> \<Rightarrow>
 \<langle>Val v',(h', l', sh')\<rangle>;
               ?P1.0 (INIT C ([C],False) \<leftarrow> unit) h l sh (Val v')
                h' l' sh';
               new_Addr h' = \<lfloor>a\<rfloor>;
               ?P \<turnstile> C has_fields FDTs;
               h'' = h'(a |-> blank ?P C) |]
            ==> ?P1.0 (new C) h l sh (addr a) h'' l' sh';
         !!sh C h l v' h' l' sh'.
            [| \<nexists>sfs. sh C = \<lfloor>(sfs, Done)\<rfloor>;
               ?P \<turnstile>\<^sub>1 \<langle>INIT C ([C],False) \<leftarrow> unit,
  (h, l, sh)\<rangle> \<Rightarrow>
 \<langle>Val v',(h', l', sh')\<rangle>;
               ?P1.0 (INIT C ([C],False) \<leftarrow> unit) h l sh (Val v')
                h' l' sh';
               new_Addr h' = None; is_class ?P C |]
            ==> ?P1.0 (new C) h l sh (THROW OutOfMemory) h' l' sh';
         !!sh C h l a aa ab b.
            [| \<nexists>sfs. sh C = \<lfloor>(sfs, Done)\<rfloor>;
               ?P \<turnstile>\<^sub>1 \<langle>INIT C ([C],False) \<leftarrow> unit,
  (h, l, sh)\<rangle> \<Rightarrow>
 \<langle>throw a,(aa, ab, b)\<rangle>;
               ?P1.0 (INIT C ([C],False) \<leftarrow> unit) h l sh (throw a)
                aa ab b;
               is_class ?P C |]
            ==> ?P1.0 (new C) h l sh (throw a) aa ab b;
         !!e a aa b ab h l sh D fs C.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>addr ab,(h, l, sh)\<rangle>;
               ?P1.0 e a aa b (addr ab) h l sh;
               h ab = \<lfloor>(D, fs)\<rfloor>;
               ?P \<turnstile> D \<preceq>\<^sup>* C |]
            ==> ?P1.0 (Cast C e) a aa b (addr ab) h l sh;
         !!e a aa b ab ac ba C.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>null,(ab, ac, ba)\<rangle>;
               ?P1.0 e a aa b null ab ac ba |]
            ==> ?P1.0 (Cast C e) a aa b null ab ac ba;
         !!e a aa b ab h l sh D fs C.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>addr ab,(h, l, sh)\<rangle>;
               ?P1.0 e a aa b (addr ab) h l sh;
               h ab = \<lfloor>(D, fs)\<rfloor>; (D, C) ~: (subcls1 ?P)^* |]
            ==> ?P1.0 (Cast C e) a aa b (THROW ClassCast) h l sh;
         !!e a aa b e' ab ac ba C.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>throw e',(ab, ac, ba)\<rangle>;
               ?P1.0 e a aa b (throw e') ab ac ba |]
            ==> ?P1.0 (Cast C e) a aa b (throw e') ab ac ba;
         !!v a aa b. ?P1.0 (Val v) a aa b (Val v) a aa b;
         !!e\<^sub>1 a aa b v\<^sub>1 ab ac ba e\<^sub>2 v\<^sub>2 ad ae bb
            bop v.
            [| ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>1,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>Val v\<^sub>1,(ab, ac, ba)\<rangle>;
               ?P1.0 e\<^sub>1 a aa b (Val v\<^sub>1) ab ac ba;
               ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>2,
  (ab, ac, ba)\<rangle> \<Rightarrow>
 \<langle>Val v\<^sub>2,(ad, ae, bb)\<rangle>;
               ?P1.0 e\<^sub>2 ab ac ba (Val v\<^sub>2) ad ae bb;
               binop (bop, v\<^sub>1, v\<^sub>2) = \<lfloor>v\<rfloor> |]
            ==> ?P1.0
                 (e\<^sub>1 \<guillemotleft>bop\<guillemotright> e\<^sub>2)
                 a aa b (Val v) ad ae bb;
         !!e\<^sub>1 a aa b e ab ac ba bop e\<^sub>2.
            [| ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>1,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>throw e,(ab, ac, ba)\<rangle>;
               ?P1.0 e\<^sub>1 a aa b (throw e) ab ac ba |]
            ==> ?P1.0
                 (e\<^sub>1 \<guillemotleft>bop\<guillemotright> e\<^sub>2)
                 a aa b (throw e) ab ac ba;
         !!e\<^sub>1 a aa b v\<^sub>1 ab ac ba e\<^sub>2 e ad ae bb bop.
            [| ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>1,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>Val v\<^sub>1,(ab, ac, ba)\<rangle>;
               ?P1.0 e\<^sub>1 a aa b (Val v\<^sub>1) ab ac ba;
               ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>2,
  (ab, ac, ba)\<rangle> \<Rightarrow>
 \<langle>throw e,(ad, ae, bb)\<rangle>;
               ?P1.0 e\<^sub>2 ab ac ba (throw e) ad ae bb |]
            ==> ?P1.0
                 (e\<^sub>1 \<guillemotleft>bop\<guillemotright> e\<^sub>2)
                 a aa b (throw e) ad ae bb;
         !!ls i v h sh.
            [| ls ! i = v; i < length ls |]
            ==> ?P1.0 (Var i) h ls sh (Val v) h ls sh;
         !!e a aa b v h ls sh i ls'.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>Val v,(h, ls, sh)\<rangle>;
               ?P1.0 e a aa b (Val v) h ls sh; i < length ls;
               ls' = ls[i := v] |]
            ==> ?P1.0 (i:=e) a aa b unit h ls' sh;
         !!e a aa b e' ab ac ba i.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>throw e',(ab, ac, ba)\<rangle>;
               ?P1.0 e a aa b (throw e') ab ac ba |]
            ==> ?P1.0 (i:=e) a aa b (throw e') ab ac ba;
         !!e a aa b ab h ls sh C fs F t D v.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>addr ab,(h, ls, sh)\<rangle>;
               ?P1.0 e a aa b (addr ab) h ls sh;
               h ab = \<lfloor>(C, fs)\<rfloor>;
               ?P \<turnstile> C has F,NonStatic:t in D;
               fs (F, D) = \<lfloor>v\<rfloor> |]
            ==> ?P1.0 (e\<bullet>F{D}) a aa b (Val v) h ls sh;
         !!e a aa b ab ac ba F D.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>null,(ab, ac, ba)\<rangle>;
               ?P1.0 e a aa b null ab ac ba |]
            ==> ?P1.0 (e\<bullet>F{D}) a aa b (THROW NullPointer) ab ac ba;
         !!e a aa b e' ab ac ba F D.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>throw e',(ab, ac, ba)\<rangle>;
               ?P1.0 e a aa b (throw e') ab ac ba |]
            ==> ?P1.0 (e\<bullet>F{D}) a aa b (throw e') ab ac ba;
         !!e a aa b ab h ls sh C fs F D.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>addr ab,(h, ls, sh)\<rangle>;
               ?P1.0 e a aa b (addr ab) h ls sh;
               h ab = \<lfloor>(C, fs)\<rfloor>;
               \<nexists>b t. ?P \<turnstile> C has F,b:t in D |]
            ==> ?P1.0 (e\<bullet>F{D}) a aa b (THROW NoSuchFieldError) h ls
                 sh;
         !!e a aa b ab h ls sh C fs F t D.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>addr ab,(h, ls, sh)\<rangle>;
               ?P1.0 e a aa b (addr ab) h ls sh;
               h ab = \<lfloor>(C, fs)\<rfloor>;
               ?P \<turnstile> C has F,Static:t in D |]
            ==> ?P1.0 (e\<bullet>F{D}) a aa b
                 (THROW IncompatibleClassChangeError) h ls sh;
         !!C F t D sh sfs v h ls.
            [| ?P \<turnstile> C has F,Static:t in D;
               sh D = \<lfloor>(sfs, Done)\<rfloor>;
               sfs F = \<lfloor>v\<rfloor> |]
            ==> ?P1.0 (C\<bullet>\<^sub>sF{D}) h ls sh (Val v) h ls sh;
         !!C F t D sh h ls v' h' ls' sh' sfs i v.
            [| ?P \<turnstile> C has F,Static:t in D;
               \<nexists>sfs. sh D = \<lfloor>(sfs, Done)\<rfloor>;
               ?P \<turnstile>\<^sub>1 \<langle>INIT D ([D],False) \<leftarrow> unit,
  (h, ls, sh)\<rangle> \<Rightarrow>
 \<langle>Val v',(h', ls', sh')\<rangle>;
               ?P1.0 (INIT D ([D],False) \<leftarrow> unit) h ls sh (Val v')
                h' ls' sh';
               sh' D = \<lfloor>(sfs, i)\<rfloor>;
               sfs F = \<lfloor>v\<rfloor> |]
            ==> ?P1.0 (C\<bullet>\<^sub>sF{D}) h ls sh (Val v) h' ls' sh';
         !!C F t D sh h ls a aa ab b.
            [| ?P \<turnstile> C has F,Static:t in D;
               \<nexists>sfs. sh D = \<lfloor>(sfs, Done)\<rfloor>;
               ?P \<turnstile>\<^sub>1 \<langle>INIT D ([D],False) \<leftarrow> unit,
  (h, ls, sh)\<rangle> \<Rightarrow>
 \<langle>throw a,(aa, ab, b)\<rangle>;
               ?P1.0 (INIT D ([D],False) \<leftarrow> unit) h ls sh
                (throw a) aa ab b |]
            ==> ?P1.0 (C\<bullet>\<^sub>sF{D}) h ls sh (throw a) aa ab b;
         !!C F D a aa b.
            \<nexists>b t. ?P \<turnstile> C has F,b:t in D ==>
            ?P1.0 (C\<bullet>\<^sub>sF{D}) a aa b (THROW NoSuchFieldError) a
             aa b;
         !!C F t D a aa b.
            ?P \<turnstile> C has F,NonStatic:t in D ==>
            ?P1.0 (C\<bullet>\<^sub>sF{D}) a aa b
             (THROW IncompatibleClassChangeError) a aa b;
         !!e\<^sub>1 a aa b ab ac ad ba e\<^sub>2 v h\<^sub>2 l\<^sub>2
            sh\<^sub>2 C fs F t D fs' h\<^sub>2'.
            [| ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>1,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>addr ab,(ac, ad, ba)\<rangle>;
               ?P1.0 e\<^sub>1 a aa b (addr ab) ac ad ba;
               ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>2,
  (ac, ad, ba)\<rangle> \<Rightarrow>
 \<langle>Val v,(h\<^sub>2, l\<^sub>2, sh\<^sub>2)\<rangle>;
               ?P1.0 e\<^sub>2 ac ad ba (Val v) h\<^sub>2 l\<^sub>2
                sh\<^sub>2;
               h\<^sub>2 ab = \<lfloor>(C, fs)\<rfloor>;
               ?P \<turnstile> C has F,NonStatic:t in D;
               fs' = fs((F, D) |-> v);
               h\<^sub>2' = h\<^sub>2(ab |-> (C, fs')) |]
            ==> ?P1.0 (e\<^sub>1\<bullet>F{D} := e\<^sub>2) a aa b unit
                 h\<^sub>2' l\<^sub>2 sh\<^sub>2;
         !!e\<^sub>1 a aa b ab ac ba e\<^sub>2 v ad ae bb F D.
            [| ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>1,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>null,(ab, ac, ba)\<rangle>;
               ?P1.0 e\<^sub>1 a aa b null ab ac ba;
               ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>2,
  (ab, ac, ba)\<rangle> \<Rightarrow>
 \<langle>Val v,(ad, ae, bb)\<rangle>;
               ?P1.0 e\<^sub>2 ab ac ba (Val v) ad ae bb |]
            ==> ?P1.0 (e\<^sub>1\<bullet>F{D} := e\<^sub>2) a aa b
                 (THROW NullPointer) ad ae bb;
         !!e\<^sub>1 a aa b e' ab ac ba F D e\<^sub>2.
            [| ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>1,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>throw e',(ab, ac, ba)\<rangle>;
               ?P1.0 e\<^sub>1 a aa b (throw e') ab ac ba |]
            ==> ?P1.0 (e\<^sub>1\<bullet>F{D} := e\<^sub>2) a aa b
                 (throw e') ab ac ba;
         !!e\<^sub>1 a aa b v ab ac ba e\<^sub>2 e' ad ae bb F D.
            [| ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>1,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>Val v,(ab, ac, ba)\<rangle>;
               ?P1.0 e\<^sub>1 a aa b (Val v) ab ac ba;
               ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>2,
  (ab, ac, ba)\<rangle> \<Rightarrow>
 \<langle>throw e',(ad, ae, bb)\<rangle>;
               ?P1.0 e\<^sub>2 ab ac ba (throw e') ad ae bb |]
            ==> ?P1.0 (e\<^sub>1\<bullet>F{D} := e\<^sub>2) a aa b
                 (throw e') ad ae bb;
         !!e\<^sub>1 a aa b ab ac ad ba e\<^sub>2 v h\<^sub>2 l\<^sub>2
            sh\<^sub>2 C fs F D.
            [| ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>1,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>addr ab,(ac, ad, ba)\<rangle>;
               ?P1.0 e\<^sub>1 a aa b (addr ab) ac ad ba;
               ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>2,
  (ac, ad, ba)\<rangle> \<Rightarrow>
 \<langle>Val v,(h\<^sub>2, l\<^sub>2, sh\<^sub>2)\<rangle>;
               ?P1.0 e\<^sub>2 ac ad ba (Val v) h\<^sub>2 l\<^sub>2
                sh\<^sub>2;
               h\<^sub>2 ab = \<lfloor>(C, fs)\<rfloor>;
               \<nexists>b t. ?P \<turnstile> C has F,b:t in D |]
            ==> ?P1.0 (e\<^sub>1\<bullet>F{D} := e\<^sub>2) a aa b
                 (THROW NoSuchFieldError) h\<^sub>2 l\<^sub>2 sh\<^sub>2;
         !!e\<^sub>1 a aa b ab ac ad ba e\<^sub>2 v h\<^sub>2 l\<^sub>2
            sh\<^sub>2 C fs F t D.
            [| ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>1,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>addr ab,(ac, ad, ba)\<rangle>;
               ?P1.0 e\<^sub>1 a aa b (addr ab) ac ad ba;
               ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>2,
  (ac, ad, ba)\<rangle> \<Rightarrow>
 \<langle>Val v,(h\<^sub>2, l\<^sub>2, sh\<^sub>2)\<rangle>;
               ?P1.0 e\<^sub>2 ac ad ba (Val v) h\<^sub>2 l\<^sub>2
                sh\<^sub>2;
               h\<^sub>2 ab = \<lfloor>(C, fs)\<rfloor>;
               ?P \<turnstile> C has F,Static:t in D |]
            ==> ?P1.0 (e\<^sub>1\<bullet>F{D} := e\<^sub>2) a aa b
                 (THROW IncompatibleClassChangeError) h\<^sub>2 l\<^sub>2
                 sh\<^sub>2;
         !!e\<^sub>2 a aa b v h\<^sub>1 l\<^sub>1 sh\<^sub>1 C F t D sfs
            sfs' sh\<^sub>1'.
            [| ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>2,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>Val v,(h\<^sub>1, l\<^sub>1, sh\<^sub>1)\<rangle>;
               ?P1.0 e\<^sub>2 a aa b (Val v) h\<^sub>1 l\<^sub>1
                sh\<^sub>1;
               ?P \<turnstile> C has F,Static:t in D;
               sh\<^sub>1 D = \<lfloor>(sfs, Done)\<rfloor>;
               sfs' = sfs(F |-> v);
               sh\<^sub>1' = sh\<^sub>1(D |-> (sfs', Done)) |]
            ==> ?P1.0 (C\<bullet>\<^sub>sF{D} := e\<^sub>2) a aa b unit
                 h\<^sub>1 l\<^sub>1 sh\<^sub>1';
         !!e\<^sub>2 a aa b v h\<^sub>1 l\<^sub>1 sh\<^sub>1 C F t D v' h'
            l' sh' sfs i sfs' sh''.
            [| ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>2,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>Val v,(h\<^sub>1, l\<^sub>1, sh\<^sub>1)\<rangle>;
               ?P1.0 e\<^sub>2 a aa b (Val v) h\<^sub>1 l\<^sub>1
                sh\<^sub>1;
               ?P \<turnstile> C has F,Static:t in D;
               \<nexists>sfs. sh\<^sub>1 D = \<lfloor>(sfs, Done)\<rfloor>;
               ?P \<turnstile>\<^sub>1 \<langle>INIT D ([D],False) \<leftarrow> unit,
  (h\<^sub>1, l\<^sub>1, sh\<^sub>1)\<rangle> \<Rightarrow>
 \<langle>Val v',(h', l', sh')\<rangle>;
               ?P1.0 (INIT D ([D],False) \<leftarrow> unit) h\<^sub>1
                l\<^sub>1 sh\<^sub>1 (Val v') h' l' sh';
               sh' D = \<lfloor>(sfs, i)\<rfloor>; sfs' = sfs(F |-> v);
               sh'' = sh'(D |-> (sfs', i)) |]
            ==> ?P1.0 (C\<bullet>\<^sub>sF{D} := e\<^sub>2) a aa b unit h'
                 l' sh'';
         !!e\<^sub>2 a aa b v h\<^sub>1 l\<^sub>1 sh\<^sub>1 C F t D ab ac
            ad ba.
            [| ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>2,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>Val v,(h\<^sub>1, l\<^sub>1, sh\<^sub>1)\<rangle>;
               ?P1.0 e\<^sub>2 a aa b (Val v) h\<^sub>1 l\<^sub>1
                sh\<^sub>1;
               ?P \<turnstile> C has F,Static:t in D;
               \<nexists>sfs. sh\<^sub>1 D = \<lfloor>(sfs, Done)\<rfloor>;
               ?P \<turnstile>\<^sub>1 \<langle>INIT D ([D],False) \<leftarrow> unit,
  (h\<^sub>1, l\<^sub>1, sh\<^sub>1)\<rangle> \<Rightarrow>
 \<langle>throw ab,(ac, ad, ba)\<rangle>;
               ?P1.0 (INIT D ([D],False) \<leftarrow> unit) h\<^sub>1
                l\<^sub>1 sh\<^sub>1 (throw ab) ac ad ba |]
            ==> ?P1.0 (C\<bullet>\<^sub>sF{D} := e\<^sub>2) a aa b
                 (throw ab) ac ad ba;
         !!e\<^sub>2 a aa b e' ab ac ba C F D.
            [| ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>2,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>throw e',(ab, ac, ba)\<rangle>;
               ?P1.0 e\<^sub>2 a aa b (throw e') ab ac ba |]
            ==> ?P1.0 (C\<bullet>\<^sub>sF{D} := e\<^sub>2) a aa b
                 (throw e') ab ac ba;
         !!e\<^sub>2 a aa b v h\<^sub>2 l\<^sub>2 sh\<^sub>2 C F D.
            [| ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>2,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>Val v,(h\<^sub>2, l\<^sub>2, sh\<^sub>2)\<rangle>;
               ?P1.0 e\<^sub>2 a aa b (Val v) h\<^sub>2 l\<^sub>2
                sh\<^sub>2;
               \<nexists>b t. ?P \<turnstile> C has F,b:t in D |]
            ==> ?P1.0 (C\<bullet>\<^sub>sF{D} := e\<^sub>2) a aa b
                 (THROW NoSuchFieldError) h\<^sub>2 l\<^sub>2 sh\<^sub>2;
         !!e\<^sub>2 a aa b v h\<^sub>2 l\<^sub>2 sh\<^sub>2 C F t D.
            [| ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>2,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>Val v,(h\<^sub>2, l\<^sub>2, sh\<^sub>2)\<rangle>;
               ?P1.0 e\<^sub>2 a aa b (Val v) h\<^sub>2 l\<^sub>2
                sh\<^sub>2;
               ?P \<turnstile> C has F,NonStatic:t in D |]
            ==> ?P1.0 (C\<bullet>\<^sub>sF{D} := e\<^sub>2) a aa b
                 (THROW IncompatibleClassChangeError) h\<^sub>2 l\<^sub>2
                 sh\<^sub>2;
         !!e a aa b e' ab ac ba M es.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>throw e',(ab, ac, ba)\<rangle>;
               ?P1.0 e a aa b (throw e') ab ac ba |]
            ==> ?P1.0 (e\<bullet>M(es)) a aa b (throw e') ab ac ba;
         !!e a aa b ab ac ba es vs ad ae bb M.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>null,(ab, ac, ba)\<rangle>;
               ?P1.0 e a aa b null ab ac ba;
               ?P \<turnstile>\<^sub>1 \<langle>es,
  (ab, ac, ba)\<rangle> [\<Rightarrow>]
 \<langle>map Val vs,(ad, ae, bb)\<rangle>;
               ?P2.0 es ab ac ba (map Val vs) ad ae bb |]
            ==> ?P1.0 (e\<bullet>M(es)) a aa b (THROW NullPointer) ad ae bb;
         !!e a aa b ab ac ad ba es vs h\<^sub>2 ls\<^sub>2 sh\<^sub>2 C fs M
            Ts T body D ls\<^sub>2' e' h\<^sub>3 ls\<^sub>3 sh\<^sub>3.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>addr ab,(ac, ad, ba)\<rangle>;
               ?P1.0 e a aa b (addr ab) ac ad ba;
               ?P \<turnstile>\<^sub>1 \<langle>es,
  (ac, ad, ba)\<rangle> [\<Rightarrow>]
 \<langle>map Val vs,(h\<^sub>2, ls\<^sub>2, sh\<^sub>2)\<rangle>;
               ?P2.0 es ac ad ba (map Val vs) h\<^sub>2 ls\<^sub>2
                sh\<^sub>2;
               h\<^sub>2 ab = \<lfloor>(C, fs)\<rfloor>;
               ?P \<turnstile> C sees M, NonStatic :  Ts\<rightarrow>T = body in D;
               length vs = length Ts;
               ls\<^sub>2' =
               Addr ab # vs @ replicate (max_vars body) undefined;
               ?P \<turnstile>\<^sub>1 \<langle>body,
  (h\<^sub>2, ls\<^sub>2', sh\<^sub>2)\<rangle> \<Rightarrow>
 \<langle>e',(h\<^sub>3, ls\<^sub>3, sh\<^sub>3)\<rangle>;
               ?P1.0 body h\<^sub>2 ls\<^sub>2' sh\<^sub>2 e' h\<^sub>3
                ls\<^sub>3 sh\<^sub>3 |]
            ==> ?P1.0 (e\<bullet>M(es)) a aa b e' h\<^sub>3 ls\<^sub>2
                 sh\<^sub>3;
         !!e a aa b v ab ac ba es es' ad ae bb vs ex es\<^sub>2 M.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>Val v,(ab, ac, ba)\<rangle>;
               ?P1.0 e a aa b (Val v) ab ac ba;
               ?P \<turnstile>\<^sub>1 \<langle>es,
  (ab, ac, ba)\<rangle> [\<Rightarrow>]
 \<langle>es',(ad, ae, bb)\<rangle>;
               ?P2.0 es ab ac ba es' ad ae bb;
               es' = map Val vs @ throw ex # es\<^sub>2 |]
            ==> ?P1.0 (e\<bullet>M(es)) a aa b (throw ex) ad ae bb;
         !!e a aa b ab ac ad ba ps vs h\<^sub>2 ls\<^sub>2 sh\<^sub>2 C fs
            M. [| ?P \<turnstile>\<^sub>1 \<langle>e,
     (a, aa, b)\<rangle> \<Rightarrow>
    \<langle>addr ab,(ac, ad, ba)\<rangle>;
                  ?P1.0 e a aa b (addr ab) ac ad ba;
                  ?P \<turnstile>\<^sub>1 \<langle>ps,
     (ac, ad, ba)\<rangle> [\<Rightarrow>]
    \<langle>map Val vs,(h\<^sub>2, ls\<^sub>2, sh\<^sub>2)\<rangle>;
                  ?P2.0 ps ac ad ba (map Val vs) h\<^sub>2 ls\<^sub>2
                   sh\<^sub>2;
                  h\<^sub>2 ab = \<lfloor>(C, fs)\<rfloor>;
                  \<nexists>b Ts T body. Ex (Method ?P C M b Ts T body) |]
               ==> ?P1.0 (e\<bullet>M(ps)) a aa b (THROW NoSuchMethodError)
                    h\<^sub>2 ls\<^sub>2 sh\<^sub>2;
         !!e a aa b ab ac ad ba ps vs h\<^sub>2 ls\<^sub>2 sh\<^sub>2 C fs M
            Ts T body D.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>addr ab,(ac, ad, ba)\<rangle>;
               ?P1.0 e a aa b (addr ab) ac ad ba;
               ?P \<turnstile>\<^sub>1 \<langle>ps,
  (ac, ad, ba)\<rangle> [\<Rightarrow>]
 \<langle>map Val vs,(h\<^sub>2, ls\<^sub>2, sh\<^sub>2)\<rangle>;
               ?P2.0 ps ac ad ba (map Val vs) h\<^sub>2 ls\<^sub>2
                sh\<^sub>2;
               h\<^sub>2 ab = \<lfloor>(C, fs)\<rfloor>;
               ?P \<turnstile> C sees M, Static :  Ts\<rightarrow>T = body in D |]
            ==> ?P1.0 (e\<bullet>M(ps)) a aa b
                 (THROW IncompatibleClassChangeError) h\<^sub>2 ls\<^sub>2
                 sh\<^sub>2;
         !!es a aa b es' ab ac ba vs ex es\<^sub>2 C M.
            [| ?P \<turnstile>\<^sub>1 \<langle>es,
  (a, aa, b)\<rangle> [\<Rightarrow>]
 \<langle>es',(ab, ac, ba)\<rangle>;
               ?P2.0 es a aa b es' ab ac ba;
               es' = map Val vs @ throw ex # es\<^sub>2 |]
            ==> ?P1.0 (C\<bullet>\<^sub>sM(es)) a aa b (throw ex) ab ac ba;
         !!ps a aa b vs ab ac ba C M.
            [| ?P \<turnstile>\<^sub>1 \<langle>ps,
  (a, aa, b)\<rangle> [\<Rightarrow>]
 \<langle>map Val vs,(ab, ac, ba)\<rangle>;
               ?P2.0 ps a aa b (map Val vs) ab ac ba;
               \<nexists>b Ts T body. Ex (Method ?P C M b Ts T body) |]
            ==> ?P1.0 (C\<bullet>\<^sub>sM(ps)) a aa b
                 (THROW NoSuchMethodError) ab ac ba;
         !!ps a aa b vs ab ac ba C M Ts T body D.
            [| ?P \<turnstile>\<^sub>1 \<langle>ps,
  (a, aa, b)\<rangle> [\<Rightarrow>]
 \<langle>map Val vs,(ab, ac, ba)\<rangle>;
               ?P2.0 ps a aa b (map Val vs) ab ac ba;
               ?P \<turnstile> C sees M, NonStatic :  Ts\<rightarrow>T = body in D |]
            ==> ?P1.0 (C\<bullet>\<^sub>sM(ps)) a aa b
                 (THROW IncompatibleClassChangeError) ab ac ba;
         !!ps a aa b vs h\<^sub>1 ls\<^sub>1 sh\<^sub>1 C M Ts T body D ab
            ac ad ba.
            [| ?P \<turnstile>\<^sub>1 \<langle>ps,
  (a, aa, b)\<rangle> [\<Rightarrow>]
 \<langle>map Val vs,(h\<^sub>1, ls\<^sub>1, sh\<^sub>1)\<rangle>;
               ?P2.0 ps a aa b (map Val vs) h\<^sub>1 ls\<^sub>1 sh\<^sub>1;
               ?P \<turnstile> C sees M, Static :  Ts\<rightarrow>T = body in D;
               \<nexists>sfs. sh\<^sub>1 D = \<lfloor>(sfs, Done)\<rfloor>;
               M ~= clinit;
               ?P \<turnstile>\<^sub>1 \<langle>INIT D ([D],False) \<leftarrow> unit,
  (h\<^sub>1, ls\<^sub>1, sh\<^sub>1)\<rangle> \<Rightarrow>
 \<langle>throw ab,(ac, ad, ba)\<rangle>;
               ?P1.0 (INIT D ([D],False) \<leftarrow> unit) h\<^sub>1
                ls\<^sub>1 sh\<^sub>1 (throw ab) ac ad ba |]
            ==> ?P1.0 (C\<bullet>\<^sub>sM(ps)) a aa b (throw ab) ac ad ba;
         !!ps a aa b vs h\<^sub>1 ls\<^sub>1 sh\<^sub>1 C M Ts T body D v'
            h\<^sub>2 ls\<^sub>2 sh\<^sub>2 ls\<^sub>2' e' h\<^sub>3
            ls\<^sub>3 sh\<^sub>3.
            [| ?P \<turnstile>\<^sub>1 \<langle>ps,
  (a, aa, b)\<rangle> [\<Rightarrow>]
 \<langle>map Val vs,(h\<^sub>1, ls\<^sub>1, sh\<^sub>1)\<rangle>;
               ?P2.0 ps a aa b (map Val vs) h\<^sub>1 ls\<^sub>1 sh\<^sub>1;
               ?P \<turnstile> C sees M, Static :  Ts\<rightarrow>T = body in D;
               \<nexists>sfs. sh\<^sub>1 D = \<lfloor>(sfs, Done)\<rfloor>;
               M ~= clinit;
               ?P \<turnstile>\<^sub>1 \<langle>INIT D ([D],False) \<leftarrow> unit,
  (h\<^sub>1, ls\<^sub>1, sh\<^sub>1)\<rangle> \<Rightarrow>
 \<langle>Val v',(h\<^sub>2, ls\<^sub>2, sh\<^sub>2)\<rangle>;
               ?P1.0 (INIT D ([D],False) \<leftarrow> unit) h\<^sub>1
                ls\<^sub>1 sh\<^sub>1 (Val v') h\<^sub>2 ls\<^sub>2
                sh\<^sub>2;
               length vs = length Ts;
               ls\<^sub>2' = vs @ replicate (max_vars body) undefined;
               ?P \<turnstile>\<^sub>1 \<langle>body,
  (h\<^sub>2, ls\<^sub>2', sh\<^sub>2)\<rangle> \<Rightarrow>
 \<langle>e',(h\<^sub>3, ls\<^sub>3, sh\<^sub>3)\<rangle>;
               ?P1.0 body h\<^sub>2 ls\<^sub>2' sh\<^sub>2 e' h\<^sub>3
                ls\<^sub>3 sh\<^sub>3 |]
            ==> ?P1.0 (C\<bullet>\<^sub>sM(ps)) a aa b e' h\<^sub>3
                 ls\<^sub>2 sh\<^sub>3;
         !!ps a aa b vs h\<^sub>2 ls\<^sub>2 sh\<^sub>2 C M Ts T body D sfs
            ls\<^sub>2' e' h\<^sub>3 ls\<^sub>3 sh\<^sub>3.
            [| ?P \<turnstile>\<^sub>1 \<langle>ps,
  (a, aa, b)\<rangle> [\<Rightarrow>]
 \<langle>map Val vs,(h\<^sub>2, ls\<^sub>2, sh\<^sub>2)\<rangle>;
               ?P2.0 ps a aa b (map Val vs) h\<^sub>2 ls\<^sub>2 sh\<^sub>2;
               ?P \<turnstile> C sees M, Static :  Ts\<rightarrow>T = body in D;
               sh\<^sub>2 D = \<lfloor>(sfs, Done)\<rfloor> |
               M = clinit &
               sh\<^sub>2 D = \<lfloor>(sfs, Processing)\<rfloor>;
               length vs = length Ts;
               ls\<^sub>2' = vs @ replicate (max_vars body) undefined;
               ?P \<turnstile>\<^sub>1 \<langle>body,
  (h\<^sub>2, ls\<^sub>2', sh\<^sub>2)\<rangle> \<Rightarrow>
 \<langle>e',(h\<^sub>3, ls\<^sub>3, sh\<^sub>3)\<rangle>;
               ?P1.0 body h\<^sub>2 ls\<^sub>2' sh\<^sub>2 e' h\<^sub>3
                ls\<^sub>3 sh\<^sub>3 |]
            ==> ?P1.0 (C\<bullet>\<^sub>sM(ps)) a aa b e' h\<^sub>3
                 ls\<^sub>2 sh\<^sub>3;
         !!e a aa b e' ab ac ba i T.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>e',(ab, ac, ba)\<rangle>;
               ?P1.0 e a aa b e' ab ac ba |]
            ==> ?P1.0 {i:T; e} a aa b e' ab ac ba;
         !!e\<^sub>0 a aa b v ab ac ba e\<^sub>1 e\<^sub>2 ad ae bb.
            [| ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>0,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>Val v,(ab, ac, ba)\<rangle>;
               ?P1.0 e\<^sub>0 a aa b (Val v) ab ac ba;
               ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>1,
  (ab, ac, ba)\<rangle> \<Rightarrow>
 \<langle>e\<^sub>2,(ad, ae, bb)\<rangle>;
               ?P1.0 e\<^sub>1 ab ac ba e\<^sub>2 ad ae bb |]
            ==> ?P1.0 (e\<^sub>0;; e\<^sub>1) a aa b e\<^sub>2 ad ae bb;
         !!e\<^sub>0 a aa b e ab ac ba e\<^sub>1.
            [| ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>0,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>throw e,(ab, ac, ba)\<rangle>;
               ?P1.0 e\<^sub>0 a aa b (throw e) ab ac ba |]
            ==> ?P1.0 (e\<^sub>0;; e\<^sub>1) a aa b (throw e) ab ac ba;
         !!e a aa b ab ac ba e\<^sub>1 e' ad ae bb e\<^sub>2.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>true,(ab, ac, ba)\<rangle>;
               ?P1.0 e a aa b true ab ac ba;
               ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>1,
  (ab, ac, ba)\<rangle> \<Rightarrow>
 \<langle>e',(ad, ae, bb)\<rangle>;
               ?P1.0 e\<^sub>1 ab ac ba e' ad ae bb |]
            ==> ?P1.0 (if (e) e\<^sub>1 else e\<^sub>2) a aa b e' ad ae bb;
         !!e a aa b ab ac ba e\<^sub>2 e' ad ae bb e\<^sub>1.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>false,(ab, ac, ba)\<rangle>;
               ?P1.0 e a aa b false ab ac ba;
               ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>2,
  (ab, ac, ba)\<rangle> \<Rightarrow>
 \<langle>e',(ad, ae, bb)\<rangle>;
               ?P1.0 e\<^sub>2 ab ac ba e' ad ae bb |]
            ==> ?P1.0 (if (e) e\<^sub>1 else e\<^sub>2) a aa b e' ad ae bb;
         !!e a aa b e' ab ac ba e\<^sub>1 e\<^sub>2.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>throw e',(ab, ac, ba)\<rangle>;
               ?P1.0 e a aa b (throw e') ab ac ba |]
            ==> ?P1.0 (if (e) e\<^sub>1 else e\<^sub>2) a aa b (throw e') ab
                 ac ba;
         !!e a aa b ab ac ba c.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>false,(ab, ac, ba)\<rangle>;
               ?P1.0 e a aa b false ab ac ba |]
            ==> ?P1.0 (while (e) c) a aa b unit ab ac ba;
         !!e a aa b ab ac ba c v\<^sub>1 ad ae bb e\<^sub>3 af ag bc.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>true,(ab, ac, ba)\<rangle>;
               ?P1.0 e a aa b true ab ac ba;
               ?P \<turnstile>\<^sub>1 \<langle>c,
  (ab, ac, ba)\<rangle> \<Rightarrow>
 \<langle>Val v\<^sub>1,(ad, ae, bb)\<rangle>;
               ?P1.0 c ab ac ba (Val v\<^sub>1) ad ae bb;
               ?P \<turnstile>\<^sub>1 \<langle>while (e) c,
  (ad, ae, bb)\<rangle> \<Rightarrow>
 \<langle>e\<^sub>3,(af, ag, bc)\<rangle>;
               ?P1.0 (while (e) c) ad ae bb e\<^sub>3 af ag bc |]
            ==> ?P1.0 (while (e) c) a aa b e\<^sub>3 af ag bc;
         !!e a aa b e' ab ac ba c.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>throw e',(ab, ac, ba)\<rangle>;
               ?P1.0 e a aa b (throw e') ab ac ba |]
            ==> ?P1.0 (while (e) c) a aa b (throw e') ab ac ba;
         !!e a aa b ab ac ba c e' ad ae bb.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>true,(ab, ac, ba)\<rangle>;
               ?P1.0 e a aa b true ab ac ba;
               ?P \<turnstile>\<^sub>1 \<langle>c,
  (ab, ac, ba)\<rangle> \<Rightarrow>
 \<langle>throw e',(ad, ae, bb)\<rangle>;
               ?P1.0 c ab ac ba (throw e') ad ae bb |]
            ==> ?P1.0 (while (e) c) a aa b (throw e') ad ae bb;
         !!e a aa b ab ac ad ba.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>addr ab,(ac, ad, ba)\<rangle>;
               ?P1.0 e a aa b (addr ab) ac ad ba |]
            ==> ?P1.0 (throw e) a aa b (Throw ab) ac ad ba;
         !!e a aa b ab ac ba.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>null,(ab, ac, ba)\<rangle>;
               ?P1.0 e a aa b null ab ac ba |]
            ==> ?P1.0 (throw e) a aa b (THROW NullPointer) ab ac ba;
         !!e a aa b e' ab ac ba.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>throw e',(ab, ac, ba)\<rangle>;
               ?P1.0 e a aa b (throw e') ab ac ba |]
            ==> ?P1.0 (throw e) a aa b (throw e') ab ac ba;
         !!e\<^sub>1 a aa b v\<^sub>1 ab ac ba C i e\<^sub>2.
            [| ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>1,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>Val v\<^sub>1,(ab, ac, ba)\<rangle>;
               ?P1.0 e\<^sub>1 a aa b (Val v\<^sub>1) ab ac ba |]
            ==> ?P1.0 (try e\<^sub>1 catch(C i) e\<^sub>2) a aa b
                 (Val v\<^sub>1) ab ac ba;
         !!e\<^sub>1 a aa b ab h\<^sub>1 ls\<^sub>1 sh\<^sub>1 D fs C i
            e\<^sub>2 e\<^sub>2' h\<^sub>2 ls\<^sub>2 sh\<^sub>2.
            [| ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>1,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>Throw ab,(h\<^sub>1, ls\<^sub>1, sh\<^sub>1)\<rangle>;
               ?P1.0 e\<^sub>1 a aa b (Throw ab) h\<^sub>1 ls\<^sub>1
                sh\<^sub>1;
               h\<^sub>1 ab = \<lfloor>(D, fs)\<rfloor>;
               ?P \<turnstile> D \<preceq>\<^sup>* C; i < length ls\<^sub>1;
               ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>2,
  (h\<^sub>1, ls\<^sub>1[i := Addr ab], sh\<^sub>1)\<rangle> \<Rightarrow>
 \<langle>e\<^sub>2',(h\<^sub>2, ls\<^sub>2, sh\<^sub>2)\<rangle>;
               ?P1.0 e\<^sub>2 h\<^sub>1 (ls\<^sub>1[i := Addr ab])
                sh\<^sub>1 e\<^sub>2' h\<^sub>2 ls\<^sub>2 sh\<^sub>2 |]
            ==> ?P1.0 (try e\<^sub>1 catch(C i) e\<^sub>2) a aa b e\<^sub>2'
                 h\<^sub>2 ls\<^sub>2 sh\<^sub>2;
         !!e\<^sub>1 a aa b ab h\<^sub>1 ls\<^sub>1 sh\<^sub>1 D fs C i
            e\<^sub>2.
            [| ?P \<turnstile>\<^sub>1 \<langle>e\<^sub>1,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>Throw ab,(h\<^sub>1, ls\<^sub>1, sh\<^sub>1)\<rangle>;
               ?P1.0 e\<^sub>1 a aa b (Throw ab) h\<^sub>1 ls\<^sub>1
                sh\<^sub>1;
               h\<^sub>1 ab = \<lfloor>(D, fs)\<rfloor>;
               (D, C) ~: (subcls1 ?P)^* |]
            ==> ?P1.0 (try e\<^sub>1 catch(C i) e\<^sub>2) a aa b (Throw ab)
                 h\<^sub>1 ls\<^sub>1 sh\<^sub>1;
         !!a aa b. ?P2.0 [] a aa b [] a aa b;
         !!e a aa b v ab ac ba es es' ad ae bb.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>Val v,(ab, ac, ba)\<rangle>;
               ?P1.0 e a aa b (Val v) ab ac ba;
               ?P \<turnstile>\<^sub>1 \<langle>es,
  (ab, ac, ba)\<rangle> [\<Rightarrow>]
 \<langle>es',(ad, ae, bb)\<rangle>;
               ?P2.0 es ab ac ba es' ad ae bb |]
            ==> ?P2.0 (e # es) a aa b (Val v # es') ad ae bb;
         !!e a aa b e' ab ac ba es.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>throw e',(ab, ac, ba)\<rangle>;
               ?P1.0 e a aa b (throw e') ab ac ba |]
            ==> ?P2.0 (e # es) a aa b (throw e' # es) ab ac ba;
         !!e a aa b e' ab ac ba C bb.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>e',(ab, ac, ba)\<rangle>;
               ?P1.0 e a aa b e' ab ac ba |]
            ==> ?P1.0 (INIT C ([],bb) \<leftarrow> e) a aa b e' ab ac ba;
         !!sh C C' Cs e h l e' a aa b.
            [| sh C = None;
               ?P \<turnstile>\<^sub>1 \<langle>INIT C' (C #
                   Cs,False) \<leftarrow> e,
  (h, l, sh(C |-> (sblank ?P C, Prepared)))\<rangle> \<Rightarrow>
 \<langle>e',(a, aa, b)\<rangle>;
               ?P1.0 (INIT C' (C # Cs,False) \<leftarrow> e) h l
                (sh(C |-> (sblank ?P C, Prepared))) e' a aa b |]
            ==> ?P1.0 (INIT C' (C # Cs,False) \<leftarrow> e) h l sh e' a aa
                 b;
         !!sh C sfs C' Cs e h l e' a aa b.
            [| sh C = \<lfloor>(sfs, Done)\<rfloor>;
               ?P \<turnstile>\<^sub>1 \<langle>INIT C' (Cs,True) \<leftarrow> e,
  (h, l, sh)\<rangle> \<Rightarrow>
 \<langle>e',(a, aa, b)\<rangle>;
               ?P1.0 (INIT C' (Cs,True) \<leftarrow> e) h l sh e' a aa b |]
            ==> ?P1.0 (INIT C' (C # Cs,False) \<leftarrow> e) h l sh e' a aa
                 b;
         !!sh C sfs C' Cs e h l e' a aa b.
            [| sh C = \<lfloor>(sfs, Processing)\<rfloor>;
               ?P \<turnstile>\<^sub>1 \<langle>INIT C' (Cs,True) \<leftarrow> e,
  (h, l, sh)\<rangle> \<Rightarrow>
 \<langle>e',(a, aa, b)\<rangle>;
               ?P1.0 (INIT C' (Cs,True) \<leftarrow> e) h l sh e' a aa b |]
            ==> ?P1.0 (INIT C' (C # Cs,False) \<leftarrow> e) h l sh e' a aa
                 b;
         !!sh C sfs Cs e h l e' a aa b C'.
            [| sh C = \<lfloor>(sfs, Error)\<rfloor>;
               ?P \<turnstile>\<^sub>1 \<langle>RI (C,THROW
                 NoClassDefFoundError) ; Cs \<leftarrow> e,
  (h, l, sh)\<rangle> \<Rightarrow>
 \<langle>e',(a, aa, b)\<rangle>;
               ?P1.0 (RI (C,THROW NoClassDefFoundError) ; Cs \<leftarrow> e)
                h l sh e' a aa b |]
            ==> ?P1.0 (INIT C' (C # Cs,False) \<leftarrow> e) h l sh e' a aa
                 b;
         !!sh C sfs sh' C' Cs e h l e' a aa b.
            [| sh C = \<lfloor>(sfs, Prepared)\<rfloor>; C = Object;
               sh' = sh(C |-> (sfs, Processing));
               ?P \<turnstile>\<^sub>1 \<langle>INIT C' (C #
                   Cs,True) \<leftarrow> e,
  (h, l, sh')\<rangle> \<Rightarrow>
 \<langle>e',(a, aa, b)\<rangle>;
               ?P1.0 (INIT C' (C # Cs,True) \<leftarrow> e) h l sh' e' a aa
                b |]
            ==> ?P1.0 (INIT C' (C # Cs,False) \<leftarrow> e) h l sh e' a aa
                 b;
         !!sh C sfs D a b sh' C' Cs e h l e' aa ab ba.
            [| sh C = \<lfloor>(sfs, Prepared)\<rfloor>; C ~= Object;
               class ?P C = \<lfloor>(D, a, b)\<rfloor>;
               sh' = sh(C |-> (sfs, Processing));
               ?P \<turnstile>\<^sub>1 \<langle>INIT C' (D #
                   C # Cs,False) \<leftarrow> e,
  (h, l, sh')\<rangle> \<Rightarrow>
 \<langle>e',(aa, ab, ba)\<rangle>;
               ?P1.0 (INIT C' (D # C # Cs,False) \<leftarrow> e) h l sh' e'
                aa ab ba |]
            ==> ?P1.0 (INIT C' (C # Cs,False) \<leftarrow> e) h l sh e' aa
                 ab ba;
         !!C Cs e h l sh e' a aa b C'.
            [| ?P \<turnstile>\<^sub>1 \<langle>RI (C,C\<bullet>\<^sub>sclinit([])) ; Cs \<leftarrow> e,
  (h, l, sh)\<rangle> \<Rightarrow>
 \<langle>e',(a, aa, b)\<rangle>;
               ?P1.0
                (RI (C,C\<bullet>\<^sub>sclinit([])) ; Cs \<leftarrow> e) h
                l sh e' a aa b |]
            ==> ?P1.0 (INIT C' (C # Cs,True) \<leftarrow> e) h l sh e' a aa
                 b;
         !!e a aa b v h' l' sh' C sfs i sh'' C' Cs e' e\<^sub>1 ab ac ba.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>Val v,(h', l', sh')\<rangle>;
               ?P1.0 e a aa b (Val v) h' l' sh';
               sh' C = \<lfloor>(sfs, i)\<rfloor>;
               sh'' = sh'(C |-> (sfs, Done)); C' = last (C # Cs);
               ?P \<turnstile>\<^sub>1 \<langle>INIT C' (Cs,True) \<leftarrow> e',
  (h', l', sh'')\<rangle> \<Rightarrow>
 \<langle>e\<^sub>1,(ab, ac, ba)\<rangle>;
               ?P1.0 (INIT C' (Cs,True) \<leftarrow> e') h' l' sh''
                e\<^sub>1 ab ac ba |]
            ==> ?P1.0 (RI (C,e) ; Cs \<leftarrow> e') a aa b e\<^sub>1 ab ac
                 ba;
         !!e a aa b ab h' l' sh' C sfs i sh'' D Cs e' e\<^sub>1 ac ad ba.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>throw ab,(h', l', sh')\<rangle>;
               ?P1.0 e a aa b (throw ab) h' l' sh';
               sh' C = \<lfloor>(sfs, i)\<rfloor>;
               sh'' = sh'(C |-> (sfs, Error));
               ?P \<turnstile>\<^sub>1 \<langle>RI (D,throw
                 ab) ; Cs \<leftarrow> e',
  (h', l', sh'')\<rangle> \<Rightarrow>
 \<langle>e\<^sub>1,(ac, ad, ba)\<rangle>;
               ?P1.0 (RI (D,throw ab) ; Cs \<leftarrow> e') h' l' sh''
                e\<^sub>1 ac ad ba |]
            ==> ?P1.0 (RI (C,e) ; D # Cs \<leftarrow> e') a aa b e\<^sub>1
                 ac ad ba;
         !!e a aa b ab h' l' sh' C sfs i sh'' e'.
            [| ?P \<turnstile>\<^sub>1 \<langle>e,
  (a, aa, b)\<rangle> \<Rightarrow>
 \<langle>throw ab,(h', l', sh')\<rangle>;
               ?P1.0 e a aa b (throw ab) h' l' sh';
               sh' C = \<lfloor>(sfs, i)\<rfloor>;
               sh'' = sh'(C |-> (sfs, Error)) |]
            ==> ?P1.0 (RI (C,e) ; [] \<leftarrow> e') a aa b (throw ab) h'
                 l' sh'' |]
      ==> (?P \<turnstile>\<^sub>1 \<langle>?x1a,
                                    (?x2a, ?x2b,
                                     ?x2c)\<rangle> \<Rightarrow>
                                   \<langle>?x3a,
                                    (?x4a, ?x4b, ?x4c)\<rangle> -->
           ?P1.0 ?x1a ?x2a ?x2b ?x2c ?x3a ?x4a ?x4b ?x4c) &
          (?P \<turnstile>\<^sub>1 \<langle>?x5a,
                                    (?x6a, ?x6b,
                                     ?x6c)\<rangle> [\<Rightarrow>]
                                   \<langle>?x7a,
                                    (?x8a, ?x8b, ?x8c)\<rangle> -->
           ?P2.0 ?x5a ?x6a ?x6b ?x6c ?x7a ?x8a ?x8b ?x8c)",
     template_implication
      ([template_predicate (template_app (template_hole 136, t_empty)),
        template_predicate (template_app (template_hole 136, t_empty)),
        template_predicate (template_app (template_hole 136, t_empty)),
        template_predicate (template_app (template_hole 136, t_empty)),
        template_predicate (template_app (template_hole 136, t_empty)),
        template_predicate (template_app (template_hole 97, t_empty)),
        template_predicate (template_app (template_hole 97, t_empty)),
        template_predicate (template_app (template_hole 97, t_empty)),
        template_predicate (template_app (template_hole 97, t_empty)),
        template_predicate (template_app (template_hole 109, t_empty)),
        template_predicate (template_app (template_hole 97, t_empty)),
        template_predicate (template_app (template_hole 97, t_empty)),
        template_predicate (template_app (template_hole 97, t_empty)),
        template_predicate (template_app (template_hole 130, t_empty)),
        template_predicate (template_app (template_hole 97, t_empty)),
        template_predicate (template_app (template_hole 97, t_empty)),
        template_predicate (template_app (template_hole 97, t_empty)),
        template_predicate (template_app (template_hole 97, t_empty)),
        template_predicate (template_app (template_hole 97, t_empty)),
        template_predicate (template_app (template_hole 97, t_empty)),
        template_predicate (template_app (template_hole 97, t_empty)),
        template_predicate (template_app (template_hole 135, t_empty)),
        template_predicate (template_app (template_hole 135, t_empty)),
        template_predicate (template_app (template_hole 135, t_empty)),
        template_predicate (template_app (template_hole 135, t_empty)),
        template_predicate (template_app (template_hole 135, t_empty)),
        template_predicate (template_app (template_hole 97, t_empty)),
        template_predicate (template_app (template_hole 97, t_empty)),
        template_predicate (template_app (template_hole 97, t_empty)),
        template_predicate (template_app (template_hole 97, t_empty)),
        template_predicate (template_app (template_hole 97, t_empty)),
        template_predicate (template_app (template_hole 97, t_empty)),
        template_predicate (template_app (template_hole 97, t_empty)),
        template_predicate (template_app (template_hole 97, t_empty)),
        template_predicate (template_app (template_hole 97, t_empty)),
        template_predicate (template_app (template_hole 97, t_empty)),
        template_predicate (template_app (template_hole 97, t_empty)),
        template_predicate (template_app (template_hole 97, t_empty)),
        template_predicate (template_app (template_hole 97, t_empty)),
        template_predicate (template_app (template_hole 97, t_empty)),
        template_predicate (template_app (template_hole 97, t_empty)),
        template_predicate (template_app (template_hole 97, t_empty)),
        template_predicate (template_app (template_hole 97, t_empty)),
        template_predicate (template_app (template_hole 97, t_empty)),
        template_predicate (template_app (template_hole 51, t_empty)),
        template_predicate (template_app (template_hole 51, t_empty)),
        template_predicate (template_app (template_hole 51, t_empty)),
        template_predicate (template_app (template_hole 51, t_empty)),
        template_predicate (template_app (template_hole 51, t_empty)),
        template_predicate (template_app (template_hole 51, t_empty)),
        template_predicate (template_app (template_hole 97, t_empty)),
        template_predicate (template_app (template_hole 97, t_empty)),
        template_predicate (template_app (template_hole 97, t_empty)),
        template_predicate (template_app (template_hole 97, t_empty)),
        template_predicate (template_app (template_hole 97, t_empty)),
        template_predicate (template_app (template_hole 97, t_empty)),
        template_predicate (template_app (template_hole 97, t_empty)),
        template_predicate (template_app (template_hole 97, t_empty)),
        template_predicate (template_app (template_hole 97, t_empty)),
        template_predicate (template_app (template_hole 97, t_empty)),
        template_predicate (template_app (template_hole 97, t_empty)),
        template_predicate (template_app (template_hole 97, t_empty)),
        template_predicate (template_app (template_hole 97, t_empty)),
        template_predicate (template_app (template_hole 97, t_empty)),
        template_predicate (template_app (template_hole 97, t_empty)),
        template_predicate (template_app (template_hole 97, t_empty)),
        template_predicate (template_app (template_hole 133, t_empty)),
        template_predicate (template_app (template_hole 97, t_empty)),
        template_predicate (template_app (template_hole 97, t_empty)),
        template_predicate (template_app (template_hole 97, t_empty)),
        template_predicate (template_app (template_hole 136, t_empty)),
        template_predicate (template_app (template_hole 136, t_empty)),
        template_predicate (template_app (template_hole 136, t_empty)),
        template_predicate (template_app (template_hole 136, t_empty)),
        template_predicate (template_app (template_hole 136, t_empty)),
        template_predicate (template_app (template_hole 136, t_empty)),
        template_predicate (template_app (template_hole 135, t_empty)),
        template_predicate (template_app (template_hole 97, t_empty)),
        template_predicate (template_app (template_hole 97, t_empty)),
        template_predicate (template_app (template_hole 97, t_empty))],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 27,
               template_app
                (template_app
                  (template_hole 0,
                   template_app
                    (template_app
                      (template_app
                        (template_app
                          (template_app
                            (template_hole 106, template_var 18),
                           template_var 15),
                         template_app
                          (template_app
                            (template_hole 100, template_var 14),
                           template_app
                            (template_app
                              (template_hole 99, template_var 13),
                             template_var 12))),
                       template_var 11),
                     template_app
                      (template_app (template_hole 100, template_var 10),
                       template_app
                        (template_app (template_hole 99, template_var 9),
                         template_var 8)))),
                 template_app
                  (template_app
                    (template_app
                      (template_app
                        (template_app
                          (template_app
                            (template_app
                              (template_app
                                (template_var 17, template_var 15),
                               template_var 14),
                             template_var 13),
                           template_var 12),
                         template_var 11),
                       template_var 10),
                     template_var 9),
                   template_var 8))),
             template_app
              (template_app
                (template_hole 0,
                 template_app
                  (template_app
                    (template_app
                      (template_app
                        (template_app (template_hole 49, template_var 18),
                         template_var 7),
                       template_app
                        (template_app (template_hole 100, template_var 6),
                         template_app
                          (template_app (template_hole 99, template_var 5),
                           template_var 4))),
                     template_var 3),
                   template_app
                    (template_app (template_hole 100, template_var 2),
                     template_app
                      (template_app (template_hole 99, template_var 1),
                       template_var 0)))),
               template_app
                (template_app
                  (template_app
                    (template_app
                      (template_app
                        (template_app
                          (template_app
                            (template_app (template_var 16, template_var 7),
                             template_var 6),
                           template_var 5),
                         template_var 4),
                       template_var 3),
                     template_var 2),
                   template_var 1),
                 template_var 0)))
           )))]:
   (string * thm * template) list
### theory "Draft.J1MoreTemplates"
### 4.124s elapsed time, 4.379s cpu time, 0.098s GC time
val it = (): unit
