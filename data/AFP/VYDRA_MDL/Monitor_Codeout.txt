Loading theory "Containers.Equal" (required by "Draft.Monitor_CodeMoreTemplates" via "Draft.Monitor_Code" via "Containers.Containers")
Loading theory "Containers.Extend_Partial_Order" (required by "Draft.Monitor_CodeMoreTemplates" via "Draft.Monitor_Code" via "Containers.Containers" via "Containers.Set_Linorder")
Loading theory "Deriving.Comparator" (required by "Draft.Monitor_CodeMoreTemplates" via "Draft.Monitor_Code" via "Containers.Containers" via "Containers.Collection_Order" via "Deriving.Compare_Instances" via "Deriving.Compare_Generator" via "Deriving.Comparator_Generator")
Loading theory "Containers.List_Fusion" (required by "Draft.Monitor_CodeMoreTemplates" via "Draft.Monitor_Code" via "Containers.Containers" via "Containers.Set_Linorder" via "Containers.Lexicographic_Order")
locale equal_base
  fixes equal :: "'a => 'a => bool"
locale Equal.equal
  fixes equal :: "'a => 'a => bool"
  assumes "equal equal"
### theory "Containers.Equal"
### 0.038s elapsed time, 0.185s cpu time, 0.000s GC time
Loading theory "Containers.Closure_Set" (required by "Draft.Monitor_CodeMoreTemplates" via "Draft.Monitor_Code" via "Containers.Containers" via "Containers.Mapping_Impl" via "Containers.Set_Impl")
Proofs for inductive predicate(s) "terminates_onp"
  Proving monotonicity ...
locale equal_base
  fixes equal :: "'a => 'a => bool"
### theory "Containers.Closure_Set"
### 0.040s elapsed time, 0.160s cpu time, 0.000s GC time
Loading theory "Deriving.Derive_Manager" (required by "Draft.Monitor_CodeMoreTemplates" via "Draft.Monitor_Code" via "Containers.Containers" via "Containers.Collection_Order" via "Containers.Containers_Generator")
signature DERIVE_MANAGER =
  sig
    val derive: string -> string -> string -> theory -> theory
    val derive_cmd: string -> string -> string -> theory -> theory
    val print_info: theory -> unit
    val register_derive:
       string ->
         string ->
           (string -> string -> theory -> theory) -> theory -> theory
  end
structure Derive_Manager: DERIVE_MANAGER
### theory "Deriving.Derive_Manager"
### 0.058s elapsed time, 0.218s cpu time, 0.039s GC time
Loading theory "Deriving.Generator_Aux" (required by "Draft.Monitor_CodeMoreTemplates" via "Draft.Monitor_Code" via "Containers.Containers" via "Containers.Collection_Order" via "Containers.Containers_Generator")
### theory "Containers.Extend_Partial_Order"
### 0.153s elapsed time, 0.627s cpu time, 0.039s GC time
Loading theory "HOL-Library.AList" (required by "Draft.Monitor_CodeMoreTemplates" via "Draft.Monitor_Code" via "Containers.Containers" via "Containers.Mapping_Impl" via "Containers.AssocList" via "HOL-Library.DAList")
signature BNF_ACCESS =
  sig
    val bnf_types: Proof.context -> string list -> typ list
    val case_consts: Proof.context -> string list -> term list
    val case_simps: Proof.context -> string list -> thm list list
    val case_thms: Proof.context -> string list -> thm list
    val constr_argument_types:
       Proof.context -> string list -> typ list list list
    val constr_terms: Proof.context -> string -> term list
    val distinct_thms: Proof.context -> string list -> thm list list
    val induct_thms: Proof.context -> string list -> thm list
    val inject_thms: Proof.context -> string list -> thm list list
    val map_comps: Proof.context -> string list -> thm list
    val map_simps: Proof.context -> string list -> thm list list
    val map_terms: Proof.context -> string list -> term list
    val set_simps: Proof.context -> string list -> thm list list
    val set_terms: Proof.context -> string list -> term list list
  end
structure Bnf_Access: BNF_ACCESS
consts
  update :: "'key => 'val => ('key * 'val) list => ('key * 'val) list"
locale list
  fixes g :: "('a, 's) generator"
signature GENERATOR_AUX =
  sig
    val OF_option: thm -> thm option list -> thm
    val add_used_tycos:
       Proof.context -> string -> string list -> string list
    val alist_to_string: (string * 'a) list -> string
    val conjI_tac:
       thm list ->
         Proof.context ->
           'a list -> (Proof.context -> int -> tactic) -> tactic
    val create_map:
       (typ -> term) ->
         (string * typ -> 'a -> term) ->
           'a ->
             (typ -> bool) ->
               (local_theory -> string -> bool list) ->
                 (local_theory -> string -> term) ->
                   (local_theory -> string -> 'a -> term) ->
                     string list ->
                       (local_theory -> string -> 'a) ->
                         typ -> local_theory -> term
    val create_partial:
       'a ->
         (typ -> bool) ->
           (local_theory -> string -> bool list) ->
             (local_theory -> string -> term) ->
               (local_theory -> string -> 'a -> term) ->
                 string list ->
                   (local_theory -> string -> 'a) ->
                     typ -> local_theory -> term
    val define_overloaded:
       string * term -> local_theory -> thm * local_theory
    val define_overloaded_generic:
       Attrib.binding * term -> local_theory -> thm * local_theory
    val drop_last: 'a list -> 'a list
    val freeify_tvars: typ -> typ
    val ind_case_to_idxs: 'a list list -> int -> int * int
    val infer_type: Proof.context -> term -> term
    val ints_to_subscript: int list -> string
    val is_class_instance: theory -> string -> sort -> bool
    val lambdas: term list -> term -> term
    val mk_case_tac:
       Proof.context ->
         term option list list ->
           thm ->
             (int ->
                Proof.context * thm list * (string * cterm) list -> tactic)
               -> tactic
    val mk_def: typ -> string -> term -> term
    val mk_id: typ -> term
    val mk_infer_const: string -> Proof.context -> term -> term
    val mutual_recursive_types:
       string -> Proof.context -> string list * typ list
    val prove_multi_future:
       Proof.context ->
         string list ->
           term list ->
             term list ->
               ({context: Proof.context, prems: thm list} -> tactic) ->
                 thm list
    val recursor:
       (string -> 'a) * ('a -> bool list) * string list ->
         bool ->
           (typ -> 'b) ->
             (typ -> 'b) ->
               (typ -> 'b) ->
                 ((typ * 'b option) list * 'a -> 'b) -> typ -> 'b
    val rename_types: (typ * typ) list -> term -> term
    val split_IHs:
       (string -> 'a) * ('a -> bool list) * string list ->
         typ list -> thm list -> thm list list
    val std_recursor_tac:
       (string -> 'a) * ('a -> bool list) * string list ->
         typ list ->
           ('a -> thm) ->
             thm list -> typ -> thm list -> Proof.context -> tactic
    val sub: string -> string
    val subT: string -> typ -> string
    val typ_and_vs_of_typname:
       theory -> string -> sort -> typ * (string * sort) list
    val typ_and_vs_of_used_typname:
       string ->
         bool list -> string list -> typ * (string * string list) list
    val type_parameters:
       typ -> Proof.context -> (string * sort) list * typ list
  end
structure Generator_Aux: GENERATOR_AUX
### theory "Deriving.Generator_Aux"
### 0.155s elapsed time, 0.610s cpu time, 0.068s GC time
Loading theory "Deriving.Equality_Generator" (required by "Draft.Monitor_CodeMoreTemplates" via "Draft.Monitor_Code" via "Containers.Containers" via "Containers.Collection_Eq" via "Deriving.Equality_Instances")
consts
  list_has_next :: "'a list => bool"
### No equation for constructor "[]"
consts
  list_next :: "'a list => 'a * 'a list"
consts
  update_with_aux ::
    "'val
     => 'key => ('val => 'val) => ('key * 'val) list => ('key * 'val) list"
Found termination order: "{}"
locale comparator
  fixes comp :: "'a => 'a => order"
  assumes "comparator comp"
Found termination order: "(%p. size_list size (snd p)) <*mlex*> {}"
Found termination order: "{}"
signature EQUALITY_GENERATOR =
  sig
    val ensure_info: equality_type -> string -> local_theory -> local_theory
    datatype equality_type = BNF | EQ
    val generate_equality:
       equality_type -> string -> local_theory -> local_theory
    val generate_equalitys_from_bnf_fp:
       string ->
         local_theory ->
           ((term * thm list) list * (term * thm) list) * local_theory
    val get_info: Proof.context -> string -> info option
    type info =
       {equality: term,
        equality_def: thm option,
        equality_thm: thm,
        map: term,
        map_comp: thm option,
        partial_equality_thm: thm,
        pequality: term, used_positions: bool list}
    val register_equality_of: string -> local_theory -> local_theory
    val register_foreign_equality:
       typ -> term -> thm -> local_theory -> local_theory
    val register_foreign_partial_and_full_equality:
       string ->
         term ->
           term ->
             term ->
               thm option ->
                 thm option ->
                   thm -> thm -> bool list -> local_theory -> local_theory
  end
structure Equality_Generator: EQUALITY_GENERATOR
### theory "Deriving.Equality_Generator"
### 0.289s elapsed time, 1.129s cpu time, 0.105s GC time
Loading theory "Deriving.Equality_Instances" (required by "Draft.Monitor_CodeMoreTemplates" via "Draft.Monitor_Code" via "Containers.Containers" via "Containers.Collection_Eq")
Found termination order: "case_sum (%x. Suc 0) (%x. 0) <*mlex*> {}"
generating equality for type "Sum_Type.sum"
generating equality for type "List.list"
generating equality for type "Product_Type.prod"
generating equality for type "Option.option"
### theory "Deriving.Equality_Instances"
### 0.095s elapsed time, 0.383s cpu time, 0.000s GC time
Loading theory "HOL-Library.Adhoc_Overloading" (required by "Draft.Monitor_CodeMoreTemplates" via "Draft.Monitor_Code" via "Containers.Containers" via "Containers.Set_Linorder" via "Containers.Containers_Auxiliary" via "HOL-Library.Monad_Syntax")
### theory "Deriving.Comparator"
### 0.688s elapsed time, 2.733s cpu time, 0.212s GC time
Loading theory "Deriving.Compare" (required by "Draft.Monitor_CodeMoreTemplates" via "Draft.Monitor_Code" via "Containers.Containers" via "Containers.Collection_Order" via "Deriving.Compare_Instances" via "Deriving.Compare_Generator")
Proofs for inductive predicate(s) "filter_has_next"
class compare = type +
  fixes compare :: "'a => 'a => order"
  assumes "comparator_compare": "comparator compare"
signature ADHOC_OVERLOADING =
  sig
    val generic_add_overloaded: string -> Context.generic -> Context.generic
    val generic_add_variant:
       string -> term -> Context.generic -> Context.generic
    val generic_remove_overloaded:
       string -> Context.generic -> Context.generic
    val generic_remove_variant:
       string -> term -> Context.generic -> Context.generic
    val is_overloaded: Proof.context -> string -> bool
    val show_variants: bool Config.T
  end
structure Adhoc_Overloading: ADHOC_OVERLOADING
  Proving monotonicity ...
### theory "HOL-Library.Adhoc_Overloading"
### 0.099s elapsed time, 0.388s cpu time, 0.050s GC time
Loading theory "Deriving.Comparator_Generator" (required by "Draft.Monitor_CodeMoreTemplates" via "Draft.Monitor_Code" via "Containers.Containers" via "Containers.Collection_Order" via "Deriving.Compare_Instances" via "Deriving.Compare_Generator")
class compare_order = compare + ord +
  assumes "ord_defs": "le_of_comp compare = (<=)" "lt_of_comp compare = (<)"
### theory "Containers.List_Fusion"
### 0.944s elapsed time, 3.730s cpu time, 0.308s GC time
Loading theory "HOL-Library.Monad_Syntax" (required by "Draft.Monitor_CodeMoreTemplates" via "Draft.Monitor_Code" via "Containers.Containers" via "Containers.Set_Linorder" via "Containers.Containers_Auxiliary")
### theory "HOL-Library.Monad_Syntax"
### 0.037s elapsed time, 0.145s cpu time, 0.000s GC time
Loading theory "Containers.Containers_Auxiliary" (required by "Draft.Monitor_CodeMoreTemplates" via "Draft.Monitor_Code" via "Containers.Containers" via "Containers.Set_Linorder")
Found termination order: "(%p. size_list size (snd (snd p))) <*mlex*> {}"
Found termination order: "size_list size <*mlex*> {}"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
### Dropping global mixfix syntax: "less_eq_prod" (infix \<open>\<sqsubseteq>\<close> 50)
### Dropping global mixfix syntax: "less_prod" (infix \<open>\<sqsubset>\<close> 50)
Found termination order:
  "(%p. size_list size (snd (snd (snd p)))) <*mlex*> {}"
### Dropping global mixfix syntax: "less_eq_prod'" (infix \<open>\<sqsubseteq>\<close> 50)
### theory "HOL-Library.AList"
### 1.058s elapsed time, 4.167s cpu time, 0.334s GC time
Loading theory "HOL-Library.DAList" (required by "Draft.Monitor_CodeMoreTemplates" via "Draft.Monitor_Code" via "Containers.Containers" via "Containers.Mapping_Impl" via "Containers.AssocList")
### Dropping global mixfix syntax: "less_prod'" (infix \<open>\<sqsubset>\<close> 50)
### theory "Containers.Containers_Auxiliary"
### 0.415s elapsed time, 1.503s cpu time, 0.557s GC time
Loading theory "HOL-Library.Char_ord" (required by "Draft.Monitor_CodeMoreTemplates" via "Draft.Monitor_Code" via "Containers.Containers" via "Containers.Set_Linorder" via "Containers.Lexicographic_Order")
instantiation
  char :: linorder
  less_eq_char == less_eq :: char => char => bool
  less_char == less :: char => char => bool
instantiation
  char :: distrib_lattice
  inf_char == inf :: char => char => char
  sup_char == sup :: char => char => char
### theory "HOL-Library.Char_ord"
### 0.090s elapsed time, 0.337s cpu time, 0.027s GC time
Loading theory "Containers.Lexicographic_Order" (required by "Draft.Monitor_CodeMoreTemplates" via "Draft.Monitor_Code" via "Containers.Containers" via "Containers.Set_Linorder")
class compare_order = compare + linorder +
  assumes "ord_defs": "le_of_comp compare = (<=)" "lt_of_comp compare = (<)"
signature COMPARE_CODE =
  sig
    val change_compare_code:
       term -> string list -> local_theory -> local_theory
  end
structure Compare_Code: COMPARE_CODE
### theory "Deriving.Compare"
### 0.853s elapsed time, 3.222s cpu time, 0.680s GC time
Loading theory "HOL-Library.Code_Abstract_Nat" (required by "Draft.Monitor_CodeMoreTemplates" via "Draft.Monitor_Code" via "HOL-Library.Code_Target_Nat")
signature COMPARATOR_GENERATOR =
  sig
    datatype comparator_type = BNF | Linorder
    val ensure_info:
       comparator_type -> string -> local_theory -> local_theory
    val generate_comparator:
       comparator_type -> string -> local_theory -> local_theory
    val generate_comparators_from_bnf_fp:
       string ->
         local_theory ->
           ((term * thm list) list * (term * thm) list) * local_theory
    val get_info: Proof.context -> string -> info option
    type info =
       {comp: term,
        comp_def: thm option,
        comp_thm: thm,
        map: term,
        map_comp: thm option,
        partial_comp_thms: thm list, pcomp: term, used_positions: bool list}
    val register_comparator_of: string -> local_theory -> local_theory
    val register_foreign_comparator:
       typ -> term -> thm -> local_theory -> local_theory
    val register_foreign_partial_and_full_comparator:
       string ->
         term ->
           term ->
             term ->
               thm option ->
                 thm option ->
                   thm ->
                     thm ->
                       thm ->
                         thm -> bool list -> local_theory -> local_theory
  end
structure Comparator_Generator: COMPARATOR_GENERATOR
### theory "Deriving.Comparator_Generator"
### 0.779s elapsed time, 2.936s cpu time, 0.629s GC time
Loading theory "Deriving.Compare_Generator" (required by "Draft.Monitor_CodeMoreTemplates" via "Draft.Monitor_Code" via "Containers.Containers" via "Containers.Collection_Order" via "Deriving.Compare_Instances")
### theory "HOL-Library.Code_Abstract_Nat"
### 0.071s elapsed time, 0.287s cpu time, 0.000s GC time
Loading theory "HOL-Library.Code_Target_Nat" (required by "Draft.Monitor_CodeMoreTemplates" via "Draft.Monitor_Code")
instantiation
  alist :: (equal, equal) equal
  equal_alist == equal_class.equal ::
    ('a, 'b) alist => ('a, 'b) alist => bool
instantiation
  alist :: (type, type) size
  size_alist == size :: ('a, 'b) alist => nat
### Code generator: dropping subsumed code equation
### divmod_nat ?m ?n ==
### if ?n = 0 | ?m < ?n then (0, ?m)
### else let (q, y) = divmod_nat (?m - ?n) ?n in (Suc q, y)
### Code generator: dropping subsumed code equation
### divmod (num.Bit1 ?m) (num.Bit1 ?n) ==
### if ?m < ?n then (0, numeral (num.Bit1 ?m))
### else divmod_step (num.Bit1 ?n)
###       (divmod (num.Bit1 ?m) (num.Bit0 (num.Bit1 ?n)))
### Code generator: dropping subsumed code equation
### divmod (num.Bit0 ?m) (num.Bit1 ?n) ==
### if ?m <= ?n then (0, numeral (num.Bit0 ?m))
### else divmod_step (num.Bit1 ?n)
###       (divmod (num.Bit0 ?m) (num.Bit0 (num.Bit1 ?n)))
### Code generator: dropping subsumed code equation
### divmod (num.Bit1 ?m) (num.Bit0 ?n) ==
### case divmod ?m ?n of (q, r) => (q, 2 * r + 1)
### Code generator: dropping subsumed code equation
### divmod (num.Bit0 ?m) (num.Bit0 ?n) ==
### case divmod ?m ?n of (q, r) => (q, 2 * r)
### Code generator: dropping subsumed code equation
### divmod num.One (num.Bit1 ?n) == (0, Numeral1)
### Code generator: dropping subsumed code equation
### divmod num.One (num.Bit0 ?n) == (0, Numeral1)
### Code generator: dropping subsumed code equation
### divmod ?m num.One == (numeral ?m, 0)
### Code generator: dropping subsumed code equation
### Suc ?m <= ?n == ?m < ?n
### Code generator: dropping subsumed code equation
### 0 <= ?n == True
### Code generator: dropping subsumed code equation
### ?m < Suc ?n == ?m <= ?n
### Code generator: dropping subsumed code equation
### ?n < 0 == False
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
### Code generator: dropping subsumed code equation
### of_nat ?n == semiring_1_class.of_nat_aux (%i. i + (1::?'a)) ?n (0::?'a)
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
### theory "HOL-Library.Code_Target_Nat"
### 0.157s elapsed time, 0.618s cpu time, 0.036s GC time
Loading theory "HOL-Library.Function_Algebras" (required by "Draft.Monitor_CodeMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
### Additional type variable(s) in specification of "random_aux_alist_rel": 'a, 'b
### theory "Containers.Lexicographic_Order"
### 0.299s elapsed time, 1.174s cpu time, 0.036s GC time
Loading theory "HOL-Library.IArray" (required by "Draft.Monitor_CodeMoreTemplates" via "Draft.Monitor_Code" via "Draft.Monitor" via "Draft.Temporal" via "Draft.NFA")
instantiation
  fun :: (type, plus) plus
  plus_fun == plus :: ('a => 'b) => ('a => 'b) => 'a => 'b
### Additional type variable(s) in specification of "random_aux_alist_dom": 'a, 'b
instantiation
  fun :: (type, zero) zero
  zero_fun == zero_class.zero :: 'a => 'b
instantiation
  fun :: (type, times) times
  times_fun == times :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  fun :: (type, one) one
  one_fun == one_class.one :: 'a => 'b
Found termination order: "(%p. nat_of_natural (fst p)) <*mlex*> {}"
instantiation
  alist :: (random, random) random
  random_alist == random_class.random ::
    natural
    => natural * natural
       => (('a, 'b) alist * (unit => term)) * natural * natural
instantiation
  alist :: (exhaustive, exhaustive) exhaustive
  exhaustive_alist == exhaustive_class.exhaustive ::
    (('a, 'b) alist => (bool * term list) option)
    => natural => (bool * term list) option
### theory "HOL-Library.Function_Algebras"
### 0.133s elapsed time, 0.519s cpu time, 0.062s GC time
Loading theory "HOL-Library.Infinite_Set" (required by "Draft.Monitor_CodeMoreTemplates" via "Draft.Monitor_Code" via "Draft.Monitor" via "Draft.MDL" via "Draft.Interval" via "Draft.Timestamp" via "HOL-Library.Extended_Nat" via "HOL-Library.Order_Continuity" via "HOL-Library.Countable_Complete_Lattices" via "HOL-Library.Countable_Set")
signature COMPARE_GENERATOR =
  sig
    val compare_instance:
       Comparator_Generator.comparator_type -> string -> theory -> theory
    val compare_order_instance_via_comparator_of: string -> theory -> theory
    val compare_order_instance_via_compare: string -> theory -> theory
  end
structure Compare_Generator: COMPARE_GENERATOR
### theory "Deriving.Compare_Generator"
### 0.354s elapsed time, 1.387s cpu time, 0.098s GC time
Loading theory "Deriving.Compare_Instances" (required by "Draft.Monitor_CodeMoreTemplates" via "Draft.Monitor_Code" via "Containers.Containers" via "Containers.Collection_Order")
Found termination order: "(%p. nat_of_natural (snd p)) <*mlex*> {}"
instantiation
  alist :: (full_exhaustive, full_exhaustive) full_exhaustive
  full_exhaustive_alist == full_exhaustive_class.full_exhaustive ::
    (('a, 'b) alist * (unit => term) => (bool * term list) option)
    => natural => (bool * term list) option
Found termination order: "(%p. nat_of_natural (snd p)) <*mlex*> {}"
deriving "compare_order" instance for type "Int.int"
deriving "compare" instance for type "Int.int"
consts
  enumerate :: "'a set => nat => 'a"
deriving "compare_order" instance for type "Code_Numeral.integer"
deriving "compare" instance for type "Code_Numeral.integer"
deriving "compare_order" instance for type "Nat.nat"
deriving "compare" instance for type "Nat.nat"
deriving "compare_order" instance for type "String.char"
deriving "compare" instance for type "String.char"
deriving "compare" instance for type "Sum_Type.sum"
generating comparator for type "Sum_Type.sum"
deriving "compare" instance for type "List.list"
generating comparator for type "List.list"
### theory "HOL-Library.DAList"
### 0.972s elapsed time, 3.692s cpu time, 0.690s GC time
Loading theory "Containers.AssocList" (required by "Draft.Monitor_CodeMoreTemplates" via "Draft.Monitor_Code" via "Containers.Containers" via "Containers.Mapping_Impl")
deriving "compare" instance for type "Product_Type.prod"
generating comparator for type "Product_Type.prod"
### theory "HOL-Library.Infinite_Set"
### 0.298s elapsed time, 1.187s cpu time, 0.073s GC time
Loading theory "HOL-Library.Mapping" (required by "Draft.Monitor_CodeMoreTemplates" via "Draft.Monitor_Code" via "Containers.Containers" via "Containers.Mapping_Impl")
consts
  list_of :: "'a iarray => 'a list"
deriving "compare" instance for type "Option.option"
generating comparator for type "Option.option"
consts
  update_with_aux ::
    "'val
     => 'key => ('val => 'val) => ('key * 'val) list => ('key * 'val) list"
Found termination order: "{}"
consts
  tabulate :: "integer * (integer => 'a) => 'a iarray"
consts
  sub' :: "'a iarray * integer => 'a"
Found termination order: "(%p. size_list size (snd p)) <*mlex*> {}"
### theory "HOL-Library.IArray"
### 0.554s elapsed time, 2.184s cpu time, 0.212s GC time
Loading theory "Draft.NFA" (required by "Draft.Monitor_CodeMoreTemplates" via "Draft.Monitor_Code" via "Draft.Monitor" via "Draft.Temporal")
Found termination order: "{}"
deriving "compare" instance for type "HOL.bool"
deriving "compare" instance for type "Product_Type.unit"
deriving "compare_order" instance for type "HOL.bool"
deriving "compare_order" instance for type "Product_Type.unit"
### theory "Deriving.Compare_Instances"
### 0.503s elapsed time, 1.986s cpu time, 0.207s GC time
Loading theory "HOL-Library.Nat_Bijection" (required by "Draft.Monitor_CodeMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.Stream")
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
### theory "Containers.AssocList"
### 0.358s elapsed time, 1.404s cpu time, 0.134s GC time
Loading theory "HOL-Library.Old_Datatype" (required by "Draft.Monitor_CodeMoreTemplates" via "Draft.Monitor_Code" via "Draft.Monitor" via "Draft.MDL" via "Draft.Interval" via "Draft.Timestamp" via "HOL-Library.Extended_Nat" via "HOL-Library.Countable")
Found termination order: "size_list size <*mlex*> {}"
### theory "HOL-Library.Nat_Bijection"
### 0.332s elapsed time, 1.306s cpu time, 0.108s GC time
Loading theory "HOL-Library.Stream" (required by "Draft.Monitor_CodeMoreTemplates" via "Draft.ExtrEqs")
instantiation
  mapping :: (type, type) equal
  equal_mapping == equal_class.equal ::
    ('a, 'b) mapping => ('a, 'b) mapping => bool
Found termination order: "{}"
Found termination order: "{}"
signature OLD_DATATYPE =
  sig
    val check_specs: spec list -> theory -> spec list * Proof.context
    type config = {quiet: bool, strict: bool}
    val default_config: config
    type descr =
       (int * (string * dtyp list * (string * dtyp list) list)) list
    val distinct_lemma: thm
    datatype dtyp
    = DtRec of int | DtTFree of string * sort | DtType of string * dtyp list
    type info =
       {case_cong: thm,
        case_cong_weak: thm,
        case_name: string,
        case_rewrites: thm list,
        descr: descr,
        distinct: thm list,
        exhaust: thm,
        index: int,
        induct: thm,
        inducts: thm list,
        inject: thm list,
        nchotomy: thm,
        rec_names: string list,
        rec_rewrites: thm list, split: thm, split_asm: thm}
    val read_specs: spec_cmd list -> theory -> spec list * Proof.context
    type spec =
       (binding * (string * sort) list * mixfix) *
       (binding * typ list * mixfix) list
    type spec_cmd =
       (binding * (string * string option) list * mixfix) *
       (binding * string list * mixfix) list
  end
structure Old_Datatype: OLD_DATATYPE
### theory "HOL-Library.Old_Datatype"
### 0.436s elapsed time, 1.707s cpu time, 0.170s GC time
Loading theory "HOL-Library.Phantom_Type" (required by "Draft.Monitor_CodeMoreTemplates" via "Draft.Monitor_Code" via "Containers.Containers" via "Containers.Set_Linorder" via "HOL-Library.Cardinality")
locale combine_mapping_abel_semigroup
  fixes f :: "'a => 'a => 'a"  (infixl \<open>\<^bold>*\<close> 70)
  assumes "combine_mapping_abel_semigroup (\<^bold>*)"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
consts
  shift :: "'a list => 'a stream => 'a stream"
Proofs for coinductive predicate(s) "streamsp"
  Proving monotonicity ...
locale nfa_array
  fixes transs :: "transition list"
    and transs' :: "transition iarray"
    and len :: "nat"
  assumes "nfa_array transs transs' len"
consts
  snth :: "'a stream => nat => 'a"
consts
  stake :: "nat => 'a stream => 'a list"
consts
  sdrop :: "nat => 'a stream => 'a stream"
locale nfa
  fixes q0 :: "nat"
    and qf :: "nat"
    and transs :: "transition list"
  assumes "nfa q0 qf transs"
### theory "HOL-Library.Mapping"
### 1.134s elapsed time, 4.447s cpu time, 0.454s GC time
Loading theory "HOL-Library.Product_Lexorder" (required by "Draft.Monitor_CodeMoreTemplates" via "Draft.Monitor_Code" via "Draft.Monitor" via "Draft.MDL" via "Draft.Interval")
instantiation
  prod :: (ord, ord) ord
  less_eq_prod == less_eq :: 'a * 'b => 'a * 'b => bool
  less_prod == less :: 'a * 'b => 'a * 'b => bool
consts
  sfilter :: "('a => bool) => 'a stream => 'a stream"
instantiation
  prod :: (linorder, linorder) distrib_lattice
  inf_prod == inf :: 'a * 'b => 'a * 'b => 'a * 'b
  sup_prod == sup :: 'a * 'b => 'a * 'b => 'a * 'b
locale nfa_cong
  fixes q0 :: "nat"
    and q0' :: "nat"
    and qf :: "nat"
    and qf' :: "nat"
    and transs :: "transition list"
    and transs' :: "transition list"
  assumes "nfa_cong q0 q0' qf qf' transs transs'"
consts
  cycle :: "'a list => 'a stream"
instantiation
  prod :: (bot, bot) bot
  bot_prod == bot :: 'a * 'b
instantiation
  prod :: (top, top) top
  top_prod == top :: 'a * 'b
### theory "HOL-Library.Product_Lexorder"
### 0.120s elapsed time, 0.463s cpu time, 0.078s GC time
Loading theory "HOL-Library.RBT_Impl" (required by "Draft.Monitor_CodeMoreTemplates" via "Draft.Monitor_Code" via "Containers.Containers" via "Containers.Mapping_Impl" via "Containers.RBT_Mapping2" via "Containers.RBT_ext")
consts
  siterate :: "('a => 'a) => 'a => 'a stream"
Found termination order: "length <*mlex*> {}"
consts
  flat :: "'a list stream => 'a stream"
locale nfa_cong'
  fixes q0 :: "nat"
    and q0' :: "nat"
    and qf :: "nat"
    and qf' :: "nat"
    and transs :: "transition list"
    and transs' :: "transition list"
  assumes "nfa_cong' q0 q0' qf qf' transs transs'"
### theory "HOL-Library.Phantom_Type"
### 0.917s elapsed time, 3.436s cpu time, 1.360s GC time
Loading theory "Containers.Containers_Generator" (required by "Draft.Monitor_CodeMoreTemplates" via "Draft.Monitor_Code" via "Containers.Containers" via "Containers.Collection_Order")
consts
  sinterleave :: "'a stream => 'a stream => 'a stream"
consts
  szip :: "'a stream => 'b stream => ('a * 'b) stream"
consts
  smap2 :: "('a => 'b => 'c) => 'a stream => 'b stream => 'c stream"
locale nfa_cong_Plus
  fixes q0 :: "nat"
    and q0' :: "nat"
    and q0'' :: "nat"
    and qf :: "nat"
    and qf' :: "nat"
    and qf'' :: "nat"
    and transs :: "transition list"
    and transs' :: "transition list"
    and transs'' :: "transition list"
  assumes "nfa_cong_Plus q0 q0' q0'' qf qf' qf'' transs transs' transs''"
### theory "HOL-Library.Stream"
### 1.280s elapsed time, 4.858s cpu time, 1.476s GC time
Loading theory "HOL-Library.Cardinality" (required by "Draft.Monitor_CodeMoreTemplates" via "Draft.Monitor_Code" via "Containers.Containers" via "Containers.Set_Linorder")
locale nfa_cong_Times
  fixes q0 :: "nat"
    and q0' :: "nat"
    and qf :: "nat"
    and transs :: "transition list"
    and transs' :: "transition list"
    and transs'' :: "transition list"
  assumes "nfa_cong_Times q0 q0' qf transs transs' transs''"
### Additional type variable(s) in locale specification "CARD_1": 'a
locale nfa_cong_Star
  fixes q0 :: "nat"
    and q0' :: "nat"
    and qf :: "nat"
    and transs :: "transition list"
    and transs' :: "transition list"
  assumes "nfa_cong_Star q0 q0' qf transs transs'"
### theory "Draft.NFA"
### 1.782s elapsed time, 6.829s cpu time, 1.698s GC time
Loading theory "HOL-Library.Set_Algebras" (required by "Draft.Monitor_CodeMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
class CARD_1 = type +
  assumes "CARD_1": "CARD('a) = 1"
instantiation
  set :: (plus) plus
  plus_set == plus :: 'a set => 'a set => 'a set
instantiation
  set :: (times) times
  times_set == times :: 'a set => 'a set => 'a set
instantiation
  set :: (zero) zero
  zero_set == zero_class.zero :: 'a set
instantiation
  set :: (one) one
  one_set == one_class.one :: 'a set
### Additional type variable(s) in locale specification "card2": 'a
class card2 = finite +
  assumes "two_le_card": "2 <= CARD('a)"
signature CONTAINERS_GENERATOR =
  sig
    val HOLogic_list_conj: term list -> term
    val all_tys: term -> typ list -> term -> term
    val derive_is_c_dots_lemma:
       typ -> string -> thm list -> string -> theory -> theory
    val derive_none:
       string -> sort -> (typ -> term) -> string -> theory -> theory
    val derive_set_map_impl:
       string ->
         sort ->
           (string * term) list -> string -> string -> theory -> theory
    val is_class_instance: theory -> string -> sort -> bool
    val mk_Some: term -> term
    val mk_is_c_dots: typ -> string -> term
    val register_is_c_dots_lemma:
       string -> string -> thm -> theory -> theory
  end
structure Containers_Generator: CONTAINERS_GENERATOR
### theory "Containers.Containers_Generator"
### 0.425s elapsed time, 1.677s cpu time, 0.130s GC time
Loading theory "Containers.Collection_Enum" (required by "Draft.Monitor_CodeMoreTemplates" via "Draft.Monitor_Code" via "Containers.Containers")
### theory "HOL-Library.Set_Algebras"
### 0.219s elapsed time, 0.870s cpu time, 0.072s GC time
Loading theory "Containers.Collection_Eq" (required by "Draft.Monitor_CodeMoreTemplates" via "Draft.Monitor_Code" via "Containers.Containers")
class finite_UNIV = type +
  fixes finite_UNIV :: "('a, bool) phantom"
  assumes "finite_UNIV": "finite_UNIV = Phantom('a) (finite UNIV)"
class card_UNIV = finite_UNIV +
  fixes card_UNIV :: "('a, nat) phantom"
  assumes "card_UNIV": "card_UNIV_class.card_UNIV = Phantom('a) CARD('a)"
class cenum = type +
  fixes
    cEnum ::
      "('a list * (('a => bool) => bool) * (('a => bool) => bool)) option"
  assumes
    "UNIV_cenum":
      "!!enum enum_all enum_ex.
          cEnum = Some (enum, enum_all, enum_ex) ==> UNIV = set enum"
    and
    "cenum_all_UNIV":
      "!!enum enum_all enum_ex P.
          cEnum = Some (enum, enum_all, enum_ex) ==>
          enum_all P = Ball UNIV P"
    and
    "cenum_ex_UNIV":
      "!!enum enum_all enum_ex P.
          cEnum = Some (enum, enum_all, enum_ex) ==> enum_ex P = Bex UNIV P"
instantiation
  nat :: card_UNIV
  card_UNIV_nat == card_UNIV_class.card_UNIV :: (nat, nat) phantom
  finite_UNIV_nat == finite_UNIV :: (nat, bool) phantom
instantiation
  int :: card_UNIV
  card_UNIV_int == card_UNIV_class.card_UNIV :: (int, nat) phantom
  finite_UNIV_int == finite_UNIV :: (int, bool) phantom
instantiation
  natural :: card_UNIV
  card_UNIV_natural == card_UNIV_class.card_UNIV :: (natural, nat) phantom
  finite_UNIV_natural == finite_UNIV :: (natural, bool) phantom
signature CENUM_GENERATOR =
  sig val derive_no_cenum: string -> theory -> theory end
structure Cenum_Generator: CENUM_GENERATOR
instantiation
  integer :: card_UNIV
  card_UNIV_integer == card_UNIV_class.card_UNIV :: (integer, nat) phantom
  finite_UNIV_integer == finite_UNIV :: (integer, bool) phantom
instantiation
  list :: (type) card_UNIV
  card_UNIV_list == card_UNIV_class.card_UNIV :: ('a list, nat) phantom
  finite_UNIV_list == finite_UNIV :: ('a list, bool) phantom
instantiation
  unit :: card_UNIV
  card_UNIV_unit == card_UNIV_class.card_UNIV :: (unit, nat) phantom
  finite_UNIV_unit == finite_UNIV :: (unit, bool) phantom
instantiation
  bool :: card_UNIV
  card_UNIV_bool == card_UNIV_class.card_UNIV :: (bool, nat) phantom
  finite_UNIV_bool == finite_UNIV :: (bool, bool) phantom
### Rewrite rule not in simpset:
### Wellfounded.accp all_n_lists_rel (?P1, ?n1) ==>
### all_n_lists ?P1 ?n1 ==
### if ?n1 = 0 then ?P1 []
### else cenum_all (%x. all_n_lists (%xs. ?P1 (x # xs)) (?n1 - 1))
instantiation
  char :: card_UNIV
  card_UNIV_char == card_UNIV_class.card_UNIV :: (char, nat) phantom
  finite_UNIV_char == finite_UNIV :: (char, bool) phantom
class ceq = type +
  fixes ceq :: "('a => 'a => bool) option"
  assumes "ceq": "!!eqa. ceq = Some eqa ==> eqa = (=)"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
instantiation
  prod :: (finite_UNIV, finite_UNIV) finite_UNIV
  finite_UNIV_prod == finite_UNIV :: ('a * 'b, bool) phantom
instantiation
  prod :: (card_UNIV, card_UNIV) card_UNIV
  card_UNIV_prod == card_UNIV_class.card_UNIV :: ('a * 'b, nat) phantom
instantiation
  sum :: (finite_UNIV, finite_UNIV) finite_UNIV
  finite_UNIV_sum == finite_UNIV :: ('a + 'b, bool) phantom
instantiation
  sum :: (card_UNIV, card_UNIV) card_UNIV
  card_UNIV_sum == card_UNIV_class.card_UNIV :: ('a + 'b, nat) phantom
instantiation
  fun :: (finite_UNIV, card_UNIV) finite_UNIV
  finite_UNIV_fun == finite_UNIV :: ('a => 'b, bool) phantom
instantiation
  fun :: (card_UNIV, card_UNIV) card_UNIV
  card_UNIV_fun == card_UNIV_class.card_UNIV :: ('a => 'b, nat) phantom
signature CEQ_GENERATOR =
  sig
    val ceq_instance_via_eq: string -> theory -> theory
    val ceq_instance_via_equality: string -> theory -> theory
    val derive_no_ceq: string -> theory -> theory
  end
structure Ceq_Generator: CEQ_GENERATOR
deriving "ceq" instance for type "Product_Type.unit" via "="
instantiation
  option :: (finite_UNIV) finite_UNIV
  finite_UNIV_option == finite_UNIV :: ('a option, bool) phantom
derived is_ceq_unit-lemma
### Code generator: dropping subsumed code equation
### CEQ(unit) == Some (=)
deriving "ceq" instance for type "HOL.bool" via "="
instantiation
  option :: (card_UNIV) card_UNIV
  card_UNIV_option == card_UNIV_class.card_UNIV :: ('a option, nat) phantom
### Rewrite rule not in simpset:
### Wellfounded.accp ex_n_lists_rel (?P1, ?n1) ==>
### ex_n_lists ?P1 ?n1 ==
### if ?n1 = 0 then ?P1 []
### else cenum_ex (%x. ex_n_lists (%xs. ?P1 (x # xs)) (?n1 - 1))
derived is_ceq_bool-lemma
deriving "ceq" instance for type "Nat.nat" via "="
instantiation
  String.literal :: card_UNIV
  card_UNIV_literal == card_UNIV_class.card_UNIV ::
    (String.literal, nat) phantom
  finite_UNIV_literal == finite_UNIV :: (String.literal, bool) phantom
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
derived is_ceq_nat-lemma
deriving "ceq" instance for type "Int.int" via "="
instantiation
  set :: (finite_UNIV) finite_UNIV
  finite_UNIV_set == finite_UNIV :: ('a set, bool) phantom
derived is_ceq_int-lemma
deriving "ceq" instance for type "Enum.finite_1" via "="
instantiation
  fun :: (cenum, cenum) cenum
  cEnum_fun == cEnum ::
    (('a => 'b) list *
     ((('a => 'b) => bool) => bool) * ((('a => 'b) => bool) => bool)) option
instantiation
  set :: (card_UNIV) card_UNIV
  card_UNIV_set == card_UNIV_class.card_UNIV :: ('a set, nat) phantom
derived is_ceq_finite_1-lemma
deriving "ceq" instance for type "Enum.finite_2" via "="
derived is_ceq_finite_2-lemma
deriving "ceq" instance for type "Enum.finite_3" via "="
### Ambiguous input (line 136 of "$AFP/Containers/Collection_Enum.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_CENUM" ("\<^type>fun" ("_position_sort" 'a) ("_position_sort" 'b)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CENUM" ("_position_sort" 'a)))
###       ("_case2" ("_case1" ("_position" None) ("_position" None))
###         ("_case1"
###           ("_applC" ("_position" Some)
###             ("_tuple" ("_position" enum_a)
###               ("_tuple_args" ("_position" enum_all_a)
###                 ("_tuple_arg" ("_position" enum_ex_a)))))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CENUM" ("_position_sort" 'b)))
###             ("_case2" ("_case1" ("_position" None) ("_position" None))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("_tuple" ("_position" enum_b)
###                     ("_tuple_args" ("_position" enum_all_b)
###                       ("_tuple_arg" ("_position" enum_ex_b)))))
###                 ("_applC" ("_position" Some)
###                   ("_tuple"
###                     ("_applC" ("_position" map)
###                       ("_cargs"
###                         ("_lambda" ("_position" ys)
###                           ("\<^const>Fun.comp" ("_position" the)
###                             ("_applC" ("_position" map_of)
###                               ("_applC" ("_position" zip)
###                                 ("_cargs" ("_position" enum_a)
###                                   ("_position" ys))))))
###                         ("_applC" ("_position" List.n_lists)
###                           ("_cargs"
###                             ("_applC" ("_position" length)
###                               ("_position" enum_a))
###                             ("_position" enum_b)))))
###                     ("_tuple_args"
###                       ("_lambda" ("_position" P)
###                         ("_applC" ("_position" all_n_lists)
###                           ("_cargs" ("_position" enum_all_b)
###                             ("_cargs"
###                               ("_lambda" ("_position" bs)
###                                 ("_applC" ("_position" P)
###                                   ("\<^const>Fun.comp" ("_position" the)
###                                     ("_applC" ("_position" map_of)
### ("_applC" ("_position" zip)
###   ("_cargs" ("_position" enum_a) ("_position" bs)))))))
###                               ("_applC" ("_position" length)
###                                 ("_position" enum_a))))))
###                       ("_tuple_arg"
###                         ("_lambda" ("_position" P)
###                           ("_applC" ("_position" ex_n_lists)
###                             ("_cargs" ("_position" enum_ex_b)
###                               ("_cargs"
###                                 ("_lambda" ("_position" bs)
###                                   ("_applC" ("_position" P)
###                                     ("\<^const>Fun.comp" ("_position" the)
### ("_applC" ("_position" map_of)
###   ("_applC" ("_position" zip)
###     ("_cargs" ("_position" enum_a) ("_position" bs)))))))
###                                 ("_applC" ("_position" length)
###                                   ("_position" enum_a))))))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_CENUM" ("\<^type>fun" ("_position_sort" 'a) ("_position_sort" 'b)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CENUM" ("_position_sort" 'a)))
###       ("_case2" ("_case1" ("_position" None) ("_position" None))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some)
###               ("_tuple" ("_position" enum_a)
###                 ("_tuple_args" ("_position" enum_all_a)
###                   ("_tuple_arg" ("_position" enum_ex_a)))))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CENUM" ("_position_sort" 'b)))
###               ("_case1" ("_position" None) ("_position" None))))
###           ("_case1"
###             ("_applC" ("_position" Some)
###               ("_tuple" ("_position" enum_b)
###                 ("_tuple_args" ("_position" enum_all_b)
###                   ("_tuple_arg" ("_position" enum_ex_b)))))
###             ("_applC" ("_position" Some)
###               ("_tuple"
###                 ("_applC" ("_position" map)
###                   ("_cargs"
###                     ("_lambda" ("_position" ys)
###                       ("\<^const>Fun.comp" ("_position" the)
###                         ("_applC" ("_position" map_of)
###                           ("_applC" ("_position" zip)
###                             ("_cargs" ("_position" enum_a)
###                               ("_position" ys))))))
###                     ("_applC" ("_position" List.n_lists)
###                       ("_cargs"
###                         ("_applC" ("_position" length) ("_position" enum_a))
###                         ("_position" enum_b)))))
###                 ("_tuple_args"
###                   ("_lambda" ("_position" P)
###                     ("_applC" ("_position" all_n_lists)
###                       ("_cargs" ("_position" enum_all_b)
###                         ("_cargs"
###                           ("_lambda" ("_position" bs)
###                             ("_applC" ("_position" P)
###                               ("\<^const>Fun.comp" ("_position" the)
###                                 ("_applC" ("_position" map_of)
###                                   ("_applC" ("_position" zip)
###                                     ("_cargs" ("_position" enum_a)
### ("_position" bs)))))))
###                           ("_applC" ("_position" length)
###                             ("_position" enum_a))))))
###                   ("_tuple_arg"
###                     ("_lambda" ("_position" P)
###                       ("_applC" ("_position" ex_n_lists)
###                         ("_cargs" ("_position" enum_ex_b)
###                           ("_cargs"
###                             ("_lambda" ("_position" bs)
###                               ("_applC" ("_position" P)
###                                 ("\<^const>Fun.comp" ("_position" the)
###                                   ("_applC" ("_position" map_of)
###                                     ("_applC" ("_position" zip)
### ("_cargs" ("_position" enum_a) ("_position" bs)))))))
###                             ("_applC" ("_position" length)
###                               ("_position" enum_a))))))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
instantiation
  Enum.finite_1 :: card_UNIV
  card_UNIV_finite_1 == card_UNIV_class.card_UNIV ::
    (Enum.finite_1, nat) phantom
  finite_UNIV_finite_1 == finite_UNIV :: (Enum.finite_1, bool) phantom
derived is_ceq_finite_3-lemma
deriving "ceq" instance for type "Enum.finite_4" via "="
derived is_ceq_finite_4-lemma
deriving "ceq" instance for type "Enum.finite_5" via "="
instantiation
  Enum.finite_2 :: card_UNIV
  card_UNIV_finite_2 == card_UNIV_class.card_UNIV ::
    (Enum.finite_2, nat) phantom
  finite_UNIV_finite_2 == finite_UNIV :: (Enum.finite_2, bool) phantom
derived is_ceq_finite_5-lemma
deriving "ceq" instance for type "Code_Numeral.integer" via "="
instantiation
  set :: (cenum) cenum
  cEnum_set == cEnum ::
    ('a set list *
     (('a set => bool) => bool) * (('a set => bool) => bool)) option
instantiation
  Enum.finite_3 :: card_UNIV
  card_UNIV_finite_3 == card_UNIV_class.card_UNIV ::
    (Enum.finite_3, nat) phantom
  finite_UNIV_finite_3 == finite_UNIV :: (Enum.finite_3, bool) phantom
derived is_ceq_integer-lemma
deriving "ceq" instance for type "Code_Numeral.natural" via "="
derived is_ceq_natural-lemma
deriving "ceq" instance for type "String.char" via "="
instantiation
  Enum.finite_4 :: card_UNIV
  card_UNIV_finite_4 == card_UNIV_class.card_UNIV ::
    (Enum.finite_4, nat) phantom
  finite_UNIV_finite_4 == finite_UNIV :: (Enum.finite_4, bool) phantom
instantiation
  unit :: cenum
  cEnum_unit == cEnum ::
    (unit list * ((unit => bool) => bool) * ((unit => bool) => bool)) option
derived is_ceq_char-lemma
deriving "ceq" instance for type "String.literal" via "="
instantiation
  bool :: cenum
  cEnum_bool == cEnum ::
    (bool list * ((bool => bool) => bool) * ((bool => bool) => bool)) option
derived is_ceq_literal-lemma
deriving "ceq" instance for type "Sum_Type.sum"
instantiation
  Enum.finite_5 :: card_UNIV
  card_UNIV_finite_5 == card_UNIV_class.card_UNIV ::
    (Enum.finite_5, nat) phantom
  finite_UNIV_finite_5 == finite_UNIV :: (Enum.finite_5, bool) phantom
instantiation
  prod :: (cenum, cenum) cenum
  cEnum_prod == cEnum ::
    (('a * 'b) list *
     (('a * 'b => bool) => bool) * (('a * 'b => bool) => bool)) option
derived is_ceq_sum-lemma
deriving "ceq" instance for type "Product_Type.prod"
### theory "HOL-Library.Cardinality"
### 1.108s elapsed time, 4.171s cpu time, 1.477s GC time
Loading theory "Containers.Set_Linorder" (required by "Draft.Monitor_CodeMoreTemplates" via "Draft.Monitor_Code" via "Containers.Containers")
### Ambiguous input (line 225 of "$AFP/Containers/Collection_Enum.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_CENUM"
###       ("\<^type>Product_Type.prod" ("_position_sort" 'a)
###         ("_position_sort" 'b)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CENUM" ("_position_sort" 'a)))
###       ("_case2" ("_case1" ("_position" None) ("_position" None))
###         ("_case1"
###           ("_applC" ("_position" Some)
###             ("_tuple" ("_position" enum_a)
###               ("_tuple_args" ("_position" enum_all_a)
###                 ("_tuple_arg" ("_position" enum_ex_a)))))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CENUM" ("_position_sort" 'b)))
###             ("_case2" ("_case1" ("_position" None) ("_position" None))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("_tuple" ("_position" enum_b)
###                     ("_tuple_args" ("_position" enum_all_b)
###                       ("_tuple_arg" ("_position" enum_ex_b)))))
###                 ("_applC" ("_position" Some)
###                   ("_tuple"
###                     ("_applC" ("_position" List.product)
###                       ("_cargs" ("_position" enum_a) ("_position" enum_b)))
###                     ("_tuple_args"
###                       ("_lambda" ("_position" P)
###                         ("_applC" ("_position" enum_all_a)
###                           ("_lambda" ("_position" x)
###                             ("_applC" ("_position" enum_all_b)
###                               ("_lambda" ("_position" y)
###                                 ("_applC" ("_position" P)
###                                   ("_tuple" ("_position" x)
###                                     ("_tuple_arg" ("_position" y)))))))))
###                       ("_tuple_arg"
###                         ("_lambda" ("_position" P)
###                           ("_applC" ("_position" enum_ex_a)
###                             ("_lambda" ("_position" x)
###                               ("_applC" ("_position" enum_ex_b)
###                                 ("_lambda" ("_position" y)
###                                   ("_applC" ("_position" P)
###                                     ("_tuple" ("_position" x)
### ("_tuple_arg" ("_position" y)))))))))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_CENUM"
###       ("\<^type>Product_Type.prod" ("_position_sort" 'a)
###         ("_position_sort" 'b)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CENUM" ("_position_sort" 'a)))
###       ("_case2" ("_case1" ("_position" None) ("_position" None))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some)
###               ("_tuple" ("_position" enum_a)
###                 ("_tuple_args" ("_position" enum_all_a)
###                   ("_tuple_arg" ("_position" enum_ex_a)))))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CENUM" ("_position_sort" 'b)))
###               ("_case1" ("_position" None) ("_position" None))))
###           ("_case1"
###             ("_applC" ("_position" Some)
###               ("_tuple" ("_position" enum_b)
###                 ("_tuple_args" ("_position" enum_all_b)
###                   ("_tuple_arg" ("_position" enum_ex_b)))))
###             ("_applC" ("_position" Some)
###               ("_tuple"
###                 ("_applC" ("_position" List.product)
###                   ("_cargs" ("_position" enum_a) ("_position" enum_b)))
###                 ("_tuple_args"
###                   ("_lambda" ("_position" P)
###                     ("_applC" ("_position" enum_all_a)
###                       ("_lambda" ("_position" x)
###                         ("_applC" ("_position" enum_all_b)
###                           ("_lambda" ("_position" y)
###                             ("_applC" ("_position" P)
###                               ("_tuple" ("_position" x)
###                                 ("_tuple_arg" ("_position" y)))))))))
###                   ("_tuple_arg"
###                     ("_lambda" ("_position" P)
###                       ("_applC" ("_position" enum_ex_a)
###                         ("_lambda" ("_position" x)
###                           ("_applC" ("_position" enum_ex_b)
###                             ("_lambda" ("_position" y)
###                               ("_applC" ("_position" P)
###                                 ("_tuple" ("_position" x)
###                                   ("_tuple_arg"
###                                     ("_position" y)))))))))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
derived is_ceq_prod-lemma
deriving "ceq" instance for type "List.list"
instantiation
  sum :: (cenum, cenum) cenum
  cEnum_sum == cEnum ::
    (('a + 'b) list *
     (('a + 'b => bool) => bool) * (('a + 'b => bool) => bool)) option
derived is_ceq_list-lemma
deriving "ceq" instance for type "Option.option"
derived is_ceq_option-lemma
use None as trivial implementation of ceq for type fun
### Ambiguous input (line 237 of "$AFP/Containers/Collection_Enum.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_CENUM"
###       ("\<^type>Sum_Type.sum" ("_position_sort" 'a) ("_position_sort" 'b)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CENUM" ("_position_sort" 'a)))
###       ("_case2" ("_case1" ("_position" None) ("_position" None))
###         ("_case1"
###           ("_applC" ("_position" Some)
###             ("_tuple" ("_position" enum_a)
###               ("_tuple_args" ("_position" enum_all_a)
###                 ("_tuple_arg" ("_position" enum_ex_a)))))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CENUM" ("_position_sort" 'b)))
###             ("_case2" ("_case1" ("_position" None) ("_position" None))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("_tuple" ("_position" enum_b)
###                     ("_tuple_args" ("_position" enum_all_b)
###                       ("_tuple_arg" ("_position" enum_ex_b)))))
###                 ("_applC" ("_position" Some)
###                   ("_tuple"
###                     ("\<^const>List.append"
###                       ("_applC" ("_position" map)
###                         ("_cargs" ("_position" Inl) ("_position" enum_a)))
###                       ("_applC" ("_position" map)
###                         ("_cargs" ("_position" Inr) ("_position" enum_b))))
###                     ("_tuple_args"
###                       ("_lambda" ("_position" P)
###                         ("\<^const>HOL.conj"
###                           ("_applC" ("_position" enum_all_a)
###                             ("_lambda" ("_position" x)
###                               ("_applC" ("_position" P)
###                                 ("_applC" ("_position" Inl)
###                                   ("_position" x)))))
###                           ("_applC" ("_position" enum_all_b)
###                             ("_lambda" ("_position" x)
###                               ("_applC" ("_position" P)
###                                 ("_applC" ("_position" Inr)
###                                   ("_position" x)))))))
###                       ("_tuple_arg"
###                         ("_lambda" ("_position" P)
###                           ("\<^const>HOL.disj"
###                             ("_applC" ("_position" enum_ex_a)
###                               ("_lambda" ("_position" x)
###                                 ("_applC" ("_position" P)
###                                   ("_applC" ("_position" Inl)
###                                     ("_position" x)))))
###                             ("_applC" ("_position" enum_ex_b)
###                               ("_lambda" ("_position" x)
###                                 ("_applC" ("_position" P)
###                                   ("_applC" ("_position" Inr)
###                                     ("_position" x)))))))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_CENUM"
###       ("\<^type>Sum_Type.sum" ("_position_sort" 'a) ("_position_sort" 'b)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CENUM" ("_position_sort" 'a)))
###       ("_case2" ("_case1" ("_position" None) ("_position" None))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some)
###               ("_tuple" ("_position" enum_a)
###                 ("_tuple_args" ("_position" enum_all_a)
###                   ("_tuple_arg" ("_position" enum_ex_a)))))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CENUM" ("_position_sort" 'b)))
###               ("_case1" ("_position" None) ("_position" None))))
###           ("_case1"
###             ("_applC" ("_position" Some)
###               ("_tuple" ("_position" enum_b)
###                 ("_tuple_args" ("_position" enum_all_b)
###                   ("_tuple_arg" ("_position" enum_ex_b)))))
###             ("_applC" ("_position" Some)
###               ("_tuple"
###                 ("\<^const>List.append"
###                   ("_applC" ("_position" map)
###                     ("_cargs" ("_position" Inl) ("_position" enum_a)))
###                   ("_applC" ("_position" map)
###                     ("_cargs" ("_position" Inr) ("_position" enum_b))))
###                 ("_tuple_args"
###                   ("_lambda" ("_position" P)
###                     ("\<^const>HOL.conj"
###                       ("_applC" ("_position" enum_all_a)
###                         ("_lambda" ("_position" x)
###                           ("_applC" ("_position" P)
###                             ("_applC" ("_position" Inl) ("_position" x)))))
###                       ("_applC" ("_position" enum_all_b)
###                         ("_lambda" ("_position" x)
###                           ("_applC" ("_position" P)
###                             ("_applC" ("_position" Inr)
###                               ("_position" x)))))))
###                   ("_tuple_arg"
###                     ("_lambda" ("_position" P)
###                       ("\<^const>HOL.disj"
###                         ("_applC" ("_position" enum_ex_a)
###                           ("_lambda" ("_position" x)
###                             ("_applC" ("_position" P)
###                               ("_applC" ("_position" Inl)
###                                 ("_position" x)))))
###                         ("_applC" ("_position" enum_ex_b)
###                           ("_lambda" ("_position" x)
###                             ("_applC" ("_position" P)
###                               ("_applC" ("_position" Inr)
###                                 ("_position" x)))))))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
registered fun in class ceq
instantiation
  set :: (ceq) ceq
  ceq_set == ceq :: ('a set => 'a set => bool) option
instantiation
  option :: (cenum) cenum
  cEnum_option == cEnum ::
    ('a option list *
     (('a option => bool) => bool) * (('a option => bool) => bool)) option
instantiation
  Enum.finite_1 :: cenum
  cEnum_finite_1 == cEnum ::
    (Enum.finite_1 list *
     ((Enum.finite_1 => bool) => bool) *
     ((Enum.finite_1 => bool) => bool)) option
instantiation
  Enum.finite_2 :: cenum
  cEnum_finite_2 == cEnum ::
    (Enum.finite_2 list *
     ((Enum.finite_2 => bool) => bool) *
     ((Enum.finite_2 => bool) => bool)) option
instantiation
  Enum.finite_3 :: cenum
  cEnum_finite_3 == cEnum ::
    (Enum.finite_3 list *
     ((Enum.finite_3 => bool) => bool) *
     ((Enum.finite_3 => bool) => bool)) option
instantiation
  Enum.finite_4 :: cenum
  cEnum_finite_4 == cEnum ::
    (Enum.finite_4 list *
     ((Enum.finite_4 => bool) => bool) *
     ((Enum.finite_4 => bool) => bool)) option
instantiation
  Predicate.pred :: (ceq) ceq
  ceq_pred == ceq :: ('a Predicate.pred => 'a Predicate.pred => bool) option
instantiation
  Enum.finite_5 :: cenum
  cEnum_finite_5 == cEnum ::
    (Enum.finite_5 list *
     ((Enum.finite_5 => bool) => bool) *
     ((Enum.finite_5 => bool) => bool)) option
### theory "Containers.Collection_Eq"
### 0.929s elapsed time, 3.453s cpu time, 1.386s GC time
Loading theory "Containers.DList_Set" (required by "Draft.Monitor_CodeMoreTemplates" via "Draft.Monitor_Code" via "Containers.Containers" via "Containers.Mapping_Impl" via "Containers.Set_Impl")
instantiation
  char :: cenum
  cEnum_char == cEnum ::
    (char list * ((char => bool) => bool) * ((char => bool) => bool)) option
use None as trivial implementation of cenum for type list
registered list in class cenum
use None as trivial implementation of cenum for type nat
registered nat in class cenum
use None as trivial implementation of cenum for type int
registered int in class cenum
use None as trivial implementation of cenum for type integer
consts
  entries :: "('a, 'b) rbt => ('a * 'b) list"
registered integer in class cenum
use None as trivial implementation of cenum for type natural
registered natural in class cenum
use None as trivial implementation of cenum for type literal
registered literal in class cenum
### theory "Containers.Collection_Enum"
### 1.009s elapsed time, 3.781s cpu time, 1.386s GC time
Loading theory "HOL-Library.Tree" (required by "Draft.Monitor_CodeMoreTemplates" via "Draft.ExtrEqs" via "Draft.Templates")
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
locale equal_base
  fixes equal :: "'a => 'a => bool"
consts
  list_member :: "'a list => 'a => bool"
consts
  list_distinct :: "'a list => bool"
consts
  list_remove1 :: "'a => 'a list => 'a list"
consts
  rbt_sorted :: "('a, 'b) rbt => bool"
consts
  list_remdups :: "'a list => 'a list"
locale Equal.equal
  fixes equal :: "'a => 'a => bool"
  assumes "equal equal"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
consts
  rbt_lookup :: "('a, 'b) rbt => 'a => 'b option"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
specification
  finite_complement_partition: finite ?A ==> ?A : infinite_complement_partition
  complement_partition: infinite UNIV ==>
(?A : infinite_complement_partition) =
(- ?A ~: infinite_complement_partition)
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
consts
  color_of :: "('a, 'b) rbt => color"
consts
  bheight :: "('a, 'b) rbt => nat"
consts
  inv1 :: "('a, 'b) rbt => bool"
consts
  inv1l :: "('a, 'b) rbt => bool"
class order = preorder +
  assumes "order_antisym": "!!x y. [| x <= y; y <= x |] ==> x = y"
consts
  inv2 :: "('a, 'b) rbt => bool"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
### theory "Containers.DList_Set"
### 0.674s elapsed time, 2.661s cpu time, 0.238s GC time
Loading theory "HOL-Library.While_Combinator" (required by "Draft.Monitor_CodeMoreTemplates" via "Draft.Monitor_Code" via "Draft.Monitor" via "Draft.Temporal" via "Draft.Window")
consts
  left :: "'a tree => 'a tree"
consts
  right :: "'a tree => 'a tree"
Found termination order: "size <*mlex*> {}"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
Found termination order: "{}"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
class height = type +
  fixes height :: "'a => nat"
instantiation
  tree :: (type) height
  height_tree == height :: 'a tree => nat
Found termination order: "{}"
Found termination order: "size <*mlex*> {}"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
Found termination order: "size <*mlex*> {}"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
Found termination order: "{}"
### theory "HOL-Library.While_Combinator"
### 0.445s elapsed time, 1.769s cpu time, 0.135s GC time
Loading theory "HOL-Library.Countable" (required by "Draft.Monitor_CodeMoreTemplates" via "Draft.Monitor_Code" via "Draft.Monitor" via "Draft.MDL" via "Draft.Interval" via "Draft.Timestamp" via "HOL-Library.Extended_Nat")
Found termination order: "size <*mlex*> {}"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
class proper_intrvl = ord +
  fixes proper_interval :: "'a option => 'a option => bool"
Found termination order: "size <*mlex*> {}"
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
class proper_interval = proper_intrvl +
  assumes
    "proper_interval_simps": "proper_interval None None = True"
      "!!y. proper_interval None (Some y) = (EX z. z < y)"
      "!!x. proper_interval (Some x) None = (EX z. x < z)"
      "!!x y. proper_interval (Some x) (Some y) = (EX z>x. z < y)"
class proper_intrvl = ord +
  fixes proper_interval :: "'a option => 'a option => bool"
### Additional type variable(s) in locale specification "countable": 'a
Found termination order: "size <*mlex*> {}"
class countable = type +
  assumes "ex_inj": "EX to_nat. inj to_nat"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
Proofs for inductive predicate(s) "finite_item"
  Proving monotonicity ...
Found termination order: "size <*mlex*> {}"
val old_countable_datatype_tac = fn: Proof.context -> int -> tactic
### ML warning (line 93 of "~~/src/HOL/Tools/BNF/bnf_lfp_countable.ML"):
### Pattern is not exhaustive.
### ML warning (line 139 of "~~/src/HOL/Tools/BNF/bnf_lfp_countable.ML"):
### Pattern is not exhaustive.
### ML warning (line 143 of "~~/src/HOL/Tools/BNF/bnf_lfp_countable.ML"):
### Matches are not exhaustive.
### ML warning (line 145 of "~~/src/HOL/Tools/BNF/bnf_lfp_countable.ML"):
### Matches are not exhaustive.
### ML warning (line 156 of "~~/src/HOL/Tools/BNF/bnf_lfp_countable.ML"):
### Pattern is not exhaustive.
signature BNF_LFP_COUNTABLE =
  sig
    val countable_datatype_tac: Proof.context -> tactic
    val derive_encode_injectives_thms:
       Proof.context -> string list -> thm list
  end
structure BNF_LFP_Countable: BNF_LFP_COUNTABLE
val countable_datatype_tac = fn: Proof.context -> thm -> thm Seq.seq
val countable_tac = fn: Proof.context -> int -> tactic
### theory "HOL-Library.Tree"
### 2.062s elapsed time, 8.140s cpu time, 0.684s GC time
Loading theory "Draft.Templates" (required by "Draft.Monitor_CodeMoreTemplates" via "Draft.ExtrEqs")
Found termination order:
  "(%p. length (snd (snd p))) <*mlex*>
   (%p. length (fst (snd p))) <*mlex*> {}"
datatype template_term
=
     t_empty
   | template_app of template_term * template_term
   | template_hole of int
   | template_var of int
datatype sign
= equals | greater_equals | greater_than | less_equals | less_than
datatype template
=
     template_bimplication of template * template
   | template_dunno
   | template_equation of template_term * template_term
   | template_implication of template list * template
   | template_inequation of sign * template_term * template_term
   | template_negation of template
   | template_predicate of template_term
constructor t_empty: template_term
constructor template_app: template_term * template_term -> template_term
constructor template_hole: int -> template_term
constructor template_var: int -> template_term
constructor equals: sign
constructor greater_equals: sign
constructor greater_than: sign
constructor less_equals: sign
constructor less_than: sign
constructor template_bimplication: template * template -> template
constructor template_dunno: template
constructor template_equation: template_term * template_term -> template
constructor template_implication: template list * template -> template
constructor template_inequation:
   sign * template_term * template_term -> template
constructor template_negation: template -> template
constructor template_predicate: template_term -> template
val vfs = fn: term -> (indexname * typ) list * (string * typ) list
val indexOf = fn: ''a list -> ''a -> int -> int
val has_eq = fn: term -> bool
val term2template = fn:
   (indexname * typ) list -> (string * typ) list -> term -> template_term
val lemma2predicate = fn: term -> term -> template
val makeTemplatewithContext = fn: term -> term -> template
val lemma2template = fn: term -> template
val thm2template = fn: thm -> template
val tterm2string = fn: template_term -> string
val template2string = fn: template -> string
val t = "height ?t <= size ?t": thm
val th =
   Const ("HOL.Trueprop", "bool => prop") $
     (Const ("Orderings.ord_class.less_eq", "nat => nat => bool") $
       (Const ("Tree.height_class.height", "?'a tree => nat") $
         Var (("t", 0), "?'a tree")) $
       (Const ("Nat.size_class.size", "?'a tree => nat") $
         Var (("t", 0), "?'a tree"))):
   term
### theory "Draft.Templates"
### 0.092s elapsed time, 0.356s cpu time, 0.074s GC time
Loading theory "HOL-Library.BigO" (required by "Draft.Monitor_CodeMoreTemplates" via "Draft.ExtrEqs")
### theory "HOL-Library.Countable"
### 1.193s elapsed time, 4.720s cpu time, 0.386s GC time
Loading theory "HOL-Library.Countable_Set" (required by "Draft.Monitor_CodeMoreTemplates" via "Draft.Monitor_Code" via "Draft.Monitor" via "Draft.MDL" via "Draft.Interval" via "Draft.Timestamp" via "HOL-Library.Extended_Nat" via "HOL-Library.Order_Continuity" via "HOL-Library.Countable_Complete_Lattices")
Found termination order:
  "(%p. length (snd (snd p))) <*mlex*>
   (%p. length (fst (snd p))) <*mlex*> {}"
locale comm_monoid_set
  fixes f :: "'a => 'a => 'a"  (infixl \<open>\<^bold>*\<close> 70)
    and z :: "'a"  (\<open>\<^bold>1\<close>)
  assumes "comm_monoid_set (\<^bold>*) \<^bold>1"
### theory "HOL-Library.Countable_Set"
### 0.459s elapsed time, 1.818s cpu time, 0.107s GC time
Loading theory "HOL-Library.Countable_Complete_Lattices" (required by "Draft.Monitor_CodeMoreTemplates" via "Draft.Monitor_Code" via "Draft.Monitor" via "Draft.MDL" via "Draft.Interval" via "Draft.Timestamp" via "HOL-Library.Extended_Nat" via "HOL-Library.Order_Continuity")
### theory "HOL-Library.BigO"
### 0.820s elapsed time, 3.250s cpu time, 0.273s GC time
Loading theory "Draft.ExtrEqs" (required by "Draft.Monitor_CodeMoreTemplates")
class countable_complete_lattice = Inf + Sup + lattice + bot + top +
  assumes "ccInf_lower": "!!A x. [| countable A; x : A |] ==> Inf A <= x"
  assumes
    "ccInf_greatest":
      "!!A z. [| countable A; !!x. x : A ==> z <= x |] ==> z <= Inf A"
  assumes "ccSup_upper": "!!A x. [| countable A; x : A |] ==> x <= Sup A"
  assumes
    "ccSup_least":
      "!!A z. [| countable A; !!x. x : A ==> x <= z |] ==> Sup A <= z"
  assumes "ccInf_empty": "Inf {} = top"
  assumes "ccSup_empty": "Sup {} = bot"
val eqpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Var (("_dummy_", 2), "?'a"))
       ):
   term Find_Theorems.criterion
val badeqpattern = Pattern (Const ("Pure.eq", "?'a => ?'a => prop")):
   term Find_Theorems.criterion
val undefpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Const ("HOL.undefined", "?'a"))
       ):
   term Find_Theorems.criterion
val thmpattern =
   Pattern
    (Const ("HOL.Trueprop", "bool => prop") $ Var (("_dummy_", 1), "bool")):
   term Find_Theorems.criterion
val badnames =
   ["*nitpick*", "*Nitpick*", "*full_exhaustive*", "*_def*", "Enum.finite*",
    "*Quickcheck*", "ATP*", "*Nunchaku*", "*Code*", "*BNF*", "*SMT*",
    "*.*.*"]:
   string list
val unwanted_names =
   [(false, Name "*nitpick*"), (false, Name "*Nitpick*"),
    (false, Name "*full_exhaustive*"), (false, Name "*_def*"),
    (false, Name "Enum.finite*"), (false, Name "*Quickcheck*"),
    (false, Name "ATP*"), (false, Name "*Nunchaku*"),
    (false, Name "*Code*"), (false, Name "*BNF*"), (false, Name "*SMT*"),
    (false, Name "*.*.*")]:
   (bool * term Find_Theorems.criterion) list
val has_vars = fn: term -> bool
val get_all_eqs = fn: string -> Proof.context -> (string * thm) list
val get_all_thms = fn: string -> Proof.context -> (string * thm) list
val get_noneq_thms = fn: string -> Proof.context -> (string * thm) list
val template_eqs = fn:
   string -> Proof.context -> (string * thm * template) list
val template_thms = fn:
   string -> Proof.context -> (string * thm * template) list
### theory "Draft.ExtrEqs"
### 1.218s elapsed time, 4.559s cpu time, 2.035s GC time
Loading theory "HOL-Library.Liminf_Limsup" (required by "Draft.Monitor_CodeMoreTemplates" via "Draft.Monitor_Code" via "Draft.Monitor" via "Draft.MDL" via "Draft.Interval" via "Draft.Timestamp" via "HOL-Library.Extended_Real")
class proper_intrvl = ord +
  fixes proper_interval :: "'a option => 'a option => bool"
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
Found termination order: "{}"
class countable_complete_distrib_lattice = countable_complete_lattice +
  assumes
    "sup_ccInf": "!!B a. countable B ==> sup a (Inf B) = Inf (sup a ` B)"
  assumes
    "inf_ccSup": "!!B a. countable B ==> inf a (Sup B) = Sup (inf a ` B)"
### theory "HOL-Library.Liminf_Limsup"
### 0.512s elapsed time, 2.014s cpu time, 0.150s GC time
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
### theory "HOL-Library.Countable_Complete_Lattices"
### 2.711s elapsed time, 10.454s cpu time, 2.450s GC time
Loading theory "HOL-Library.Order_Continuity" (required by "Draft.Monitor_CodeMoreTemplates" via "Draft.Monitor_Code" via "Draft.Monitor" via "Draft.MDL" via "Draft.Interval" via "Draft.Timestamp" via "HOL-Library.Extended_Nat")
(if ?x <= ?y then if ?x = ?y then ?P else ?Q else ?R) =
(case compare ?x ?y of Eq => ?P | Lt => ?Q | Gt => ?R)
(if ?x <= ?y then if ?y = ?x then ?P else ?Q else ?R) =
(case compare ?x ?y of Eq => ?P | Lt => ?Q | Gt => ?R)
(if ?x <= ?y then if ?y <= ?x then ?P else ?Q else ?R) =
(case compare ?x ?y of Eq => ?P | Lt => ?Q | Gt => ?R)
(if ?x <= ?y then if ?x < ?y then ?Q else ?P else ?R) =
(case compare ?x ?y of Eq => ?P | Lt => ?Q | Gt => ?R)
(if ?x < ?y then ?Q else if ?x <= ?y then ?P else ?R) =
(case compare ?x ?y of Eq => ?P | Lt => ?Q | Gt => ?R)
(if ?x < ?y then ?Q else if ?y < ?x then ?R else ?P) =
(case compare ?x ?y of Eq => ?P | Lt => ?Q | Gt => ?R)
(if ?x < ?y then ?Q else if ?x = ?y then ?P else ?R) =
(case compare ?x ?y of Eq => ?P | Lt => ?Q | Gt => ?R)
(if ?x < ?y then ?Q else if ?y = ?x then ?P else ?R) =
(case compare ?x ?y of Eq => ?P | Lt => ?Q | Gt => ?R)
(if ?x = ?y then ?P else if ?y < ?x then ?R else ?Q) =
(case compare ?x ?y of Eq => ?P | Lt => ?Q | Gt => ?R)
(if ?x = ?y then ?P else if ?x < ?y then ?Q else ?R) =
(case compare ?x ?y of Eq => ?P | Lt => ?Q | Gt => ?R)
(if ?x = ?y then ?P else if ?y <= ?x then ?R else ?Q) =
(case compare ?x ?y of Eq => ?P | Lt => ?Q | Gt => ?R)
(if ?x = ?y then ?P else if ?x <= ?y then ?Q else ?R) =
(case compare ?x ?y of Eq => ?P | Lt => ?Q | Gt => ?R)
Found termination order:
  "(%p. length (snd (snd (snd p)))) <*mlex*>
   (%p. length (fst (snd (snd p)))) <*mlex*> {}"
### theory "HOL-Library.Order_Continuity"
### 0.562s elapsed time, 1.798s cpu time, 0.098s GC time
Loading theory "HOL-Library.Extended_Nat" (required by "Draft.Monitor_CodeMoreTemplates" via "Draft.Monitor_Code" via "Draft.Monitor" via "Draft.MDL" via "Draft.Interval" via "Draft.Timestamp")
class infinity = type +
  fixes infinity :: "'a"
instantiation
  enat :: infinity
  infinity_enat == infinity :: enat
Proofs for inductive predicate(s) "rec_set_enat"
Found termination order:
  "(%p. length (snd (snd p))) <*mlex*>
   (%p. length (fst (snd p))) <*mlex*> {}"
### No equation for constructor "Extended_Nat.infinity_class.infinity"
### in definition of function "the_enat"
consts
  the_enat :: "enat => nat"
instantiation
  enat :: zero_neq_one
  one_enat == one_class.one :: enat
  zero_enat == zero_class.zero :: enat
instantiation
  enat :: comm_monoid_add
  plus_enat == plus :: enat => enat => enat
instantiation
  enat :: {comm_semiring_1,semiring_no_zero_divisors}
  times_enat == times :: enat => enat => enat
instantiation
  enat :: minus
  minus_enat == minus :: enat => enat => enat
instantiation
  enat :: linordered_ab_semigroup_add
  less_eq_enat == less_eq :: enat => enat => bool
  less_enat == less :: enat => enat => bool
instantiation
  enat :: {order_bot,order_top}
  top_enat == top :: enat
  bot_enat == bot :: enat
structure Cancel_Enat_Common:
  sig
    val dest_sum: term -> term list
    val dest_summing: term * term list -> term list
    val find_first: term -> term list -> term list
    val find_first_t: term list -> term -> term list -> term list
    val mk_eq: term * term -> term
    val mk_sum: typ -> term list -> term
    val norm_ss: simpset
    val norm_tac: Proof.context -> tactic
    val simplify_meta_eq: Proof.context -> thm -> thm -> thm
    val trans_tac: Proof.context -> thm option -> tactic
  end
structure Eq_Enat_Cancel:
  sig val proc: Proof.context -> term -> thm option end
structure Le_Enat_Cancel:
  sig val proc: Proof.context -> term -> thm option end
structure Less_Enat_Cancel:
  sig val proc: Proof.context -> term -> thm option end
instantiation
  enat :: complete_lattice
  Inf_enat == Inf :: enat set => enat
  Sup_enat == Sup :: enat set => enat
  sup_enat == sup :: enat => enat => enat
  inf_enat == inf :: enat => enat => enat
### theory "HOL-Library.Extended_Nat"
### 0.651s elapsed time, 1.985s cpu time, 0.193s GC time
Loading theory "HOL-Library.Extended_Real" (required by "Draft.Monitor_CodeMoreTemplates" via "Draft.Monitor_Code" via "Draft.Monitor" via "Draft.MDL" via "Draft.Interval" via "Draft.Timestamp")
instantiation
  unit :: proper_interval
  proper_interval_unit == proper_interval ::
    unit option => unit option => bool
Found termination order: "{}"
instantiation
  bool :: proper_interval
  proper_interval_bool == proper_interval ::
    bool option => bool option => bool
Found termination order: "{}"
instantiation
  nat :: proper_interval
  proper_interval_nat == proper_interval :: nat option => nat option => bool
Found termination order: "{}"
instantiation
  int :: proper_interval
  proper_interval_int == proper_interval :: int option => int option => bool
Found termination order: "{}"
instantiation
  integer :: proper_interval
  proper_interval_integer == proper_interval ::
    integer option => integer option => bool
instantiation
  enat :: linorder_topology
  open_enat == open :: enat set => bool
instantiation
  natural :: proper_interval
  proper_interval_natural == proper_interval ::
    natural option => natural option => bool
instantiation
  char :: proper_interval
  proper_interval_char == proper_interval ::
    char option => char option => bool
Found termination order: "{}"
instantiation
  Enum.finite_1 :: proper_interval
  proper_interval_finite_1 == proper_interval ::
    Enum.finite_1 option => Enum.finite_1 option => bool
instantiation
  Enum.finite_2 :: proper_interval
  proper_interval_finite_2 == proper_interval ::
    Enum.finite_2 option => Enum.finite_2 option => bool
Found termination order: "{}"
instantiation
  Enum.finite_3 :: proper_interval
  proper_interval_finite_3 == proper_interval ::
    Enum.finite_3 option => Enum.finite_3 option => bool
Found termination order: "{}"
instantiation
  ereal :: uminus
  uminus_ereal == uminus :: ereal => ereal
class proper_intrvl = ord +
  fixes proper_interval :: "'a option => 'a option => bool"
Found termination order: "{}"
instantiation
  ereal :: infinity
  infinity_ereal == infinity :: ereal
instantiation
  ereal :: abs
  abs_ereal == abs :: ereal => ereal
instantiation
  ereal :: {comm_monoid_add,zero_neq_one}
  one_ereal == one_class.one :: ereal
  zero_ereal == zero_class.zero :: ereal
  plus_ereal == plus :: ereal => ereal => ereal
instantiation
  ereal :: linorder
  less_eq_ereal == less_eq :: ereal => ereal => bool
  less_ereal == less :: ereal => ereal => bool
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
instantiation
  ereal :: {comm_monoid_mult,sgn}
  sgn_ereal == sgn :: ereal => ereal
  times_ereal == times :: ereal => ereal => ereal
### theory "Containers.Set_Linorder"
### 8.059s elapsed time, 29.449s cpu time, 3.949s GC time
Loading theory "Containers.Collection_Order" (required by "Draft.Monitor_CodeMoreTemplates" via "Draft.Monitor_Code" via "Containers.Containers")
instantiation
  ereal :: minus
  minus_ereal == minus :: ereal => ereal => ereal
instantiation
  ereal :: inverse
  inverse_ereal == inverse :: ereal => ereal
  divide_ereal == divide :: ereal => ereal => ereal
class ccompare = type +
  fixes ccompare :: "('a => 'a => order) option"
  assumes "ccompare": "!!comp. ccompare = Some comp ==> comparator comp"
class ccompare = type +
  fixes ccompare :: "('a => 'a => order) option"
  assumes "ccompare": "!!comp. ccompare = Some comp ==> comparator comp"
signature CCOMPARE_GENERATOR =
  sig
    val ccompare_instance_via_comparator: string -> theory -> theory
    val ccompare_instance_via_compare: string -> theory -> theory
    val derive_no_ccompare: string -> theory -> theory
  end
structure CCompare_Generator: CCOMPARE_GENERATOR
deriving "compare_order" instance for type "Enum.finite_1"
deriving "compare" instance for type "Enum.finite_1"
deriving "compare_order" instance for type "Enum.finite_2"
deriving "compare" instance for type "Enum.finite_2"
deriving "compare_order" instance for type "Enum.finite_3"
deriving "compare" instance for type "Enum.finite_3"
Found termination order: "{}"
deriving "compare_order" instance for type "Code_Numeral.natural"
deriving "compare" instance for type "Code_Numeral.natural"
instantiation
  ereal :: lattice
  inf_ereal == inf :: ereal => ereal => ereal
  sup_ereal == sup :: ereal => ereal => ereal
deriving "compare_order" instance for type "String.literal"
deriving "compare" instance for type "String.literal"
deriving "ccompare_order" instance for type "Product_Type.unit" via compare_order
instantiation
  ereal :: complete_lattice
  Inf_ereal == Inf :: ereal set => ereal
  Sup_ereal == Sup :: ereal set => ereal
  bot_ereal == bot :: ereal
  top_ereal == top :: ereal
derived is_ccompare_unit-lemma
deriving "ccompare_order" instance for type "HOL.bool" via compare_order
derived is_ccompare_bool-lemma
deriving "ccompare_order" instance for type "Nat.nat" via compare_order
derived is_ccompare_nat-lemma
deriving "ccompare_order" instance for type "Int.int" via compare_order
### Ignoring duplicate rewrite rule:
### balance Empty ?s1 ?t1 Empty == Branch B Empty ?s1 ?t1 Empty
### Ignoring duplicate rewrite rule:
### balance (Branch B ?va1 ?vb1 ?vc1 ?vd1) ?s1 ?t1 Empty ==
### Branch B (Branch B ?va1 ?vb1 ?vc1 ?vd1) ?s1 ?t1 Empty
### Ignoring duplicate rewrite rule:
### balance Empty ?s1 ?t1 (Branch B ?va1 ?vb1 ?vc1 ?vd1) ==
### Branch B Empty ?s1 ?t1 (Branch B ?va1 ?vb1 ?vc1 ?vd1)
derived is_ccompare_int-lemma
deriving "ccompare_order" instance for type "Enum.finite_1" via compare_order
derived is_ccompare_finite_1-lemma
deriving "ccompare_order" instance for type "Enum.finite_2" via compare_order
derived is_ccompare_finite_2-lemma
deriving "ccompare_order" instance for type "Enum.finite_3" via compare_order
derived is_ccompare_finite_3-lemma
deriving "ccompare_order" instance for type "Code_Numeral.integer" via compare_order
derived is_ccompare_integer-lemma
deriving "ccompare_order" instance for type "Code_Numeral.natural" via compare_order
derived is_ccompare_natural-lemma
deriving "ccompare_order" instance for type "String.char" via compare_order
derived is_ccompare_char-lemma
deriving "ccompare_order" instance for type "String.literal" via compare_order
derived is_ccompare_literal-lemma
use None as trivial implementation of ccompare for type finite_4
instantiation
  ereal :: linear_continuum_topology
  open_ereal == open :: ereal set => bool
registered finite_4 in class ccompare
use None as trivial implementation of ccompare for type finite_5
registered finite_5 in class ccompare
deriving "ccompare" instance for type "Sum_Type.sum"
derived is_ccompare_sum-lemma
deriving "ccompare" instance for type "List.list"
derived is_ccompare_list-lemma
deriving "ccompare" instance for type "Option.option"
derived is_ccompare_option-lemma
deriving "ccompare" instance for type "Product_Type.prod"
derived is_ccompare_prod-lemma
use None as trivial implementation of ccompare for type fun
registered fun in class ccompare
instantiation
  set :: (ccompare) ccompare
  ccompare_set == ccompare :: ('a set => 'a set => order) option
use None as trivial implementation of ccompare for type pred
registered pred in class ccompare
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
class cproper_interval = ccompare +
  fixes cproper_interval :: "'a option => 'a option => bool"
  assumes
    "cproper_interval":
      "[| ID ccompare ~= None; finite UNIV |]
       ==> class.proper_interval cless cproper_interval"
instantiation
  unit :: cproper_interval
  cproper_interval_unit == cproper_interval ::
    unit option => unit option => bool
instantiation
  bool :: cproper_interval
  cproper_interval_bool == cproper_interval ::
    bool option => bool option => bool
instantiation
  nat :: cproper_interval
  cproper_interval_nat == cproper_interval ::
    nat option => nat option => bool
instantiation
  int :: cproper_interval
  cproper_interval_int == cproper_interval ::
    int option => int option => bool
instantiation
  integer :: cproper_interval
  cproper_interval_integer == cproper_interval ::
    integer option => integer option => bool
instantiation
  natural :: cproper_interval
  cproper_interval_natural == cproper_interval ::
    natural option => natural option => bool
instantiation
  char :: cproper_interval
  cproper_interval_char == cproper_interval ::
    char option => char option => bool
instantiation
  Enum.finite_1 :: cproper_interval
  cproper_interval_finite_1 == cproper_interval ::
    Enum.finite_1 option => Enum.finite_1 option => bool
instantiation
  Enum.finite_2 :: cproper_interval
  cproper_interval_finite_2 == cproper_interval ::
    Enum.finite_2 option => Enum.finite_2 option => bool
instantiation
  Enum.finite_3 :: cproper_interval
  cproper_interval_finite_3 == cproper_interval ::
    Enum.finite_3 option => Enum.finite_3 option => bool
consts
  paint :: "color => ('a, 'b) rbt => ('a, 'b) rbt"
instantiation
  Enum.finite_4 :: cproper_interval
  cproper_interval_finite_4 == cproper_interval ::
    Enum.finite_4 option => Enum.finite_4 option => bool
instantiation
  Enum.finite_5 :: cproper_interval
  cproper_interval_finite_5 == cproper_interval ::
    Enum.finite_5 option => Enum.finite_5 option => bool
instantiation
  sum :: (cproper_interval, cproper_interval) cproper_interval
  cproper_interval_sum == cproper_interval ::
    ('a + 'b) option => ('a + 'b) option => bool
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
Found termination order: "{}"
instantiation
  prod :: (cproper_interval, cproper_interval) cproper_interval
  cproper_interval_prod == cproper_interval ::
    ('a * 'b) option => ('a * 'b) option => bool
Found termination order: "{}"
instantiation
  list :: (ccompare) cproper_interval
  cproper_interval_list == cproper_interval ::
    'a list option => 'a list option => bool
instantiation
  String.literal :: cproper_interval
  cproper_interval_literal == cproper_interval ::
    String.literal option => String.literal option => bool
instantiation
  option :: (cproper_interval) cproper_interval
  cproper_interval_option == cproper_interval ::
    'a option option => 'a option option => bool
### theory "HOL-Library.Extended_Real"
### 2.593s elapsed time, 8.122s cpu time, 0.818s GC time
Loading theory "Draft.Timestamp" (required by "Draft.Monitor_CodeMoreTemplates" via "Draft.Monitor_Code" via "Draft.Monitor" via "Draft.MDL" via "Draft.Interval")
Found termination order: "{}"
instantiation
  set :: (cproper_interval) cproper_interval
  cproper_interval_set == cproper_interval ::
    'a set option => 'a set option => bool
"- \<infinity>"
  :: "ereal"
Found termination order: "(%p. size (snd (snd (snd p)))) <*mlex*> {}"
### Not an equation, in theorem:
### cproper_interval_set_dom (None, None) ==> cproper_interval None None == True
### Not an equation, in theorem:
### cproper_interval_set_dom (None, Some ?B) ==>
### cproper_interval None (Some ?B) == ?B ~= {}
### Not an equation, in theorem:
### cproper_interval_set_dom (Some ?A, None) ==>
### cproper_interval (Some ?A) None == ?A ~= UNIV
### Not an equation, in theorem:
### cproper_interval_set_dom (Some ?A, Some ?B) ==>
### cproper_interval (Some ?A) (Some ?B) ==
### finite UNIV & (EX C. cless ?A C & cless C ?B)
Found termination order: "{}"
instantiation
  fun :: (type, type) cproper_interval
  cproper_interval_fun == cproper_interval ::
    ('a => 'b) option => ('a => 'b) option => bool
"\<infinity>"
  :: "ereal"
### theory "Containers.Collection_Order"
### 1.651s elapsed time, 5.475s cpu time, 0.641s GC time
"True"
  :: "bool"
"True"
  :: "bool"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
class timestamp = comm_monoid_add + semilattice_sup +
  fixes tfin :: "'a set"
    and \<iota> :: "nat => 'a"
  assumes "\<iota>_mono": "!!i j. i <= j ==> \<iota> i <= \<iota> j"
    and "\<iota>_fin": "!!i. \<iota> i : tfin"
    and
    "\<iota>_progressing":
      "!!x i. x : tfin ==> EX j. ~ \<iota> j <= \<iota> i + x"
    and "zero_tfin": "(0::'a) : tfin"
    and "tfin_closed": "!!c d. [| c : tfin; d : tfin |] ==> c + d : tfin"
    and "add_mono": "!!c d a. c <= d ==> a + c <= a + d"
    and "add_pos": "!!a c. [| a : tfin; (0::'a) < c |] ==> a < a + c"
instantiation
  prod :: (comm_monoid_add, comm_monoid_add) comm_monoid_add
  zero_prod == zero_class.zero :: 'a * 'b
  plus_prod == plus :: 'a * 'b => 'a * 'b => 'a * 'b
Found termination order: "{}"
"ereal (13 / 4)"
  :: "ereal"
instantiation
  enat :: timestamp
  tfin_enat == tfin :: enat set
  \<iota>_enat == \<iota> :: nat => enat
instantiation
  ereal :: timestamp
  tfin_ereal == tfin :: ereal set
  \<iota>_ereal == \<iota> :: nat => ereal
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
class timestamp_strict = timestamp +
  assumes "timestamp_strict_total": "!!a b. a <= b | b <= a"
    and "add_mono_strict": "!!c d a. c < d ==> a + c < a + d"
instantiation
  nat :: timestamp_strict
  tfin_nat == tfin :: nat set
  \<iota>_nat == \<iota> :: nat => nat
instantiation
  real :: timestamp_strict
  tfin_real == tfin :: real set
  \<iota>_real == \<iota> :: nat => real
Found termination order: "{}"
class order = preorder +
  assumes "order_antisym": "!!x y. [| x <= y; y <= x |] ==> x = y"
class timestamp_total = timestamp +
  assumes "timestamp_total": "!!a b. a <= b | b <= a"
  assumes
    "aux":
      "!!a c b.
          [| (0::'a) <= a; a <= c; a : tfin; c : tfin; (0::'a) <= b;
             b ~: tfin |]
          ==> c < a + b"
instantiation
  enat :: timestamp_total
instantiation
  ereal :: timestamp_total
class timestamp_total_strict = timestamp_total +
  assumes "add_mono_strict_total": "!!c d a. c < d ==> a + c < a + d"
instantiation
  nat :: timestamp_total_strict
instantiation
  real :: timestamp_total_strict
### theory "Draft.Timestamp"
### 1.426s elapsed time, 3.931s cpu time, 0.312s GC time
Loading theory "Draft.Interval" (required by "Draft.Monitor_CodeMoreTemplates" via "Draft.Monitor_Code" via "Draft.Monitor" via "Draft.MDL")
Loading theory "Draft.Trace" (required by "Draft.Monitor_CodeMoreTemplates" via "Draft.Monitor_Code" via "Draft.Monitor" via "Draft.MDL")
Loading theory "Draft.Window" (required by "Draft.Monitor_CodeMoreTemplates" via "Draft.Monitor_Code" via "Draft.Monitor" via "Draft.Temporal")
Found termination order: "{}"
class order = preorder +
  assumes "order_antisym": "!!x y. [| x <= y; y <= x |] ==> x = y"
Proofs for inductive predicate(s) "sorted_list"
  Proving monotonicity ...
instantiation
  \<I> :: (timestamp) equal
  equal_\<I> == equal_class.equal :: 'a \<I> => 'a \<I> => bool
Proofs for coinductive predicate(s) "ssorted"
  Proving monotonicity ...
Proofs for inductive predicate(s) "chain_le"
  Proving monotonicity ...
Proofs for inductive predicate(s) "reaches_on"
Found termination order:
  "(%p. size (snd p)) <*mlex*> (%p. size (fst p)) <*mlex*> {}"
  Proving monotonicity ...
### theory "Draft.Trace"
### 0.758s elapsed time, 2.991s cpu time, 0.414s GC time
Proofs for inductive predicate(s) "reaches"
  Proving monotonicity ...
### theory "Draft.Interval"
### 0.809s elapsed time, 3.141s cpu time, 0.414s GC time
Loading theory "Draft.MDL" (required by "Draft.Monitor_CodeMoreTemplates" via "Draft.Monitor_Code" via "Draft.Monitor")
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
Found termination order: "{}"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
### The transfer theorems can't be generated:
### No quotient theorem has been registered for window_ext.
### Use setup_lifting to register a quotient or type definition theorem.
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
consts
  mmap_combine ::
    "'key
     => 'val
        => ('val => 'val => 'val)
           => ('key * 'val) list => ('key * 'val) list"
Found termination order:
  "(%p. size_list (%p. size_option (%p. size (snd p)) (snd (snd p)))
         (snd (snd (snd (snd (snd (snd (snd p)))))))) <*mlex*>
   {}"
### theory "Draft.Window"
### 4.455s elapsed time, 14.815s cpu time, 4.663s GC time
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order:
  "case_sum (%p. size (fst (snd p)))
    (case_sum (%p. size (snd (snd (snd (snd p)))))
      (%p. size (snd p))) <*mlex*>
   case_sum (%x. Suc 0) (%x. 0) <*mlex*>
   case_sum (%x. 0) (case_sum (%x. Suc 0) (%x. 0)) <*mlex*> {}"
Found termination order: "case_sum size size <*mlex*> {}"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
consts
  rbt_map_entry :: "'a => ('b => 'b) => ('a, 'b) rbt => ('a, 'b) rbt"
consts
  map :: "('a => 'b => 'c) => ('a, 'b) rbt => ('a, 'c) rbt"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
Found termination order: "case_sum size size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
locale MDL
  fixes \<sigma> :: "('a, 't) trace"
Found termination order: "(%p. size (fst (snd (snd p)))) <*mlex*> {}"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
Found termination order: "case_sum (%p. size (fst p)) size <*mlex*> {}"
### theory "Draft.MDL"
### 7.221s elapsed time, 21.012s cpu time, 8.537s GC time
Loading theory "Draft.Preliminaries" (required by "Draft.Monitor_CodeMoreTemplates" via "Draft.Monitor_Code")
Loading theory "Draft.Temporal" (required by "Draft.Monitor_CodeMoreTemplates" via "Draft.Monitor_Code" via "Draft.Monitor")
Found termination order: "size <*mlex*> {}"
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
locale MDL
  fixes \<sigma> :: "('a, 't) trace"
Found termination order: "(%p. size_list size (fst p)) <*mlex*> {}"
Found termination order:
  "case_sum (%p. size (fst p)) (%p. size (fst p)) <*mlex*> {}"
Found termination order: "{}"
Found termination order: "size <*mlex*> {}"
Found termination order: "{}"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
locale MDL_window
  fixes \<sigma> :: "('a, 'd) trace"
    and r :: "('a, 'd) regex"
    and t0 :: "'t"
    and sub :: "'e"
    and args :: "(bool iarray, nat set, 'd, 't, 'e) Window.args"
  assumes "MDL_window \<sigma> r t0 sub args"
Found termination order: "{}"
### theory "Draft.Temporal"
### 2.734s elapsed time, 8.428s cpu time, 1.083s GC time
Loading theory "Draft.Monitor" (required by "Draft.Monitor_CodeMoreTemplates" via "Draft.Monitor_Code")
[| valid_matchP ?I t0 sub ?rho ?j ?w;
   w_run_t args (w_tj ?w) = Some (?tj''', ?t);
   w_run_sub args (w_sj ?w) = Some (?sj''', ?b); wf_regex r |]
==> EX w'.
       eval_mP ?I ?w =
       Some ((\<tau> \<sigma> ?j, sat (MatchP ?I r) ?j), w') &
       ?t = \<tau> \<sigma> ?j &
       valid_matchP ?I t0 sub (?rho @ [(?t, ?b)]) (Suc ?j) w'
[| valid_matchF ?I t0 sub ?rho ?i ?w; eval_mF ?I ?w = Some ((?t, ?b), ?w'');
   right ?I : tfin; wf_regex r |]
==> ?t = \<tau> \<sigma> ?i &
    ?b = sat (MatchF ?I r) ?i &
    (EX rho'. valid_matchF ?I t0 sub rho' (Suc ?i) ?w'')
[| valid_matchF ?I t0 sub ?rho ?i ?w;
   reaches_on (w_run_t args) (w_tj ?w) (map fst ?rho') ?tj''';
   reaches_on (w_run_sub args) (w_sj ?w) (map snd ?rho') ?sj''';
   w_read_t args (w_ti ?w) = Some ?t; w_read_t args ?tj''' = Some ?tm;
   ~ memR ?t ?tm ?I; wf_regex r |]
==> EX w'.
       eval_mF ?I ?w =
       Some ((\<tau> \<sigma> ?i, sat (MatchF ?I r) ?i), w') &
       valid_matchF ?I t0 sub (take (w_j w') (?rho @ ?rho')) (Suc ?i) w'
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
Found termination order: "case_sum size size <*mlex*> {}"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
locale MDL
  fixes \<sigma> :: "('a, 't) trace"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
### Ambiguous input (line 1808 of "~~/src/HOL/Library/RBT_Impl.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("_applC" ("_position" sorted)
###         ("_applC" ("_position" map)
###           ("_cargs" ("_position" fst) ("_position" xs)))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("_applC" ("_position" sorted)
###           ("_applC" ("_position" map)
###             ("_cargs" ("_position" fst) ("_position" ys)))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("_applC" ("_position" map_of)
###         ("_cargs"
###           ("_applC" ("_position" sunion_with)
###             ("_cargs" ("_position" f)
###               ("_cargs" ("_position" xs) ("_position" ys))))
###           ("_position" k)))
###       ("_case_syntax"
###         ("_applC" ("_position" map_of)
###           ("_cargs" ("_position" xs) ("_position" k)))
###         ("_case2"
###           ("_case1" ("_position" None)
###             ("_applC" ("_position" map_of)
###               ("_cargs" ("_position" ys) ("_position" k))))
###           ("_case1" ("_applC" ("_position" Some) ("_position" v))
###             ("_case_syntax"
###               ("_applC" ("_position" map_of)
###                 ("_cargs" ("_position" ys) ("_position" k)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Some) ("_position" v)))
###                 ("_case1" ("_applC" ("_position" Some) ("_position" w))
###                   ("_applC" ("_position" Some)
###                     ("_applC" ("_position" f)
###                       ("_cargs" ("_position" k)
###                         ("_cargs" ("_position" v)
###                           ("_position" w))))))))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("_applC" ("_position" sorted)
###         ("_applC" ("_position" map)
###           ("_cargs" ("_position" fst) ("_position" xs)))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("_applC" ("_position" sorted)
###           ("_applC" ("_position" map)
###             ("_cargs" ("_position" fst) ("_position" ys)))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("_applC" ("_position" map_of)
###         ("_cargs"
###           ("_applC" ("_position" sunion_with)
###             ("_cargs" ("_position" f)
###               ("_cargs" ("_position" xs) ("_position" ys))))
###           ("_position" k)))
###       ("_case_syntax"
###         ("_applC" ("_position" map_of)
###           ("_cargs" ("_position" xs) ("_position" k)))
###         ("_case2"
###           ("_case1" ("_position" None)
###             ("_applC" ("_position" map_of)
###               ("_cargs" ("_position" ys) ("_position" k))))
###           ("_case2"
###             ("_case1" ("_applC" ("_position" Some) ("_position" v))
###               ("_case_syntax"
###                 ("_applC" ("_position" map_of)
###                   ("_cargs" ("_position" ys) ("_position" k)))
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Some) ("_position" v)))))
###             ("_case1" ("_applC" ("_position" Some) ("_position" w))
###               ("_applC" ("_position" Some)
###                 ("_applC" ("_position" f)
###                   ("_cargs" ("_position" k)
###                     ("_cargs" ("_position" v) ("_position" w))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Found termination order: "case_sum (%p. size (fst p)) size <*mlex*> {}"
### theory "Draft.Preliminaries"
### 4.887s elapsed time, 15.119s cpu time, 1.901s GC time
Found termination order: "{}"
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "case_sum size size <*mlex*> {}"
Found termination order:
  "(%p. size (snd p)) <*mlex*> (%p. size (fst p)) <*mlex*> {}"
Found termination order: "(%p. size (snd (snd (snd p)))) <*mlex*> {}"
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
Found termination order: "{}"
Found termination order: "size <*mlex*> {}"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
locale VYDRA_MDL
  fixes \<sigma> :: "('a, 't) trace"
    and init_hd :: "'h"
    and run_hd :: "'h => ('h * 't * 'a set) option"
  assumes "VYDRA_MDL \<sigma> init_hd run_hd"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
Proofs for inductive predicate(s) "wf_vydra"
  Proving monotonicity ...
locale MDL
  fixes \<sigma> :: "('a, 't) trace"
### theory "Draft.Monitor"
### 7.457s elapsed time, 18.391s cpu time, 2.438s GC time
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
### Ambiguous input (line 2563 of "~~/src/HOL/Library/RBT_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" rbt_lookup)
###       ("_cargs"
###         ("_applC" ("_position" fold)
###           ("_cargs"
###             ("_applC" ("_position" rbt_insert_with_key) ("_position" f))
###             ("_cargs" ("_position" t1) ("_position" t2))))
###         ("_position" k)))
###     ("_case_syntax"
###       ("_applC" ("_position" rbt_lookup)
###         ("_cargs" ("_position" t1) ("_position" k)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" rbt_lookup)
###             ("_cargs" ("_position" t2) ("_position" k))))
###         ("_case1" ("_applC" ("_position" Some) ("_position" v))
###           ("_case_syntax"
###             ("_applC" ("_position" rbt_lookup)
###               ("_cargs" ("_position" t2) ("_position" k)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Some) ("_position" v)))
###               ("_case1" ("_applC" ("_position" Some) ("_position" w))
###                 ("_applC" ("_position" Some)
###                   ("_applC" ("_position" f)
###                     ("_cargs" ("_position" k)
###                       ("_cargs" ("_position" w) ("_position" v)))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" rbt_lookup)
###       ("_cargs"
###         ("_applC" ("_position" fold)
###           ("_cargs"
###             ("_applC" ("_position" rbt_insert_with_key) ("_position" f))
###             ("_cargs" ("_position" t1) ("_position" t2))))
###         ("_position" k)))
###     ("_case_syntax"
###       ("_applC" ("_position" rbt_lookup)
###         ("_cargs" ("_position" t1) ("_position" k)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" rbt_lookup)
###             ("_cargs" ("_position" t2) ("_position" k))))
###         ("_case2"
###           ("_case1" ("_applC" ("_position" Some) ("_position" v))
###             ("_case_syntax"
###               ("_applC" ("_position" rbt_lookup)
###                 ("_cargs" ("_position" t2) ("_position" k)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Some) ("_position" v)))))
###           ("_case1" ("_applC" ("_position" Some) ("_position" w))
###             ("_applC" ("_position" Some)
###               ("_applC" ("_position" f)
###                 ("_cargs" ("_position" k)
###                   ("_cargs" ("_position" w) ("_position" v)))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
### Ambiguous input (line 2939 of "~~/src/HOL/Library/RBT_Impl.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("_applC" ("_position" rbt_sorted) ("_position" t1)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("_applC" ("_position" rbt_sorted) ("_position" t2)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("_applC" ("_position" rbt_lookup)
###         ("_cargs"
###           ("_applC" ("_position" rbt_union_with_key)
###             ("_cargs" ("_position" f)
###               ("_cargs" ("_position" t1) ("_position" t2))))
###           ("_position" k)))
###       ("_case_syntax"
###         ("_applC" ("_position" rbt_lookup)
###           ("_cargs" ("_position" t1) ("_position" k)))
###         ("_case2"
###           ("_case1" ("_position" None)
###             ("_applC" ("_position" rbt_lookup)
###               ("_cargs" ("_position" t2) ("_position" k))))
###           ("_case1" ("_applC" ("_position" Some) ("_position" v))
###             ("_case_syntax"
###               ("_applC" ("_position" rbt_lookup)
###                 ("_cargs" ("_position" t2) ("_position" k)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Some) ("_position" v)))
###                 ("_case1" ("_applC" ("_position" Some) ("_position" w))
###                   ("_applC" ("_position" Some)
###                     ("_applC" ("_position" f)
###                       ("_cargs" ("_position" k)
###                         ("_cargs" ("_position" v)
###                           ("_position" w))))))))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("_applC" ("_position" rbt_sorted) ("_position" t1)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("_applC" ("_position" rbt_sorted) ("_position" t2)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("_applC" ("_position" rbt_lookup)
###         ("_cargs"
###           ("_applC" ("_position" rbt_union_with_key)
###             ("_cargs" ("_position" f)
###               ("_cargs" ("_position" t1) ("_position" t2))))
###           ("_position" k)))
###       ("_case_syntax"
###         ("_applC" ("_position" rbt_lookup)
###           ("_cargs" ("_position" t1) ("_position" k)))
###         ("_case2"
###           ("_case1" ("_position" None)
###             ("_applC" ("_position" rbt_lookup)
###               ("_cargs" ("_position" t2) ("_position" k))))
###           ("_case2"
###             ("_case1" ("_applC" ("_position" Some) ("_position" v))
###               ("_case_syntax"
###                 ("_applC" ("_position" rbt_lookup)
###                   ("_cargs" ("_position" t2) ("_position" k)))
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Some) ("_position" v)))))
###             ("_case1" ("_applC" ("_position" Some) ("_position" w))
###               ("_applC" ("_position" Some)
###                 ("_applC" ("_position" f)
###                   ("_cargs" ("_position" k)
###                     ("_cargs" ("_position" v) ("_position" w))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2972 of "~~/src/HOL/Library/RBT_Impl.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("_applC" ("_position" rbt_sorted) ("_position" t1)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("_applC" ("_position" rbt_sorted) ("_position" t2)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("_applC" ("_position" rbt_lookup)
###         ("_cargs"
###           ("_applC" ("_position" rbt_inter_with_key)
###             ("_cargs" ("_position" f)
###               ("_cargs" ("_position" t1) ("_position" t2))))
###           ("_position" k)))
###       ("_case_syntax"
###         ("_applC" ("_position" rbt_lookup)
###           ("_cargs" ("_position" t1) ("_position" k)))
###         ("_case2" ("_case1" ("_position" None) ("_position" None))
###           ("_case1" ("_applC" ("_position" Some) ("_position" v))
###             ("_case_syntax"
###               ("_applC" ("_position" rbt_lookup)
###                 ("_cargs" ("_position" t2) ("_position" k)))
###               ("_case2" ("_case1" ("_position" None) ("_position" None))
###                 ("_case1" ("_applC" ("_position" Some) ("_position" w))
###                   ("_applC" ("_position" Some)
###                     ("_applC" ("_position" f)
###                       ("_cargs" ("_position" k)
###                         ("_cargs" ("_position" v)
###                           ("_position" w))))))))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("_applC" ("_position" rbt_sorted) ("_position" t1)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("_applC" ("_position" rbt_sorted) ("_position" t2)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("_applC" ("_position" rbt_lookup)
###         ("_cargs"
###           ("_applC" ("_position" rbt_inter_with_key)
###             ("_cargs" ("_position" f)
###               ("_cargs" ("_position" t1) ("_position" t2))))
###           ("_position" k)))
###       ("_case_syntax"
###         ("_applC" ("_position" rbt_lookup)
###           ("_cargs" ("_position" t1) ("_position" k)))
###         ("_case2" ("_case1" ("_position" None) ("_position" None))
###           ("_case2"
###             ("_case1" ("_applC" ("_position" Some) ("_position" v))
###               ("_case_syntax"
###                 ("_applC" ("_position" rbt_lookup)
###                   ("_cargs" ("_position" t2) ("_position" k)))
###                 ("_case1" ("_position" None) ("_position" None))))
###             ("_case1" ("_applC" ("_position" Some) ("_position" w))
###               ("_applC" ("_position" Some)
###                 ("_applC" ("_position" f)
###                   ("_cargs" ("_position" k)
###                     ("_cargs" ("_position" v) ("_position" w))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Code generator: dropping subsumed code equation
### keys (Branch ?c ?l ?k ?v ?r) == keys ?l @ ?k # keys ?r
### Code generator: dropping subsumed code equation
### keys Empty == []
### theory "HOL-Library.RBT_Impl"
### 37.830s elapsed time, 105.648s cpu time, 24.634s GC time
Loading theory "Containers.RBT_ext" (required by "Draft.Monitor_CodeMoreTemplates" via "Draft.Monitor_Code" via "Containers.Containers" via "Containers.Mapping_Impl" via "Containers.RBT_Mapping2")
Loading theory "Deriving.RBT_Comparator_Impl" (required by "Draft.Monitor_CodeMoreTemplates" via "Draft.Monitor_Code" via "Containers.Containers" via "Containers.Mapping_Impl" via "Containers.RBT_Mapping2")
consts
  rbt_comp_lookup :: "('a, 'b) rbt => 'a => 'b option"
Found termination order: "(%p. size (snd (snd (snd p)))) <*mlex*> {}"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
### Dropping global mixfix syntax: "less_eq_prod'" (infix \<open>\<sqsubseteq>\<close> 50)
### Dropping global mixfix syntax: "less_prod'" (infix \<open>\<sqsubset>\<close> 50)
consts
  RBT_Impl_diag :: "('a, 'b) rbt => ('a * 'a, 'b) rbt"
Found termination order: "{}"
### Missing patterns in function definition:
### rbt_keys_next ([], rbt.Empty) = undefined
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
### Missing patterns in function definition:
### rbt_entries_next ([], rbt.Empty) = undefined
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
### theory "Containers.RBT_ext"
### 1.440s elapsed time, 3.864s cpu time, 0.598s GC time
Found termination order:
  "case_sum (%p. size (fst (snd p)))
    (case_sum (%p. size (snd (snd (snd (snd p)))))
      (%p. size (snd p))) <*mlex*>
   case_sum (%x. Suc 0) (%x. 0) <*mlex*>
   case_sum (%x. 0) (case_sum (%x. Suc 0) (%x. 0)) <*mlex*> {}"
consts
  rbt_comp_map_entry :: "'a => ('b => 'b) => ('a, 'b) rbt => ('a, 'b) rbt"
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
### theory "Deriving.RBT_Comparator_Impl"
### 4.202s elapsed time, 7.018s cpu time, 1.168s GC time
Loading theory "Containers.RBT_Mapping2" (required by "Draft.Monitor_CodeMoreTemplates" via "Draft.Monitor_Code" via "Containers.Containers" via "Containers.Mapping_Impl")
### Ambiguous input (line 247 of "$AFP/Containers/RBT_Mapping2.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" lookup)
###       ("_applC" ("_position" meet)
###         ("_cargs" ("_position" f)
###           ("_cargs"
###             ("_constrain" ("_position" t1)
###               ("_tappl" ("_position_sort" 'a) ("_position_sort" 'b)
###                 ("_type_name" mapping_rbt)))
###             ("_position" t2)))))
###     ("_lambda" ("_position" k)
###       ("_case_syntax"
###         ("_applC" ("_position" lookup)
###           ("_cargs" ("_position" t1) ("_position" k)))
###         ("_case2" ("_case1" ("_position" None) ("_position" None))
###           ("_case1" ("_applC" ("_position" Some) ("_position" v1))
###             ("_case_syntax"
###               ("_applC" ("_position" lookup)
###                 ("_cargs" ("_position" t2) ("_position" k)))
###               ("_case2" ("_case1" ("_position" None) ("_position" None))
###                 ("_case1" ("_applC" ("_position" Some) ("_position" v2))
###                   ("_applC" ("_position" Some)
###                     ("_applC" ("_position" f)
###                       ("_cargs" ("_position" k)
###                         ("_cargs" ("_position" v1)
###                           ("_position" v2))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" lookup)
###       ("_applC" ("_position" meet)
###         ("_cargs" ("_position" f)
###           ("_cargs"
###             ("_constrain" ("_position" t1)
###               ("_tappl" ("_position_sort" 'a) ("_position_sort" 'b)
###                 ("_type_name" mapping_rbt)))
###             ("_position" t2)))))
###     ("_lambda" ("_position" k)
###       ("_case_syntax"
###         ("_applC" ("_position" lookup)
###           ("_cargs" ("_position" t1) ("_position" k)))
###         ("_case2" ("_case1" ("_position" None) ("_position" None))
###           ("_case2"
###             ("_case1" ("_applC" ("_position" Some) ("_position" v1))
###               ("_case_syntax"
###                 ("_applC" ("_position" lookup)
###                   ("_cargs" ("_position" t2) ("_position" k)))
###                 ("_case1" ("_position" None) ("_position" None))))
###             ("_case1" ("_applC" ("_position" Some) ("_position" v2))
###               ("_applC" ("_position" Some)
###                 ("_applC" ("_position" f)
###                   ("_cargs" ("_position" k)
###                     ("_cargs" ("_position" v1) ("_position" v2))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "Containers.RBT_Mapping2"
### 27.420s elapsed time, 86.976s cpu time, 86.084s GC time
Loading theory "Containers.RBT_Set2" (required by "Draft.Monitor_CodeMoreTemplates" via "Draft.Monitor_Code" via "Containers.Containers" via "Containers.Mapping_Impl" via "Containers.Set_Impl")
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
### theory "Containers.RBT_Set2"
### 1.001s elapsed time, 1.072s cpu time, 0.096s GC time
Loading theory "Containers.Set_Impl" (required by "Draft.Monitor_CodeMoreTemplates" via "Draft.Monitor_Code" via "Containers.Containers" via "Containers.Mapping_Impl")
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
Found termination order: "length <*mlex*> {}"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
structure Set_Complement_Eqs: NAMED_THMS
### Code generator: dropping subsumed code equation
### Collect ?P == set (filter ?P enum_class.enum)
### Ambiguous input (line 739 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Set.union" ("_applC" ("_position" RBT_set) ("_position" rbt))
###       ("_applC" ("_position" DList_set) ("_position" dxs)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''union RBT_set DList_set: ccompare = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Set.union"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt))
###                   ("_applC" ("_position" DList_set) ("_position" dxs)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'b)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position" ''union RBT_set DList_set: ceq = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Set.union"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs)))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_applC" ("_position" RBT_set)
###                   ("_applC" ("_position" DList_Set.fold)
###                     ("_cargs" ("_position" RBT_Set2.insert)
###                       ("_cargs" ("_position" dxs)
###                         ("_position" rbt)))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Set.union" ("_applC" ("_position" RBT_set) ("_position" rbt))
###       ("_applC" ("_position" DList_set) ("_position" dxs)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''union RBT_set DList_set: ccompare = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Set.union"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt))
###                   ("_applC" ("_position" DList_set) ("_position" dxs)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'b)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position" ''union RBT_set DList_set: ceq = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Set.union"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs)))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_applC" ("_position" RBT_set)
###               ("_applC" ("_position" DList_Set.fold)
###                 ("_cargs" ("_position" RBT_Set2.insert)
###                   ("_cargs" ("_position" dxs) ("_position" rbt)))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 744 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Set.union"
###       ("_applC" ("_position" DList_set) ("_position" dxs))
###       ("_applC" ("_position" RBT_set) ("_position" rbt)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''union DList_set RBT_set: ccompare = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Set.union"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt))
###                   ("_applC" ("_position" DList_set) ("_position" dxs)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'b)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position" ''union DList_set RBT_set: ceq = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Set.union"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs)))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_applC" ("_position" RBT_set)
###                   ("_applC" ("_position" DList_Set.fold)
###                     ("_cargs" ("_position" RBT_Set2.insert)
###                       ("_cargs" ("_position" dxs)
###                         ("_position" rbt)))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Set.union"
###       ("_applC" ("_position" DList_set) ("_position" dxs))
###       ("_applC" ("_position" RBT_set) ("_position" rbt)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''union DList_set RBT_set: ccompare = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Set.union"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt))
###                   ("_applC" ("_position" DList_set) ("_position" dxs)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'b)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position" ''union DList_set RBT_set: ceq = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Set.union"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs)))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_applC" ("_position" RBT_set)
###               ("_applC" ("_position" DList_Set.fold)
###                 ("_cargs" ("_position" RBT_Set2.insert)
###                   ("_cargs" ("_position" dxs) ("_position" rbt)))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 823 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Set.inter"
###       ("_applC" ("_position" DList_set) ("_position" dxs))
###       ("_applC" ("_position" RBT_set) ("_position" rbt)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''inter DList_set RBT_set: ccompare = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Set.inter"
###                   ("_applC" ("_position" DList_set) ("_position" dxs))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'b)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position" ''inter DList_set RBT_set: ceq = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Set.inter"
###                         ("_applC" ("_position" DList_set) ("_position" dxs))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt)))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_applC" ("_position" RBT_set)
###                   ("_applC" ("_position" RBT_Set2.inter_list)
###                     ("_cargs" ("_position" rbt)
###                       ("_applC" ("_position" list_of_dlist)
###                         ("_position" dxs)))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Set.inter"
###       ("_applC" ("_position" DList_set) ("_position" dxs))
###       ("_applC" ("_position" RBT_set) ("_position" rbt)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''inter DList_set RBT_set: ccompare = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Set.inter"
###                   ("_applC" ("_position" DList_set) ("_position" dxs))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'b)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position" ''inter DList_set RBT_set: ceq = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Set.inter"
###                         ("_applC" ("_position" DList_set) ("_position" dxs))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt)))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_applC" ("_position" RBT_set)
###               ("_applC" ("_position" RBT_Set2.inter_list)
###                 ("_cargs" ("_position" rbt)
###                   ("_applC" ("_position" list_of_dlist)
###                     ("_position" dxs)))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 838 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Set.inter" ("_applC" ("_position" RBT_set) ("_position" rbt))
###       ("_applC" ("_position" DList_set) ("_position" dxs)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''inter RBT_set DList_set: ccompare = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Set.inter"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt))
###                   ("_applC" ("_position" DList_set) ("_position" dxs)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'b)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position" ''inter RBT_set DList_set: ceq = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Set.inter"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs)))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_applC" ("_position" RBT_set)
###                   ("_applC" ("_position" RBT_Set2.inter_list)
###                     ("_cargs" ("_position" rbt)
###                       ("_applC" ("_position" list_of_dlist)
###                         ("_position" dxs)))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Set.inter" ("_applC" ("_position" RBT_set) ("_position" rbt))
###       ("_applC" ("_position" DList_set) ("_position" dxs)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''inter RBT_set DList_set: ccompare = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Set.inter"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt))
###                   ("_applC" ("_position" DList_set) ("_position" dxs)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'b)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position" ''inter RBT_set DList_set: ceq = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Set.inter"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs)))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_applC" ("_position" RBT_set)
###               ("_applC" ("_position" RBT_Set2.inter_list)
###                 ("_cargs" ("_position" rbt)
###                   ("_applC" ("_position" list_of_dlist)
###                     ("_position" dxs)))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Code generator: dropping subsumed code equation
### Inf ?A ?x == INF f\<in>?A. f ?x
### Code generator: dropping subsumed code equation
### Sup ?A ?x == SUP f\<in>?A. f ?x
### Ambiguous input (line 951 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" csorted_list_of_set)
###       ("_applC" ("_position" DList_set) ("_position" dxs)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'b)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''csorted_list_of_set DList_set: ceq = None''))
###               ("_lambda" ("_idtdummy")
###                 ("_applC" ("_position" csorted_list_of_set)
###                   ("_applC" ("_position" DList_set) ("_position" dxs)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''csorted_list_of_set DList_set: ccompare = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("_applC" ("_position" csorted_list_of_set)
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs)))))))
###               ("_case1" ("_applC" ("_position" Some) ("_position" c))
###                 ("_applC" ("_position" ord.quicksort)
###                   ("_cargs"
###                     ("_applC" ("_position" lt_of_comp) ("_position" c))
###                     ("_applC" ("_position" list_of_dlist)
###                       ("_position" dxs))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" csorted_list_of_set)
###       ("_applC" ("_position" DList_set) ("_position" dxs)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'b)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''csorted_list_of_set DList_set: ceq = None''))
###               ("_lambda" ("_idtdummy")
###                 ("_applC" ("_position" csorted_list_of_set)
###                   ("_applC" ("_position" DList_set) ("_position" dxs)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'b)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''csorted_list_of_set DList_set: ccompare = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("_applC" ("_position" csorted_list_of_set)
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs)))))))))
###           ("_case1" ("_applC" ("_position" Some) ("_position" c))
###             ("_applC" ("_position" ord.quicksort)
###               ("_cargs" ("_applC" ("_position" lt_of_comp) ("_position" c))
###                 ("_applC" ("_position" list_of_dlist)
###                   ("_position" dxs))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
Found termination order: "(%p. length (snd (snd p))) <*mlex*> {}"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
### Code generator: dropping subsumed code equation
### set_eq ?A ?B == ?A <= ?B & ?B <= ?A
### Ambiguous input (line 1326 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" the_elem)
###       ("_applC" ("_position" DList_set) ("_position" dxs)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal" ("_position" ''the_elem DList_set: ceq = None''))
###               ("_lambda" ("_idtdummy")
###                 ("_applC" ("_position" the_elem)
###                   ("_applC" ("_position" DList_set) ("_position" dxs)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" list_of_dlist) ("_position" dxs))
###             ("_case2" ("_case1" ("_list" ("_position" x)) ("_position" x))
###               ("_case1" ("\<^const>Pure.dummy_pattern")
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position" ''the_elem DList_set: not unique''))
###                     ("_lambda" ("_idtdummy")
###                       ("_applC" ("_position" the_elem)
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" the_elem)
###       ("_applC" ("_position" DList_set) ("_position" dxs)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal" ("_position" ''the_elem DList_set: ceq = None''))
###               ("_lambda" ("_idtdummy")
###                 ("_applC" ("_position" the_elem)
###                   ("_applC" ("_position" DList_set) ("_position" dxs)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" list_of_dlist) ("_position" dxs))
###               ("_case1" ("_list" ("_position" x)) ("_position" x))))
###           ("_case1" ("\<^const>Pure.dummy_pattern")
###             ("_applC" ("_position" Code.abort)
###               ("_cargs"
###                 ("_Literal"
###                   ("_position" ''the_elem DList_set: not unique''))
###                 ("_lambda" ("_idtdummy")
###                   ("_applC" ("_position" the_elem)
###                     ("_applC" ("_position" DList_set)
###                       ("_position" dxs))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1331 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" the_elem)
###       ("_applC" ("_position" RBT_set) ("_position" rbt)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''the_elem RBT_set: ccompare = None''))
###               ("_lambda" ("_idtdummy")
###                 ("_applC" ("_position" the_elem)
###                   ("_applC" ("_position" RBT_set) ("_position" rbt)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" RBT_Mapping2.impl_of) ("_position" rbt))
###             ("_case2"
###               ("_case1"
###                 ("_applC" ("_position" RBT_Impl.Branch)
###                   ("_cargs" ("\<^const>Pure.dummy_pattern")
###                     ("_cargs" ("_position" RBT_Impl.Empty)
###                       ("_cargs" ("_position" x)
###                         ("_cargs" ("\<^const>Pure.dummy_pattern")
###                           ("_position" RBT_Impl.Empty))))))
###                 ("_position" x))
###               ("_case1" ("\<^const>Pure.dummy_pattern")
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position" ''the_elem RBT_set: not unique''))
###                     ("_lambda" ("_idtdummy")
###                       ("_applC" ("_position" the_elem)
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" the_elem)
###       ("_applC" ("_position" RBT_set) ("_position" rbt)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''the_elem RBT_set: ccompare = None''))
###               ("_lambda" ("_idtdummy")
###                 ("_applC" ("_position" the_elem)
###                   ("_applC" ("_position" RBT_set) ("_position" rbt)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" RBT_Mapping2.impl_of)
###                 ("_position" rbt))
###               ("_case1"
###                 ("_applC" ("_position" RBT_Impl.Branch)
###                   ("_cargs" ("\<^const>Pure.dummy_pattern")
###                     ("_cargs" ("_position" RBT_Impl.Empty)
###                       ("_cargs" ("_position" x)
###                         ("_cargs" ("\<^const>Pure.dummy_pattern")
###                           ("_position" RBT_Impl.Empty))))))
###                 ("_position" x))))
###           ("_case1" ("\<^const>Pure.dummy_pattern")
###             ("_applC" ("_position" Code.abort)
###               ("_cargs"
###                 ("_Literal" ("_position" ''the_elem RBT_set: not unique''))
###                 ("_lambda" ("_idtdummy")
###                   ("_applC" ("_position" the_elem)
###                     ("_applC" ("_position" RBT_set)
###                       ("_position" rbt))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1387 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" Product_Type.product)
###       ("_cargs" ("_applC" ("_position" DList_set) ("_position" dxs))
###         ("_applC" ("_position" DList_set) ("_position" dys))))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''product DList_set DList_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("_applC" ("_position" Product_Type.product)
###                   ("_cargs"
###                     ("_applC" ("_position" DList_set) ("_position" dxs))
###                     ("_applC" ("_position" DList_set)
###                       ("_position" dys))))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'b)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''product DList_set DList_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("_applC" ("_position" Product_Type.product)
###                         ("_cargs"
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs))
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dys))))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_applC" ("_position" DList_set)
###                   ("_applC" ("_position" DList_Set.product)
###                     ("_cargs" ("_position" dxs) ("_position" dys))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" Product_Type.product)
###       ("_cargs" ("_applC" ("_position" DList_set) ("_position" dxs))
###         ("_applC" ("_position" DList_set) ("_position" dys))))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''product DList_set DList_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("_applC" ("_position" Product_Type.product)
###                   ("_cargs"
###                     ("_applC" ("_position" DList_set) ("_position" dxs))
###                     ("_applC" ("_position" DList_set)
###                       ("_position" dys))))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'b)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''product DList_set DList_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("_applC" ("_position" Product_Type.product)
###                         ("_cargs"
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs))
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dys))))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_applC" ("_position" DList_set)
###               ("_applC" ("_position" DList_Set.product)
###                 ("_cargs" ("_position" dxs) ("_position" dys))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1403 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" Product_Type.product)
###       ("_cargs" ("_applC" ("_position" RBT_set) ("_position" rbt1))
###         ("_applC" ("_position" RBT_set) ("_position" rbt2))))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'c)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''product RBT_set RBT_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("_applC" ("_position" Product_Type.product)
###                   ("_cargs"
###                     ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                     ("_applC" ("_position" RBT_set)
###                       ("_position" rbt2))))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'd)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''product RBT_set RBT_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("_applC" ("_position" Product_Type.product)
###                         ("_cargs"
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt1))
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt2))))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_applC" ("_position" RBT_set)
###                   ("_applC" ("_position" RBT_Set2.product)
###                     ("_cargs" ("_position" rbt1)
###                       ("_position" rbt2))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" Product_Type.product)
###       ("_cargs" ("_applC" ("_position" RBT_set) ("_position" rbt1))
###         ("_applC" ("_position" RBT_set) ("_position" rbt2))))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'c)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''product RBT_set RBT_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("_applC" ("_position" Product_Type.product)
###                   ("_cargs"
###                     ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                     ("_applC" ("_position" RBT_set)
###                       ("_position" rbt2))))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'd)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''product RBT_set RBT_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("_applC" ("_position" Product_Type.product)
###                         ("_cargs"
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt1))
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt2))))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_applC" ("_position" RBT_set)
###               ("_applC" ("_position" RBT_Set2.product)
###                 ("_cargs" ("_position" rbt1) ("_position" rbt2))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1470 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.Image"
###       ("_applC" ("_position" DList_set) ("_position" dxs)) ("_position" B))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal" ("_position" ''Image DList_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.Image"
###                   ("_applC" ("_position" DList_set) ("_position" dxs))
###                   ("_position" B))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'b)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position" ''Image DList_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.Image"
###                         ("_applC" ("_position" DList_set) ("_position" dxs))
###                         ("_position" B))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_applC" ("_position" DList_Set.fold)
###                   ("_cargs"
###                     ("_lambda"
###                       ("_pttrns"
###                         ("_pattern" ("_position" x) ("_position" y))
###                         ("_position" acc))
###                       ("\<^const>HOL.If"
###                         ("\<^const>Set.member" ("_position" x)
###                           ("_position" B))
###                         ("_applC" ("_position" insert)
###                           ("_cargs" ("_position" y) ("_position" acc)))
###                         ("_position" acc)))
###                     ("_cargs" ("_position" dxs)
###                       ("\<^const>Set.empty"))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.Image"
###       ("_applC" ("_position" DList_set) ("_position" dxs)) ("_position" B))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal" ("_position" ''Image DList_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.Image"
###                   ("_applC" ("_position" DList_set) ("_position" dxs))
###                   ("_position" B))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'b)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position" ''Image DList_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.Image"
###                         ("_applC" ("_position" DList_set) ("_position" dxs))
###                         ("_position" B))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_applC" ("_position" DList_Set.fold)
###               ("_cargs"
###                 ("_lambda"
###                   ("_pttrns" ("_pattern" ("_position" x) ("_position" y))
###                     ("_position" acc))
###                   ("\<^const>HOL.If"
###                     ("\<^const>Set.member" ("_position" x) ("_position" B))
###                     ("_applC" ("_position" insert)
###                       ("_cargs" ("_position" y) ("_position" acc)))
###                     ("_position" acc)))
###                 ("_cargs" ("_position" dxs) ("\<^const>Set.empty"))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1477 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.Image"
###       ("_applC" ("_position" RBT_set) ("_position" rbt)) ("_position" C))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'c)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal" ("_position" ''Image RBT_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.Image"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt))
###                   ("_position" C))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'd)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position" ''Image RBT_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.Image"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt))
###                         ("_position" C))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_applC" ("_position" RBT_Set2.fold)
###                   ("_cargs"
###                     ("_lambda"
###                       ("_pttrns"
###                         ("_pattern" ("_position" x) ("_position" y))
###                         ("_position" acc))
###                       ("\<^const>HOL.If"
###                         ("\<^const>Set.member" ("_position" x)
###                           ("_position" C))
###                         ("_applC" ("_position" insert)
###                           ("_cargs" ("_position" y) ("_position" acc)))
###                         ("_position" acc)))
###                     ("_cargs" ("_position" rbt)
###                       ("\<^const>Set.empty"))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.Image"
###       ("_applC" ("_position" RBT_set) ("_position" rbt)) ("_position" C))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'c)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal" ("_position" ''Image RBT_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.Image"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt))
###                   ("_position" C))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'd)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position" ''Image RBT_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.Image"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt))
###                         ("_position" C))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_applC" ("_position" RBT_Set2.fold)
###               ("_cargs"
###                 ("_lambda"
###                   ("_pttrns" ("_pattern" ("_position" x) ("_position" y))
###                     ("_position" acc))
###                   ("\<^const>HOL.If"
###                     ("\<^const>Set.member" ("_position" x) ("_position" C))
###                     ("_applC" ("_position" insert)
###                       ("_cargs" ("_position" y) ("_position" acc)))
###                     ("_position" acc)))
###                 ("_cargs" ("_position" rbt) ("\<^const>Set.empty"))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1546 of "$AFP/Containers/Set_Impl.thy") produces 5 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt1))
###       ("_applC" ("_position" RBT_set) ("_position" rbt2)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp RBT_set RBT_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt2)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp RBT_set RBT_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt2)))))))
###               ("_case1" ("_applC" ("_position" Some) ("_position" c_b))
###                 ("_case_syntax"
###                   ("_applC" ("_position" ID)
###                     ("_CCOMPARE" ("_position_sort" 'c)))
###                   ("_case2"
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp RBT_set RBT_set: ccompare3 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt1))
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt2)))))))
###                     ("_case1"
###                       ("_applC" ("_position" Some)
###                         ("\<^const>Pure.dummy_pattern"))
###                       ("_applC" ("_position" RBT_Set2.fold)
###                         ("_cargs"
###                           ("_lambda"
###                             ("_pattern" ("_position" x) ("_position" y))
###                             ("_applC" ("_position" RBT_Set2.fold)
###                               ("_cargs"
###                                 ("_lambda"
###                                   ("_pttrns"
###                                     ("_pattern" ("_position" y')
### ("_position" z))
###                                     ("_position" A))
###                                   ("\<^const>HOL.If"
###                                     ("\<^const>HOL.not_equal"
### ("_applC" ("_position" c_b) ("_cargs" ("_position" y) ("_position" y')))
### ("_position" Eq))
###                                     ("_position" A)
###                                     ("_applC" ("_position" insert)
### ("_cargs" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z)))
###   ("_position" A)))))
###                                 ("_position" rbt2))))
###                           ("_cargs" ("_position" rbt1)
###                             ("\<^const>Set.empty")))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt1))
###       ("_applC" ("_position" RBT_set) ("_position" rbt2)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp RBT_set RBT_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt2)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'b)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp RBT_set RBT_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt2)))))))))
###           ("_case1" ("_applC" ("_position" Some) ("_position" c_b))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'c)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp RBT_set RBT_set: ccompare3 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt1))
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt2)))))))
###                 ("_case1"
###                   ("_applC" ("_position" Some)
###                     ("\<^const>Pure.dummy_pattern"))
###                   ("_applC" ("_position" RBT_Set2.fold)
###                     ("_cargs"
###                       ("_lambda"
###                         ("_pattern" ("_position" x) ("_position" y))
###                         ("_applC" ("_position" RBT_Set2.fold)
###                           ("_cargs"
###                             ("_lambda"
###                               ("_pttrns"
###                                 ("_pattern" ("_position" y')
###                                   ("_position" z))
###                                 ("_position" A))
###                               ("\<^const>HOL.If"
###                                 ("\<^const>HOL.not_equal"
###                                   ("_applC" ("_position" c_b)
###                                     ("_cargs" ("_position" y)
### ("_position" y')))
###                                   ("_position" Eq))
###                                 ("_position" A)
###                                 ("_applC" ("_position" insert)
###                                   ("_cargs"
###                                     ("_tuple" ("_position" x)
### ("_tuple_arg" ("_position" z)))
###                                     ("_position" A)))))
###                             ("_position" rbt2))))
###                       ("_cargs" ("_position" rbt1)
###                         ("\<^const>Set.empty")))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt1))
###       ("_applC" ("_position" RBT_set) ("_position" rbt2)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp RBT_set RBT_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt2)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp RBT_set RBT_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt2)))))))
###               ("_case2"
###                 ("_case1" ("_applC" ("_position" Some) ("_position" c_b))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CCOMPARE" ("_position_sort" 'c)))
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp RBT_set RBT_set: ccompare3 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt1))
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt2)))))))))
###                 ("_case1"
###                   ("_applC" ("_position" Some)
###                     ("\<^const>Pure.dummy_pattern"))
###                   ("_applC" ("_position" RBT_Set2.fold)
###                     ("_cargs"
###                       ("_lambda"
###                         ("_pattern" ("_position" x) ("_position" y))
###                         ("_applC" ("_position" RBT_Set2.fold)
###                           ("_cargs"
###                             ("_lambda"
###                               ("_pttrns"
###                                 ("_pattern" ("_position" y')
###                                   ("_position" z))
###                                 ("_position" A))
###                               ("\<^const>HOL.If"
###                                 ("\<^const>HOL.not_equal"
###                                   ("_applC" ("_position" c_b)
###                                     ("_cargs" ("_position" y)
### ("_position" y')))
###                                   ("_position" Eq))
###                                 ("_position" A)
###                                 ("_applC" ("_position" insert)
###                                   ("_cargs"
###                                     ("_tuple" ("_position" x)
### ("_tuple_arg" ("_position" z)))
###                                     ("_position" A)))))
###                             ("_position" rbt2))))
###                       ("_cargs" ("_position" rbt1)
###                         ("\<^const>Set.empty")))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt1))
###       ("_applC" ("_position" RBT_set) ("_position" rbt2)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp RBT_set RBT_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt2)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'b)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp RBT_set RBT_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt2)))))))))
###           ("_case2"
###             ("_case1" ("_applC" ("_position" Some) ("_position" c_b))
###               ("_case_syntax"
###                 ("_applC" ("_position" ID)
###                   ("_CCOMPARE" ("_position_sort" 'c)))
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp RBT_set RBT_set: ccompare3 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt1))
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt2)))))))))
###             ("_case1"
###               ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###               ("_applC" ("_position" RBT_Set2.fold)
###                 ("_cargs"
###                   ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                     ("_applC" ("_position" RBT_Set2.fold)
###                       ("_cargs"
###                         ("_lambda"
###                           ("_pttrns"
###                             ("_pattern" ("_position" y') ("_position" z))
###                             ("_position" A))
###                           ("\<^const>HOL.If"
###                             ("\<^const>HOL.not_equal"
###                               ("_applC" ("_position" c_b)
###                                 ("_cargs" ("_position" y) ("_position" y')))
###                               ("_position" Eq))
###                             ("_position" A)
###                             ("_applC" ("_position" insert)
###                               ("_cargs"
###                                 ("_tuple" ("_position" x)
###                                   ("_tuple_arg" ("_position" z)))
###                                 ("_position" A)))))
###                         ("_position" rbt2))))
###                   ("_cargs" ("_position" rbt1)
###                     ("\<^const>Set.empty")))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt1))
###       ("_applC" ("_position" RBT_set) ("_position" rbt2)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp RBT_set RBT_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt2)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'b)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp RBT_set RBT_set: ccompare2 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt1))
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt2)))))))
###                 ("_case1" ("_applC" ("_position" Some) ("_position" c_b))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CCOMPARE" ("_position_sort" 'c)))
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp RBT_set RBT_set: ccompare3 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt1))
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt2))))))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_applC" ("_position" RBT_Set2.fold)
###               ("_cargs"
###                 ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                   ("_applC" ("_position" RBT_Set2.fold)
###                     ("_cargs"
###                       ("_lambda"
###                         ("_pttrns"
###                           ("_pattern" ("_position" y') ("_position" z))
###                           ("_position" A))
###                         ("\<^const>HOL.If"
###                           ("\<^const>HOL.not_equal"
###                             ("_applC" ("_position" c_b)
###                               ("_cargs" ("_position" y) ("_position" y')))
###                             ("_position" Eq))
###                           ("_position" A)
###                           ("_applC" ("_position" insert)
###                             ("_cargs"
###                               ("_tuple" ("_position" x)
###                                 ("_tuple_arg" ("_position" z)))
###                               ("_position" A)))))
###                       ("_position" rbt2))))
###                 ("_cargs" ("_position" rbt1) ("\<^const>Set.empty"))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1555 of "$AFP/Containers/Set_Impl.thy") produces 14 parse trees (10 displayed):
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt3))
###       ("_applC" ("_position" DList_set) ("_position" dxs1)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position"
###                   ''relcomp RBT_set DList_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs1)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'd)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp RBT_set DList_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs1)))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_case_syntax"
###                   ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'd)))
###                   ("_case2"
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp RBT_set DList_set: ceq2 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt3))
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs1)))))))
###                     ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                       ("_case_syntax"
###                         ("_applC" ("_position" ID)
###                           ("_CEQ" ("_position_sort" 'e)))
###                         ("_case2"
###                           ("_case1" ("_position" None)
###                             ("_applC" ("_position" Code.abort)
###                               ("_cargs"
###                                 ("_Literal"
###                                   ("_position"
###                                     ''relcomp RBT_set DList_set: ceq3 = None''))
###                                 ("_lambda" ("_idtdummy")
###                                   ("\<^const>Relation.relcomp"
###                                     ("_applC" ("_position" RBT_set)
### ("_position" rbt3))
###                                     ("_applC" ("_position" DList_set)
### ("_position" dxs1)))))))
###                           ("_case1"
###                             ("_applC" ("_position" Some)
###                               ("\<^const>Pure.dummy_pattern"))
###                             ("_applC" ("_position" RBT_Set2.fold)
###                               ("_cargs"
###                                 ("_lambda"
###                                   ("_pattern" ("_position" x)
###                                     ("_position" y))
###                                   ("_applC" ("_position" DList_Set.fold)
###                                     ("_cargs"
### ("_lambda"
###   ("_pttrns" ("_pattern" ("_position" y') ("_position" z)) ("_position" A))
###   ("\<^const>HOL.If"
###     ("_applC" ("_position" eq) ("_cargs" ("_position" y) ("_position" y')))
###     ("_applC" ("_position" insert)
###       ("_cargs" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z)))
###         ("_position" A)))
###     ("_position" A)))
### ("_position" dxs1))))
###                                 ("_cargs" ("_position" rbt3)
###                                   ("\<^const>Set.empty"))))))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt3))
###       ("_applC" ("_position" DList_set) ("_position" dxs1)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position"
###                   ''relcomp RBT_set DList_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs1)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'd)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp RBT_set DList_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs1)))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'd)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp RBT_set DList_set: ceq2 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt3))
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs1)))))))
###                 ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CEQ" ("_position_sort" 'e)))
###                     ("_case2"
###                       ("_case1" ("_position" None)
###                         ("_applC" ("_position" Code.abort)
###                           ("_cargs"
###                             ("_Literal"
###                               ("_position"
###                                 ''relcomp RBT_set DList_set: ceq3 = None''))
###                             ("_lambda" ("_idtdummy")
###                               ("\<^const>Relation.relcomp"
###                                 ("_applC" ("_position" RBT_set)
###                                   ("_position" rbt3))
###                                 ("_applC" ("_position" DList_set)
###                                   ("_position" dxs1)))))))
###                       ("_case1"
###                         ("_applC" ("_position" Some)
###                           ("\<^const>Pure.dummy_pattern"))
###                         ("_applC" ("_position" RBT_Set2.fold)
###                           ("_cargs"
###                             ("_lambda"
###                               ("_pattern" ("_position" x) ("_position" y))
###                               ("_applC" ("_position" DList_Set.fold)
###                                 ("_cargs"
###                                   ("_lambda"
###                                     ("_pttrns"
### ("_pattern" ("_position" y') ("_position" z)) ("_position" A))
###                                     ("\<^const>HOL.If"
### ("_applC" ("_position" eq) ("_cargs" ("_position" y) ("_position" y')))
### ("_applC" ("_position" insert)
###   ("_cargs" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z)))
###     ("_position" A)))
### ("_position" A)))
###                                   ("_position" dxs1))))
###                             ("_cargs" ("_position" rbt3)
###                               ("\<^const>Set.empty"))))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt3))
###       ("_applC" ("_position" DList_set) ("_position" dxs1)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position"
###                   ''relcomp RBT_set DList_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs1)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'd)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp RBT_set DList_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs1)))))))
###               ("_case2"
###                 ("_case1"
###                   ("_applC" ("_position" Some)
###                     ("\<^const>Pure.dummy_pattern"))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CEQ" ("_position_sort" 'd)))
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp RBT_set DList_set: ceq2 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt3))
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs1)))))))))
###                 ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CEQ" ("_position_sort" 'e)))
###                     ("_case2"
###                       ("_case1" ("_position" None)
###                         ("_applC" ("_position" Code.abort)
###                           ("_cargs"
###                             ("_Literal"
###                               ("_position"
###                                 ''relcomp RBT_set DList_set: ceq3 = None''))
###                             ("_lambda" ("_idtdummy")
###                               ("\<^const>Relation.relcomp"
###                                 ("_applC" ("_position" RBT_set)
###                                   ("_position" rbt3))
###                                 ("_applC" ("_position" DList_set)
###                                   ("_position" dxs1)))))))
###                       ("_case1"
###                         ("_applC" ("_position" Some)
###                           ("\<^const>Pure.dummy_pattern"))
###                         ("_applC" ("_position" RBT_Set2.fold)
###                           ("_cargs"
###                             ("_lambda"
###                               ("_pattern" ("_position" x) ("_position" y))
###                               ("_applC" ("_position" DList_Set.fold)
###                                 ("_cargs"
###                                   ("_lambda"
###                                     ("_pttrns"
### ("_pattern" ("_position" y') ("_position" z)) ("_position" A))
###                                     ("\<^const>HOL.If"
### ("_applC" ("_position" eq) ("_cargs" ("_position" y) ("_position" y')))
### ("_applC" ("_position" insert)
###   ("_cargs" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z)))
###     ("_position" A)))
### ("_position" A)))
###                                   ("_position" dxs1))))
###                             ("_cargs" ("_position" rbt3)
###                               ("\<^const>Set.empty"))))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt3))
###       ("_applC" ("_position" DList_set) ("_position" dxs1)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position"
###                   ''relcomp RBT_set DList_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs1)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'd)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp RBT_set DList_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs1)))))))))
###           ("_case2"
###             ("_case1"
###               ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###               ("_case_syntax"
###                 ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'd)))
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp RBT_set DList_set: ceq2 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt3))
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs1)))))))))
###             ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###               ("_case_syntax"
###                 ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###                 ("_case2"
###                   ("_case1" ("_position" None)
###                     ("_applC" ("_position" Code.abort)
###                       ("_cargs"
###                         ("_Literal"
###                           ("_position"
###                             ''relcomp RBT_set DList_set: ceq3 = None''))
###                         ("_lambda" ("_idtdummy")
###                           ("\<^const>Relation.relcomp"
###                             ("_applC" ("_position" RBT_set)
###                               ("_position" rbt3))
###                             ("_applC" ("_position" DList_set)
###                               ("_position" dxs1)))))))
###                   ("_case1"
###                     ("_applC" ("_position" Some)
###                       ("\<^const>Pure.dummy_pattern"))
###                     ("_applC" ("_position" RBT_Set2.fold)
###                       ("_cargs"
###                         ("_lambda"
###                           ("_pattern" ("_position" x) ("_position" y))
###                           ("_applC" ("_position" DList_Set.fold)
###                             ("_cargs"
###                               ("_lambda"
###                                 ("_pttrns"
###                                   ("_pattern" ("_position" y')
###                                     ("_position" z))
###                                   ("_position" A))
###                                 ("\<^const>HOL.If"
###                                   ("_applC" ("_position" eq)
###                                     ("_cargs" ("_position" y)
### ("_position" y')))
###                                   ("_applC" ("_position" insert)
###                                     ("_cargs"
### ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z))) ("_position" A)))
###                                   ("_position" A)))
###                               ("_position" dxs1))))
###                         ("_cargs" ("_position" rbt3)
###                           ("\<^const>Set.empty"))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt3))
###       ("_applC" ("_position" DList_set) ("_position" dxs1)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position"
###                   ''relcomp RBT_set DList_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs1)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'd)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp RBT_set DList_set: ccompare2 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt3))
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs1)))))))
###                 ("_case1"
###                   ("_applC" ("_position" Some)
###                     ("\<^const>Pure.dummy_pattern"))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CEQ" ("_position_sort" 'd)))
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp RBT_set DList_set: ceq2 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt3))
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs1))))))))))))
###           ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp RBT_set DList_set: ceq3 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt3))
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs1)))))))
###                 ("_case1"
###                   ("_applC" ("_position" Some)
###                     ("\<^const>Pure.dummy_pattern"))
###                   ("_applC" ("_position" RBT_Set2.fold)
###                     ("_cargs"
###                       ("_lambda"
###                         ("_pattern" ("_position" x) ("_position" y))
###                         ("_applC" ("_position" DList_Set.fold)
###                           ("_cargs"
###                             ("_lambda"
###                               ("_pttrns"
###                                 ("_pattern" ("_position" y')
###                                   ("_position" z))
###                                 ("_position" A))
###                               ("\<^const>HOL.If"
###                                 ("_applC" ("_position" eq)
###                                   ("_cargs" ("_position" y)
###                                     ("_position" y')))
###                                 ("_applC" ("_position" insert)
###                                   ("_cargs"
###                                     ("_tuple" ("_position" x)
### ("_tuple_arg" ("_position" z)))
###                                     ("_position" A)))
###                                 ("_position" A)))
###                             ("_position" dxs1))))
###                       ("_cargs" ("_position" rbt3)
###                         ("\<^const>Set.empty")))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt3))
###       ("_applC" ("_position" DList_set) ("_position" dxs1)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position"
###                   ''relcomp RBT_set DList_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs1)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'd)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp RBT_set DList_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs1)))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_case_syntax"
###                   ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'd)))
###                   ("_case2"
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp RBT_set DList_set: ceq2 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt3))
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs1)))))))
###                     ("_case2"
###                       ("_case1"
###                         ("_applC" ("_position" Some) ("_position" eq))
###                         ("_case_syntax"
###                           ("_applC" ("_position" ID)
###                             ("_CEQ" ("_position_sort" 'e)))
###                           ("_case1" ("_position" None)
###                             ("_applC" ("_position" Code.abort)
###                               ("_cargs"
###                                 ("_Literal"
###                                   ("_position"
###                                     ''relcomp RBT_set DList_set: ceq3 = None''))
###                                 ("_lambda" ("_idtdummy")
###                                   ("\<^const>Relation.relcomp"
###                                     ("_applC" ("_position" RBT_set)
### ("_position" rbt3))
###                                     ("_applC" ("_position" DList_set)
### ("_position" dxs1)))))))))
###                       ("_case1"
###                         ("_applC" ("_position" Some)
###                           ("\<^const>Pure.dummy_pattern"))
###                         ("_applC" ("_position" RBT_Set2.fold)
###                           ("_cargs"
###                             ("_lambda"
###                               ("_pattern" ("_position" x) ("_position" y))
###                               ("_applC" ("_position" DList_Set.fold)
###                                 ("_cargs"
###                                   ("_lambda"
###                                     ("_pttrns"
### ("_pattern" ("_position" y') ("_position" z)) ("_position" A))
###                                     ("\<^const>HOL.If"
### ("_applC" ("_position" eq) ("_cargs" ("_position" y) ("_position" y')))
### ("_applC" ("_position" insert)
###   ("_cargs" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z)))
###     ("_position" A)))
### ("_position" A)))
###                                   ("_position" dxs1))))
###                             ("_cargs" ("_position" rbt3)
###                               ("\<^const>Set.empty"))))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt3))
###       ("_applC" ("_position" DList_set) ("_position" dxs1)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position"
###                   ''relcomp RBT_set DList_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs1)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'd)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp RBT_set DList_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs1)))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'd)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp RBT_set DList_set: ceq2 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt3))
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs1)))))))
###                 ("_case2"
###                   ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                     ("_case_syntax"
###                       ("_applC" ("_position" ID)
###                         ("_CEQ" ("_position_sort" 'e)))
###                       ("_case1" ("_position" None)
###                         ("_applC" ("_position" Code.abort)
###                           ("_cargs"
###                             ("_Literal"
###                               ("_position"
###                                 ''relcomp RBT_set DList_set: ceq3 = None''))
###                             ("_lambda" ("_idtdummy")
###                               ("\<^const>Relation.relcomp"
###                                 ("_applC" ("_position" RBT_set)
###                                   ("_position" rbt3))
###                                 ("_applC" ("_position" DList_set)
###                                   ("_position" dxs1)))))))))
###                   ("_case1"
###                     ("_applC" ("_position" Some)
###                       ("\<^const>Pure.dummy_pattern"))
###                     ("_applC" ("_position" RBT_Set2.fold)
###                       ("_cargs"
###                         ("_lambda"
###                           ("_pattern" ("_position" x) ("_position" y))
###                           ("_applC" ("_position" DList_Set.fold)
###                             ("_cargs"
###                               ("_lambda"
###                                 ("_pttrns"
###                                   ("_pattern" ("_position" y')
###                                     ("_position" z))
###                                   ("_position" A))
###                                 ("\<^const>HOL.If"
###                                   ("_applC" ("_position" eq)
###                                     ("_cargs" ("_position" y)
### ("_position" y')))
###                                   ("_applC" ("_position" insert)
###                                     ("_cargs"
### ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z))) ("_position" A)))
###                                   ("_position" A)))
###                               ("_position" dxs1))))
###                         ("_cargs" ("_position" rbt3)
###                           ("\<^const>Set.empty"))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt3))
###       ("_applC" ("_position" DList_set) ("_position" dxs1)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position"
###                   ''relcomp RBT_set DList_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs1)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'd)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp RBT_set DList_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs1)))))))
###               ("_case2"
###                 ("_case1"
###                   ("_applC" ("_position" Some)
###                     ("\<^const>Pure.dummy_pattern"))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CEQ" ("_position_sort" 'd)))
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp RBT_set DList_set: ceq2 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt3))
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs1)))))))))
###                 ("_case2"
###                   ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                     ("_case_syntax"
###                       ("_applC" ("_position" ID)
###                         ("_CEQ" ("_position_sort" 'e)))
###                       ("_case1" ("_position" None)
###                         ("_applC" ("_position" Code.abort)
###                           ("_cargs"
###                             ("_Literal"
###                               ("_position"
###                                 ''relcomp RBT_set DList_set: ceq3 = None''))
###                             ("_lambda" ("_idtdummy")
###                               ("\<^const>Relation.relcomp"
###                                 ("_applC" ("_position" RBT_set)
###                                   ("_position" rbt3))
###                                 ("_applC" ("_position" DList_set)
###                                   ("_position" dxs1)))))))))
###                   ("_case1"
###                     ("_applC" ("_position" Some)
###                       ("\<^const>Pure.dummy_pattern"))
###                     ("_applC" ("_position" RBT_Set2.fold)
###                       ("_cargs"
###                         ("_lambda"
###                           ("_pattern" ("_position" x) ("_position" y))
###                           ("_applC" ("_position" DList_Set.fold)
###                             ("_cargs"
###                               ("_lambda"
###                                 ("_pttrns"
###                                   ("_pattern" ("_position" y')
###                                     ("_position" z))
###                                   ("_position" A))
###                                 ("\<^const>HOL.If"
###                                   ("_applC" ("_position" eq)
###                                     ("_cargs" ("_position" y)
### ("_position" y')))
###                                   ("_applC" ("_position" insert)
###                                     ("_cargs"
### ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z))) ("_position" A)))
###                                   ("_position" A)))
###                               ("_position" dxs1))))
###                         ("_cargs" ("_position" rbt3)
###                           ("\<^const>Set.empty"))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt3))
###       ("_applC" ("_position" DList_set) ("_position" dxs1)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position"
###                   ''relcomp RBT_set DList_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs1)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'd)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp RBT_set DList_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs1)))))))))
###           ("_case2"
###             ("_case1"
###               ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###               ("_case_syntax"
###                 ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'd)))
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp RBT_set DList_set: ceq2 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt3))
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs1)))))))))
###             ("_case2"
###               ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                 ("_case_syntax"
###                   ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###                   ("_case1" ("_position" None)
###                     ("_applC" ("_position" Code.abort)
###                       ("_cargs"
###                         ("_Literal"
###                           ("_position"
###                             ''relcomp RBT_set DList_set: ceq3 = None''))
###                         ("_lambda" ("_idtdummy")
###                           ("\<^const>Relation.relcomp"
###                             ("_applC" ("_position" RBT_set)
###                               ("_position" rbt3))
###                             ("_applC" ("_position" DList_set)
###                               ("_position" dxs1)))))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_applC" ("_position" RBT_Set2.fold)
###                   ("_cargs"
###                     ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                       ("_applC" ("_position" DList_Set.fold)
###                         ("_cargs"
###                           ("_lambda"
###                             ("_pttrns"
###                               ("_pattern" ("_position" y') ("_position" z))
###                               ("_position" A))
###                             ("\<^const>HOL.If"
###                               ("_applC" ("_position" eq)
###                                 ("_cargs" ("_position" y) ("_position" y')))
###                               ("_applC" ("_position" insert)
###                                 ("_cargs"
###                                   ("_tuple" ("_position" x)
###                                     ("_tuple_arg" ("_position" z)))
###                                   ("_position" A)))
###                               ("_position" A)))
###                           ("_position" dxs1))))
###                     ("_cargs" ("_position" rbt3)
###                       ("\<^const>Set.empty"))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt3))
###       ("_applC" ("_position" DList_set) ("_position" dxs1)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position"
###                   ''relcomp RBT_set DList_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs1)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'd)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp RBT_set DList_set: ccompare2 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt3))
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs1)))))))
###                 ("_case1"
###                   ("_applC" ("_position" Some)
###                     ("\<^const>Pure.dummy_pattern"))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CEQ" ("_position_sort" 'd)))
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp RBT_set DList_set: ceq2 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt3))
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs1))))))))))))
###           ("_case2"
###             ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###               ("_case_syntax"
###                 ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp RBT_set DList_set: ceq3 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt3))
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs1)))))))))
###             ("_case1"
###               ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###               ("_applC" ("_position" RBT_Set2.fold)
###                 ("_cargs"
###                   ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                     ("_applC" ("_position" DList_Set.fold)
###                       ("_cargs"
###                         ("_lambda"
###                           ("_pttrns"
###                             ("_pattern" ("_position" y') ("_position" z))
###                             ("_position" A))
###                           ("\<^const>HOL.If"
###                             ("_applC" ("_position" eq)
###                               ("_cargs" ("_position" y) ("_position" y')))
###                             ("_applC" ("_position" insert)
###                               ("_cargs"
###                                 ("_tuple" ("_position" x)
###                                   ("_tuple_arg" ("_position" z)))
###                                 ("_position" A)))
###                             ("_position" A)))
###                         ("_position" dxs1))))
###                   ("_cargs" ("_position" rbt3)
###                     ("\<^const>Set.empty")))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1566 of "$AFP/Containers/Set_Impl.thy") produces 14 parse trees (10 displayed):
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs2))
###       ("_applC" ("_position" RBT_set) ("_position" rbt4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set RBT_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs2))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt4)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'd)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp DList_set RBT_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs2))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt4)))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_case_syntax"
###                   ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'd)))
###                   ("_case2"
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp DList_set RBT_set: ccompare2 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs2))
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt4)))))))
###                     ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                       ("_case_syntax"
###                         ("_applC" ("_position" ID)
###                           ("_CCOMPARE" ("_position_sort" 'a)))
###                         ("_case2"
###                           ("_case1" ("_position" None)
###                             ("_applC" ("_position" Code.abort)
###                               ("_cargs"
###                                 ("_Literal"
###                                   ("_position"
###                                     ''relcomp DList_set RBT_set: ccompare3 = None''))
###                                 ("_lambda" ("_idtdummy")
###                                   ("\<^const>Relation.relcomp"
###                                     ("_applC" ("_position" DList_set)
### ("_position" dxs2))
###                                     ("_applC" ("_position" RBT_set)
### ("_position" rbt4)))))))
###                           ("_case1"
###                             ("_applC" ("_position" Some)
###                               ("\<^const>Pure.dummy_pattern"))
###                             ("_applC" ("_position" DList_Set.fold)
###                               ("_cargs"
###                                 ("_lambda"
###                                   ("_pattern" ("_position" x)
###                                     ("_position" y))
###                                   ("_applC" ("_position" RBT_Set2.fold)
###                                     ("_cargs"
### ("_lambda"
###   ("_pttrns" ("_pattern" ("_position" y') ("_position" z)) ("_position" A))
###   ("\<^const>HOL.If"
###     ("_applC" ("_position" eq) ("_cargs" ("_position" y) ("_position" y')))
###     ("_applC" ("_position" insert)
###       ("_cargs" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z)))
###         ("_position" A)))
###     ("_position" A)))
### ("_position" rbt4))))
###                                 ("_cargs" ("_position" dxs2)
###                                   ("\<^const>Set.empty"))))))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs2))
###       ("_applC" ("_position" RBT_set) ("_position" rbt4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set RBT_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs2))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt4)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'd)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp DList_set RBT_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs2))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt4)))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'd)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp DList_set RBT_set: ccompare2 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs2))
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt4)))))))
###                 ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CCOMPARE" ("_position_sort" 'a)))
###                     ("_case2"
###                       ("_case1" ("_position" None)
###                         ("_applC" ("_position" Code.abort)
###                           ("_cargs"
###                             ("_Literal"
###                               ("_position"
###                                 ''relcomp DList_set RBT_set: ccompare3 = None''))
###                             ("_lambda" ("_idtdummy")
###                               ("\<^const>Relation.relcomp"
###                                 ("_applC" ("_position" DList_set)
###                                   ("_position" dxs2))
###                                 ("_applC" ("_position" RBT_set)
###                                   ("_position" rbt4)))))))
###                       ("_case1"
###                         ("_applC" ("_position" Some)
###                           ("\<^const>Pure.dummy_pattern"))
###                         ("_applC" ("_position" DList_Set.fold)
###                           ("_cargs"
###                             ("_lambda"
###                               ("_pattern" ("_position" x) ("_position" y))
###                               ("_applC" ("_position" RBT_Set2.fold)
###                                 ("_cargs"
###                                   ("_lambda"
###                                     ("_pttrns"
### ("_pattern" ("_position" y') ("_position" z)) ("_position" A))
###                                     ("\<^const>HOL.If"
### ("_applC" ("_position" eq) ("_cargs" ("_position" y) ("_position" y')))
### ("_applC" ("_position" insert)
###   ("_cargs" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z)))
###     ("_position" A)))
### ("_position" A)))
###                                   ("_position" rbt4))))
###                             ("_cargs" ("_position" dxs2)
###                               ("\<^const>Set.empty"))))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs2))
###       ("_applC" ("_position" RBT_set) ("_position" rbt4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set RBT_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs2))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt4)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'd)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp DList_set RBT_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs2))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt4)))))))
###               ("_case2"
###                 ("_case1"
###                   ("_applC" ("_position" Some)
###                     ("\<^const>Pure.dummy_pattern"))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CEQ" ("_position_sort" 'd)))
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp DList_set RBT_set: ccompare2 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs2))
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt4)))))))))
###                 ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CCOMPARE" ("_position_sort" 'a)))
###                     ("_case2"
###                       ("_case1" ("_position" None)
###                         ("_applC" ("_position" Code.abort)
###                           ("_cargs"
###                             ("_Literal"
###                               ("_position"
###                                 ''relcomp DList_set RBT_set: ccompare3 = None''))
###                             ("_lambda" ("_idtdummy")
###                               ("\<^const>Relation.relcomp"
###                                 ("_applC" ("_position" DList_set)
###                                   ("_position" dxs2))
###                                 ("_applC" ("_position" RBT_set)
###                                   ("_position" rbt4)))))))
###                       ("_case1"
###                         ("_applC" ("_position" Some)
###                           ("\<^const>Pure.dummy_pattern"))
###                         ("_applC" ("_position" DList_Set.fold)
###                           ("_cargs"
###                             ("_lambda"
###                               ("_pattern" ("_position" x) ("_position" y))
###                               ("_applC" ("_position" RBT_Set2.fold)
###                                 ("_cargs"
###                                   ("_lambda"
###                                     ("_pttrns"
### ("_pattern" ("_position" y') ("_position" z)) ("_position" A))
###                                     ("\<^const>HOL.If"
### ("_applC" ("_position" eq) ("_cargs" ("_position" y) ("_position" y')))
### ("_applC" ("_position" insert)
###   ("_cargs" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z)))
###     ("_position" A)))
### ("_position" A)))
###                                   ("_position" rbt4))))
###                             ("_cargs" ("_position" dxs2)
###                               ("\<^const>Set.empty"))))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs2))
###       ("_applC" ("_position" RBT_set) ("_position" rbt4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set RBT_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs2))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt4)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'd)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp DList_set RBT_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs2))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt4)))))))))
###           ("_case2"
###             ("_case1"
###               ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###               ("_case_syntax"
###                 ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'd)))
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp DList_set RBT_set: ccompare2 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs2))
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt4)))))))))
###             ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###               ("_case_syntax"
###                 ("_applC" ("_position" ID)
###                   ("_CCOMPARE" ("_position_sort" 'a)))
###                 ("_case2"
###                   ("_case1" ("_position" None)
###                     ("_applC" ("_position" Code.abort)
###                       ("_cargs"
###                         ("_Literal"
###                           ("_position"
###                             ''relcomp DList_set RBT_set: ccompare3 = None''))
###                         ("_lambda" ("_idtdummy")
###                           ("\<^const>Relation.relcomp"
###                             ("_applC" ("_position" DList_set)
###                               ("_position" dxs2))
###                             ("_applC" ("_position" RBT_set)
###                               ("_position" rbt4)))))))
###                   ("_case1"
###                     ("_applC" ("_position" Some)
###                       ("\<^const>Pure.dummy_pattern"))
###                     ("_applC" ("_position" DList_Set.fold)
###                       ("_cargs"
###                         ("_lambda"
###                           ("_pattern" ("_position" x) ("_position" y))
###                           ("_applC" ("_position" RBT_Set2.fold)
###                             ("_cargs"
###                               ("_lambda"
###                                 ("_pttrns"
###                                   ("_pattern" ("_position" y')
###                                     ("_position" z))
###                                   ("_position" A))
###                                 ("\<^const>HOL.If"
###                                   ("_applC" ("_position" eq)
###                                     ("_cargs" ("_position" y)
### ("_position" y')))
###                                   ("_applC" ("_position" insert)
###                                     ("_cargs"
### ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z))) ("_position" A)))
###                                   ("_position" A)))
###                               ("_position" rbt4))))
###                         ("_cargs" ("_position" dxs2)
###                           ("\<^const>Set.empty"))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs2))
###       ("_applC" ("_position" RBT_set) ("_position" rbt4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set RBT_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs2))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt4)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'd)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp DList_set RBT_set: ceq2 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs2))
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt4)))))))
###                 ("_case1"
###                   ("_applC" ("_position" Some)
###                     ("\<^const>Pure.dummy_pattern"))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CEQ" ("_position_sort" 'd)))
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp DList_set RBT_set: ccompare2 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs2))
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt4))))))))))))
###           ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'a)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp DList_set RBT_set: ccompare3 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs2))
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt4)))))))
###                 ("_case1"
###                   ("_applC" ("_position" Some)
###                     ("\<^const>Pure.dummy_pattern"))
###                   ("_applC" ("_position" DList_Set.fold)
###                     ("_cargs"
###                       ("_lambda"
###                         ("_pattern" ("_position" x) ("_position" y))
###                         ("_applC" ("_position" RBT_Set2.fold)
###                           ("_cargs"
###                             ("_lambda"
###                               ("_pttrns"
###                                 ("_pattern" ("_position" y')
###                                   ("_position" z))
###                                 ("_position" A))
###                               ("\<^const>HOL.If"
###                                 ("_applC" ("_position" eq)
###                                   ("_cargs" ("_position" y)
###                                     ("_position" y')))
###                                 ("_applC" ("_position" insert)
###                                   ("_cargs"
###                                     ("_tuple" ("_position" x)
### ("_tuple_arg" ("_position" z)))
###                                     ("_position" A)))
###                                 ("_position" A)))
###                             ("_position" rbt4))))
###                       ("_cargs" ("_position" dxs2)
###                         ("\<^const>Set.empty")))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs2))
###       ("_applC" ("_position" RBT_set) ("_position" rbt4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set RBT_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs2))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt4)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'd)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp DList_set RBT_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs2))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt4)))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_case_syntax"
###                   ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'd)))
###                   ("_case2"
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp DList_set RBT_set: ccompare2 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs2))
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt4)))))))
###                     ("_case2"
###                       ("_case1"
###                         ("_applC" ("_position" Some) ("_position" eq))
###                         ("_case_syntax"
###                           ("_applC" ("_position" ID)
###                             ("_CCOMPARE" ("_position_sort" 'a)))
###                           ("_case1" ("_position" None)
###                             ("_applC" ("_position" Code.abort)
###                               ("_cargs"
###                                 ("_Literal"
###                                   ("_position"
###                                     ''relcomp DList_set RBT_set: ccompare3 = None''))
###                                 ("_lambda" ("_idtdummy")
###                                   ("\<^const>Relation.relcomp"
###                                     ("_applC" ("_position" DList_set)
### ("_position" dxs2))
###                                     ("_applC" ("_position" RBT_set)
### ("_position" rbt4)))))))))
###                       ("_case1"
###                         ("_applC" ("_position" Some)
###                           ("\<^const>Pure.dummy_pattern"))
###                         ("_applC" ("_position" DList_Set.fold)
###                           ("_cargs"
###                             ("_lambda"
###                               ("_pattern" ("_position" x) ("_position" y))
###                               ("_applC" ("_position" RBT_Set2.fold)
###                                 ("_cargs"
###                                   ("_lambda"
###                                     ("_pttrns"
### ("_pattern" ("_position" y') ("_position" z)) ("_position" A))
###                                     ("\<^const>HOL.If"
### ("_applC" ("_position" eq) ("_cargs" ("_position" y) ("_position" y')))
### ("_applC" ("_position" insert)
###   ("_cargs" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z)))
###     ("_position" A)))
### ("_position" A)))
###                                   ("_position" rbt4))))
###                             ("_cargs" ("_position" dxs2)
###                               ("\<^const>Set.empty"))))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs2))
###       ("_applC" ("_position" RBT_set) ("_position" rbt4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set RBT_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs2))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt4)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'd)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp DList_set RBT_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs2))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt4)))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'd)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp DList_set RBT_set: ccompare2 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs2))
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt4)))))))
###                 ("_case2"
###                   ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                     ("_case_syntax"
###                       ("_applC" ("_position" ID)
###                         ("_CCOMPARE" ("_position_sort" 'a)))
###                       ("_case1" ("_position" None)
###                         ("_applC" ("_position" Code.abort)
###                           ("_cargs"
###                             ("_Literal"
###                               ("_position"
###                                 ''relcomp DList_set RBT_set: ccompare3 = None''))
###                             ("_lambda" ("_idtdummy")
###                               ("\<^const>Relation.relcomp"
###                                 ("_applC" ("_position" DList_set)
###                                   ("_position" dxs2))
###                                 ("_applC" ("_position" RBT_set)
###                                   ("_position" rbt4)))))))))
###                   ("_case1"
###                     ("_applC" ("_position" Some)
###                       ("\<^const>Pure.dummy_pattern"))
###                     ("_applC" ("_position" DList_Set.fold)
###                       ("_cargs"
###                         ("_lambda"
###                           ("_pattern" ("_position" x) ("_position" y))
###                           ("_applC" ("_position" RBT_Set2.fold)
###                             ("_cargs"
###                               ("_lambda"
###                                 ("_pttrns"
###                                   ("_pattern" ("_position" y')
###                                     ("_position" z))
###                                   ("_position" A))
###                                 ("\<^const>HOL.If"
###                                   ("_applC" ("_position" eq)
###                                     ("_cargs" ("_position" y)
### ("_position" y')))
###                                   ("_applC" ("_position" insert)
###                                     ("_cargs"
### ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z))) ("_position" A)))
###                                   ("_position" A)))
###                               ("_position" rbt4))))
###                         ("_cargs" ("_position" dxs2)
###                           ("\<^const>Set.empty"))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs2))
###       ("_applC" ("_position" RBT_set) ("_position" rbt4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set RBT_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs2))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt4)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'd)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp DList_set RBT_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs2))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt4)))))))
###               ("_case2"
###                 ("_case1"
###                   ("_applC" ("_position" Some)
###                     ("\<^const>Pure.dummy_pattern"))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CEQ" ("_position_sort" 'd)))
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp DList_set RBT_set: ccompare2 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs2))
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt4)))))))))
###                 ("_case2"
###                   ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                     ("_case_syntax"
###                       ("_applC" ("_position" ID)
###                         ("_CCOMPARE" ("_position_sort" 'a)))
###                       ("_case1" ("_position" None)
###                         ("_applC" ("_position" Code.abort)
###                           ("_cargs"
###                             ("_Literal"
###                               ("_position"
###                                 ''relcomp DList_set RBT_set: ccompare3 = None''))
###                             ("_lambda" ("_idtdummy")
###                               ("\<^const>Relation.relcomp"
###                                 ("_applC" ("_position" DList_set)
###                                   ("_position" dxs2))
###                                 ("_applC" ("_position" RBT_set)
###                                   ("_position" rbt4)))))))))
###                   ("_case1"
###                     ("_applC" ("_position" Some)
###                       ("\<^const>Pure.dummy_pattern"))
###                     ("_applC" ("_position" DList_Set.fold)
###                       ("_cargs"
###                         ("_lambda"
###                           ("_pattern" ("_position" x) ("_position" y))
###                           ("_applC" ("_position" RBT_Set2.fold)
###                             ("_cargs"
###                               ("_lambda"
###                                 ("_pttrns"
###                                   ("_pattern" ("_position" y')
###                                     ("_position" z))
###                                   ("_position" A))
###                                 ("\<^const>HOL.If"
###                                   ("_applC" ("_position" eq)
###                                     ("_cargs" ("_position" y)
### ("_position" y')))
###                                   ("_applC" ("_position" insert)
###                                     ("_cargs"
### ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z))) ("_position" A)))
###                                   ("_position" A)))
###                               ("_position" rbt4))))
###                         ("_cargs" ("_position" dxs2)
###                           ("\<^const>Set.empty"))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs2))
###       ("_applC" ("_position" RBT_set) ("_position" rbt4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set RBT_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs2))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt4)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'd)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp DList_set RBT_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs2))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt4)))))))))
###           ("_case2"
###             ("_case1"
###               ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###               ("_case_syntax"
###                 ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'd)))
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp DList_set RBT_set: ccompare2 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs2))
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt4)))))))))
###             ("_case2"
###               ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                 ("_case_syntax"
###                   ("_applC" ("_position" ID)
###                     ("_CCOMPARE" ("_position_sort" 'a)))
###                   ("_case1" ("_position" None)
###                     ("_applC" ("_position" Code.abort)
###                       ("_cargs"
###                         ("_Literal"
###                           ("_position"
###                             ''relcomp DList_set RBT_set: ccompare3 = None''))
###                         ("_lambda" ("_idtdummy")
###                           ("\<^const>Relation.relcomp"
###                             ("_applC" ("_position" DList_set)
###                               ("_position" dxs2))
###                             ("_applC" ("_position" RBT_set)
###                               ("_position" rbt4)))))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_applC" ("_position" DList_Set.fold)
###                   ("_cargs"
###                     ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                       ("_applC" ("_position" RBT_Set2.fold)
###                         ("_cargs"
###                           ("_lambda"
###                             ("_pttrns"
###                               ("_pattern" ("_position" y') ("_position" z))
###                               ("_position" A))
###                             ("\<^const>HOL.If"
###                               ("_applC" ("_position" eq)
###                                 ("_cargs" ("_position" y) ("_position" y')))
###                               ("_applC" ("_position" insert)
###                                 ("_cargs"
###                                   ("_tuple" ("_position" x)
###                                     ("_tuple_arg" ("_position" z)))
###                                   ("_position" A)))
###                               ("_position" A)))
###                           ("_position" rbt4))))
###                     ("_cargs" ("_position" dxs2)
###                       ("\<^const>Set.empty"))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs2))
###       ("_applC" ("_position" RBT_set) ("_position" rbt4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set RBT_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs2))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt4)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'd)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp DList_set RBT_set: ceq2 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs2))
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt4)))))))
###                 ("_case1"
###                   ("_applC" ("_position" Some)
###                     ("\<^const>Pure.dummy_pattern"))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CEQ" ("_position_sort" 'd)))
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp DList_set RBT_set: ccompare2 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs2))
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt4))))))))))))
###           ("_case2"
###             ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###               ("_case_syntax"
###                 ("_applC" ("_position" ID)
###                   ("_CCOMPARE" ("_position_sort" 'a)))
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp DList_set RBT_set: ccompare3 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs2))
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt4)))))))))
###             ("_case1"
###               ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###               ("_applC" ("_position" DList_Set.fold)
###                 ("_cargs"
###                   ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                     ("_applC" ("_position" RBT_Set2.fold)
###                       ("_cargs"
###                         ("_lambda"
###                           ("_pttrns"
###                             ("_pattern" ("_position" y') ("_position" z))
###                             ("_position" A))
###                           ("\<^const>HOL.If"
###                             ("_applC" ("_position" eq)
###                               ("_cargs" ("_position" y) ("_position" y')))
###                             ("_applC" ("_position" insert)
###                               ("_cargs"
###                                 ("_tuple" ("_position" x)
###                                   ("_tuple_arg" ("_position" z)))
###                                 ("_position" A)))
###                             ("_position" A)))
###                         ("_position" rbt4))))
###                   ("_cargs" ("_position" dxs2)
###                     ("\<^const>Set.empty")))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1577 of "$AFP/Containers/Set_Impl.thy") produces 5 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs3))
###       ("_applC" ("_position" DList_set) ("_position" dxs4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set DList_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs4)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'f)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp DList_set DList_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs3))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs4)))))))
###               ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                 ("_case_syntax"
###                   ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'g)))
###                   ("_case2"
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp DList_set DList_set: ceq3 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs3))
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs4)))))))
###                     ("_case1"
###                       ("_applC" ("_position" Some)
###                         ("\<^const>Pure.dummy_pattern"))
###                       ("_applC" ("_position" DList_Set.fold)
###                         ("_cargs"
###                           ("_lambda"
###                             ("_pattern" ("_position" x) ("_position" y))
###                             ("_applC" ("_position" DList_Set.fold)
###                               ("_cargs"
###                                 ("_lambda"
###                                   ("_pttrns"
###                                     ("_pattern" ("_position" y')
### ("_position" z))
###                                     ("_position" A))
###                                   ("\<^const>HOL.If"
###                                     ("_applC" ("_position" eq)
### ("_cargs" ("_position" y) ("_position" y')))
###                                     ("_applC" ("_position" insert)
### ("_cargs" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z)))
###   ("_position" A)))
###                                     ("_position" A)))
###                                 ("_position" dxs4))))
###                           ("_cargs" ("_position" dxs3)
###                             ("\<^const>Set.empty")))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs3))
###       ("_applC" ("_position" DList_set) ("_position" dxs4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set DList_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs4)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'f)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp DList_set DList_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs3))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs4)))))))))
###           ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'g)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp DList_set DList_set: ceq3 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs3))
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs4)))))))
###                 ("_case1"
###                   ("_applC" ("_position" Some)
###                     ("\<^const>Pure.dummy_pattern"))
###                   ("_applC" ("_position" DList_Set.fold)
###                     ("_cargs"
###                       ("_lambda"
###                         ("_pattern" ("_position" x) ("_position" y))
###                         ("_applC" ("_position" DList_Set.fold)
###                           ("_cargs"
###                             ("_lambda"
###                               ("_pttrns"
###                                 ("_pattern" ("_position" y')
###                                   ("_position" z))
###                                 ("_position" A))
###                               ("\<^const>HOL.If"
###                                 ("_applC" ("_position" eq)
###                                   ("_cargs" ("_position" y)
###                                     ("_position" y')))
###                                 ("_applC" ("_position" insert)
###                                   ("_cargs"
###                                     ("_tuple" ("_position" x)
### ("_tuple_arg" ("_position" z)))
###                                     ("_position" A)))
###                                 ("_position" A)))
###                             ("_position" dxs4))))
###                       ("_cargs" ("_position" dxs3)
###                         ("\<^const>Set.empty")))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs3))
###       ("_applC" ("_position" DList_set) ("_position" dxs4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set DList_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs4)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'f)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp DList_set DList_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs3))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs4)))))))
###               ("_case2"
###                 ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CEQ" ("_position_sort" 'g)))
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp DList_set DList_set: ceq3 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs3))
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs4)))))))))
###                 ("_case1"
###                   ("_applC" ("_position" Some)
###                     ("\<^const>Pure.dummy_pattern"))
###                   ("_applC" ("_position" DList_Set.fold)
###                     ("_cargs"
###                       ("_lambda"
###                         ("_pattern" ("_position" x) ("_position" y))
###                         ("_applC" ("_position" DList_Set.fold)
###                           ("_cargs"
###                             ("_lambda"
###                               ("_pttrns"
###                                 ("_pattern" ("_position" y')
###                                   ("_position" z))
###                                 ("_position" A))
###                               ("\<^const>HOL.If"
###                                 ("_applC" ("_position" eq)
###                                   ("_cargs" ("_position" y)
###                                     ("_position" y')))
###                                 ("_applC" ("_position" insert)
###                                   ("_cargs"
###                                     ("_tuple" ("_position" x)
### ("_tuple_arg" ("_position" z)))
###                                     ("_position" A)))
###                                 ("_position" A)))
###                             ("_position" dxs4))))
###                       ("_cargs" ("_position" dxs3)
###                         ("\<^const>Set.empty")))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs3))
###       ("_applC" ("_position" DList_set) ("_position" dxs4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set DList_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs4)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'f)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp DList_set DList_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs3))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs4)))))))))
###           ("_case2"
###             ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###               ("_case_syntax"
###                 ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'g)))
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp DList_set DList_set: ceq3 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs3))
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs4)))))))))
###             ("_case1"
###               ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###               ("_applC" ("_position" DList_Set.fold)
###                 ("_cargs"
###                   ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                     ("_applC" ("_position" DList_Set.fold)
###                       ("_cargs"
###                         ("_lambda"
###                           ("_pttrns"
###                             ("_pattern" ("_position" y') ("_position" z))
###                             ("_position" A))
###                           ("\<^const>HOL.If"
###                             ("_applC" ("_position" eq)
###                               ("_cargs" ("_position" y) ("_position" y')))
###                             ("_applC" ("_position" insert)
###                               ("_cargs"
###                                 ("_tuple" ("_position" x)
###                                   ("_tuple_arg" ("_position" z)))
###                                 ("_position" A)))
###                             ("_position" A)))
###                         ("_position" dxs4))))
###                   ("_cargs" ("_position" dxs3)
###                     ("\<^const>Set.empty")))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs3))
###       ("_applC" ("_position" DList_set) ("_position" dxs4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set DList_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs4)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'f)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp DList_set DList_set: ceq2 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs3))
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs4)))))))
###                 ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CEQ" ("_position_sort" 'g)))
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp DList_set DList_set: ceq3 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs3))
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs4))))))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_applC" ("_position" DList_Set.fold)
###               ("_cargs"
###                 ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                   ("_applC" ("_position" DList_Set.fold)
###                     ("_cargs"
###                       ("_lambda"
###                         ("_pttrns"
###                           ("_pattern" ("_position" y') ("_position" z))
###                           ("_position" A))
###                         ("\<^const>HOL.If"
###                           ("_applC" ("_position" eq)
###                             ("_cargs" ("_position" y) ("_position" y')))
###                           ("_applC" ("_position" insert)
###                             ("_cargs"
###                               ("_tuple" ("_position" x)
###                                 ("_tuple_arg" ("_position" z)))
###                               ("_position" A)))
###                           ("_position" A)))
###                       ("_position" dxs4))))
###                 ("_cargs" ("_position" dxs3) ("\<^const>Set.empty"))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1591 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt1))
###       ("_applC" ("_position" Set_Monad) ("_position" xs3)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position"
###                   ''relcomp RBT_set Set_Monad: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                   ("_applC" ("_position" Set_Monad) ("_position" xs3)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp RBT_set Set_Monad: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                         ("_applC" ("_position" Set_Monad)
###                           ("_position" xs3)))))))
###               ("_case1" ("_applC" ("_position" Some) ("_position" c_b))
###                 ("_applC" ("_position" RBT_Set2.fold)
###                   ("_cargs"
###                     ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                       ("_applC" ("_position" fold)
###                         ("_cargs"
###                           ("_lambda"
###                             ("_pttrns"
###                               ("_pattern" ("_position" y') ("_position" z))
###                               ("_position" A))
###                             ("\<^const>HOL.If"
###                               ("\<^const>HOL.not_equal"
###                                 ("_applC" ("_position" c_b)
###                                   ("_cargs" ("_position" y)
###                                     ("_position" y')))
###                                 ("_position" Eq))
###                               ("_position" A)
###                               ("_applC" ("_position" insert)
###                                 ("_cargs"
###                                   ("_tuple" ("_position" x)
###                                     ("_tuple_arg" ("_position" z)))
###                                   ("_position" A)))))
###                           ("_position" xs3))))
###                     ("_cargs" ("_position" rbt1)
###                       ("\<^const>Set.empty"))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt1))
###       ("_applC" ("_position" Set_Monad) ("_position" xs3)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position"
###                   ''relcomp RBT_set Set_Monad: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                   ("_applC" ("_position" Set_Monad) ("_position" xs3)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'b)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp RBT_set Set_Monad: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                         ("_applC" ("_position" Set_Monad)
###                           ("_position" xs3)))))))))
###           ("_case1" ("_applC" ("_position" Some) ("_position" c_b))
###             ("_applC" ("_position" RBT_Set2.fold)
###               ("_cargs"
###                 ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                   ("_applC" ("_position" fold)
###                     ("_cargs"
###                       ("_lambda"
###                         ("_pttrns"
###                           ("_pattern" ("_position" y') ("_position" z))
###                           ("_position" A))
###                         ("\<^const>HOL.If"
###                           ("\<^const>HOL.not_equal"
###                             ("_applC" ("_position" c_b)
###                               ("_cargs" ("_position" y) ("_position" y')))
###                             ("_position" Eq))
###                           ("_position" A)
###                           ("_applC" ("_position" insert)
###                             ("_cargs"
###                               ("_tuple" ("_position" x)
###                                 ("_tuple_arg" ("_position" z)))
###                               ("_position" A)))))
###                       ("_position" xs3))))
###                 ("_cargs" ("_position" rbt1) ("\<^const>Set.empty"))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1598 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" Set_Monad) ("_position" xs4))
###       ("_applC" ("_position" RBT_set) ("_position" rbt5)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position"
###                   ''relcomp Set_Monad RBT_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" Set_Monad) ("_position" xs4))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt5)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp Set_Monad RBT_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" Set_Monad) ("_position" xs4))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt5)))))))
###               ("_case1" ("_applC" ("_position" Some) ("_position" c_b))
###                 ("_applC" ("_position" fold)
###                   ("_cargs"
###                     ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                       ("_applC" ("_position" RBT_Set2.fold)
###                         ("_cargs"
###                           ("_lambda"
###                             ("_pttrns"
###                               ("_pattern" ("_position" y') ("_position" z))
###                               ("_position" A))
###                             ("\<^const>HOL.If"
###                               ("\<^const>HOL.not_equal"
###                                 ("_applC" ("_position" c_b)
###                                   ("_cargs" ("_position" y)
###                                     ("_position" y')))
###                                 ("_position" Eq))
###                               ("_position" A)
###                               ("_applC" ("_position" insert)
###                                 ("_cargs"
###                                   ("_tuple" ("_position" x)
###                                     ("_tuple_arg" ("_position" z)))
###                                   ("_position" A)))))
###                           ("_position" rbt5))))
###                     ("_cargs" ("_position" xs4)
###                       ("\<^const>Set.empty"))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" Set_Monad) ("_position" xs4))
###       ("_applC" ("_position" RBT_set) ("_position" rbt5)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position"
###                   ''relcomp Set_Monad RBT_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" Set_Monad) ("_position" xs4))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt5)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'b)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp Set_Monad RBT_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" Set_Monad) ("_position" xs4))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt5)))))))))
###           ("_case1" ("_applC" ("_position" Some) ("_position" c_b))
###             ("_applC" ("_position" fold)
###               ("_cargs"
###                 ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                   ("_applC" ("_position" RBT_Set2.fold)
###                     ("_cargs"
###                       ("_lambda"
###                         ("_pttrns"
###                           ("_pattern" ("_position" y') ("_position" z))
###                           ("_position" A))
###                         ("\<^const>HOL.If"
###                           ("\<^const>HOL.not_equal"
###                             ("_applC" ("_position" c_b)
###                               ("_cargs" ("_position" y) ("_position" y')))
###                             ("_position" Eq))
###                           ("_position" A)
###                           ("_applC" ("_position" insert)
###                             ("_cargs"
###                               ("_tuple" ("_position" x)
###                                 ("_tuple_arg" ("_position" z)))
###                               ("_position" A)))))
###                       ("_position" rbt5))))
###                 ("_cargs" ("_position" xs4) ("\<^const>Set.empty"))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1605 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs3))
###       ("_applC" ("_position" Set_Monad) ("_position" xs5)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set Set_Monad: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs3))
###                   ("_applC" ("_position" Set_Monad) ("_position" xs5)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'f)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp DList_set Set_Monad: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs3))
###                         ("_applC" ("_position" Set_Monad)
###                           ("_position" xs5)))))))
###               ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                 ("_applC" ("_position" DList_Set.fold)
###                   ("_cargs"
###                     ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                       ("_applC" ("_position" fold)
###                         ("_cargs"
###                           ("_lambda"
###                             ("_pttrns"
###                               ("_pattern" ("_position" y') ("_position" z))
###                               ("_position" A))
###                             ("\<^const>HOL.If"
###                               ("_applC" ("_position" eq)
###                                 ("_cargs" ("_position" y) ("_position" y')))
###                               ("_applC" ("_position" insert)
###                                 ("_cargs"
###                                   ("_tuple" ("_position" x)
###                                     ("_tuple_arg" ("_position" z)))
###                                   ("_position" A)))
###                               ("_position" A)))
###                           ("_position" xs5))))
###                     ("_cargs" ("_position" dxs3)
###                       ("\<^const>Set.empty"))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs3))
###       ("_applC" ("_position" Set_Monad) ("_position" xs5)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set Set_Monad: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs3))
###                   ("_applC" ("_position" Set_Monad) ("_position" xs5)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'f)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp DList_set Set_Monad: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs3))
###                         ("_applC" ("_position" Set_Monad)
###                           ("_position" xs5)))))))))
###           ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###             ("_applC" ("_position" DList_Set.fold)
###               ("_cargs"
###                 ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                   ("_applC" ("_position" fold)
###                     ("_cargs"
###                       ("_lambda"
###                         ("_pttrns"
###                           ("_pattern" ("_position" y') ("_position" z))
###                           ("_position" A))
###                         ("\<^const>HOL.If"
###                           ("_applC" ("_position" eq)
###                             ("_cargs" ("_position" y) ("_position" y')))
###                           ("_applC" ("_position" insert)
###                             ("_cargs"
###                               ("_tuple" ("_position" x)
###                                 ("_tuple_arg" ("_position" z)))
###                               ("_position" A)))
###                           ("_position" A)))
###                       ("_position" xs5))))
###                 ("_cargs" ("_position" dxs3) ("\<^const>Set.empty"))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1612 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" Set_Monad) ("_position" xs6))
###       ("_applC" ("_position" DList_set) ("_position" dxs4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'f)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp Set_Monad DList_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" Set_Monad) ("_position" xs6))
###                   ("_applC" ("_position" DList_set) ("_position" dxs4)))))))
###         ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'g)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp Set_Monad DList_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" Set_Monad) ("_position" xs6))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs4)))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_applC" ("_position" fold)
###                   ("_cargs"
###                     ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                       ("_applC" ("_position" DList_Set.fold)
###                         ("_cargs"
###                           ("_lambda"
###                             ("_pttrns"
###                               ("_pattern" ("_position" y') ("_position" z))
###                               ("_position" A))
###                             ("\<^const>HOL.If"
###                               ("_applC" ("_position" eq)
###                                 ("_cargs" ("_position" y) ("_position" y')))
###                               ("_applC" ("_position" insert)
###                                 ("_cargs"
###                                   ("_tuple" ("_position" x)
###                                     ("_tuple_arg" ("_position" z)))
###                                   ("_position" A)))
###                               ("_position" A)))
###                           ("_position" dxs4))))
###                     ("_cargs" ("_position" xs6)
###                       ("\<^const>Set.empty"))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" Set_Monad) ("_position" xs6))
###       ("_applC" ("_position" DList_set) ("_position" dxs4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'f)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp Set_Monad DList_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" Set_Monad) ("_position" xs6))
###                   ("_applC" ("_position" DList_set) ("_position" dxs4)))))))
###         ("_case2"
###           ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'g)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp Set_Monad DList_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" Set_Monad) ("_position" xs6))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs4)))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_applC" ("_position" fold)
###               ("_cargs"
###                 ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                   ("_applC" ("_position" DList_Set.fold)
###                     ("_cargs"
###                       ("_lambda"
###                         ("_pttrns"
###                           ("_pattern" ("_position" y') ("_position" z))
###                           ("_position" A))
###                         ("\<^const>HOL.If"
###                           ("_applC" ("_position" eq)
###                             ("_cargs" ("_position" y) ("_position" y')))
###                           ("_applC" ("_position" insert)
###                             ("_cargs"
###                               ("_tuple" ("_position" x)
###                                 ("_tuple_arg" ("_position" z)))
###                               ("_position" A)))
###                           ("_position" A)))
###                       ("_position" dxs4))))
###                 ("_cargs" ("_position" xs6) ("\<^const>Set.empty"))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1629 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.iff" ("_applC" ("_position" irrefl) ("_position" r))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###           ("_Ball" ("_pattern" ("_position" x) ("_position" y))
###             ("_position" r)
###             ("\<^const>HOL.Not"
###               ("_applC" ("_position" eq)
###                 ("_cargs" ("_position" x) ("_position" y))))))
###         ("_case1" ("_position" None)
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''irrefl: ceq = None & ccompare = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("_applC" ("_position" irrefl) ("_position" r))))))
###               ("_case1" ("_applC" ("_position" Some) ("_position" c))
###                 ("_Ball" ("_pattern" ("_position" x) ("_position" y))
###                   ("_position" r)
###                   ("\<^const>HOL.not_equal"
###                     ("_applC" ("_position" c)
###                       ("_cargs" ("_position" x) ("_position" y)))
###                     ("_position" Eq)))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.iff" ("_applC" ("_position" irrefl) ("_position" r))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###           ("_Ball" ("_pattern" ("_position" x) ("_position" y))
###             ("_position" r)
###             ("\<^const>HOL.Not"
###               ("_applC" ("_position" eq)
###                 ("_cargs" ("_position" x) ("_position" y))))))
###         ("_case2"
###           ("_case1" ("_position" None)
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'a)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''irrefl: ceq = None & ccompare = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("_applC" ("_position" irrefl) ("_position" r))))))))
###           ("_case1" ("_applC" ("_position" Some) ("_position" c))
###             ("_Ball" ("_pattern" ("_position" x) ("_position" y))
###               ("_position" r)
###               ("\<^const>HOL.not_equal"
###                 ("_applC" ("_position" c)
###                   ("_cargs" ("_position" x) ("_position" y)))
###                 ("_position" Eq)))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1722 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" can_select)
###       ("_cargs" ("_position" P)
###         ("_applC" ("_position" Set_Monad) ("_position" xs))))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''can_select Set_Monad: ceq = None''))
###               ("_lambda" ("_idtdummy")
###                 ("_applC" ("_position" can_select)
###                   ("_cargs" ("_position" P)
###                     ("_applC" ("_position" Set_Monad)
###                       ("_position" xs))))))))
###         ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###           ("_case_syntax"
###             ("_applC" ("_position" filter)
###               ("_cargs" ("_position" P) ("_position" xs)))
###             ("_case2" ("_case1" ("_position" Nil) ("_position" False))
###               ("_case1"
###                 ("\<^const>List.list.Cons" ("_position" x) ("_position" xs))
###                 ("_applC" ("_position" list_all)
###                   ("_cargs" ("_applC" ("_position" eq) ("_position" x))
###                     ("_position" xs)))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" can_select)
###       ("_cargs" ("_position" P)
###         ("_applC" ("_position" Set_Monad) ("_position" xs))))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''can_select Set_Monad: ceq = None''))
###               ("_lambda" ("_idtdummy")
###                 ("_applC" ("_position" can_select)
###                   ("_cargs" ("_position" P)
###                     ("_applC" ("_position" Set_Monad)
###                       ("_position" xs))))))))
###         ("_case2"
###           ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###             ("_case_syntax"
###               ("_applC" ("_position" filter)
###                 ("_cargs" ("_position" P) ("_position" xs)))
###               ("_case1" ("_position" Nil) ("_position" False))))
###           ("_case1"
###             ("\<^const>List.list.Cons" ("_position" x) ("_position" xs))
###             ("_applC" ("_position" list_all)
###               ("_cargs" ("_applC" ("_position" eq) ("_position" x))
###                 ("_position" xs)))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1833 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_constrain" ("_position" set_empty_choose)
###       ("_tapp"
###         ("_ofsort" ("_position_sort" 'a)
###           ("_sort"
###             ("_classes" ("_class_name" ceq) ("_class_name" ccompare))))
###         ("_type_name" set)))
###     ("_case_syntax" ("_CCOMPARE" ("_position_sort" 'a))
###       ("_case2"
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_applC" ("_position" RBT_set) ("_position" RBT_Set2.empty)))
###         ("_case1" ("_position" None)
###           ("_case_syntax" ("_CEQ" ("_position_sort" 'a))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Set_Monad)
###                   ("\<^const>List.list.Nil")))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_applC" ("_position" DList_set)
###                   ("_position" DList_Set.empty))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_constrain" ("_position" set_empty_choose)
###       ("_tapp"
###         ("_ofsort" ("_position_sort" 'a)
###           ("_sort"
###             ("_classes" ("_class_name" ceq) ("_class_name" ccompare))))
###         ("_type_name" set)))
###     ("_case_syntax" ("_CCOMPARE" ("_position_sort" 'a))
###       ("_case2"
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_applC" ("_position" RBT_set) ("_position" RBT_Set2.empty)))
###         ("_case2"
###           ("_case1" ("_position" None)
###             ("_case_syntax" ("_CEQ" ("_position_sort" 'a))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Set_Monad)
###                   ("\<^const>List.list.Nil")))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_applC" ("_position" DList_set)
###               ("_position" DList_Set.empty))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
class set_impl = type +
  fixes set_impl :: "('a, set_impl) phantom"
signature SET_IMPL_GENERATOR =
  sig val derive_set_impl: string -> string -> theory -> theory end
structure Set_Impl_Generator: SET_IMPL_GENERATOR
use dlist as set_impl for type unit
registered unit in class set_impl
use dlist as set_impl for type bool
registered bool in class set_impl
use rbt as set_impl for type nat
registered nat in class set_impl
use set_RBT as set_impl for type int
registered int in class set_impl
use dlist as set_impl for type finite_1
registered finite_1 in class set_impl
use dlist as set_impl for type finite_2
registered finite_2 in class set_impl
use dlist as set_impl for type finite_3
registered finite_3 in class set_impl
use rbt as set_impl for type integer
registered integer in class set_impl
use rbt as set_impl for type natural
registered natural in class set_impl
use rbt as set_impl for type char
registered char in class set_impl
instantiation
  sum :: (set_impl, set_impl) set_impl
  set_impl_sum == set_impl :: ('a + 'b, set_impl) phantom
instantiation
  prod :: (set_impl, set_impl) set_impl
  set_impl_prod == set_impl :: ('a * 'b, set_impl) phantom
use choose as set_impl for type list
registered list in class set_impl
use rbt as set_impl for type literal
registered literal in class set_impl
instantiation
  option :: (set_impl) set_impl
  set_impl_option == set_impl :: ('a option, set_impl) phantom
use monad as set_impl for type fun
registered fun in class set_impl
use choose as set_impl for type set
registered set in class set_impl
instantiation
  phantom :: (type, set_impl) set_impl
  set_impl_phantom == set_impl :: (('a, 'b) phantom, set_impl) phantom
### Ambiguous input (line 1952 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" set_aux) ("_position" set_Choose))
###     ("_case_syntax"
###       ("_CCOMPARE"
###         ("_ofsort" ("_position_sort" 'a)
###           ("_sort"
###             ("_classes" ("_class_name" ccompare) ("_class_name" ceq)))))
###       ("_case2"
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_applC" ("_position" conv)
###             ("_applC" ("_position" RBT_set) ("_position" RBT_Set2.empty))))
###         ("_case1" ("_position" None)
###           ("_case_syntax" ("_CEQ" ("_position_sort" 'a))
###             ("_case2" ("_case1" ("_position" None) ("_position" Set_Monad))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_applC" ("_position" conv)
###                   ("_applC" ("_position" DList_set)
###                     ("_position" DList_Set.empty)))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" set_aux) ("_position" set_Choose))
###     ("_case_syntax"
###       ("_CCOMPARE"
###         ("_ofsort" ("_position_sort" 'a)
###           ("_sort"
###             ("_classes" ("_class_name" ccompare) ("_class_name" ceq)))))
###       ("_case2"
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_applC" ("_position" conv)
###             ("_applC" ("_position" RBT_set) ("_position" RBT_Set2.empty))))
###         ("_case2"
###           ("_case1" ("_position" None)
###             ("_case_syntax" ("_CEQ" ("_position_sort" 'a))
###               ("_case1" ("_position" None) ("_position" Set_Monad))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_applC" ("_position" conv)
###               ("_applC" ("_position" DList_set)
###                 ("_position" DList_Set.empty)))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "Containers.Set_Impl"
### 9.618s elapsed time, 10.598s cpu time, 1.014s GC time
Loading theory "Containers.Mapping_Impl" (required by "Draft.Monitor_CodeMoreTemplates" via "Draft.Monitor_Code" via "Containers.Containers")
class mapping_impl = type +
  fixes mapping_impl :: "('a, mapping_impl) phantom"
signature MAPPING_IMPL_GENERATOR =
  sig val derive_mapping_impl: string -> string -> theory -> theory end
structure Mapping_Impl_Generator: MAPPING_IMPL_GENERATOR
use assoclist as mapping_impl for type unit
registered unit in class mapping_impl
use assoclist as mapping_impl for type bool
registered bool in class mapping_impl
use rbt as mapping_impl for type nat
registered nat in class mapping_impl
use mapping_RBT as mapping_impl for type int
registered int in class mapping_impl
use assoclist as mapping_impl for type finite_1
registered finite_1 in class mapping_impl
use assoclist as mapping_impl for type finite_2
registered finite_2 in class mapping_impl
use assoclist as mapping_impl for type finite_3
registered finite_3 in class mapping_impl
use rbt as mapping_impl for type integer
registered integer in class mapping_impl
use rbt as mapping_impl for type natural
registered natural in class mapping_impl
use rbt as mapping_impl for type char
registered char in class mapping_impl
instantiation
  sum :: (mapping_impl, mapping_impl) mapping_impl
  mapping_impl_sum == mapping_impl :: ('a + 'b, mapping_impl) phantom
instantiation
  prod :: (mapping_impl, mapping_impl) mapping_impl
  mapping_impl_prod == mapping_impl :: ('a * 'b, mapping_impl) phantom
use choose as mapping_impl for type list
registered list in class mapping_impl
use rbt as mapping_impl for type literal
registered literal in class mapping_impl
instantiation
  option :: (mapping_impl) mapping_impl
  mapping_impl_option == mapping_impl :: ('a option, mapping_impl) phantom
use choose as mapping_impl for type set
registered set in class mapping_impl
instantiation
  phantom :: (type, mapping_impl) mapping_impl
  mapping_impl_phantom == mapping_impl ::
    (('a, 'b) phantom, mapping_impl) phantom
### theory "Containers.Mapping_Impl"
### 1.147s elapsed time, 1.439s cpu time, 0.173s GC time
Loading theory "Containers.Map_To_Mapping" (required by "Draft.Monitor_CodeMoreTemplates" via "Draft.Monitor_Code" via "Containers.Containers")
structure Containers_Pre: NAMED_THMS
structure Containers_Post: NAMED_THMS
val map_apply_simproc =
   Simproc
    {lhss = [Var (("f", 0), "?'b => ?'a option") $ Var (("x", 0), "?'b")],
     name = "map_apply", proc = fn, stamp = Stamp 8975560}:
   simproc
signature CONTAINERS =
  sig
    val identify: Context.generic -> thm -> thm
    val identify_attribute: attribute
  end
structure Containers: CONTAINERS
### theory "Containers.Map_To_Mapping"
### 0.129s elapsed time, 0.130s cpu time, 0.000s GC time
Loading theory "Containers.Containers" (required by "Draft.Monitor_CodeMoreTemplates" via "Draft.Monitor_Code")
### theory "Containers.Containers"
### 0.026s elapsed time, 0.026s cpu time, 0.000s GC time
Loading theory "Draft.Monitor_Code" (required by "Draft.Monitor_CodeMoreTemplates")
deriving "ceq" instance for type "Extended_Nat.enat" via "="
derived is_ceq_enat-lemma
instantiation
  enat :: ccompare
  ccompare_enat == ccompare :: (enat => enat => order) option
instantiation
  iarray :: (ccompare) ccompare
  ccompare_iarray == ccompare :: ('a iarray => 'a iarray => order) option
use rbt as mapping_impl for type iarray
registered iarray in class mapping_impl
See theory exports
### theory "Draft.Monitor_Code"
### 5.599s elapsed time, 5.931s cpu time, 0.341s GC time
Loading theory "Draft.Monitor_CodeMoreTemplates"
val templateLemmas = []: (string * thm * template) list
### theory "Draft.Monitor_CodeMoreTemplates"
### 0.987s elapsed time, 1.259s cpu time, 0.120s GC time
val it = (): unit
