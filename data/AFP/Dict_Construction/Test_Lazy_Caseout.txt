Loading theory "Deriving.Derive_Manager" (required by "Draft.Test_Lazy_CaseMoreTemplates" via "Draft.Test_Lazy_Case" via "Show.Show_Instances" via "Show.Show")
Loading theory "Automatic_Refinement.Refine_Util_Bootstrap1" (required by "Draft.Test_Lazy_CaseMoreTemplates" via "Draft.Test_Lazy_Case" via "Draft.Dict_Construction" via "Automatic_Refinement.Refine_Util")
Loading theory "Deriving.Generator_Aux" (required by "Draft.Test_Lazy_CaseMoreTemplates" via "Draft.Test_Lazy_Case" via "Show.Show_Instances" via "Show.Show")
Loading theory "HOL-Library.Function_Algebras" (required by "Draft.Test_Lazy_CaseMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
instantiation
  fun :: (type, plus) plus
  plus_fun == plus :: ('a => 'b) => ('a => 'b) => 'a => 'b
infix 1 ##
signature BASIC_REFINE_UTIL =
  sig
    val ## : ('a -> 'b) * ('c -> 'd) -> 'a * 'c -> 'b * 'd
    val map_fold: ('a -> 'b -> 'c * 'b) -> 'a list -> 'b -> 'c list * 'b
    val map_option: ('a -> 'b) -> 'a option -> 'b option
    val seq_is_empty: 'a Seq.seq -> bool * 'a Seq.seq
    val split: ('a -> bool) -> 'a list -> 'a list * 'a list
    val split_matching:
       ('a -> 'b -> bool) ->
         'a list -> 'b list -> ('b list * 'b list) option
    val yield_singleton2:
       ('a list -> 'b -> ('c * 'd list) * 'e) -> 'a -> 'b -> ('c * 'd) * 'e
  end
structure Basic_Refine_Util: BASIC_REFINE_UTIL
val map_option = fn: ('a -> 'b) -> 'a option -> 'b option
val split = fn: ('a -> bool) -> 'a list -> 'a list * 'a list
val map_fold = fn: ('a -> 'b -> 'c * 'b) -> 'a list -> 'b -> 'c list * 'b
val split_matching = fn:
   ('a -> 'b -> bool) -> 'a list -> 'b list -> ('b list * 'b list) option
val seq_is_empty = fn: 'a Seq.seq -> bool * 'a Seq.seq
val ## = fn: ('a -> 'b) * ('c -> 'd) -> 'a * 'c -> 'b * 'd
val yield_singleton2 = fn:
   ('a list -> 'b -> ('c * 'd list) * 'e) -> 'a -> 'b -> ('c * 'd) * 'e
### theory "Automatic_Refinement.Refine_Util_Bootstrap1"
### 0.041s elapsed time, 0.198s cpu time, 0.000s GC time
Loading theory "Automatic_Refinement.Mk_Term_Antiquot" (required by "Draft.Test_Lazy_CaseMoreTemplates" via "Draft.Test_Lazy_Case" via "Draft.Dict_Construction" via "Automatic_Refinement.Refine_Util")
instantiation
  fun :: (type, zero) zero
  zero_fun == zero_class.zero :: 'a => 'b
signature BNF_ACCESS =
  sig
    val bnf_types: Proof.context -> string list -> typ list
    val case_consts: Proof.context -> string list -> term list
    val case_simps: Proof.context -> string list -> thm list list
    val case_thms: Proof.context -> string list -> thm list
    val constr_argument_types:
       Proof.context -> string list -> typ list list list
    val constr_terms: Proof.context -> string -> term list
    val distinct_thms: Proof.context -> string list -> thm list list
    val induct_thms: Proof.context -> string list -> thm list
    val inject_thms: Proof.context -> string list -> thm list list
    val map_comps: Proof.context -> string list -> thm list
    val map_simps: Proof.context -> string list -> thm list list
    val map_terms: Proof.context -> string list -> term list
    val set_simps: Proof.context -> string list -> thm list list
    val set_terms: Proof.context -> string list -> term list list
  end
structure Bnf_Access: BNF_ACCESS
signature DERIVE_MANAGER =
  sig
    val derive: string -> string -> string -> theory -> theory
    val derive_cmd: string -> string -> string -> theory -> theory
    val print_info: theory -> unit
    val register_derive:
       string ->
         string ->
           (string -> string -> theory -> theory) -> theory -> theory
  end
structure Derive_Manager: DERIVE_MANAGER
instantiation
  fun :: (type, times) times
  times_fun == times :: ('a => 'b) => ('a => 'b) => 'a => 'b
### theory "Deriving.Derive_Manager"
### 0.057s elapsed time, 0.263s cpu time, 0.000s GC time
Loading theory "Automatic_Refinement.Mpat_Antiquot" (required by "Draft.Test_Lazy_CaseMoreTemplates" via "Draft.Test_Lazy_Case" via "Draft.Dict_Construction" via "Automatic_Refinement.Refine_Util")
instantiation
  fun :: (type, one) one
  one_fun == one_class.one :: 'a => 'b
val mk_term_antiquot = fn:
   Context.generic * Token.T list ->
     string * (Context.generic * Token.T list)
### theory "Automatic_Refinement.Mk_Term_Antiquot"
### 0.086s elapsed time, 0.334s cpu time, 0.030s GC time
Loading theory "HOL-Library.Nat_Bijection" (required by "Draft.Test_Lazy_CaseMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.Stream")
### theory "HOL-Library.Function_Algebras"
### 0.129s elapsed time, 0.535s cpu time, 0.030s GC time
Loading theory "HOL-Library.Set_Algebras" (required by "Draft.Test_Lazy_CaseMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
instantiation
  set :: (plus) plus
  plus_set == plus :: 'a set => 'a set => 'a set
instantiation
  set :: (times) times
  times_set == times :: 'a set => 'a set => 'a set
signature GENERATOR_AUX =
  sig
    val OF_option: thm -> thm option list -> thm
    val add_used_tycos:
       Proof.context -> string -> string list -> string list
    val alist_to_string: (string * 'a) list -> string
    val conjI_tac:
       thm list ->
         Proof.context ->
           'a list -> (Proof.context -> int -> tactic) -> tactic
    val create_map:
       (typ -> term) ->
         (string * typ -> 'a -> term) ->
           'a ->
             (typ -> bool) ->
               (local_theory -> string -> bool list) ->
                 (local_theory -> string -> term) ->
                   (local_theory -> string -> 'a -> term) ->
                     string list ->
                       (local_theory -> string -> 'a) ->
                         typ -> local_theory -> term
    val create_partial:
       'a ->
         (typ -> bool) ->
           (local_theory -> string -> bool list) ->
             (local_theory -> string -> term) ->
               (local_theory -> string -> 'a -> term) ->
                 string list ->
                   (local_theory -> string -> 'a) ->
                     typ -> local_theory -> term
    val define_overloaded:
       string * term -> local_theory -> thm * local_theory
    val define_overloaded_generic:
       Attrib.binding * term -> local_theory -> thm * local_theory
    val drop_last: 'a list -> 'a list
    val freeify_tvars: typ -> typ
    val ind_case_to_idxs: 'a list list -> int -> int * int
    val infer_type: Proof.context -> term -> term
    val ints_to_subscript: int list -> string
    val is_class_instance: theory -> string -> sort -> bool
    val lambdas: term list -> term -> term
    val mk_case_tac:
       Proof.context ->
         term option list list ->
           thm ->
             (int ->
                Proof.context * thm list * (string * cterm) list -> tactic)
               -> tactic
    val mk_def: typ -> string -> term -> term
    val mk_id: typ -> term
    val mk_infer_const: string -> Proof.context -> term -> term
    val mutual_recursive_types:
       string -> Proof.context -> string list * typ list
    val prove_multi_future:
       Proof.context ->
         string list ->
           term list ->
             term list ->
               ({context: Proof.context, prems: thm list} -> tactic) ->
                 thm list
    val recursor:
       (string -> 'a) * ('a -> bool list) * string list ->
         bool ->
           (typ -> 'b) ->
             (typ -> 'b) ->
               (typ -> 'b) ->
                 ((typ * 'b option) list * 'a -> 'b) -> typ -> 'b
    val rename_types: (typ * typ) list -> term -> term
    val split_IHs:
       (string -> 'a) * ('a -> bool list) * string list ->
         typ list -> thm list -> thm list list
    val std_recursor_tac:
       (string -> 'a) * ('a -> bool list) * string list ->
         typ list ->
           ('a -> thm) ->
             thm list -> typ -> thm list -> Proof.context -> tactic
    val sub: string -> string
    val subT: string -> typ -> string
    val typ_and_vs_of_typname:
       theory -> string -> sort -> typ * (string * sort) list
    val typ_and_vs_of_used_typname:
       string ->
         bool list -> string list -> typ * (string * string list) list
    val type_parameters:
       typ -> Proof.context -> (string * sort) list * typ list
  end
structure Generator_Aux: GENERATOR_AUX
instantiation
  set :: (zero) zero
  zero_set == zero_class.zero :: 'a set
instantiation
  set :: (one) one
  one_set == one_class.one :: 'a set
### theory "Deriving.Generator_Aux"
### 0.183s elapsed time, 0.757s cpu time, 0.030s GC time
Loading theory "HOL-Library.Tree" (required by "Draft.Test_Lazy_CaseMoreTemplates" via "Draft.ExtrEqs" via "Draft.Templates")
val mpat_antiquot = fn:
   Context.generic * Token.T list ->
     string * (Context.generic * Token.T list)
### theory "Automatic_Refinement.Mpat_Antiquot"
### 0.140s elapsed time, 0.554s cpu time, 0.030s GC time
Loading theory "Automatic_Refinement.Refine_Util" (required by "Draft.Test_Lazy_CaseMoreTemplates" via "Draft.Test_Lazy_Case" via "Draft.Dict_Construction")
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
Found termination order: "size_list size <*mlex*> {}"
### theory "HOL-Library.Set_Algebras"
### 0.213s elapsed time, 0.834s cpu time, 0.067s GC time
Loading theory "HOL-Library.BigO" (required by "Draft.Test_Lazy_CaseMoreTemplates" via "Draft.ExtrEqs")
### theory "HOL-Library.Nat_Bijection"
### 0.320s elapsed time, 1.255s cpu time, 0.157s GC time
Loading theory "HOL-Library.Stream" (required by "Draft.Test_Lazy_CaseMoreTemplates" via "Draft.ExtrEqs")
### ML warning (line 563 of "$AFP/Automatic_Refinement/Lib/Refine_Util.thy"):
### Handler catches all exceptions.
infix 0 THEN_ELSE'
infix 0 THEN_ELSE_COMB'
infix 1 THEN_ALL_NEW_FWD
infix 1 THEN_INTERVAL
infix 2 ORELSE_INTERVAL
infix 3 ->>
type itactic = int -> int -> tactic
type tactic' = int -> tactic
signature BASIC_REFINE_UTIL =
  sig
    val ## : ('a -> 'b) * ('c -> 'd) -> 'a * 'c -> 'b * 'd
    val ->> :
       'a context_parser * ('a * Context.generic -> 'b * Context.generic) ->
         'b context_parser
    val ALL_GOALS_FWD: tactic' -> tactic
    val ALL_GOALS_FWD': tactic' -> tactic'
    val APPEND_LIST': tactic' list -> tactic'
    val CAN': tactic' -> tactic'
    val CASES': (tactic' * tactic) list -> tactic'
    val CONCL_COND': (term -> bool) -> tactic'
    val COND': (term -> bool) -> tactic'
    val IF_EXGOAL: (int -> tactic) -> tactic'
    val INTERVAL_FWD: tactic' -> int -> int -> tactic
    val NTIMES': tactic' -> int -> tactic'
    val ORELSE_INTERVAL: itactic * itactic -> itactic
    val REPEAT': tactic' -> tactic'
    val REPEAT_ALL_NEW_FWD: tactic' -> tactic'
    val REPEAT_DETERM': tactic' -> tactic'
    val RSm: Proof.context -> thm -> thm -> thm
    val SINGLE_INTERVAL: itactic -> tactic'
    val THEN_ALL_NEW_FWD: tactic' * tactic' -> tactic'
    val THEN_ELSE': tactic' * (tactic' * tactic') -> tactic'
    val THEN_ELSE_COMB':
       tactic' * ((tactic' * tactic' -> tactic') * tactic' * tactic') ->
         tactic'
    val THEN_INTERVAL: itactic * itactic -> itactic
    val TRADE: (Proof.context -> tactic') -> Proof.context -> tactic'
    val TRY_SOLVED': tactic' -> tactic'
    val WITH_concl: (term -> tactic') -> tactic'
    val WITH_subgoal: (term -> tactic') -> tactic'
    val elim_all_tac: Proof.context -> thm list -> tactic
    val eqsubst_inst_meth: (Proof.context -> Proof.method) context_parser
    val eqsubst_inst_tac:
       Proof.context ->
         bool ->
           int list ->
             ((indexname * Position.T) * string) list ->
               thm -> int -> tactic
    val fo_resolve_tac: thm list -> Proof.context -> tactic'
    val fo_rtac: thm -> Proof.context -> tactic'
    val has_Var: term -> bool
    val insert_subgoal_tac: cterm -> tactic'
    val insert_subgoals_tac: cterm list -> tactic'
    val is_Abs: term -> bool
    val is_Comb: term -> bool
    val is_TFree: typ -> bool
    val is_def_thm: thm -> bool
    type itactic = int -> int -> tactic
    val map_fold: ('a -> 'b -> 'c * 'b) -> 'a list -> 'b -> 'c list * 'b
    val map_option: ('a -> 'b) -> 'a option -> 'b option
    val prefer_tac: int -> tactic
    val rprem_tac: int -> Proof.context -> tactic'
    val rprems_tac: Proof.context -> tactic'
    val seq_is_empty: 'a Seq.seq -> bool * 'a Seq.seq
    val split: ('a -> bool) -> 'a list -> 'a list * 'a list
    val split_matching:
       ('a -> 'b -> bool) ->
         'a list -> 'b list -> ('b list * 'b list) option
    type tactic' = int -> tactic
    val yield_singleton2:
       ('a list -> 'b -> ('c * 'd list) * 'e) -> 'a -> 'b -> ('c * 'd) * 'e
  end
signature REFINE_UTIL =
  sig
    val ## : ('a -> 'b) * ('c -> 'd) -> 'a * 'c -> 'b * 'd
    val ->> :
       'a context_parser * ('a * Context.generic -> 'b * Context.generic) ->
         'b context_parser
    val ALL_GOALS_FWD: tactic' -> tactic
    val ALL_GOALS_FWD': tactic' -> tactic'
    val APPEND_LIST': tactic' list -> tactic'
    val CAN': tactic' -> tactic'
    val CASES': (tactic' * tactic) list -> tactic'
    val CONCL_COND': (term -> bool) -> tactic'
    val COND': (term -> bool) -> tactic'
    val HOL_concl_conv: (Proof.context -> conv) -> Proof.context -> conv
    val IF_EXGOAL: (int -> tactic) -> tactic'
    val INTERVAL_FWD: tactic' -> int -> int -> tactic
    val NTIMES': tactic' -> int -> tactic'
    val OF_fst: thm list -> thm list -> thm
    val ORELSE_INTERVAL: itactic * itactic -> itactic
    val REPEAT': tactic' -> tactic'
    val REPEAT_ALL_NEW_FWD: tactic' -> tactic'
    val REPEAT_DETERM': tactic' -> tactic'
    val RS_fst: thm -> thm list -> thm
    val RSm: Proof.context -> thm -> thm -> thm
    val SINGLE_INTERVAL: itactic -> tactic'
    val THEN_ALL_NEW_FWD: tactic' * tactic' -> tactic'
    val THEN_ELSE': tactic' * (tactic' * tactic') -> tactic'
    val THEN_ELSE_COMB':
       tactic' * ((tactic' * tactic' -> tactic') * tactic' * tactic') ->
         tactic'
    val THEN_INTERVAL: itactic * itactic -> itactic
    val TRADE: (Proof.context -> tactic') -> Proof.context -> tactic'
    val TRY_SOLVED': tactic' -> tactic'
    val WITH_concl: (term -> tactic') -> tactic'
    val WITH_subgoal: (term -> tactic') -> tactic'
    val abs_def: Proof.context -> thm -> thm
    val anorm_term: term -> term
    val anorm_typ: typ -> typ
    val apply_configs:
       ('a Config.T * 'a) list -> Proof.context -> Proof.context
    val build_res_net: thm list -> (int * thm) Net.net
    val cfg_trace_f_tac_conv: bool Config.T
    val changed_rule: (thm -> thm) -> thm -> thm
    val dest_itselfT: typ -> typ
    val dummify_tvars: term -> term
    val elim_all_tac: Proof.context -> thm list -> tactic
    val eqsubst_inst_meth: (Proof.context -> Proof.method) context_parser
    val eqsubst_inst_tac:
       Proof.context ->
         bool ->
           int list ->
             ((indexname * Position.T) * string) list ->
               thm -> int -> tactic
    val f_tac_conv:
       Proof.context -> (term -> term) -> (Proof.context -> tactic) -> conv
    val fcomb_conv: conv -> conv
    val fix_conv: Proof.context -> conv -> conv
    val fix_left_tuple_from_Ts:
       string -> typ list -> Proof.context -> term * Proof.context
    val fixup_vars: cterm -> thm -> thm
    val fixup_vars_conv: conv -> conv
    val fixup_vars_conv': (Proof.context -> conv) -> Proof.context -> conv
    val fo_matches: theory -> cterm -> term -> bool
    val fo_matchp: theory -> cterm -> term -> term list option
    val fo_resolve_tac: thm list -> Proof.context -> tactic'
    val fo_rtac: thm -> Proof.context -> tactic'
    val fold_binop_left:
       ('a -> 'b * 'a) ->
         ('c -> 'a -> 'b * 'a) ->
           ('b * 'b -> 'b) -> 'c list -> 'a -> 'b * 'a
    val fsub_conv: (Proof.context -> conv) -> Proof.context -> conv
    val ftop_conv: (Proof.context -> conv) -> Proof.context -> conv
    val has_Var: term -> bool
    val import_conv: (Proof.context -> conv) -> Proof.context -> conv
    val import_cterms:
       bool -> cterm list -> Proof.context -> cterm list * Proof.context
    val insert_subgoal_tac: cterm -> tactic'
    val insert_subgoals_tac: cterm list -> tactic'
    val instantiate_tuples:
       Proof.context -> (indexname * typ) list -> thm -> thm
    val instantiate_tuples_from_term_tac: Proof.context -> term -> tactic
    val instantiate_tuples_subgoal_tac: Proof.context -> tactic'
    val is_Abs: term -> bool
    val is_Comb: term -> bool
    val is_TFree: typ -> bool
    val is_def_thm: thm -> bool
    type itactic = int -> int -> tactic
    val ite_conv: conv -> conv -> conv -> conv
    val lambda_tuple: term list -> term -> term
    val list_binop_left: 'a -> ('a * 'a -> 'a) -> 'a list -> 'a
    val list_prodT_left: typ list -> typ
    val map_fold: ('a -> 'b -> 'c * 'b) -> 'a list -> 'b -> 'c list * 'b
    val map_option: ('a -> 'b) -> 'a option -> 'b option
    val mk_compN: int -> term -> term -> term
    val mk_compN1: typ list -> int -> term -> term -> term
    val mk_ltuple: term list -> term
    val monitor_conv: string -> conv -> conv
    val monitor_conv':
       string -> (Proof.context -> conv) -> Proof.context -> conv
    val order_by: ('a * 'a -> order) -> ('b -> 'a) -> 'b list -> 'b list
    val parse_bool_config: string -> bool Config.T -> bool context_parser
    val parse_bool_config':
       string ->
         bool Config.T ->
           Token.T list -> (bool Config.T * bool) * Token.T list
    val parse_paren_list: 'a context_parser -> 'a list context_parser
    val parse_paren_list':
       'a parser -> Token.T list -> 'a list * Token.T list
    val parse_paren_lists: 'a context_parser -> 'a list list context_parser
    val pat_conv: cterm -> (Proof.context -> conv) -> Proof.context -> conv
    val pat_conv':
       cterm -> (string -> Proof.context -> conv) -> Proof.context -> conv
    val prefer_tac: int -> tactic
    val repeat_rule: (thm -> thm) -> thm -> thm
    val rprem_tac: int -> Proof.context -> tactic'
    val rprems_tac: Proof.context -> tactic'
    val seq_is_empty: 'a Seq.seq -> bool * 'a Seq.seq
    val shift_lambda_left: thm -> thm
    val shift_lambda_leftN: int -> thm -> thm
    val split: ('a -> bool) -> 'a list -> 'a list * 'a list
    val split_matching:
       ('a -> 'b -> bool) ->
         'a list -> 'b list -> ('b list * 'b list) option
    val strip_prodT_left: typ -> typ list
    val subsume_sort: ('a -> term) -> theory -> 'a list -> 'a list
    val subsume_sort_gen:
       ('a -> term) -> Context.generic -> 'a list -> 'a list
    type tactic' = int -> tactic
    val trace_conv: conv
    val trade_rule:
       (Proof.context -> thm -> thm) -> Proof.context -> thm -> thm
    val try_rule: (thm -> thm) -> thm -> thm
    val yield_singleton2:
       ('a list -> 'b -> ('c * 'd list) * 'e) -> 'a -> 'b -> ('c * 'd) * 'e
  end
structure Refine_Util: REFINE_UTIL
structure Basic_Refine_Util: BASIC_REFINE_UTIL
val map_option = fn: ('a -> 'b) -> 'a option -> 'b option
val split = fn: ('a -> bool) -> 'a list -> 'a list * 'a list
val REPEAT_DETERM' = fn: tactic' -> tactic'
val RSm = fn: Proof.context -> thm -> thm -> thm
val NTIMES' = fn: tactic' -> int -> tactic'
val fo_resolve_tac = fn: thm list -> Proof.context -> tactic'
val SINGLE_INTERVAL = fn: itactic -> tactic'
val insert_subgoals_tac = fn: cterm list -> tactic'
val insert_subgoal_tac = fn: cterm -> tactic'
val THEN_ALL_NEW_FWD = fn: tactic' * tactic' -> tactic'
val TRY_SOLVED' = fn: tactic' -> tactic'
val INTERVAL_FWD = fn: tactic' -> int -> int -> tactic
val IF_EXGOAL = fn: (int -> tactic) -> tactic'
val eqsubst_inst_tac = fn:
   Proof.context ->
     bool ->
       int list ->
         ((indexname * Position.T) * string) list -> thm -> int -> tactic
val fo_rtac = fn: thm -> Proof.context -> tactic'
val TRADE = fn: (Proof.context -> tactic') -> Proof.context -> tactic'
val is_TFree = fn: typ -> bool
val ALL_GOALS_FWD = fn: tactic' -> tactic
val yield_singleton2 = fn:
   ('a list -> 'b -> ('c * 'd list) * 'e) -> 'a -> 'b -> ('c * 'd) * 'e
val ## = fn: ('a -> 'b) * ('c -> 'd) -> 'a * 'c -> 'b * 'd
val CAN' = fn: tactic' -> tactic'
val WITH_concl = fn: (term -> tactic') -> tactic'
val is_Abs = fn: term -> bool
val COND' = fn: (term -> bool) -> tactic'
val split_matching = fn:
   ('a -> 'b -> bool) -> 'a list -> 'b list -> ('b list * 'b list) option
val REPEAT_ALL_NEW_FWD = fn: tactic' -> tactic'
val CASES' = fn: (tactic' * tactic) list -> tactic'
val APPEND_LIST' = fn: tactic' list -> tactic'
val map_fold = fn: ('a -> 'b -> 'c * 'b) -> 'a list -> 'b -> 'c list * 'b
val is_def_thm = fn: thm -> bool
val THEN_INTERVAL = fn: itactic * itactic -> itactic
val rprems_tac = fn: Proof.context -> tactic'
val WITH_subgoal = fn: (term -> tactic') -> tactic'
val is_Comb = fn: term -> bool
val THEN_ELSE_COMB' = fn:
   tactic' * ((tactic' * tactic' -> tactic') * tactic' * tactic') -> tactic'
val eqsubst_inst_meth = fn: (Proof.context -> Proof.method) context_parser
val elim_all_tac = fn: Proof.context -> thm list -> tactic
val ->> = fn:
   'a context_parser * ('a * Context.generic -> 'b * Context.generic) ->
     'b context_parser
val ALL_GOALS_FWD' = fn: tactic' -> tactic'
val prefer_tac = fn: int -> tactic
val rprem_tac = fn: int -> Proof.context -> tactic'
val has_Var = fn: term -> bool
val REPEAT' = fn: tactic' -> tactic'
val THEN_ELSE' = fn: tactic' * (tactic' * tactic') -> tactic'
val CONCL_COND' = fn: (term -> bool) -> tactic'
val ORELSE_INTERVAL = fn: itactic * itactic -> itactic
val seq_is_empty = fn: 'a Seq.seq -> bool * 'a Seq.seq
### theory "Automatic_Refinement.Refine_Util"
### 0.318s elapsed time, 1.241s cpu time, 0.157s GC time
Loading theory "Draft.Dict_Construction" (required by "Draft.Test_Lazy_CaseMoreTemplates" via "Draft.Test_Lazy_Case")
consts
  left :: "'a tree => 'a tree"
consts
  right :: "'a tree => 'a tree"
### ML warning (line 246 of "$AFP/Dict_Construction/dict_construction_util.ML"):
### Pattern is not exhaustive.
### ML warning (line 246 of "$AFP/Dict_Construction/dict_construction_util.ML"):
### Value identifier (frees) has not been referenced.
infixr 5 ==>
infixr 0 ===>
infix 1 CONTINUE_WITH
infix 1 CONTINUE_WITH_FW
signature DICT_CONSTRUCTION_UTIL =
  sig
    val ===> : term list * term -> term
    val ==> : term * term -> term
    val ALLGOALS': Proof.context -> (int -> tactic) -> tactic
    val ANY: tactic list -> tactic
    val ANY': ('a -> tactic) list -> 'a -> tactic
    val CONTINUE_WITH:
       (int -> tactic) * (int -> tactic) list -> int -> thm -> thm Seq.seq
    val CONTINUE_WITH_FW:
       (int -> tactic) * (int -> tactic) list -> int -> thm -> thm Seq.seq
    val SOLVED: tactic -> tactic
    val TRY': ('a -> tactic) -> 'a -> tactic
    val all_frees: term -> (string * typ) list
    val all_frees': term -> string list
    val all_tfrees: typ -> (string * sort) list
    val cat_options: 'a option list -> 'a list
    val changed_conv: ('a -> thm) -> 'a -> thm
    val contract: Proof.context -> thm -> thm
    val conv_result: ('a -> thm) -> 'a -> term
    val debug: bool Config.T
    val define_params_nosyn: term -> local_theory -> thm * local_theory
    val descend_fun_conv: conv -> conv
    val flat_right: ('a * 'b list) list -> ('a * 'b) list
    val fo_cong_tac: Proof.context -> thm -> int -> tactic
    val if_debug: Proof.context -> (unit -> unit) -> unit
    val lhs_conv: conv -> conv
    val maybe_induct_tac:
       thm list option ->
         term list list -> term list list -> Proof.context -> tactic
    val multi_induct_tac:
       thm list ->
         term list list -> term list list -> Proof.context -> tactic
    val note_thm: binding -> thm -> local_theory -> thm * local_theory
    val note_thms:
       binding -> thm list -> local_theory -> thm list * local_theory
    val on_thms_complete: (unit -> 'a) -> thm list -> thm list
    val partition: ('a -> bool) -> 'a list -> 'a list * 'a list
    val pretty_const: Proof.context -> string -> Pretty.T
    val print_tac': Proof.context -> string -> int -> tactic
    val prove':
       Proof.context ->
         string list ->
           term list ->
             term ->
               ({context: Proof.context, prems: thm list} -> tactic) -> thm
    val prove_common':
       Proof.context ->
         string list ->
           term list ->
             term list ->
               ({context: Proof.context, prems: thm list} -> tactic) ->
                 thm list
    val rewr_lhs_head_conv: thm -> conv
    val rewr_rhs_head_conv: thm -> conv
    val rhs_conv: conv -> conv
    val sortify: sort -> term -> term
    val sortify_typ: sort -> typ -> typ
    val split_list3: ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
    val symreltab_of_symtab:
       'a Symtab.table Symtab.table -> 'a Symreltab.table
    val typify: term -> term
    val typify_typ: typ -> typ
    val unappend: 'a list * 'b -> 'c list -> 'c list * 'c list
    val with_timeout: Time.time -> ('a -> 'a) -> 'a -> 'a
    val zip_symtabs:
       ('a -> 'b -> 'c) ->
         'a Symtab.table -> 'b Symtab.table -> 'c Symtab.table
  end
structure Dict_Construction_Util: DICT_CONSTRUCTION_UTIL
signature TRANSFER_TERMINATION =
  sig
    val termination_tac:
       Function.info -> Function.info -> Proof.context -> int -> tactic
  end
structure Transfer_Termination: TRANSFER_TERMINATION
Found termination order: "size <*mlex*> {}"
signature CONGRUENCES =
  sig
    type ctx = (string * typ) list * term list
    datatype ctx_tree = Tree of term * (rule * (ctx * ctx_tree) list) option
    val export_term_ctx: ctx -> term -> term
    val fold_tree:
       (term -> 'a) ->
         (term -> rule -> (ctx * 'a) list -> 'a) -> ctx_tree -> 'a
    val import_rule: Proof.context -> thm -> rule
    val import_term: Proof.context -> rule list -> term -> ctx_tree
    type rule = {concl: term, prems: term list, proper: bool, rule: thm}
  end
structure Congruences: CONGRUENCES
Found termination order: "size <*mlex*> {}"
consts
  shift :: "'a list => 'a stream => 'a stream"
### ML warning (line 54 of "$AFP/Dict_Construction/side_conditions.ML"):
### Pattern is not exhaustive.
### ML warning (line 96 of "$AFP/Dict_Construction/side_conditions.ML"):
### Matches are not exhaustive.
signature SIDE_CONDITIONS =
  sig
    val get_predicate: Proof.context -> term -> predicate option
    val is_total: Proof.context -> term -> bool
    val mk_side:
       thm list ->
         thm list option -> local_theory -> predicate list * local_theory
    type predicate =
       {alt: thm option, f: term, index: int, inductive: Inductive.result}
    val set_alt: term -> thm -> Context.generic -> Context.generic
    val time_limit: real Config.T
    val transform_predicate: morphism -> predicate -> predicate
  end
structure Side_Conditions: SIDE_CONDITIONS
Proofs for coinductive predicate(s) "streamsp"
  Proving monotonicity ...
Found termination order: "size <*mlex*> {}"
signature CLASS_GRAPH =
  sig
    val all_edges: local_theory -> edge Symreltab.table
    val all_nodes: local_theory -> node Symtab.table
    val class_of: ev -> class
    val dict_typ: node -> typ -> typ
    type edge = {subclass: thm, super_selector: selector}
    val edges: local_theory -> class -> edge Symtab.table option
    val ensure_class: class -> local_theory -> ev * local_theory
    type ev
    val find_path: ev -> class -> path option
    val find_path': ev -> (ev -> 'a option) -> (path * 'a) option
    val fold_path: path -> typ -> term -> term
    val mangle: string -> string
    val node: local_theory -> class -> node option
    type node =
       {cert: typ -> term,
        cert_thms: thm * thm * thm list,
        class: string,
        data_thms: thm list,
        make: typ -> term, qname: string, selectors: selector Symtab.table}
    val node_of: ev -> node
    val param_sorts: string -> class -> theory -> class list list
    val parents_of: ev -> (edge * ev) Symtab.table
    type path = edge list
    val pretty_ev: Proof.context -> ev -> Pretty.T
    type selector = typ -> term
    val super_classes: class -> theory -> string list
  end
structure Class_Graph: CLASS_GRAPH
consts
  snth :: "'a stream => nat => 'a"
class height = type +
  fixes height :: "'a => nat"
instantiation
  tree :: (type) height
  height_tree == height :: 'a tree => nat
consts
  stake :: "nat => 'a stream => 'a list"
consts
  sdrop :: "nat => 'a stream => 'a stream"
Found termination order: "size <*mlex*> {}"
consts
  sfilter :: "('a => bool) => 'a stream => 'a stream"
consts
  cycle :: "'a list => 'a stream"
Found termination order: "size <*mlex*> {}"
consts
  siterate :: "('a => 'a) => 'a => 'a stream"
Found termination order: "size <*mlex*> {}"
### theory "HOL-Library.BigO"
### 1.035s elapsed time, 3.898s cpu time, 0.897s GC time
Loading theory "Lazy_Case.Lazy_Case" (required by "Draft.Test_Lazy_CaseMoreTemplates" via "Draft.Test_Lazy_Case")
consts
  flat :: "'a list stream => 'a stream"
Found termination order: "size <*mlex*> {}"
consts
  sinterleave :: "'a stream => 'a stream => 'a stream"
consts
  szip :: "'a stream => 'b stream => ('a * 'b) stream"
signature LAZY_CASE =
  sig
    val lazify: Ctr_Sugar.ctr_sugar -> local_theory -> local_theory
    val lazify_cmd: string -> local_theory -> local_theory
    val lazify_typ: typ -> local_theory -> local_theory
    val lazy_case_plugin: string
    val setup: theory -> theory
  end
structure Lazy_Case: LAZY_CASE
consts
  smap2 :: "('a => 'b => 'c) => 'a stream => 'b stream => 'c stream"
Found termination order: "size <*mlex*> {}"
### theory "Lazy_Case.Lazy_Case"
### 0.167s elapsed time, 0.654s cpu time, 0.049s GC time
Loading theory "Show.Show" (required by "Draft.Test_Lazy_CaseMoreTemplates" via "Draft.Test_Lazy_Case" via "Show.Show_Instances")
### theory "HOL-Library.Stream"
### 1.112s elapsed time, 4.198s cpu time, 0.856s GC time
val mk_2elem_list = fn: term -> term -> term
val mk_compr = fn: term -> term -> term
val test1 = "[1, 2]": cterm
val test2 = "{x: {1, 2, 3}. 2 < x}": cterm
val test3 =
   Const ("Groups.plus_class.plus", "nat => nat => nat") $ Bound 0 $
     Bound 0:
   term
Found termination order: "size <*mlex*> {}"
val dest_pair_singleton = fn: term -> term
val dest_nat_pair_singleton = fn: term -> term * term
val dest_pair_singleton_T = fn: term -> (term * typ) * (term * typ)
val dest_pair_lambda = fn: term -> string * typ * string * typ * term * term
val foo = fn: term -> term * term * int * term * term
### ML warning (line 269 of "$AFP/Dict_Construction/dict_construction.ML"):
### Pattern is not exhaustive.
### ML warning (line 300 of "$AFP/Dict_Construction/dict_construction.ML"):
### Pattern is not exhaustive.
### ML warning (line 782 of "$AFP/Dict_Construction/dict_construction.ML"):
### Matches are not exhaustive.
### ML warning (line 806 of "$AFP/Dict_Construction/dict_construction.ML"):
### Matches are not exhaustive.
### ML warning (line 884 of "$AFP/Dict_Construction/dict_construction.ML"):
### Value identifier (side) has not been referenced.
signature DICT_CONSTRUCTION =
  sig
    val annotate_code_eqs:
       local_theory -> string list -> const sccs * local_theory
    val axclass: class -> local_theory -> Class_Graph.node * local_theory
    datatype cert_proof = Cert | Skip
    val cong_of_const: Proof.context -> string -> thm option
    type const
    type const_info =
       {base_certs: thm list,
        base_thms: thm list,
        code_thms: thm list,
        congs: thm list option,
        fun_info: Function.info option,
        inducts: thm list option, simps: thm list}
    val consts:
       (string * const) Symtab.table ->
         cert_proof -> (string * const) list -> local_theory -> local_theory
    type dict_target = (string * class) list * (term * string * class)
    type dict_thms = {base_thms: thm list, def_thm: thm}
    type fun_target = (string * class) list * (term * term)
    val get_code_eqs: Proof.context -> string -> thm list
    val group_code_eqs:
       Proof.context ->
         string list ->
           (string *
            (((string * sort) list * typ) *
             ((term list * term) * thm option) list)
           )
           list
           list
    val instance:
       (string * const) Symtab.table ->
         string -> class -> local_theory -> term * local_theory
    val new_names: local_theory -> const sccs -> (string * const) sccs
    val normalizer_conv: Proof.context -> conv
    val prove_dict_cert: dict_target -> dict_thms -> local_theory -> thm
    val prove_fun_cert:
       fun_target list ->
         const_info -> cert_proof -> local_theory -> thm list
    type 'a sccs = (string * 'a) list list
    val symtab_of_sccs: 'a sccs -> 'a Symtab.table
    val term:
       term Symreltab.table ->
         (string * const) Symtab.table ->
           term -> local_theory -> term * local_theory
    val the_info: Proof.context -> string -> const_info
  end
structure Dict_Construction: DICT_CONSTRUCTION
### theory "Draft.Dict_Construction"
### 1.111s elapsed time, 4.177s cpu time, 0.856s GC time
Found termination order: "size <*mlex*> {}"
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
class show = type +
  fixes shows_prec :: "nat => 'a => char list => char list"
    and shows_list :: "'a list => char list => char list"
  assumes
    "shows_prec_append":
      "!!p x r s. shows_prec p x (r @ s) = shows_prec p x r @ s"
    and
    "shows_list_append":
      "!!xs r s. shows_list xs (r @ s) = shows_list xs r @ s"
Found termination order: "(%p. length (snd (snd p))) <*mlex*> {}"
instantiation
  char :: show
  shows_prec_char == shows_prec :: nat => char => char list => char list
  shows_list_char == shows_list :: char list => char list => char list
Found termination order: "size <*mlex*> {}"
signature SHOW_GENERATOR =
  sig
    val generate_showsp: string -> local_theory -> local_theory
    val register_foreign_partial_and_full_showsp:
       string ->
         int ->
           term ->
             term ->
               thm option ->
                 term ->
                   thm option ->
                     bool list -> thm -> local_theory -> local_theory
    val register_foreign_showsp:
       typ -> term -> thm -> local_theory -> local_theory
    val show_instance: string -> theory -> theory
  end
structure Show_Generator: SHOW_GENERATOR
instantiation
  list :: (show) show
  shows_prec_list == shows_prec :: nat => 'a list => char list => char list
  shows_list_list == shows_list :: 'a list list => char list => char list
### theory "HOL-Library.Tree"
### 2.063s elapsed time, 6.813s cpu time, 1.139s GC time
Loading theory "Draft.Templates" (required by "Draft.Test_Lazy_CaseMoreTemplates" via "Draft.ExtrEqs")
instantiation
  String.literal :: show
  shows_prec_literal == shows_prec ::
    nat => String.literal => char list => char list
  shows_list_literal == shows_list ::
    String.literal list => char list => char list
### theory "Show.Show"
### 0.741s elapsed time, 1.721s cpu time, 0.127s GC time
Loading theory "Show.Show_Instances" (required by "Draft.Test_Lazy_CaseMoreTemplates" via "Draft.Test_Lazy_Case")
datatype template_term
=
     t_empty
   | template_app of template_term * template_term
   | template_hole of int
   | template_var of int
datatype sign
= equals | greater_equals | greater_than | less_equals | less_than
datatype template
=
     template_bimplication of template * template
   | template_dunno
   | template_equation of template_term * template_term
   | template_implication of template list * template
   | template_inequation of sign * template_term * template_term
   | template_negation of template
   | template_predicate of template_term
constructor t_empty: template_term
constructor template_app: template_term * template_term -> template_term
constructor template_hole: int -> template_term
constructor template_var: int -> template_term
constructor equals: sign
constructor greater_equals: sign
constructor greater_than: sign
constructor less_equals: sign
constructor less_than: sign
constructor template_bimplication: template * template -> template
constructor template_dunno: template
constructor template_equation: template_term * template_term -> template
constructor template_implication: template list * template -> template
constructor template_inequation:
   sign * template_term * template_term -> template
constructor template_negation: template -> template
constructor template_predicate: template_term -> template
val vfs = fn: term -> (indexname * typ) list * (string * typ) list
val indexOf = fn: ''a list -> ''a -> int -> int
val has_eq = fn: term -> bool
val term2template = fn:
   (indexname * typ) list -> (string * typ) list -> term -> template_term
val lemma2predicate = fn: term -> term -> template
val makeTemplatewithContext = fn: term -> term -> template
val lemma2template = fn: term -> template
val thm2template = fn: thm -> template
val tterm2string = fn: template_term -> string
val template2string = fn: template -> string
val t = "height ?t <= size ?t": thm
val th =
   Const ("HOL.Trueprop", "bool => prop") $
     (Const ("Orderings.ord_class.less_eq", "nat => nat => bool") $
       (Const ("Tree.height_class.height", "?'a tree => nat") $
         Var (("t", 0), "?'a tree")) $
       (Const ("Nat.size_class.size", "?'a tree => nat") $
         Var (("t", 0), "?'a tree"))):
   term
### theory "Draft.Templates"
### 0.056s elapsed time, 0.125s cpu time, 0.000s GC time
Loading theory "Draft.ExtrEqs" (required by "Draft.Test_Lazy_CaseMoreTemplates")
consts
  showsp_bool :: "nat => bool => char list => char list"
consts
  pshowsp_prod ::
    "nat
     => (char list => char list) * (char list => char list)
        => char list => char list"
Found termination order: "{}"
val eqpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Var (("_dummy_", 2), "?'a"))
       ):
   term Find_Theorems.criterion
val badeqpattern = Pattern (Const ("Pure.eq", "?'a => ?'a => prop")):
   term Find_Theorems.criterion
val undefpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Const ("HOL.undefined", "?'a"))
       ):
   term Find_Theorems.criterion
val thmpattern =
   Pattern
    (Const ("HOL.Trueprop", "bool => prop") $ Var (("_dummy_", 1), "bool")):
   term Find_Theorems.criterion
val badnames =
   ["*nitpick*", "*Nitpick*", "*full_exhaustive*", "*_def*", "Enum.finite*",
    "*Quickcheck*", "ATP*", "*Nunchaku*", "*Code*", "*BNF*", "*SMT*",
    "*.*.*"]:
   string list
val unwanted_names =
   [(false, Name "*nitpick*"), (false, Name "*Nitpick*"),
    (false, Name "*full_exhaustive*"), (false, Name "*_def*"),
    (false, Name "Enum.finite*"), (false, Name "*Quickcheck*"),
    (false, Name "ATP*"), (false, Name "*Nunchaku*"),
    (false, Name "*Code*"), (false, Name "*BNF*"), (false, Name "*SMT*"),
    (false, Name "*.*.*")]:
   (bool * term Find_Theorems.criterion) list
val has_vars = fn: term -> bool
val get_all_eqs = fn: string -> Proof.context -> (string * thm) list
val get_all_thms = fn: string -> Proof.context -> (string * thm) list
val get_noneq_thms = fn: string -> Proof.context -> (string * thm) list
val template_eqs = fn:
   string -> Proof.context -> (string * thm * template) list
val template_thms = fn:
   string -> Proof.context -> (string * thm * template) list
### theory "Draft.ExtrEqs"
### 0.537s elapsed time, 1.113s cpu time, 0.081s GC time
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
deriving "show" instance for type "Option.option"
generating show function for type "Option.option"
deriving "show" instance for type "Sum_Type.sum"
generating show function for type "Sum_Type.sum"
deriving "show" instance for type "Product_Type.prod"
deriving "show" instance for type "Product_Type.unit"
deriving "show" instance for type "HOL.bool"
deriving "show" instance for type "Nat.nat"
deriving "show" instance for type "Int.int"
deriving "show" instance for type "Rat.rat"
### theory "Show.Show_Instances"
### 0.819s elapsed time, 1.406s cpu time, 0.081s GC time
Loading theory "Draft.Test_Lazy_Case" (required by "Draft.Test_Lazy_CaseMoreTemplates")
locale experiment5434738
Redefining constant(s) []
Redefining constant(s) (#)
Redefining constant(s) map
Proofs for inductive predicate(s) "List_list_map_side"
Porting fundef_cong rule for  map
Proved equivalence for map
Redefining constant(s) ()
Redefining constant(s) Fork
Redefining constant(s) Node
Redefining constant(s) Test_Lazy_Case.tree.case_lazy
Proofs for inductive predicate(s) "Test__Lazy__Case_Test__Lazy__Case_tree_case__lazy_side"
Porting fundef_cong rule for  Test_Lazy_Case.tree.case_lazy
Proved equivalence for Test_Lazy_Case.tree.case_lazy
Redefining constant(s) map_tree
Proofs for inductive predicate(s) "Test__Lazy__Case_tree_map__tree_side"
Porting fundef_cong rule for  map_tree
Proved equivalence for map_tree
List_list_map = map
Test__Lazy__Case_tree_map__tree = map_tree
Test__Lazy__Case_Test__Lazy__Case_tree_case__lazy =
Test_Lazy_Case.tree.case_lazy
locale experiment5442978
Defining record for class show
### ignoring code equation with non-linear pattern
Redefining constant(s) id
Proofs for inductive predicate(s) "Fun_id_side"
Porting fundef_cong rule for  id
Proved equivalence for id
Redefining constant(s) Let
Proofs for inductive predicate(s) "HOL_Let_side"
Porting fundef_cong rule for  Let
Proved equivalence for Let
Redefining constant(s) Suc
Redefining constant(s) (o)
Proofs for inductive predicate(s) "Fun_comp_side"
Porting fundef_cong rule for  (o)
Proved equivalence for (o)
Redefining constant(s) True
Redefining constant(s) False
Redefining constant(s) (|)
Proofs for inductive predicate(s) "HOL_disj_side"
Proved equivalence for (|)
Redefining constant(s) (#)
Redefining constant(s) []
Redefining constant(s) List.null
Proofs for inductive predicate(s) "List_null_side"
Proved equivalence for List.null
Redefining constant(s) (@)
Proofs for inductive predicate(s) "List_append_side"
Proved equivalence for (@)
Redefining constant(s) num.One
Redefining constant(s) num.Bit0
Redefining constant(s) num.Bit1
Redefining constant(s) show_char_inst.shows_prec_char
Proofs for inductive predicate(s) "Show_show__char__inst_shows__prec__char_side"
Proved equivalence for show_char_inst.shows_prec_char
Redefining constant(s) ()
Redefining constant(s) HOL.bool.case_lazy
Proofs for inductive predicate(s) "Product__Type_HOL_bool_case__lazy_side"
Porting fundef_cong rule for  HOL.bool.case_lazy
Proved equivalence for HOL.bool.case_lazy
Redefining constant(s) zero_nat_inst.zero_nat
Redefining constant(s) ord_nat_inst.less_nat, ord_nat_inst.less_eq_nat
Proofs for inductive predicate(s) "Nat_ord__nat__inst_less__nat_side", "Nat_ord__nat__inst_less__eq__nat_side"
Proved equivalence for ord_nat_inst.less_nat, ord_nat_inst.less_eq_nat
Redefining constant(s) Char
Redefining constant(s) shows_pl
Proofs for inductive predicate(s) "Show_shows__pl_side"
Proved equivalence for shows_pl
Redefining constant(s) shows_pr
Proofs for inductive predicate(s) "Show_shows__pr_side"
Proved equivalence for shows_pr
Redefining constant(s) plus_nat_inst.plus_nat
Proofs for inductive predicate(s) "Nat_plus__nat__inst_plus__nat_side"
Proved equivalence for plus_nat_inst.plus_nat
Redefining constant(s) one_nat_inst.one_nat
Proofs for inductive predicate(s) "Nat_one__nat__inst_one__nat_side"
Proved equivalence for one_nat_inst.one_nat
Redefining constant(s) nat_of_num
Proofs for inductive predicate(s) "Num_nat__of__num_side"
Proved equivalence for nat_of_num
Redefining constant(s) shows_string
Proofs for inductive predicate(s) "Show_shows__string_side"
Proved equivalence for shows_string
Redefining constant(s) shows_sep
### Falling back to another termination proof
Proofs for inductive predicate(s) "Show_shows__sep_side"
Porting fundef_cong rule for  shows_sep
Proved equivalence for shows_sep
Redefining constant(s) shows_space
Proofs for inductive predicate(s) "Show_shows__space_side"
Proved equivalence for shows_space
Redefining constant(s) shows_list_gen
Proofs for inductive predicate(s) "Show_shows__list__gen_side"
Porting fundef_cong rule for  shows_list_gen
Proved equivalence for shows_list_gen
Redefining constant(s) showsp_list
Proofs for inductive predicate(s) "Show_showsp__list_side"
Porting fundef_cong rule for  showsp_list
Proved equivalence for showsp_list
Redefining constant(s) Some
Redefining constant(s) None
Redefining constant(s) showsp_option
Proofs for inductive predicate(s) "Show__Instances_showsp__option_side"
Proved equivalence for showsp_option
Redefining constant(s) shows_prec
Redefining constant(s) show_option_inst.shows_prec_option
Proofs for inductive predicate(s) "Show__Instances_show__option__inst_shows__prec__option_side"
Proved equivalence for show_option_inst.shows_prec_option
Redefining constant(s) show_option_inst.shows_list_option
Proofs for inductive predicate(s) "Show__Instances_show__option__inst_shows__list__option_side"
Proved equivalence for show_option_inst.shows_list_option
Redefining constant(s) showsp_unit
Proofs for inductive predicate(s) "Show__Instances_showsp__unit_side"
### Potentially underspecified function(s): Show__Instances_showsp__unit
Proved equivalence for showsp_unit
Redefining constant(s) show_unit_inst.shows_prec_unit
Proofs for inductive predicate(s) "Show__Instances_show__unit__inst_shows__prec__unit_side"
### Potentially underspecified function(s): Show__Instances_show__unit__inst_shows__prec__unit
Proved equivalence for show_unit_inst.shows_prec_unit
Redefining constant(s) show_unit_inst.shows_list_unit
Proofs for inductive predicate(s) "Show__Instances_show__unit__inst_shows__list__unit_side"
Proved equivalence for show_unit_inst.shows_list_unit
Redefining constant(s) Pair
Redefining constant(s) showsp_prod
Proofs for inductive predicate(s) "Show__Instances_showsp__prod_side"
Proved equivalence for showsp_prod
Redefining constant(s) show_prod_inst.shows_prec_prod
Proofs for inductive predicate(s) "Show__Instances_show__prod__inst_shows__prec__prod_side"
Proved equivalence for show_prod_inst.shows_prec_prod
Redefining constant(s) show_prod_inst.shows_list_prod
Proofs for inductive predicate(s) "Show__Instances_show__prod__inst_shows__list__prod_side"
Proved equivalence for show_prod_inst.shows_list_prod
Redefining constant(s) showsp_bool
Proofs for inductive predicate(s) "Show__Instances_showsp__bool_side"
Proved equivalence for showsp_bool
Redefining constant(s) show_bool_inst.shows_prec_bool
Proofs for inductive predicate(s) "Show__Instances_show__bool__inst_shows__prec__bool_side"
Proved equivalence for show_bool_inst.shows_prec_bool
Redefining constant(s) show_bool_inst.shows_list_bool
Proofs for inductive predicate(s) "Show__Instances_show__bool__inst_shows__list__bool_side"
Proved equivalence for show_bool_inst.shows_list_bool
Redefining constant(s) snd
Proofs for inductive predicate(s) "Product__Type_prod_snd_side"
Proved equivalence for snd
Redefining constant(s) minus_nat_inst.minus_nat
Proofs for inductive predicate(s) "Nat_minus__nat__inst_minus__nat_side"
Proved equivalence for minus_nat_inst.minus_nat
Redefining constant(s) equal_nat_inst.equal_nat
Proofs for inductive predicate(s) "Nat_equal__nat__inst_equal__nat_side"
Proved equivalence for equal_nat_inst.equal_nat
Redefining constant(s) case_prod
Proofs for inductive predicate(s) "Product__Type_prod_case__prod_side"
Porting fundef_cong rule for  case_prod
Proved equivalence for case_prod
Redefining constant(s) divmod_nat
Proofs for inductive predicate(s) "Divides_divmod__nat_side"
Proved equivalence for divmod_nat
Redefining constant(s) modulo_nat_inst.modulo_nat
Proofs for inductive predicate(s) "Euclidean__Division_modulo__nat__inst_modulo__nat_side"
Proved equivalence for modulo_nat_inst.modulo_nat
Redefining constant(s) fst
Proofs for inductive predicate(s) "Product__Type_prod_fst_side"
Proved equivalence for fst
Redefining constant(s) divide_nat_inst.divide_nat
Proofs for inductive predicate(s) "Euclidean__Division_divide__nat__inst_divide__nat_side"
Proved equivalence for divide_nat_inst.divide_nat
Redefining constant(s) string_of_digit
Proofs for inductive predicate(s) "Show__Instances_string__of__digit_side"
Proved equivalence for string_of_digit
Redefining constant(s) showsp_nat
### Falling back to another termination proof
Proofs for inductive predicate(s) "Show__Instances_showsp__nat_side"
Proved equivalence for showsp_nat
Redefining constant(s) show_nat_inst.shows_prec_nat
Proofs for inductive predicate(s) "Show__Instances_show__nat__inst_shows__prec__nat_side"
Proved equivalence for show_nat_inst.shows_prec_nat
Redefining constant(s) show_nat_inst.shows_list_nat
Proofs for inductive predicate(s) "Show__Instances_show__nat__inst_shows__list__nat_side"
Proved equivalence for show_nat_inst.shows_list_nat
Redefining constant(s) shows_list
Redefining constant(s) show_list_inst.shows_prec_list
Proofs for inductive predicate(s) "Show_show__list__inst_shows__prec__list_side"
Proved equivalence for show_list_inst.shows_prec_list
Redefining constant(s) show_list_inst.shows_list_list
Proofs for inductive predicate(s) "Show_show__list__inst_shows__list__list_side"
Proved equivalence for show_list_inst.shows_list_list
Redefining constant(s) show_char_inst.shows_list_char
Proofs for inductive predicate(s) "Show_show__char__inst_shows__list__char_side"
Proved equivalence for show_char_inst.shows_list_char
Redefining constant(s) i
Defining instance 'a * 'b :: show
Defining instance unit :: show
Defining instance 'a list :: show
Defining instance bool :: show
Defining instance char :: show
Defining instance 'a option :: show
Defining instance nat :: show
Proofs for inductive predicate(s) "Test__Lazy__Case_i_side"
Proved equivalence for i
### theory "Draft.Test_Lazy_Case"
### 4.812s elapsed time, 5.222s cpu time, 0.491s GC time
Loading theory "Draft.Test_Lazy_CaseMoreTemplates"
Show_show__dict__cert Show_show__instance__Nat_nat
Show_show__dict__cert Show_show__instance__HOL_bool
Show_show__dict__cert ?a ==>
Show_show__dict__cert (Show_show__instance__List_list ?a)
Show_show__dict__cert Show_show__instance__String_char
Show_show__dict__cert ?a ==>
Show_show__dict__cert (Show_show__instance__Option_option ?a)
[| Show_show__dict__cert ?a; Show_show__dict__cert ?b |]
==> Show_show__dict__cert (Show_show__instance__Product__Type_prod ?a ?b)
Show_show__dict__cert Show_show__instance__Product__Type_unit
Fun_id = id
HOL_Let = Let
Fun_comp = (o)
HOL_disj = (|)
List_null = List.null
List_append = (@)
Show_shows__pl = shows_pl
Show_shows__pr = shows_pr
Num_nat__of__num = nat_of_num
Show_shows__sep = shows_sep
Show_shows__space = shows_space
Show_showsp__list = showsp_list
Test__Lazy__Case_i = i
Show_shows__string = shows_string
Divides_divmod__nat = divmod_nat
Show_shows__list__gen = shows_list_gen
Product__Type_prod_fst = fst
Product__Type_prod_snd = snd
Nat_one__nat__inst_one__nat = 1
Nat_ord__nat__inst_less__nat = (<)
Show__Instances_showsp__nat = showsp_nat
Nat_plus__nat__inst_plus__nat = (+)
Show__Instances_showsp__bool = showsp_bool
Show__Instances_showsp__prod = showsp_prod
Show__Instances_showsp__unit = showsp_unit
Product__Type_prod_case__prod = case_prod
Nat_equal__nat__inst_equal__nat = equal_class.equal
Nat_minus__nat__inst_minus__nat = (-)
Nat_ord__nat__inst_less__eq__nat = (<=)
Show__Instances_showsp__option = showsp_option
Show__Instances_string__of__digit = string_of_digit
Product__Type_HOL_bool_case__lazy = HOL.bool.case_lazy
Show_show__char__inst_shows__list__char = shows_list
Show_show__char__inst_shows__prec__char = showsp_char
Show_show__dict__cert ?a ==>
Show_show__list__inst_shows__list__list ?a = shows_list
Show_show__dict__cert ?a ==>
Show_show__list__inst_shows__prec__list ?a = shows_prec
Show__Instances_show__nat__inst_shows__list__nat = shows_list
Show__Instances_show__nat__inst_shows__prec__nat = shows_prec
Euclidean__Division_divide__nat__inst_divide__nat = (div)
Euclidean__Division_modulo__nat__inst_modulo__nat = (mod)
Show__Instances_show__bool__inst_shows__list__bool = shows_list
Show__Instances_show__bool__inst_shows__prec__bool = shows_prec
[| Show_show__dict__cert ?a; Show_show__dict__cert ?b |]
==> Show__Instances_show__prod__inst_shows__list__prod ?a ?b = shows_list
[| Show_show__dict__cert ?a; Show_show__dict__cert ?b |]
==> Show__Instances_show__prod__inst_shows__prec__prod ?a ?b = shows_prec
Show__Instances_show__unit__inst_shows__list__unit = shows_list
Show__Instances_show__unit__inst_shows__prec__unit = shows_prec
Show_show__dict__cert ?a ==>
Show__Instances_show__option__inst_shows__list__option ?a = shows_list
Show_show__dict__cert ?a ==>
Show__Instances_show__option__inst_shows__prec__option ?a = shows_prec
val templateLemmas =
   [("Test_Lazy_Case.map_tree",
     "Test_Lazy_Case.tree.map_tree ?f ?t =
      (case ?t of Test_Lazy_Case.tree.Node => Test_Lazy_Case.tree.Node
       | Fork x ts =>
           Fork (?f x) (map (Test_Lazy_Case.tree.map_tree ?f) ts))",
     template_equation
      (template_app
        (template_app (template_hole 4, template_var 1), template_var 0),
       template_app
        (template_app
          (template_app (template_hole 3, template_hole 2), t_empty),
         template_var 0)))]:
   (string * thm * template) list
### theory "Draft.Test_Lazy_CaseMoreTemplates"
### 0.357s elapsed time, 0.503s cpu time, 0.041s GC time
val it = (): unit
