Loading theory "Draft.Eisbach_Protocol_Verification" (required by "Draft.ExamplesTemplates" via "Draft.Examples" via "Draft.Keyserver" via "Draft.PSPSP")
Loading theory "Draft.ml_yacc_lib" (required by "Draft.ExamplesTemplates" via "Draft.Examples" via "Draft.Keyserver" via "Draft.PSPSP" via "Draft.trac" via "Draft.trac_fp_parser" via "Draft.trac_term")
Loading theory "Draft.Templates" (required by "Draft.ExamplesTemplates" via "Draft.ExtrEqs")
Loading theory "Draft.Term_Variants" (required by "Draft.ExamplesTemplates" via "Draft.Examples" via "Draft.Keyserver" via "Draft.PSPSP" via "Draft.Stateful_Protocol_Verification" via "Draft.Term_Implication")
signature STREAM =
  sig
    val cons: 'a * 'a stream -> 'a stream
    val get: 'a stream -> 'a * 'a stream
    type 'a stream
    val streamify: (unit -> 'a) -> 'a stream
  end
signature LR_TABLE =
  sig
    exception Goto of state * nonterm
    val action: table -> state * term -> action
    datatype action = ACCEPT | ERROR | REDUCE of int | SHIFT of state
    val describeActions: table -> state -> (term, action) pairlist * action
    val describeGoto: table -> state -> (nonterm, state) pairlist
    val goto: table -> state * nonterm -> state
    val initialState: table -> state
    val mkLrTable:
       {actions: ((term, action) pairlist * action) array,
        gotos: (nonterm, state) pairlist array,
        initialState: state, numRules: int, numStates: int}
         -> table
    datatype nonterm = NT of int
    val numRules: table -> int
    val numStates: table -> int
    datatype ('a, 'b) pairlist = EMPTY | PAIR of 'a * 'b * ('a, 'b) pairlist
    datatype state = STATE of int
    type table
    datatype term = T of int
  end
signature TOKEN =
  sig
    structure LrTable: LR_TABLE
    val sameToken: ('a, 'b) token * ('a, 'b) token -> bool
    datatype ('a, 'b) token = TOKEN of LrTable.term * ('a * 'b * 'b)
  end
signature LR_PARSER =
  sig
    structure LrTable: LR_TABLE
    exception ParseError
    structure Stream: STREAM
    structure Token: TOKEN
    val parse:
       {arg: 'a,
        ec:
        {error: string * 'b * 'b -> unit,
         errtermvalue: LrTable.term -> 'c,
         is_keyword: LrTable.term -> bool,
         noShift: LrTable.term -> bool,
         preferred_change: (LrTable.term list * LrTable.term list) list,
         showTerminal: LrTable.term -> string, terms: LrTable.term list}
        ,
        lexer: ('c, 'b) Token.token Stream.stream,
        lookahead: int,
        saction:
        int * 'b * (LrTable.state * ('c * 'b * 'b)) list * 'a ->
          LrTable.nonterm * ('c * 'b * 'b) *
          (LrTable.state * ('c * 'b * 'b)) list
        ,
        table: LrTable.table, void: 'c}
         -> 'c * ('c, 'b) Token.token Stream.stream
  end
signature LEXER =
  sig
    structure UserDeclarations:
      sig type pos type svalue type ('a, 'b) token end
    val makeLexer:
       (int -> string) ->
         unit ->
           (UserDeclarations.svalue, UserDeclarations.pos)
           UserDeclarations.token
  end
signature ARG_LEXER =
  sig
    structure UserDeclarations:
      sig type arg type pos type svalue type ('a, 'b) token end
    val makeLexer:
       (int -> string) ->
         UserDeclarations.arg ->
           unit ->
             (UserDeclarations.svalue, UserDeclarations.pos)
             UserDeclarations.token
  end
signature PARSER_DATA =
  sig
    structure Actions:
      sig
        val actions:
           int * pos * (LrTable.state * (svalue * pos * pos)) list * arg ->
             LrTable.nonterm * (svalue * pos * pos) *
             (LrTable.state * (svalue * pos * pos)) list
        val extract: svalue -> result
        val void: svalue
      end
    structure EC:
      sig
        val errtermvalue: LrTable.term -> svalue
        val is_keyword: LrTable.term -> bool
        val noShift: LrTable.term -> bool
        val preferred_change: (LrTable.term list * LrTable.term list) list
        val showTerminal: LrTable.term -> string
        val terms: LrTable.term list
      end
    structure LrTable: LR_TABLE
    structure Token: TOKEN
    type arg
    type pos
    type result
    type svalue
    val table: LrTable.table
  end
signature PARSER =
  sig
    exception ParseError
    structure Stream: STREAM
    structure Token: TOKEN
    type arg
    val makeLexer:
       (int -> string) -> (svalue, pos) Token.token Stream.stream
    val parse:
       int * (svalue, pos) Token.token Stream.stream *
       (string * pos * pos -> unit) * arg
         -> result * (svalue, pos) Token.token Stream.stream
    type pos
    type result
    val sameToken:
       (svalue, pos) Token.token * (svalue, pos) Token.token -> bool
    type svalue
  end
signature ARG_PARSER =
  sig
    exception ParseError
    structure Stream: STREAM
    structure Token: TOKEN
    type arg
    type lexarg
    val makeLexer:
       (int -> string) -> lexarg -> (svalue, pos) Token.token Stream.stream
    val parse:
       int * (svalue, pos) Token.token Stream.stream *
       (string * pos * pos -> unit) * arg
         -> result * (svalue, pos) Token.token Stream.stream
    type pos
    type result
    val sameToken:
       (svalue, pos) Token.token * (svalue, pos) Token.token -> bool
    type svalue
  end
functor Join (
  sig
    structure Lex: LEXER
    structure LrParser: LR_PARSER
    structure ParserData: PARSER_DATA
  end
  ): 
  PARSER
functor JoinWithArg (
  sig
    structure Lex: ARG_LEXER
    structure LrParser: LR_PARSER
    structure ParserData: PARSER_DATA
  end
  ): 
  ARG_PARSER
structure LrTable: LR_TABLE
### Opaque signature matching (:>) fails to work with ML pretty printing --
### prefer non-opaque matching (:) possibly with abstype (line 30 of "$AFP/Automated_Stateful_Protocol_Verification/trac/ml-yacc-lib/stream.sml")
datatype template_term
=
     t_empty
   | template_app of template_term * template_term
   | template_hole of int
   | template_var of int
datatype sign
= equals | greater_equals | greater_than | less_equals | less_than
datatype template
=
     template_bimplication of template * template
   | template_dunno
   | template_equation of template_term * template_term
   | template_implication of template list * template
   | template_inequation of sign * template_term * template_term
   | template_negation of template
   | template_predicate of template_term
constructor t_empty: template_term
constructor template_app: template_term * template_term -> template_term
constructor template_hole: int -> template_term
constructor template_var: int -> template_term
constructor equals: sign
constructor greater_equals: sign
constructor greater_than: sign
constructor less_equals: sign
constructor less_than: sign
constructor template_bimplication: template * template -> template
constructor template_dunno: template
constructor template_equation: template_term * template_term -> template
constructor template_implication: template list * template -> template
constructor template_inequation:
   sign * template_term * template_term -> template
constructor template_negation: template -> template
constructor template_predicate: template_term -> template
val vfs = fn: term -> (indexname * typ) list * (string * typ) list
val indexOf = fn: ''a list -> ''a -> int -> int
val has_eq = fn: term -> bool
val term2template = fn:
   (indexname * typ) list -> (string * typ) list -> term -> template_term
val lemma2predicate = fn: term -> term -> template
val makeTemplatewithContext = fn: term -> term -> template
val lemma2template = fn: term -> template
val thm2template = fn: thm -> template
val tterm2string = fn: template_term -> string
val template2string = fn: template -> string
val t = "height ?t <= size ?t": thm
val th =
   Const ("HOL.Trueprop", "bool => prop") $
     (Const ("Orderings.ord_class.less_eq", "nat => nat => bool") $
       (Const ("Tree.height_class.height", "?'a tree => nat") $
         Var (("t", 0), "?'a tree")) $
       (Const ("Nat.size_class.size", "?'a tree => nat") $
         Var (("t", 0), "?'a tree"))):
   term
### theory "Draft.Templates"
### 0.090s elapsed time, 0.355s cpu time, 0.017s GC time
Loading theory "Draft.ExtrEqs" (required by "Draft.ExamplesTemplates")
structure Stream: STREAM
### Opaque signature matching (:>) fails to work with ML pretty printing --
### prefer non-opaque matching (:) possibly with abstype (line 121 of "$AFP/Automated_Stateful_Protocol_Verification/trac/ml-yacc-lib/parser2.sml")
### Opaque signature matching (:>) fails to work with ML pretty printing --
### prefer non-opaque matching (:) possibly with abstype (line 144 of "$AFP/Automated_Stateful_Protocol_Verification/trac/ml-yacc-lib/parser2.sml")
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
### ML warning (line 207 of "$AFP/Automated_Stateful_Protocol_Verification/trac/ml-yacc-lib/parser2.sml"):
### Value identifier (action) has not been referenced.
### ML warning (line 193 of "$AFP/Automated_Stateful_Protocol_Verification/trac/ml-yacc-lib/parser2.sml"):
### Value identifier (next) has not been referenced.
### ML warning (line 310 of "$AFP/Automated_Stateful_Protocol_Verification/trac/ml-yacc-lib/parser2.sml"):
### Value identifier (stack) has not been referenced.
### ML warning (line 310 of "$AFP/Automated_Stateful_Protocol_Verification/trac/ml-yacc-lib/parser2.sml"):
### Value identifier (value) has not been referenced.
### ML warning (line 310 of "$AFP/Automated_Stateful_Protocol_Verification/trac/ml-yacc-lib/parser2.sml"):
### Value identifier (lexv) has not been referenced.
### ML warning (line 363 of "$AFP/Automated_Stateful_Protocol_Verification/trac/ml-yacc-lib/parser2.sml"):
### Value identifier (printChangeList) has not been referenced.
### ML warning (line 398 of "$AFP/Automated_Stateful_Protocol_Verification/trac/ml-yacc-lib/parser2.sml"):
### Value identifier (term) has not been referenced.
### ML warning (line 403 of "$AFP/Automated_Stateful_Protocol_Verification/trac/ml-yacc-lib/parser2.sml"):
### Value identifier (right) has not been referenced.
### ML warning (line 421 of "$AFP/Automated_Stateful_Protocol_Verification/trac/ml-yacc-lib/parser2.sml"):
### Value identifier (lexPair) has not been referenced.
### ML warning (line 442 of "$AFP/Automated_Stateful_Protocol_Verification/trac/ml-yacc-lib/parser2.sml"):
### Value identifier (r) has not been referenced.
### ML warning (line 445 of "$AFP/Automated_Stateful_Protocol_Verification/trac/ml-yacc-lib/parser2.sml"):
### Value identifier (l') has not been referenced.
### ML warning (line 515 of "$AFP/Automated_Stateful_Protocol_Verification/trac/ml-yacc-lib/parser2.sml"):
### Value identifier (h) has not been referenced.
signature FIFO =
  sig
    exception Empty
    val empty: 'a queue
    val get: 'a queue -> 'a * 'a queue
    val put: 'a * 'a queue -> 'a queue
    type 'a queue
  end
structure LrParser: LR_PARSER
### theory "Draft.ml_yacc_lib"
### 0.194s elapsed time, 0.765s cpu time, 0.017s GC time
Loading theory "Draft.trac_term" (required by "Draft.ExamplesTemplates" via "Draft.Examples" via "Draft.Keyserver" via "Draft.PSPSP" via "Draft.trac" via "Draft.trac_fp_parser")
Proofs for inductive predicate(s) "term_variants_pred"
  Proving monotonicity ...
### theory "Draft.Term_Variants"
### 0.361s elapsed time, 1.396s cpu time, 0.068s GC time
Loading theory "Draft.Transactions" (required by "Draft.ExamplesTemplates" via "Draft.Examples" via "Draft.Keyserver" via "Draft.PSPSP" via "Draft.Stateful_Protocol_Verification" via "Draft.Stateful_Protocol_Model")
structure Trac_Utils:
  sig
    val list_find: ('a -> bool) -> 'a list -> ('a * int) option
    val list_intersect: ''a list -> ''a list -> bool
    val list_minus: ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
    val list_partitions: ''a list -> (''a * ''a) list -> ''a list list list
    val list_product: 'a list list -> 'a list list
    val list_rm_pair: ('a -> ''b) -> 'a list -> ''b -> 'a list
    val list_subseqs: 'a list -> 'a list list
    val list_toString: ('a -> string) -> 'a list -> string
    val list_to_str: string list -> string
    val list_triangle_product: ('a -> 'a -> 'b) -> 'a list -> 'b list
    val list_upto: int -> int list
    val map_prod: ('a -> 'b) -> 'a * 'a -> 'b * 'b
    val mk_unique: ''a list -> ''a list
  end
structure Trac_Term:
  sig
    datatype Msg
    = Attack | Const of string | Fun of string * Msg list | Var of string
    type TypeDecl = string * string
    exception TypeError
    datatype VarType = EnumType of string | Untyped | ValueType
    datatype cMsg
    =
         cAbs of (string * string list) list
       | cAttack
       | cConst of string
       | cEnum of string
       | cFun of string * cMsg list
       | cOccursFact of cMsg
       | cPrivFunSec
       | cSet of string * cMsg list
       | cVar of string * VarType
    val certifyMsg: (string * string) list -> string list -> Msg -> cMsg
    val fv_Msg: Msg -> string list
    val fv_cMsg: cMsg -> (string * VarType) list
    val list_find: ('a -> bool) -> 'a list -> ('a * int) option
    val list_intersect: ''a list -> ''a list -> bool
    val list_minus: ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
    val list_partitions: ''a list -> (''a * ''a) list -> ''a list list list
    val list_product: 'a list list -> 'a list list
    val list_rm_pair: ('a -> ''b) -> 'a list -> ''b -> 'a list
    val list_subseqs: 'a list -> 'a list list
    val list_toString: ('a -> string) -> 'a list -> string
    val list_to_str: string list -> string
    val list_triangle_product: ('a -> 'a -> 'b) -> 'a list -> 'b list
    val list_upto: int -> int list
    val map_prod: ('a -> 'b) -> 'a * 'a -> 'b * 'b
    val mk_Value_cVar: string -> cMsg
    val mk_unique: ''a list -> ''a list
    val subst_apply: (string * cMsg) list -> cMsg -> cMsg
    val subst_apply': (string * VarType -> cMsg) -> cMsg -> cMsg
    val type_of: (''a * string) list -> ''a list -> ''a -> VarType
  end
structure TracProtocol:
  sig
    exception TypeError
    datatype action
    =
         ATTACK
       | DELETE of Trac_Term.Msg * (string * Trac_Term.Msg list)
       | IN of Trac_Term.Msg * (string * Trac_Term.Msg list)
       | INSERT of Trac_Term.Msg * (string * Trac_Term.Msg list)
       | NEW of string
       | NOTIN of Trac_Term.Msg * (string * Trac_Term.Msg list)
       | NOTINANY of Trac_Term.Msg * string
       | RECEIVE of Trac_Term.Msg
       | SEND of Trac_Term.Msg
    type anaT = ruleT list
    datatype cAction
    =
         cAssertAttack
       | cDelete of Trac_Term.cMsg * Trac_Term.cMsg
       | cInSet of Trac_Term.cMsg * Trac_Term.cMsg
       | cInequality of Trac_Term.cMsg * Trac_Term.cMsg
       | cInsert of Trac_Term.cMsg * Trac_Term.cMsg
       | cNew of string
       | cNotInAny of Trac_Term.cMsg * string
       | cNotInSet of Trac_Term.cMsg * Trac_Term.cMsg
       | cReceive of Trac_Term.cMsg
       | cSend of Trac_Term.cMsg
    type cTransaction =
       {attack_actions: (prot_label * cAction) list,
        checkall_actions: (prot_label * cAction) list,
        checksingle_actions: (prot_label * cAction) list,
        fresh_actions: (prot_label * cAction) list,
        receive_actions: (prot_label * cAction) list,
        send_actions: (prot_label * cAction) list,
        transaction: transaction_name,
        update_actions: (prot_label * cAction) list}
    val certifyAction:
       (string * string) list -> string list -> 'a * action -> 'a * cAction
    val certifyTransaction: transaction -> cTransaction
    val empty: protocol
    val extract_Consts: type_spec -> string list
    type funT = string * string
    val fun_empty: fun_spec
    type fun_spec = {private: funT list, public: funT list}
    val is_ATTACK: action -> bool
    val is_Attack: cAction -> bool
    val is_Consts: type_spec_elem -> bool
    val is_DELETE: action -> bool
    val is_Delete: cAction -> bool
    val is_Fresh: cAction -> bool
    val is_IN: action -> bool
    val is_INSERT: action -> bool
    val is_InSet: cAction -> bool
    val is_Inequality: cAction -> bool
    val is_Insert: cAction -> bool
    val is_NEW: action -> bool
    val is_NOTIN: action -> bool
    val is_NOTINANY: action -> bool
    val is_NotInAny: cAction -> bool
    val is_NotInSet: cAction -> bool
    val is_RECEIVE: action -> bool
    val is_Receive: cAction -> bool
    val is_SEND: action -> bool
    val is_Send: cAction -> bool
    val list_find: ('a -> bool) -> 'a list -> ('a * int) option
    val list_intersect: ''a list -> ''a list -> bool
    val list_minus: ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
    val list_partitions: ''a list -> (''a * ''a) list -> ''a list list list
    val list_product: 'a list list -> 'a list list
    val list_rm_pair: ('a -> ''b) -> 'a list -> ''b -> 'a list
    val list_subseqs: 'a list -> 'a list list
    val list_toString: ('a -> string) -> 'a list -> string
    val list_to_str: string list -> string
    val list_triangle_product: ('a -> 'a -> 'b) -> 'a list -> 'b list
    val list_upto: int -> int list
    val map_prod: ('a -> 'b) -> 'a * 'a -> 'b * 'b
    val maybe_the_DELETE:
       action -> (Trac_Term.Msg * (string * Trac_Term.Msg list)) option
    val maybe_the_Delete:
       cAction -> (Trac_Term.cMsg * Trac_Term.cMsg) option
    val maybe_the_Fresh: cAction -> string option
    val maybe_the_IN:
       action -> (Trac_Term.Msg * (string * Trac_Term.Msg list)) option
    val maybe_the_INSERT:
       action -> (Trac_Term.Msg * (string * Trac_Term.Msg list)) option
    val maybe_the_InSet: cAction -> (Trac_Term.cMsg * Trac_Term.cMsg) option
    val maybe_the_Inequality:
       cAction -> (Trac_Term.cMsg * Trac_Term.cMsg) option
    val maybe_the_Insert:
       cAction -> (Trac_Term.cMsg * Trac_Term.cMsg) option
    val maybe_the_NEW: action -> string option
    val maybe_the_NOTIN:
       action -> (Trac_Term.Msg * (string * Trac_Term.Msg list)) option
    val maybe_the_NOTINANY: action -> (Trac_Term.Msg * string) option
    val maybe_the_NotInAny: cAction -> (Trac_Term.cMsg * string) option
    val maybe_the_NotInSet:
       cAction -> (Trac_Term.cMsg * Trac_Term.cMsg) option
    val maybe_the_RECEIVE: action -> Trac_Term.Msg option
    val maybe_the_Receive: cAction -> Trac_Term.cMsg option
    val maybe_the_SEND: action -> Trac_Term.Msg option
    val maybe_the_Send: cAction -> Trac_Term.cMsg option
    val mkTransaction:
       transaction_name -> (prot_label * action) list -> transaction
    val mk_unique: ''a list -> ''a list
    datatype prot_label = LabelN | LabelS
    type protocol =
       {analysis_spec: anaT,
        fixed_point:
        (Trac_Term.cMsg list * (string * string list) list list *
         ((string * string list) list * (string * string list) list) list
        )
        option
        ,
        function_spec: fun_spec option,
        name: string,
        set_spec: set_spec list,
        transaction_spec: (string option * transaction list) list,
        type_spec: type_spec}
    type ruleT = (string * string list) * Trac_Term.Msg list * string list
    type set_spec = string * string
    val subst_apply_action:
       (string * Trac_Term.cMsg) list ->
         prot_label * cAction -> prot_label * cAction
    val subst_apply_actions:
       (string * Trac_Term.cMsg) list ->
         (prot_label * cAction) list -> (prot_label * cAction) list
    val the_Consts: type_spec_elem -> string list
    val the_DELETE: action -> Trac_Term.Msg * (string * Trac_Term.Msg list)
    val the_Delete: cAction -> Trac_Term.cMsg * Trac_Term.cMsg
    val the_Fresh: cAction -> string
    val the_IN: action -> Trac_Term.Msg * (string * Trac_Term.Msg list)
    val the_INSERT: action -> Trac_Term.Msg * (string * Trac_Term.Msg list)
    val the_InSet: cAction -> Trac_Term.cMsg * Trac_Term.cMsg
    val the_Inequality: cAction -> Trac_Term.cMsg * Trac_Term.cMsg
    val the_Insert: cAction -> Trac_Term.cMsg * Trac_Term.cMsg
    val the_NEW: action -> string
    val the_NOTIN: action -> Trac_Term.Msg * (string * Trac_Term.Msg list)
    val the_NOTINANY: action -> Trac_Term.Msg * string
    val the_NotInAny: cAction -> Trac_Term.cMsg * string
    val the_NotInSet: cAction -> Trac_Term.cMsg * Trac_Term.cMsg
    val the_RECEIVE: action -> Trac_Term.Msg
    val the_Receive: cAction -> Trac_Term.cMsg
    val the_SEND: action -> Trac_Term.Msg
    val the_Send: cAction -> Trac_Term.cMsg
    type transaction =
       {actions: (prot_label * action) list, transaction: transaction_name}
    type transaction_name =
       string * (string * string) list * (string * string) list
    type type_spec = (string * type_spec_elem) list
    datatype type_spec_elem = Consts of string list | Union of string list
    val update_analysis:
       protocol ->
         ((string * string list) * Trac_Term.Msg list * string list) list ->
           protocol
    val update_fixed_point:
       protocol ->
         (Trac_Term.cMsg list * (string * string list) list list *
          ((string * string list) list * (string * string list) list) list
         )
         option
           -> protocol
    val update_fun_private: fun_spec -> funT list -> fun_spec
    val update_fun_public: fun_spec -> funT list -> fun_spec
    val update_functions: protocol -> fun_spec option -> protocol
    val update_name: protocol -> string -> protocol
    val update_sets: protocol -> (string * string) list -> protocol
    val update_transactions:
       string option -> protocol -> transaction list -> protocol
    val update_type_spec:
       protocol -> (string * type_spec_elem) list -> protocol
  end
### theory "Draft.trac_term"
### 0.492s elapsed time, 1.910s cpu time, 0.143s GC time
Loading theory "Draft.trac_fp_parser" (required by "Draft.ExamplesTemplates" via "Draft.Examples" via "Draft.Keyserver" via "Draft.PSPSP" via "Draft.trac")
val eqpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Var (("_dummy_", 2), "?'a"))
       ):
   term Find_Theorems.criterion
val badeqpattern = Pattern (Const ("Pure.eq", "?'a => ?'a => prop")):
   term Find_Theorems.criterion
val undefpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Const ("HOL.undefined", "?'a"))
       ):
   term Find_Theorems.criterion
val thmpattern =
   Pattern
    (Const ("HOL.Trueprop", "bool => prop") $ Var (("_dummy_", 1), "bool")):
   term Find_Theorems.criterion
val badnames =
   ["*nitpick*", "*Nitpick*", "*full_exhaustive*", "*_def*", "Enum.finite*",
    "*Quickcheck*", "ATP*", "*Nunchaku*", "*Code*", "*BNF*", "*SMT*",
    "*.*.*"]:
   string list
val unwanted_names =
   [(false, Name "*nitpick*"), (false, Name "*Nitpick*"),
    (false, Name "*full_exhaustive*"), (false, Name "*_def*"),
    (false, Name "Enum.finite*"), (false, Name "*Quickcheck*"),
    (false, Name "ATP*"), (false, Name "*Nunchaku*"),
    (false, Name "*Code*"), (false, Name "*BNF*"), (false, Name "*SMT*"),
    (false, Name "*.*.*")]:
   (bool * term Find_Theorems.criterion) list
val has_vars = fn: term -> bool
val get_all_eqs = fn: string -> Proof.context -> (string * thm) list
val get_all_thms = fn: string -> Proof.context -> (string * thm) list
val get_noneq_thms = fn: string -> Proof.context -> (string * thm) list
val template_eqs = fn:
   string -> Proof.context -> (string * thm * template) list
val template_thms = fn:
   string -> Proof.context -> (string * thm * template) list
### theory "Draft.ExtrEqs"
### 0.609s elapsed time, 2.368s cpu time, 0.143s GC time
Loading theory "Draft.trac_protocol_parser" (required by "Draft.ExamplesTemplates" via "Draft.Examples" via "Draft.Keyserver" via "Draft.PSPSP" via "Draft.trac")
signature Trac_TOKENS =
  sig
    val ASTERISK: string * 'a * 'a -> (svalue, 'a) token
    val ATTACK: string * 'a * 'a -> (svalue, 'a) token
    val COLON: string * 'a * 'a -> (svalue, 'a) token
    val COMMA: string * 'a * 'a -> (svalue, 'a) token
    val DOUBLE_ASTERISK: string * 'a * 'a -> (svalue, 'a) token
    val DOUBLE_RARROW: string * 'a * 'a -> (svalue, 'a) token
    val EOF: 'a * 'a -> (svalue, 'a) token
    val FIXEDPOINT: string * 'a * 'a -> (svalue, 'a) token
    val INTEGER_LITERAL: string * 'a * 'a -> (svalue, 'a) token
    val LOWER_STRING_LITERAL: string * 'a * 'a -> (svalue, 'a) token
    val ONE: string * 'a * 'a -> (svalue, 'a) token
    val PAREN_CLOSE: string * 'a * 'a -> (svalue, 'a) token
    val PAREN_OPEN: string * 'a * 'a -> (svalue, 'a) token
    val STRING_LITERAL: string * 'a * 'a -> (svalue, 'a) token
    val UPPER_STRING_LITERAL: string * 'a * 'a -> (svalue, 'a) token
    val WHERE: string * 'a * 'a -> (svalue, 'a) token
    val ZERO: string * 'a * 'a -> (svalue, 'a) token
    type svalue
    type ('a, 'b) token
  end
signature Trac_LRVALS =
  sig structure ParserData: PARSER_DATA structure Tokens: Trac_TOKENS end
signature TracTransaction_TOKENS =
  sig
    val ABSTRACTION: string * 'a * 'a -> (svalue, 'a) token
    val ACTIONS: string * 'a * 'a -> (svalue, 'a) token
    val ANALYSIS: string * 'a * 'a -> (svalue, 'a) token
    val ARROW: string * 'a * 'a -> (svalue, 'a) token
    val ATTACK: string * 'a * 'a -> (svalue, 'a) token
    val AUTHCH: string * 'a * 'a -> (svalue, 'a) token
    val AUTHENTICATES: string * 'a * 'a -> (svalue, 'a) token
    val CLOSEB: string * 'a * 'a -> (svalue, 'a) token
    val CLOSEP: string * 'a * 'a -> (svalue, 'a) token
    val CLOSESCRYPT: string * 'a * 'a -> (svalue, 'a) token
    val CLOSESQB: string * 'a * 'a -> (svalue, 'a) token
    val COLON: string * 'a * 'a -> (svalue, 'a) token
    val COMMA: string * 'a * 'a -> (svalue, 'a) token
    val CONFCH: string * 'a * 'a -> (svalue, 'a) token
    val DELETE: string * 'a * 'a -> (svalue, 'a) token
    val DOT: string * 'a * 'a -> (svalue, 'a) token
    val EOF: 'a * 'a -> (svalue, 'a) token
    val EXCLAM: string * 'a * 'a -> (svalue, 'a) token
    val FAUTHCH: string * 'a * 'a -> (svalue, 'a) token
    val FSECCH: string * 'a * 'a -> (svalue, 'a) token
    val FUNCTIONS: string * 'a * 'a -> (svalue, 'a) token
    val GOALS: string * 'a * 'a -> (svalue, 'a) token
    val IN: string * 'a * 'a -> (svalue, 'a) token
    val INSECCH: string * 'a * 'a -> (svalue, 'a) token
    val INSERT: string * 'a * 'a -> (svalue, 'a) token
    val INTEGER_LITERAL: string * 'a * 'a -> (svalue, 'a) token
    val KNOWLEDGE: string * 'a * 'a -> (svalue, 'a) token
    val LOWER_STRING_LITERAL: string * 'a * 'a -> (svalue, 'a) token
    val NEW: string * 'a * 'a -> (svalue, 'a) token
    val NOTIN: string * 'a * 'a -> (svalue, 'a) token
    val OF: string * 'a * 'a -> (svalue, 'a) token
    val ON: string * 'a * 'a -> (svalue, 'a) token
    val OPENB: string * 'a * 'a -> (svalue, 'a) token
    val OPENP: string * 'a * 'a -> (svalue, 'a) token
    val OPENSCRYPT: string * 'a * 'a -> (svalue, 'a) token
    val OPENSQB: string * 'a * 'a -> (svalue, 'a) token
    val PERCENT: string * 'a * 'a -> (svalue, 'a) token
    val PRIVATE: string * 'a * 'a -> (svalue, 'a) token
    val PROTOCOL: string * 'a * 'a -> (svalue, 'a) token
    val PUBLIC: string * 'a * 'a -> (svalue, 'a) token
    val QUESTION: string * 'a * 'a -> (svalue, 'a) token
    val RECEIVE: string * 'a * 'a -> (svalue, 'a) token
    val SECCH: string * 'a * 'a -> (svalue, 'a) token
    val SEMICOLON: string * 'a * 'a -> (svalue, 'a) token
    val SEND: string * 'a * 'a -> (svalue, 'a) token
    val SETS: string * 'a * 'a -> (svalue, 'a) token
    val STAR: string * 'a * 'a -> (svalue, 'a) token
    val STRING_LITERAL: string * 'a * 'a -> (svalue, 'a) token
    val Sets: string * 'a * 'a -> (svalue, 'a) token
    val TBETWEEN: string * 'a * 'a -> (svalue, 'a) token
    val TRANSACTIONS: string * 'a * 'a -> (svalue, 'a) token
    val TSECRET: string * 'a * 'a -> (svalue, 'a) token
    val TYPES: string * 'a * 'a -> (svalue, 'a) token
    val UNDERSCORE: string * 'a * 'a -> (svalue, 'a) token
    val UNEQUAL: string * 'a * 'a -> (svalue, 'a) token
    val UNION: string * 'a * 'a -> (svalue, 'a) token
    val UPPER_STRING_LITERAL: string * 'a * 'a -> (svalue, 'a) token
    val WEAKLY: string * 'a * 'a -> (svalue, 'a) token
    val WHERE: string * 'a * 'a -> (svalue, 'a) token
    val equal: string * 'a * 'a -> (svalue, 'a) token
    val slash: string * 'a * 'a -> (svalue, 'a) token
    type svalue
    type ('a, 'b) token
  end
signature TracTransaction_LRVALS =
  sig
    structure ParserData: PARSER_DATA
    structure Tokens: TracTransaction_TOKENS
  end
### theory "Draft.Eisbach_Protocol_Verification"
### 0.753s elapsed time, 2.932s cpu time, 0.161s GC time
### ML warning (line 556 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_fp.lex.sml"):
### Value identifier (i) has not been referenced.
### ML warning (line 650 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_fp.lex.sml"):
### Value identifier (YYBEGIN) has not been referenced.
### ML warning (line 654 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_fp.lex.sml"):
### Value identifier (continue) has not been referenced.
### ML warning (line 658 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_fp.lex.sml"):
### Value identifier (l) has not been referenced.
### ML warning (line 658 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_fp.lex.sml"):
### Value identifier (acts) has not been referenced.
### ML warning (line 656 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_fp.lex.sml"):
### Value identifier (i) has not been referenced.
functor TracLexFun (sig structure Tokens: Trac_TOKENS end): 
  sig
    structure Internal:
      sig
        exception LexerError
        structure StartStates:
          sig
            val INITIAL: yystartstate
            datatype yystartstate = STARTSTATE of int
          end
        type result = UserDeclarations.lexresult
        type statedata = {fin: yyfinstate list, trans: string}
        val tab: {fin: yyfinstate list, trans: string} vector
        datatype yyfinstate = N of int
      end
    exception LexError
    structure UserDeclarations:
      sig
        datatype Msg
        =
             Attack
           | Const of string
           | Fun of string * Msg list
           | Var of string
        structure Tokens: Trac_TOKENS
        type TypeDecl = string * string
        exception TypeError
        datatype VarType = EnumType of string | Untyped | ValueType
        datatype cMsg
        =
             cAbs of (string * string list) list
           | cAttack
           | cConst of string
           | cEnum of string
           | cFun of string * cMsg list
           | cOccursFact of cMsg
           | cPrivFunSec
           | cSet of string * cMsg list
           | cVar of string * VarType
        val certifyMsg: (string * string) list -> string list -> Msg -> cMsg
        val eof: unit -> (svalue, int * int * int) token
        val error: string * (int * int * int) * 'a -> unit
        val fv_Msg: Msg -> string list
        val fv_cMsg: cMsg -> (string * VarType) list
        val inputPos: int -> (int * int * int) * (int * int * int)
        val inputPos_half: int -> int * int * int
        type lexresult = (svalue, pos) token
        val list_find: ('a -> bool) -> 'a list -> ('a * int) option
        val list_intersect: ''a list -> ''a list -> bool
        val list_minus: ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
        val list_partitions:
           ''a list -> (''a * ''a) list -> ''a list list list
        val list_product: 'a list list -> 'a list list
        val list_rm_pair: ('a -> ''b) -> 'a list -> ''b -> 'a list
        val list_subseqs: 'a list -> 'a list list
        val list_toString: ('a -> string) -> 'a list -> string
        val list_to_str: string list -> string
        val list_triangle_product: ('a -> 'a -> 'b) -> 'a list -> 'b list
        val list_upto: int -> int list
        val map_prod: ('a -> 'b) -> 'a * 'a -> 'b * 'b
        val mk_Value_cVar: string -> cMsg
        val mk_unique: ''a list -> ''a list
        val pos: (int * int * int) ref
        type pos = int * int * int
        val subst_apply: (string * cMsg) list -> cMsg -> cMsg
        val subst_apply': (string * VarType -> cMsg) -> cMsg -> cMsg
        type svalue
        type ('a, 'b) token
        val type_of: (''a * string) list -> ''a list -> ''a -> VarType
      end
    val makeLexer:
       (int -> string) ->
         unit -> (Tokens.svalue, int * int * int) Tokens.token
  end
### ML warning (line 309 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_fp.grm.sml"):
### Value identifier (defaultPos) has not been referenced.
### ML warning (line 314 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_fp.grm.sml"):
### Value identifier (trac_file1) has not been referenced.
### ML warning (line 323 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_fp.grm.sml"):
### Value identifier (FIXEDPOINT1) has not been referenced.
### ML warning (line 324 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_fp.grm.sml"):
### Value identifier (symfact_list_exp1) has not been referenced.
### ML warning (line 333 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_fp.grm.sml"):
### Value identifier (symfact_list_exp1) has not been referenced.
### ML warning (line 342 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_fp.grm.sml"):
### Value identifier (symfact_exp1) has not been referenced.
### ML warning (line 352 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_fp.grm.sml"):
### Value identifier (symfact_exp1) has not been referenced.
### ML warning (line 353 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_fp.grm.sml"):
### Value identifier (symfact_list_exp1) has not been referenced.
### ML warning (line 362 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_fp.grm.sml"):
### Value identifier (DOUBLE_RARROW1) has not been referenced.
### ML warning (line 363 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_fp.grm.sml"):
### Value identifier (ATTACK1) has not been referenced.
### ML warning (line 373 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_fp.grm.sml"):
### Value identifier (rule_exp1) has not been referenced.
### ML warning (line 374 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_fp.grm.sml"):
### Value identifier (WHERE1) has not been referenced.
### ML warning (line 375 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_fp.grm.sml"):
### Value identifier (type_list_exp1) has not been referenced.
### ML warning (line 385 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_fp.grm.sml"):
### Value identifier (DOUBLE_RARROW1) has not been referenced.
### ML warning (line 387 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_fp.grm.sml"):
### Value identifier (rule_exp1) has not been referenced.
### ML warning (line 388 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_fp.grm.sml"):
### Value identifier (WHERE1) has not been referenced.
### ML warning (line 389 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_fp.grm.sml"):
### Value identifier (type_list_exp1) has not been referenced.
### ML warning (line 400 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_fp.grm.sml"):
### Value identifier (DOUBLE_ASTERISK1) has not been referenced.
### ML warning (line 402 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_fp.grm.sml"):
### Value identifier (DOUBLE_RARROW1) has not been referenced.
### ML warning (line 403 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_fp.grm.sml"):
### Value identifier (rule_exp1) has not been referenced.
### ML warning (line 404 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_fp.grm.sml"):
### Value identifier (WHERE1) has not been referenced.
### ML warning (line 405 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_fp.grm.sml"):
### Value identifier (type_list_exp1) has not been referenced.
### ML warning (line 413 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_fp.grm.sml"):
### Value identifier (rule_exp1) has not been referenced.
### ML warning (line 423 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_fp.grm.sml"):
### Value identifier (DOUBLE_RARROW1) has not been referenced.
### ML warning (line 424 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_fp.grm.sml"):
### Value identifier (rule_exp1) has not been referenced.
### ML warning (line 434 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_fp.grm.sml"):
### Value identifier (DOUBLE_ASTERISK1) has not been referenced.
### ML warning (line 435 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_fp.grm.sml"):
### Value identifier (DOUBLE_RARROW1) has not been referenced.
### ML warning (line 436 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_fp.grm.sml"):
### Value identifier (rule_exp1) has not been referenced.
### ML warning (line 445 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_fp.grm.sml"):
### Value identifier (upper_literal1) has not been referenced.
### ML warning (line 454 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_fp.grm.sml"):
### Value identifier (lower_literal1) has not been referenced.
### ML warning (line 465 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_fp.grm.sml"):
### Value identifier (lower_literal1) has not been referenced.
### ML warning (line 466 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_fp.grm.sml"):
### Value identifier (PAREN_OPEN1) has not been referenced.
### ML warning (line 467 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_fp.grm.sml"):
### Value identifier (arg_list_exp1) has not been referenced.
### ML warning (line 468 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_fp.grm.sml"):
### Value identifier (PAREN_CLOSE1) has not been referenced.
### ML warning (line 476 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_fp.grm.sml"):
### Value identifier (arg_exp1) has not been referenced.
### ML warning (line 486 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_fp.grm.sml"):
### Value identifier (arg_exp1) has not been referenced.
### ML warning (line 488 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_fp.grm.sml"):
### Value identifier (COMMA1) has not been referenced.
### ML warning (line 489 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_fp.grm.sml"):
### Value identifier (arg_list_exp1) has not been referenced.
### ML warning (line 497 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_fp.grm.sml"):
### Value identifier (rule_exp1) has not been referenced.
### ML warning (line 506 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_fp.grm.sml"):
### Value identifier (ASTERISK1) has not been referenced.
### ML warning (line 507 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_fp.grm.sml"):
### Value identifier (int_literal1) has not been referenced.
### ML warning (line 515 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_fp.grm.sml"):
### Value identifier (int_literal1) has not been referenced.
### ML warning (line 524 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_fp.grm.sml"):
### Value identifier (type_exp1) has not been referenced.
### ML warning (line 534 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_fp.grm.sml"):
### Value identifier (type_exp1) has not been referenced.
### ML warning (line 536 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_fp.grm.sml"):
### Value identifier (type_list_exp1) has not been referenced.
### ML warning (line 546 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_fp.grm.sml"):
### Value identifier (ASTERISK1) has not been referenced.
### ML warning (line 548 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_fp.grm.sml"):
### Value identifier (int_literal1) has not been referenced.
### ML warning (line 549 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_fp.grm.sml"):
### Value identifier (COLON1) has not been referenced.
### ML warning (line 550 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_fp.grm.sml"):
### Value identifier (string_literal1) has not been referenced.
### ML warning (line 560 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_fp.grm.sml"):
### Value identifier (upper_literal1) has not been referenced.
### ML warning (line 561 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_fp.grm.sml"):
### Value identifier (COLON1) has not been referenced.
### ML warning (line 562 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_fp.grm.sml"):
### Value identifier (string_literal1) has not been referenced.
### ML warning (line 571 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_fp.grm.sml"):
### Value identifier (UPPER_STRING_LITERAL1) has not been referenced.
### ML warning (line 581 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_fp.grm.sml"):
### Value identifier (LOWER_STRING_LITERAL1) has not been referenced.
### ML warning (line 591 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_fp.grm.sml"):
### Value identifier (upper_literal1) has not been referenced.
### ML warning (line 600 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_fp.grm.sml"):
### Value identifier (lower_literal1) has not been referenced.
### ML warning (line 609 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_fp.grm.sml"):
### Value identifier (INTEGER_LITERAL1) has not been referenced.
### ML warning (line 617 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_fp.grm.sml"):
### Value identifier (ZERO1) has not been referenced.
### ML warning (line 623 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_fp.grm.sml"):
### Value identifier (ONE1) has not been referenced.
functor TracLrValsFun (sig structure Token: TOKEN end): 
  sig structure ParserData: PARSER_DATA structure Tokens: Trac_TOKENS end
### ML warning (line 1777 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.lex.sml"):
### Value identifier (i) has not been referenced.
### ML warning (line 2016 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.lex.sml"):
### Value identifier (YYBEGIN) has not been referenced.
### ML warning (line 2020 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.lex.sml"):
### Value identifier (continue) has not been referenced.
### ML warning (line 2024 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.lex.sml"):
### Value identifier (l) has not been referenced.
### ML warning (line 2024 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.lex.sml"):
### Value identifier (acts) has not been referenced.
### ML warning (line 2022 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.lex.sml"):
### Value identifier (i) has not been referenced.
functor TracTransactionLexFun (
  sig structure Tokens: TracTransaction_TOKENS end): 
  sig
    structure Internal:
      sig
        exception LexerError
        structure StartStates:
          sig
            val INITIAL: yystartstate
            datatype yystartstate = STARTSTATE of int
          end
        type result = UserDeclarations.lexresult
        type statedata = {fin: yyfinstate list, trans: string}
        val tab: {fin: yyfinstate list, trans: string} vector
        datatype yyfinstate = N of int
      end
    exception LexError
    structure UserDeclarations:
      sig
        structure Tokens: TracTransaction_TOKENS
        exception TypeError
        datatype action
        =
             ATTACK
           | DELETE of Trac_Term.Msg * (string * Trac_Term.Msg list)
           | IN of Trac_Term.Msg * (string * Trac_Term.Msg list)
           | INSERT of Trac_Term.Msg * (string * Trac_Term.Msg list)
           | NEW of string
           | NOTIN of Trac_Term.Msg * (string * Trac_Term.Msg list)
           | NOTINANY of Trac_Term.Msg * string
           | RECEIVE of Trac_Term.Msg
           | SEND of Trac_Term.Msg
        type anaT = ruleT list
        datatype cAction
        =
             cAssertAttack
           | cDelete of Trac_Term.cMsg * Trac_Term.cMsg
           | cInSet of Trac_Term.cMsg * Trac_Term.cMsg
           | cInequality of Trac_Term.cMsg * Trac_Term.cMsg
           | cInsert of Trac_Term.cMsg * Trac_Term.cMsg
           | cNew of string
           | cNotInAny of Trac_Term.cMsg * string
           | cNotInSet of Trac_Term.cMsg * Trac_Term.cMsg
           | cReceive of Trac_Term.cMsg
           | cSend of Trac_Term.cMsg
        type cTransaction =
           {attack_actions: (prot_label * cAction) list,
            checkall_actions: (prot_label * cAction) list,
            checksingle_actions: (prot_label * cAction) list,
            fresh_actions: (prot_label * cAction) list,
            receive_actions: (prot_label * cAction) list,
            send_actions: (prot_label * cAction) list,
            transaction: transaction_name,
            update_actions: (prot_label * cAction) list}
        val certifyAction:
           (string * string) list ->
             string list -> 'a * action -> 'a * cAction
        val certifyTransaction: transaction -> cTransaction
        val empty: protocol
        val eof: unit -> (svalue, int * int * int) token
        val error: string * (int * int * int) * 'a -> unit
        val extract_Consts: type_spec -> string list
        type funT = string * string
        val fun_empty: fun_spec
        type fun_spec = {private: funT list, public: funT list}
        val inputPos: int -> (int * int * int) * (int * int * int)
        val inputPos_half: int -> int * int * int
        val is_ATTACK: action -> bool
        val is_Attack: cAction -> bool
        val is_Consts: type_spec_elem -> bool
        val is_DELETE: action -> bool
        val is_Delete: cAction -> bool
        val is_Fresh: cAction -> bool
        val is_IN: action -> bool
        val is_INSERT: action -> bool
        val is_InSet: cAction -> bool
        val is_Inequality: cAction -> bool
        val is_Insert: cAction -> bool
        val is_NEW: action -> bool
        val is_NOTIN: action -> bool
        val is_NOTINANY: action -> bool
        val is_NotInAny: cAction -> bool
        val is_NotInSet: cAction -> bool
        val is_RECEIVE: action -> bool
        val is_Receive: cAction -> bool
        val is_SEND: action -> bool
        val is_Send: cAction -> bool
        type lexresult = (svalue, pos) token
        val list_find: ('a -> bool) -> 'a list -> ('a * int) option
        val list_intersect: ''a list -> ''a list -> bool
        val list_minus: ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
        val list_partitions:
           ''a list -> (''a * ''a) list -> ''a list list list
        val list_product: 'a list list -> 'a list list
        val list_rm_pair: ('a -> ''b) -> 'a list -> ''b -> 'a list
        val list_subseqs: 'a list -> 'a list list
        val list_toString: ('a -> string) -> 'a list -> string
        val list_to_str: string list -> string
        val list_triangle_product: ('a -> 'a -> 'b) -> 'a list -> 'b list
        val list_upto: int -> int list
        val map_prod: ('a -> 'b) -> 'a * 'a -> 'b * 'b
        val maybe_the_DELETE:
           action -> (Trac_Term.Msg * (string * Trac_Term.Msg list)) option
        val maybe_the_Delete:
           cAction -> (Trac_Term.cMsg * Trac_Term.cMsg) option
        val maybe_the_Fresh: cAction -> string option
        val maybe_the_IN:
           action -> (Trac_Term.Msg * (string * Trac_Term.Msg list)) option
        val maybe_the_INSERT:
           action -> (Trac_Term.Msg * (string * Trac_Term.Msg list)) option
        val maybe_the_InSet:
           cAction -> (Trac_Term.cMsg * Trac_Term.cMsg) option
        val maybe_the_Inequality:
           cAction -> (Trac_Term.cMsg * Trac_Term.cMsg) option
        val maybe_the_Insert:
           cAction -> (Trac_Term.cMsg * Trac_Term.cMsg) option
        val maybe_the_NEW: action -> string option
        val maybe_the_NOTIN:
           action -> (Trac_Term.Msg * (string * Trac_Term.Msg list)) option
        val maybe_the_NOTINANY: action -> (Trac_Term.Msg * string) option
        val maybe_the_NotInAny: cAction -> (Trac_Term.cMsg * string) option
        val maybe_the_NotInSet:
           cAction -> (Trac_Term.cMsg * Trac_Term.cMsg) option
        val maybe_the_RECEIVE: action -> Trac_Term.Msg option
        val maybe_the_Receive: cAction -> Trac_Term.cMsg option
        val maybe_the_SEND: action -> Trac_Term.Msg option
        val maybe_the_Send: cAction -> Trac_Term.cMsg option
        val mkTransaction:
           transaction_name -> (prot_label * action) list -> transaction
        val mk_unique: ''a list -> ''a list
        val pos: (int * int * int) ref
        type pos = int * int * int
        datatype prot_label = LabelN | LabelS
        type protocol =
           {analysis_spec: anaT,
            fixed_point:
            (Trac_Term.cMsg list * (string * string list) list list *
             ((string * string list) list * (string * string list) list)
             list
            )
            option
            ,
            function_spec: fun_spec option,
            name: string,
            set_spec: set_spec list,
            transaction_spec: (string option * transaction list) list,
            type_spec: type_spec}
        type ruleT =
           (string * string list) * Trac_Term.Msg list * string list
        type set_spec = string * string
        val subst_apply_action:
           (string * Trac_Term.cMsg) list ->
             prot_label * cAction -> prot_label * cAction
        val subst_apply_actions:
           (string * Trac_Term.cMsg) list ->
             (prot_label * cAction) list -> (prot_label * cAction) list
        type svalue
        val the_Consts: type_spec_elem -> string list
        val the_DELETE:
           action -> Trac_Term.Msg * (string * Trac_Term.Msg list)
        val the_Delete: cAction -> Trac_Term.cMsg * Trac_Term.cMsg
        val the_Fresh: cAction -> string
        val the_IN: action -> Trac_Term.Msg * (string * Trac_Term.Msg list)
        val the_INSERT:
           action -> Trac_Term.Msg * (string * Trac_Term.Msg list)
        val the_InSet: cAction -> Trac_Term.cMsg * Trac_Term.cMsg
        val the_Inequality: cAction -> Trac_Term.cMsg * Trac_Term.cMsg
        val the_Insert: cAction -> Trac_Term.cMsg * Trac_Term.cMsg
        val the_NEW: action -> string
        val the_NOTIN:
           action -> Trac_Term.Msg * (string * Trac_Term.Msg list)
        val the_NOTINANY: action -> Trac_Term.Msg * string
        val the_NotInAny: cAction -> Trac_Term.cMsg * string
        val the_NotInSet: cAction -> Trac_Term.cMsg * Trac_Term.cMsg
        val the_RECEIVE: action -> Trac_Term.Msg
        val the_Receive: cAction -> Trac_Term.cMsg
        val the_SEND: action -> Trac_Term.Msg
        val the_Send: cAction -> Trac_Term.cMsg
        type ('a, 'b) token
        type transaction =
           {actions: (prot_label * action) list,
            transaction: transaction_name}
        type transaction_name =
           string * (string * string) list * (string * string) list
        type type_spec = (string * type_spec_elem) list
        datatype type_spec_elem
        = Consts of string list | Union of string list
        val update_analysis:
           protocol ->
             ((string * string list) * Trac_Term.Msg list * string list)
             list
               -> protocol
        val update_fixed_point:
           protocol ->
             (Trac_Term.cMsg list * (string * string list) list list *
              ((string * string list) list * (string * string list) list)
              list
             )
             option
               -> protocol
        val update_fun_private: fun_spec -> funT list -> fun_spec
        val update_fun_public: fun_spec -> funT list -> fun_spec
        val update_functions: protocol -> fun_spec option -> protocol
        val update_name: protocol -> string -> protocol
        val update_sets: protocol -> (string * string) list -> protocol
        val update_transactions:
           string option -> protocol -> transaction list -> protocol
        val update_type_spec:
           protocol -> (string * type_spec_elem) list -> protocol
      end
    val makeLexer:
       (int -> string) ->
         unit -> (Tokens.svalue, int * int * int) Tokens.token
  end
structure TracFpParser:
  sig
    val attack: Trac_Term.cMsg list -> bool
    val parse_file: string -> Trac_Term.cMsg list
    val parse_str: string -> Trac_Term.cMsg list
  end
### theory "Draft.trac_fp_parser"
### 0.182s elapsed time, 0.598s cpu time, 0.060s GC time
### ML warning (line 1717 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### (OF) has infix status but was not preceded by op.
### ML warning (line 1577 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (INTEGER_LITERAL1) has not been referenced.
### ML warning (line 1567 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (ident1) has not been referenced.
### ML warning (line 1568 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (COMMA1) has not been referenced.
### ML warning (line 1569 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (idents1) has not been referenced.
### ML warning (line 1559 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (ident1) has not been referenced.
### ML warning (line 1552 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (lident1) has not been referenced.
### ML warning (line 1545 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (uident1) has not been referenced.
### ML warning (line 1535 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (lident1) has not been referenced.
### ML warning (line 1536 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (COMMA1) has not been referenced.
### ML warning (line 1537 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (lidents1) has not been referenced.
### ML warning (line 1526 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (lident1) has not been referenced.
### ML warning (line 1517 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (LOWER_STRING_LITERAL1) has not been referenced.
### ML warning (line 1506 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (uident1) has not been referenced.
### ML warning (line 1507 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (COMMA1) has not been referenced.
### ML warning (line 1508 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (uidents1) has not been referenced.
### ML warning (line 1497 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (uident1) has not been referenced.
### ML warning (line 1488 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (UPPER_STRING_LITERAL1) has not been referenced.
### ML warning (line 1478 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (LOWER_STRING_LITERAL1) has not been referenced.
### ML warning (line 1468 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (UPPER_STRING_LITERAL1) has not been referenced.
### ML warning (line 1458 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (msg1) has not been referenced.
### ML warning (line 1459 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (COMMA1) has not been referenced.
### ML warning (line 1460 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (msgs1) has not been referenced.
### ML warning (line 1449 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (msg1) has not been referenced.
### ML warning (line 1438 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (lident1) has not been referenced.
### ML warning (line 1440 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (OPENP1) has not been referenced.
### ML warning (line 1441 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (msgs1) has not been referenced.
### ML warning (line 1442 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (CLOSEP1) has not been referenced.
### ML warning (line 1429 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (lident1) has not been referenced.
### ML warning (line 1421 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (uident1) has not been referenced.
### ML warning (line 1410 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (lident1) has not been referenced.
### ML warning (line 1411 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (OPENP1) has not been referenced.
### ML warning (line 1412 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (msgs1) has not been referenced.
### ML warning (line 1413 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (CLOSEP1) has not been referenced.
### ML warning (line 1400 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (lident1) has not been referenced.
### ML warning (line 1390 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (STAR1) has not been referenced.
### ML warning (line 1391 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (DELETE1) has not been referenced.
### ML warning (line 1391 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (DELETE) has not been referenced.
### ML warning (line 1392 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (msg1) has not been referenced.
### ML warning (line 1393 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (setexp1) has not been referenced.
### ML warning (line 1379 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (STAR1) has not been referenced.
### ML warning (line 1380 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (INSERT1) has not been referenced.
### ML warning (line 1380 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (INSERT) has not been referenced.
### ML warning (line 1381 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (msg1) has not been referenced.
### ML warning (line 1382 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (setexp1) has not been referenced.
### ML warning (line 1365 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (STAR1) has not been referenced.
### ML warning (line 1366 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (msg1) has not been referenced.
### ML warning (line 1367 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (NOTIN1) has not been referenced.
### ML warning (line 1368 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (lident1) has not been referenced.
### ML warning (line 1369 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (OPENP1) has not been referenced.
### ML warning (line 1370 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (UNDERSCORE1) has not been referenced.
### ML warning (line 1371 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (CLOSEP1) has not been referenced.
### ML warning (line 1352 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (STAR1) has not been referenced.
### ML warning (line 1353 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (msg1) has not been referenced.
### ML warning (line 1354 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (NOTIN1) has not been referenced.
### ML warning (line 1354 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (NOTIN) has not been referenced.
### ML warning (line 1355 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (setexp1) has not been referenced.
### ML warning (line 1341 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (STAR1) has not been referenced.
### ML warning (line 1342 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (msg1) has not been referenced.
### ML warning (line 1343 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (IN1) has not been referenced.
### ML warning (line 1343 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (IN) has not been referenced.
### ML warning (line 1344 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (setexp1) has not been referenced.
### ML warning (line 1331 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (STAR1) has not been referenced.
### ML warning (line 1332 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (SEND1) has not been referenced.
### ML warning (line 1332 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (SEND) has not been referenced.
### ML warning (line 1333 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (msg1) has not been referenced.
### ML warning (line 1321 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (STAR1) has not been referenced.
### ML warning (line 1322 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (RECEIVE1) has not been referenced.
### ML warning (line 1322 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (RECEIVE) has not been referenced.
### ML warning (line 1323 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (msg1) has not been referenced.
### ML warning (line 1312 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (ATTACK1) has not been referenced.
### ML warning (line 1312 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (ATTACK) has not been referenced.
### ML warning (line 1304 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (NEW1) has not been referenced.
### ML warning (line 1304 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (NEW) has not been referenced.
### ML warning (line 1305 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (uident1) has not been referenced.
### ML warning (line 1294 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (DELETE1) has not been referenced.
### ML warning (line 1294 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (DELETE) has not been referenced.
### ML warning (line 1295 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (msg1) has not been referenced.
### ML warning (line 1296 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (setexp1) has not been referenced.
### ML warning (line 1283 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (INSERT1) has not been referenced.
### ML warning (line 1283 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (INSERT) has not been referenced.
### ML warning (line 1284 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (msg1) has not been referenced.
### ML warning (line 1285 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (setexp1) has not been referenced.
### ML warning (line 1270 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (msg1) has not been referenced.
### ML warning (line 1271 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (NOTIN1) has not been referenced.
### ML warning (line 1272 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (lident1) has not been referenced.
### ML warning (line 1273 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (OPENP1) has not been referenced.
### ML warning (line 1274 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (UNDERSCORE1) has not been referenced.
### ML warning (line 1275 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (CLOSEP1) has not been referenced.
### ML warning (line 1258 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (msg1) has not been referenced.
### ML warning (line 1259 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (NOTIN1) has not been referenced.
### ML warning (line 1259 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (NOTIN) has not been referenced.
### ML warning (line 1260 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (setexp1) has not been referenced.
### ML warning (line 1248 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (msg1) has not been referenced.
### ML warning (line 1249 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (IN1) has not been referenced.
### ML warning (line 1249 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (IN) has not been referenced.
### ML warning (line 1250 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (setexp1) has not been referenced.
### ML warning (line 1239 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (SEND1) has not been referenced.
### ML warning (line 1239 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (SEND) has not been referenced.
### ML warning (line 1240 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (msg1) has not been referenced.
### ML warning (line 1230 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (RECEIVE1) has not been referenced.
### ML warning (line 1230 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (RECEIVE) has not been referenced.
### ML warning (line 1232 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (msg1) has not been referenced.
### ML warning (line 1220 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (action1) has not been referenced.
### ML warning (line 1222 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (actions1) has not been referenced.
### ML warning (line 1212 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (action1) has not been referenced.
### ML warning (line 1203 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (LOWER_STRING_LITERAL1) has not been referenced.
### ML warning (line 1193 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (UPPER_STRING_LITERAL1) has not been referenced.
### ML warning (line 1183 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (ident1) has not been referenced.
### ML warning (line 1184 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (COLON1) has not been referenced.
### ML warning (line 1185 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (typ1) has not been referenced.
### ML warning (line 1172 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (parameter1) has not been referenced.
### ML warning (line 1173 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (COMMA1) has not been referenced.
### ML warning (line 1174 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (parameters1) has not been referenced.
### ML warning (line 1161 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (parameter1) has not been referenced.
### ML warning (line 1152 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (ident1) has not been referenced.
### ML warning (line 1153 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (OPENP1) has not been referenced.
### ML warning (line 1154 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (CLOSEP1) has not been referenced.
### ML warning (line 1141 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (ident1) has not been referenced.
### ML warning (line 1142 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (OPENP1) has not been referenced.
### ML warning (line 1143 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (parameters1) has not been referenced.
### ML warning (line 1144 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (CLOSEP1) has not been referenced.
### ML warning (line 1127 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (ident1) has not been referenced.
### ML warning (line 1128 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (OPENP1) has not been referenced.
### ML warning (line 1129 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (parameters1) has not been referenced.
### ML warning (line 1130 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (CLOSEP1) has not been referenced.
### ML warning (line 1131 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (WHERE1) has not been referenced.
### ML warning (line 1132 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (ineqs1) has not been referenced.
### ML warning (line 1115 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (ineq1) has not been referenced.
### ML warning (line 1116 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (COMMA1) has not been referenced.
### ML warning (line 1117 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (ineqs1) has not been referenced.
### ML warning (line 1107 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (ineq1) has not been referenced.
### ML warning (line 1098 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (UPPER_STRING_LITERAL1) has not been referenced.
### ML warning (line 1099 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (ineq_aux1) has not been referenced.
### ML warning (line 1086 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (UNEQUAL1) has not been referenced.
### ML warning (line 1087 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (UPPER_STRING_LITERAL1) has not been referenced.
### ML warning (line 1072 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (transaction1) has not been referenced.
### ML warning (line 1073 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (actions1) has not been referenced.
### ML warning (line 1074 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (DOT1) has not been referenced.
### ML warning (line 1075 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (transaction_spec1) has not been referenced.
### ML warning (line 1059 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (transaction1) has not been referenced.
### ML warning (line 1060 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (actions1) has not been referenced.
### ML warning (line 1061 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (DOT1) has not been referenced.
### ML warning (line 1046 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (TRANSACTIONS1) has not been referenced.
### ML warning (line 1047 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (OF1) has not been referenced.
### ML warning (line 1048 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (LOWER_STRING_LITERAL1) has not been referenced.
### ML warning (line 1036 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (TRANSACTIONS1) has not been referenced.
### ML warning (line 1024 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (UPPER_STRING_LITERAL1) has not been referenced.
### ML warning (line 1026 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (COMMA1) has not been referenced.
### ML warning (line 1027 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (result1) has not been referenced.
### ML warning (line 1013 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (UPPER_STRING_LITERAL1) has not been referenced.
### ML warning (line 1005 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (msgs1) has not been referenced.
### ML warning (line 995 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (UPPER_STRING_LITERAL1) has not been referenced.
### ML warning (line 996 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (COMMA1) has not been referenced.
### ML warning (line 997 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (head_params1) has not been referenced.
### ML warning (line 983 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (UPPER_STRING_LITERAL1) has not been referenced.
### ML warning (line 970 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (LOWER_STRING_LITERAL1) has not been referenced.
### ML warning (line 972 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (OPENP1) has not been referenced.
### ML warning (line 973 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (head_params1) has not been referenced.
### ML warning (line 974 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (CLOSEP1) has not been referenced.
### ML warning (line 956 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (head1) has not been referenced.
### ML warning (line 957 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (QUESTION1) has not been referenced.
### ML warning (line 958 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (keys1) has not been referenced.
### ML warning (line 959 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (ARROW1) has not been referenced.
### ML warning (line 960 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (result1) has not been referenced.
### ML warning (line 945 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (head1) has not been referenced.
### ML warning (line 946 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (ARROW1) has not been referenced.
### ML warning (line 947 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (result1) has not been referenced.
### ML warning (line 935 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (rule1) has not been referenced.
### ML warning (line 936 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (analysis_spec1) has not been referenced.
### ML warning (line 927 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (rule1) has not been referenced.
### ML warning (line 918 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (ident1) has not been referenced.
### ML warning (line 919 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (slash1) has not been referenced.
### ML warning (line 920 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (arity1) has not been referenced.
### ML warning (line 908 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (fun_spec1) has not been referenced.
### ML warning (line 909 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (fun_specs1) has not been referenced.
### ML warning (line 899 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (fun_spec1) has not been referenced.
### ML warning (line 890 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (PRIVATE1) has not been referenced.
### ML warning (line 891 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (fun_specs1) has not been referenced.
### ML warning (line 879 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (PUBLIC1) has not been referenced.
### ML warning (line 881 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (fun_specs1) has not been referenced.
### ML warning (line 863 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (priv_fun_spec1) has not been referenced.
### ML warning (line 864 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (priv_or_pub_fun_spec1) has not been referenced.
### ML warning (line 850 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (pub_fun_spec1) has not been referenced.
### ML warning (line 851 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (priv_or_pub_fun_spec1) has not been referenced.
### ML warning (line 839 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (ident1) has not been referenced.
### ML warning (line 840 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (slash1) has not been referenced.
### ML warning (line 841 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (arity1) has not been referenced.
### ML warning (line 829 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (set_spec1) has not been referenced.
### ML warning (line 830 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (set_specs1) has not been referenced.
### ML warning (line 820 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (set_spec1) has not been referenced.
### ML warning (line 810 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (ident1) has not been referenced.
### ML warning (line 811 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (equal1) has not been referenced.
### ML warning (line 812 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (type_union1) has not been referenced.
### ML warning (line 798 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (ident1) has not been referenced.
### ML warning (line 799 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (equal1) has not been referenced.
### ML warning (line 800 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (OPENB1) has not been referenced.
### ML warning (line 801 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (lidents1) has not been referenced.
### ML warning (line 802 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (CLOSEB1) has not been referenced.
### ML warning (line 787 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (type_spec1) has not been referenced.
### ML warning (line 788 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (type_specs1) has not been referenced.
### ML warning (line 777 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (type_spec1) has not been referenced.
### ML warning (line 767 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (ident1) has not been referenced.
### ML warning (line 768 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (UNION1) has not been referenced.
### ML warning (line 769 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (type_union1) has not been referenced.
### ML warning (line 759 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (ident1) has not been referenced.
### ML warning (line 742 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (transaction_spec_head1) has not been referenced.
### ML warning (line 743 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (COLON1) has not been referenced.
### ML warning (line 744 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (transaction_spec1) has not been referenced.
### ML warning (line 745 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (protocol_spec1) has not been referenced.
### ML warning (line 726 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (ANALYSIS1) has not been referenced.
### ML warning (line 728 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (COLON1) has not been referenced.
### ML warning (line 729 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (analysis_spec1) has not been referenced.
### ML warning (line 730 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (protocol_spec1) has not been referenced.
### ML warning (line 710 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (FUNCTIONS1) has not been referenced.
### ML warning (line 711 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (COLON1) has not been referenced.
### ML warning (line 712 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (priv_or_pub_fun_spec1) has not been referenced.
### ML warning (line 714 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (protocol_spec1) has not been referenced.
### ML warning (line 696 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (SETS1) has not been referenced.
### ML warning (line 697 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (COLON1) has not been referenced.
### ML warning (line 698 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (set_specs1) has not been referenced.
### ML warning (line 699 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (protocol_spec1) has not been referenced.
### ML warning (line 683 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (TYPES1) has not been referenced.
### ML warning (line 684 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (COLON1) has not been referenced.
### ML warning (line 685 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (type_specs1) has not been referenced.
### ML warning (line 686 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (protocol_spec1) has not been referenced.
### ML warning (line 670 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (PROTOCOL1) has not been referenced.
### ML warning (line 671 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (COLON1) has not been referenced.
### ML warning (line 672 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (name1) has not been referenced.
### ML warning (line 673 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (protocol_spec1) has not been referenced.
### ML warning (line 660 of "$AFP/Automated_Stateful_Protocol_Verification/trac/trac_parser/trac_protocol.grm.sml"):
### Value identifier (trac_protocol1) has not been referenced.
functor TracTransactionLrValsFun (sig structure Token: TOKEN end): 
  sig
    structure ParserData: PARSER_DATA
    structure Tokens: TracTransaction_TOKENS
  end
structure TracProtocolParser:
  sig
    val parse_file: string -> TracProtocol.protocol
    val parse_str: string -> TracProtocol.protocol
  end
### theory "Draft.trac_protocol_parser"
### 0.450s elapsed time, 1.140s cpu time, 0.117s GC time
Loading theory "Draft.trac" (required by "Draft.ExamplesTemplates" via "Draft.Examples" via "Draft.Keyserver" via "Draft.PSPSP")
val protocol_model_interpretation_defs = fn:
   string -> string Interpretation.defines
val protocol_model_interpretation_params = fn: string -> string option list
val declare_thm_attr = fn:
   string -> string -> bool -> local_theory -> local_theory
val declare_def_attr = fn:
   string -> string -> bool -> local_theory -> local_theory
val declare_code_eqn = fn: string -> bool -> local_theory -> local_theory
val declare_protocol_check = fn:
   string -> bool -> local_theory -> local_theory
val declare_protocol_checks = fn: bool -> local_theory -> local_theory
val eval_define = fn:
   bstring * string -> Proof.context -> term * local_theory
val eval_define_declare = fn:
   bstring * string -> bool -> Proof.context -> term * local_theory
structure ml_isar_wrapper:
  sig
    val define_constant_definition:
       bstring * term -> local_theory -> thm * local_theory
    val define_constant_definition':
       bstring * term -> bool -> local_theory -> thm * local_theory
    val define_simple_abbrev: bstring * term -> local_theory -> local_theory
    val define_simple_datatype:
       (typ * sort) list * bstring ->
         (typ list * bstring) list -> local_theory -> local_theory
    val define_simple_fun:
       bstring -> (term * term) list -> local_theory -> Proof.context
    val define_simple_primrec:
       bstring -> (term * term) list -> local_theory -> local_theory
    val define_simple_type_synonym: bstring * typ -> theory -> theory
    val prove_simple:
       bstring ->
         term -> (Proof.context -> tactic) -> Proof.context -> local_theory
    val prove_state_simple: Method.text -> Proof.state -> Proof.context
  end
structure trac_definitorial_package:
  sig
    val absT: TracProtocol.protocol -> local_theory -> typ
    val abs_to_hol:
       (string * string list) list ->
         TracProtocol.protocol -> local_theory -> term
    val abssT: TracProtocol.protocol -> local_theory -> typ
    val abstract_over_enum_vars:
       (string * string) list ->
         (string * string) list ->
           term ->
             (string * string list) list ->
               TracProtocol.protocol -> local_theory -> term
    val anaN: string
    val ana_cMsg_to_hol:
       bool ->
         Trac_Term.cMsg ->
           string list -> TracProtocol.protocol -> local_theory -> term
    val arityN: string
    val atomN: string
    val atomT: TracProtocol.protocol -> local_theory -> typ
    val boolT: typ
    val cMsg_to_hol:
       Trac_Term.cMsg ->
         int ->
           typ ->
             (string * Trac_Term.VarType -> term) ->
               (string * Trac_Term.VarType -> bool) ->
                 TracProtocol.protocol -> local_theory -> term
    val check_no_vars_and_consts: Trac_Term.cMsg list -> Trac_Term.cMsg list
    val conv_enum_consts:
       TracProtocol.protocol -> Trac_Term.cMsg -> Trac_Term.cMsg
    val databaseT: TracProtocol.protocol -> local_theory -> typ
    val database_to_hol:
       string * Trac_Term.cMsg list ->
         TracProtocol.protocol -> local_theory -> term
    val def_funs: TracProtocol.protocol -> local_theory -> Proof.context
    val def_sets: TracProtocol.protocol -> local_theory -> local_theory
    val def_types:
       TracProtocol.protocol -> local_theory -> string list * local_theory
    val define_fixpoint:
       Trac_Term.cMsg list ->
         TracProtocol.protocol ->
           bool -> local_theory -> TracProtocol.protocol * local_theory
    val define_protocol:
       bool ->
         TracProtocol.protocol * local_theory ->
           TracProtocol.protocol * local_theory
    val define_term_model:
       TracProtocol.protocol -> local_theory -> Proof.context
    val enumN: string
    val enum_constsN: string
    val enum_constsT: TracProtocol.protocol -> local_theory -> typ
    val enum_typeN: string
    val flatten_type_spec:
       TracProtocol.protocol -> (string * string list) list
    val fp_triple_to_hol:
       Trac_Term.cMsg list * (string * string list) list list *
       ((string * string list) list * (string * string list) list) list
         -> TracProtocol.protocol -> local_theory -> term
    val full_name: bstring -> local_theory -> string
    val full_name':
       string -> TracProtocol.protocol -> local_theory -> string
    val funN: string
    val funT: TracProtocol.protocol -> local_theory -> typ
    val gammaN: string
    val get_enum_variables:
       TracProtocol.cTransaction -> (string * string) list
    val get_enums: TracProtocol.protocol -> string list
    val get_fresh_value_variables: TracProtocol.cTransaction -> string list
    val get_funs:
       TracProtocol.protocol ->
         (string * string) list * (string * string) list *
         (string * string) list
    val get_nonfresh_value_variables:
       TracProtocol.cTransaction -> string list
    val get_set_spec: TracProtocol.protocol -> (string * int) list
    val get_transaction_name: TracProtocol.cTransaction -> string
    val get_value_variables: TracProtocol.cTransaction -> string list
    val get_variable_restrictions:
       TracProtocol.cTransaction ->
         (string * string) list * (string * string) list
    val ground_cMsg_to_hol:
       Trac_Term.cMsg ->
         int -> TracProtocol.protocol -> local_theory -> term
    val ground_enum_variables:
       TracProtocol.protocol -> Trac_Term.cMsg list -> Trac_Term.cMsg list
    val info: string -> unit
    val is_attack_transaction: TracProtocol.cTransaction -> bool
    val is_priv_fun: TracProtocol.protocol -> string -> bool
    val labeled_strand_stepT: TracProtocol.protocol -> local_theory -> typ
    val list_find: ('a -> bool) -> 'a list -> ('a * int) option
    val list_intersect: ''a list -> ''a list -> bool
    val list_minus: ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
    val list_partitions: ''a list -> (''a * ''a) list -> ''a list list list
    val list_product: 'a list list -> 'a list list
    val list_rm_pair: ('a -> ''b) -> 'a list -> ''b -> 'a list
    val list_subseqs: 'a list -> 'a list list
    val list_toString: ('a -> string) -> 'a list -> string
    val list_to_str: string list -> string
    val list_triangle_product: ('a -> 'a -> 'b) -> 'a list -> 'b list
    val list_upto: int -> int list
    val map_prod: ('a -> 'b) -> 'a * 'a -> 'b * 'b
    val messageT: TracProtocol.protocol -> local_theory -> typ
    val messageT': typ -> TracProtocol.protocol -> local_theory -> typ
    val message_atomT: TracProtocol.protocol -> local_theory -> typ
    val message_funT: TracProtocol.protocol -> local_theory -> typ
    val message_listT: TracProtocol.protocol -> local_theory -> typ
    val message_listT': typ -> TracProtocol.protocol -> local_theory -> typ
    val message_term_typeT: TracProtocol.protocol -> local_theory -> typ
    val message_varT: TracProtocol.protocol -> local_theory -> typ
    val mkN: string * string -> string
    val mk_Delete_step:
       TracProtocol.protocol -> local_theory -> term -> term -> term -> term
    val mk_InSet_step:
       TracProtocol.protocol -> local_theory -> term -> term -> term -> term
    val mk_Inequality_step:
       TracProtocol.protocol -> local_theory -> term -> term -> term -> term
    val mk_Insert_step:
       TracProtocol.protocol -> local_theory -> term -> term -> term -> term
    val mk_NotInSet_step:
       TracProtocol.protocol -> local_theory -> term -> term -> term -> term
    val mk_Receive_step:
       TracProtocol.protocol -> local_theory -> term -> term -> term
    val mk_Send_step:
       TracProtocol.protocol -> local_theory -> term -> term -> term
    val mk_Transaction:
       TracProtocol.protocol ->
         local_theory ->
           term list ->
             term list ->
               term list -> term list -> term list -> term list -> term
    val mk_Trueprop: term -> term
    val mk_enum_const:
       string -> TracProtocol.protocol -> local_theory -> term
    val mk_enum_substs:
       TracProtocol.protocol ->
         (string * Trac_Term.VarType) list ->
           (string * Trac_Term.cMsg) list list
    val mk_eq: term * term -> term
    val mk_labeled_step: term -> term -> term
    val mk_list: typ -> term list -> term
    val mk_listT: typ -> typ
    val mk_mt_list: typ -> term
    val mk_nat: int -> term
    val mk_prod: term * term -> term
    val mk_prodT: typ * typ -> typ
    val mk_prot_label: int -> term
    val mk_prot_type:
       string -> typ list -> TracProtocol.protocol -> local_theory -> typ
    val mk_set: typ -> term list -> term
    val mk_setT: typ -> typ
    val mk_star_label: term
    val mk_tuple: term list -> term
    val mk_tupleT: typ list -> typ
    val mk_type_of_name: local_theory -> string -> string -> typ list -> typ
    val mk_unique: ''a list -> ''a list
    val name_of_typ: typ -> string
    val natT: typ
    val occursN: string
    val occurs_enc: Trac_Term.cMsg -> Trac_Term.cMsg
    val other_pubconsts_typeN: string
    val poscheckvariantT: typ
    val priv_fun_enc:
       TracProtocol.protocol -> Trac_Term.cMsg -> Trac_Term.cMsg
    val priv_fun_secN: string
    val prot_strandT: TracProtocol.protocol -> local_theory -> typ
    val prot_transactionT: TracProtocol.protocol -> local_theory -> typ
    val prove_UNIV:
       string ->
         typ -> term list -> xstring list -> Proof.context -> local_theory
    val publicN: string
    val rm_special_funs: ('a -> string) -> 'a list -> 'a list
    val secret_typeN: string
    val set_arity: TracProtocol.protocol -> string -> int option
    val setsN: string
    val special_funs: string list
    val split_fp:
       Trac_Term.cMsg list ->
         Trac_Term.cMsg list * (string * string list) list list *
         ((string * string list) list * (string * string list) list) list
    val strand_labelT: typ
    val strand_stepT: TracProtocol.protocol -> local_theory -> typ
    val timpliesN: string
    val transaction_cMsg_to_hol:
       Trac_Term.cMsg ->
         int -> string list -> TracProtocol.protocol -> local_theory -> term
    val transform_cMsg:
       TracProtocol.protocol -> Trac_Term.cMsg -> Trac_Term.cMsg
    val transform_fp:
       TracProtocol.protocol ->
         Trac_Term.cMsg list ->
           Trac_Term.cMsg list * (string * string list) list list *
           ((string * string list) list * (string * string list) list) list
    val types: string list
    val valN: string
    val val_to_abs: Trac_Term.cMsg -> Trac_Term.cMsg
    val val_to_abs_list: Trac_Term.cMsg list -> (string * string list) list
  end
structure trac:
  sig
    structure Data: GENERIC_DATA
    datatype Msg
    = Attack | Const of string | Fun of string * Msg list | Var of string
    type TypeDecl = string * string
    exception TypeError
    datatype VarType = EnumType of string | Untyped | ValueType
    datatype cMsg
    =
         cAbs of (string * string list) list
       | cAttack
       | cConst of string
       | cEnum of string
       | cFun of string * cMsg list
       | cOccursFact of cMsg
       | cPrivFunSec
       | cSet of string * cMsg list
       | cVar of string * VarType
    val certifyMsg: (string * string) list -> string list -> Msg -> cMsg
    val def_fp:
       string ->
         bool ->
           TracProtocol.protocol * local_theory ->
             TracProtocol.protocol * local_theory
    val def_fp_file:
       string ->
         bool ->
           TracProtocol.protocol * Proof.context ->
             TracProtocol.protocol * local_theory
    val def_fp_trac:
       string ->
         bool ->
           TracProtocol.protocol * Proof.context ->
             TracProtocol.protocol * local_theory
    val def_trac:
       string ->
         bool -> local_theory -> TracProtocol.protocol * local_theory
    val def_trac_file:
       string ->
         bool -> local_theory -> TracProtocol.protocol * local_theory
    val def_trac_fp_trac: string -> bool -> local_theory -> local_theory
    val def_trac_protocol:
       bool ->
         TracProtocol.protocol * local_theory ->
           TracProtocol.protocol * local_theory
    val def_trac_term_model:
       string -> local_theory -> TracProtocol.protocol * Proof.context
    val fv_Msg: Msg -> string list
    val fv_cMsg: cMsg -> (string * VarType) list
    type hide_tvar_tab = TracProtocol.protocol Symtab.table
    val info: string -> unit
    val list_find: ('a -> bool) -> 'a list -> ('a * int) option
    val list_intersect: ''a list -> ''a list -> bool
    val list_minus: ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
    val list_partitions: ''a list -> (''a * ''a) list -> ''a list list list
    val list_product: 'a list list -> 'a list list
    val list_rm_pair: ('a -> ''b) -> 'a list -> ''b -> 'a list
    val list_subseqs: 'a list -> 'a list list
    val list_toString: ('a -> string) -> 'a list -> string
    val list_to_str: string list -> string
    val list_triangle_product: ('a -> 'a -> 'b) -> 'a list -> 'b list
    val list_upto: int -> int list
    val lookup:
       Symtab.key -> theory -> TracProtocol.protocol option * theory
    val lookup_trac: string -> Proof.context -> TracProtocol.protocol
    val map_prod: ('a -> 'b) -> 'a * 'a -> 'b * 'b
    val merge_trac_tab:
       {analysis_spec: 'a,
        fixed_point: 'b,
        function_spec: 'c,
        name: ''d, set_spec: 'e, transaction_spec: 'f, type_spec: 'g}
       Symtab.table
       *
       {analysis_spec: 'a,
        fixed_point: 'b,
        function_spec: 'c,
        name: ''d, set_spec: 'e, transaction_spec: 'f, type_spec: 'g}
       Symtab.table
         ->
         {analysis_spec: 'a,
          fixed_point: 'b,
          function_spec: 'c,
          name: ''d, set_spec: 'e, transaction_spec: 'f, type_spec: 'g}
         Symtab.table
    val mk_Value_cVar: string -> cMsg
    val mk_abs_filename: theory -> string -> string
    val mk_unique: ''a list -> ''a list
    val subst_apply: (string * cMsg) list -> cMsg -> cMsg
    val subst_apply': (string * VarType -> cMsg) -> cMsg -> cMsg
    val trac_eq:
       {analysis_spec: 'a,
        fixed_point: 'b,
        function_spec: 'c,
        name: ''d, set_spec: 'e, transaction_spec: 'f, type_spec: 'g}
       *
       {analysis_spec: 'h,
        fixed_point: 'i,
        function_spec: 'j,
        name: ''d, set_spec: 'k, transaction_spec: 'l, type_spec: 'm}
         -> bool
    val type_of: (''a * string) list -> ''a list -> ''a -> VarType
    val update: TracProtocol.protocol -> theory -> theory
  end
val fileNameP = fn: Token.T list -> (string * string) * Token.T list
val name_prefix_parser = fn:
   Token.T list -> (string * string) * Token.T list
val opt_proof_method_choice = fn: Token.T list -> string * Token.T list
val opt_defs_list = fn: Token.T list -> string list * Token.T list
val security_proof_locale_parser = fn:
   Token.T list -> ((string * string) * string list) * Token.T list
val security_proof_locale_parser_with_method_choice = fn:
   Token.T list ->
     ((string * (string * string)) * string list) * Token.T list
val protocol_model_setup_proof_state = fn:
   string -> string -> local_theory -> Proof.state
val protocol_security_proof_proof_state = fn:
   bool ->
     string ->
       string ->
         string list -> bool -> local_theory -> string list * Proof.state
### theory "Draft.trac"
### 0.678s elapsed time, 1.524s cpu time, 0.506s GC time
Found termination order: "{}"
Found termination order: "{}"
instantiation
  prot_atom :: (enum) enum
  enum_prot_atom == enum_class.enum :: 'a prot_atom list
  enum_all_prot_atom == enum_class.enum_all ::
    ('a prot_atom => bool) => bool
  enum_ex_prot_atom == enum_class.enum_ex :: ('a prot_atom => bool) => bool
### theory "Draft.Transactions"
### 5.789s elapsed time, 9.165s cpu time, 1.958s GC time
Loading theory "Draft.Term_Abstraction" (required by "Draft.ExamplesTemplates" via "Draft.Examples" via "Draft.Keyserver" via "Draft.PSPSP" via "Draft.Stateful_Protocol_Verification" via "Draft.Stateful_Protocol_Model")
Found termination order:
  "(%p. size_list (%p. size (snd p)) (fst p)) <*mlex*> {}"
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
### theory "Draft.Term_Abstraction"
### 3.130s elapsed time, 3.884s cpu time, 0.387s GC time
Loading theory "Draft.Stateful_Protocol_Model" (required by "Draft.ExamplesTemplates" via "Draft.Examples" via "Draft.Keyserver" via "Draft.PSPSP" via "Draft.Stateful_Protocol_Verification")
locale stateful_protocol_model
  fixes arity\<^sub>f :: "'fun => nat"
    and arity\<^sub>s :: "'sets => nat"
    and public\<^sub>f :: "'fun => bool"
    and
    Ana\<^sub>f ::
      "'fun
       => (('fun, 'atom, 'sets) prot_fun, nat) Term.term list * nat list"
    and \<Gamma>\<^sub>f :: "'fun => 'atom option"
    and label_witness1 :: "'lbl"
    and label_witness2 :: "'lbl"
  assumes
    "stateful_protocol_model arity\<^sub>f public\<^sub>f Ana\<^sub>f
      \<Gamma>\<^sub>f label_witness1 label_witness2"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "size <*mlex*> {}"
Proofs for inductive predicate(s) "reachable_constraintsp"
  Proving monotonicity ...
### theory "Draft.Stateful_Protocol_Model"
### 4.709s elapsed time, 5.959s cpu time, 1.629s GC time
Loading theory "Draft.Term_Implication" (required by "Draft.ExamplesTemplates" via "Draft.Examples" via "Draft.Keyserver" via "Draft.PSPSP" via "Draft.Stateful_Protocol_Verification")
Proofs for inductive predicate(s) "timpl_closurep"
  Proving monotonicity ...
Proofs for inductive predicate(s) "timpl_closure'_stepp"
  Proving monotonicity ...
locale stateful_protocol_model
  fixes arity\<^sub>f :: "'fun => nat"
    and arity\<^sub>s :: "'sets => nat"
    and public\<^sub>f :: "'fun => bool"
    and
    Ana\<^sub>f ::
      "'fun
       => (('fun, 'atom, 'sets) prot_fun, nat) Term.term list * nat list"
    and \<Gamma>\<^sub>f :: "'fun => 'atom option"
    and label_witness1 :: "'lbl"
    and label_witness2 :: "'lbl"
  assumes
    "stateful_protocol_model arity\<^sub>f public\<^sub>f Ana\<^sub>f
      \<Gamma>\<^sub>f label_witness1 label_witness2"
Found termination order: "(%p. length (fst p)) <*mlex*> {}"
Found termination order: "(%p. size (snd (snd p))) <*mlex*> {}"
Found termination order: "(%p. size (snd (snd p))) <*mlex*> {}"
Found termination order: "(%p. size (snd (snd p))) <*mlex*> {}"
Found termination order: "(%p. size (snd (snd p))) <*mlex*> {}"
Found termination order: "(%p. size (snd (snd p))) <*mlex*> {}"
Found termination order: "(%p. size (snd (snd p))) <*mlex*> {}"
Proofs for inductive predicate(s) "timpls_transformable_to_pred"
  Proving monotonicity ...
### theory "Draft.Term_Implication"
### 9.887s elapsed time, 11.044s cpu time, 1.669s GC time
Loading theory "Draft.Stateful_Protocol_Verification" (required by "Draft.ExamplesTemplates" via "Draft.Examples" via "Draft.Keyserver" via "Draft.PSPSP")
locale stateful_protocol_model
  fixes arity\<^sub>f :: "'fun => nat"
    and arity\<^sub>s :: "'sets => nat"
    and public\<^sub>f :: "'fun => bool"
    and
    Ana\<^sub>f ::
      "'fun
       => (('fun, 'atom, 'sets) prot_fun, nat) Term.term list * nat list"
    and \<Gamma>\<^sub>f :: "'fun => 'atom option"
    and label_witness1 :: "'lbl"
    and label_witness2 :: "'lbl"
  assumes
    "stateful_protocol_model arity\<^sub>f public\<^sub>f Ana\<^sub>f
      \<Gamma>\<^sub>f label_witness1 label_witness2"
locale stateful_protocol_model
  fixes arity\<^sub>f :: "'fun => nat"
    and arity\<^sub>s :: "'sets => nat"
    and public\<^sub>f :: "'fun => bool"
    and
    Ana\<^sub>f ::
      "'fun
       => (('fun, 'atom, 'sets) prot_fun, nat) Term.term list * nat list"
    and \<Gamma>\<^sub>f :: "'fun => 'atom option"
    and label_witness1 :: "'lbl"
    and label_witness2 :: "'lbl"
  assumes
    "stateful_protocol_model arity\<^sub>f public\<^sub>f Ana\<^sub>f
      \<Gamma>\<^sub>f label_witness1 label_witness2"
Found termination order: "(%p. size_list size (fst p)) <*mlex*> {}"
Found termination order:
  "(%p. size_list (%p. size (snd p)) (fst p)) <*mlex*> {}"
Found termination order: "size_list size <*mlex*> {}"
Found termination order: "size_list size <*mlex*> {}"
locale stateful_protocol_model
  fixes arity\<^sub>f :: "'fun => nat"
    and arity\<^sub>s :: "'sets => nat"
    and public\<^sub>f :: "'fun => bool"
    and
    Ana\<^sub>f ::
      "'fun
       => (('fun, 'atom, 'sets) prot_fun, nat) Term.term list * nat list"
    and \<Gamma>\<^sub>f :: "'fun => 'atom option"
    and label_witness1 :: "'lbl"
    and label_witness2 :: "'lbl"
  assumes
    "stateful_protocol_model arity\<^sub>f public\<^sub>f Ana\<^sub>f
      \<Gamma>\<^sub>f label_witness1 label_witness2"
locale stateful_protocol_model
  fixes arity\<^sub>f :: "'fun => nat"
    and arity\<^sub>s :: "'sets => nat"
    and public\<^sub>f :: "'fun => bool"
    and
    Ana\<^sub>f ::
      "'fun
       => (('fun, 'atom, 'sets) prot_fun, nat) Term.term list * nat list"
    and \<Gamma>\<^sub>f :: "'fun => 'atom option"
    and label_witness1 :: "'lbl"
    and label_witness2 :: "'lbl"
  assumes
    "stateful_protocol_model arity\<^sub>f public\<^sub>f Ana\<^sub>f
      \<Gamma>\<^sub>f label_witness1 label_witness2"
locale stateful_protocol_model
  fixes arity\<^sub>f :: "'fun => nat"
    and arity\<^sub>s :: "'sets => nat"
    and public\<^sub>f :: "'fun => bool"
    and
    Ana\<^sub>f ::
      "'fun
       => (('fun, 'atom, 'sets) prot_fun, nat) Term.term list * nat list"
    and \<Gamma>\<^sub>f :: "'fun => 'atom option"
    and label_witness1 :: "'lbl"
    and label_witness2 :: "'lbl"
  assumes
    "stateful_protocol_model arity\<^sub>f public\<^sub>f Ana\<^sub>f
      \<Gamma>\<^sub>f label_witness1 label_witness2"
locale stateful_protocol_model
  fixes arity\<^sub>f :: "'fun => nat"
    and arity\<^sub>s :: "'sets => nat"
    and public\<^sub>f :: "'fun => bool"
    and
    Ana\<^sub>f ::
      "'fun
       => (('fun, 'atom, 'sets) prot_fun, nat) Term.term list * nat list"
    and \<Gamma>\<^sub>f :: "'fun => 'atom option"
    and label_witness1 :: "'lbl"
    and label_witness2 :: "'lbl"
  assumes
    "stateful_protocol_model arity\<^sub>f public\<^sub>f Ana\<^sub>f
      \<Gamma>\<^sub>f label_witness1 label_witness2"
locale secure_stateful_protocol
  fixes arity\<^sub>f :: "'fun => nat"
    and arity\<^sub>s :: "'sets => nat"
    and public\<^sub>f :: "'fun => bool"
    and
    Ana\<^sub>f ::
      "'fun
       => (('fun, 'atom, 'sets) prot_fun, nat) Term.term list * nat list"
    and \<Gamma>\<^sub>f :: "'fun => 'atom option"
    and label_witness1 :: "'lbl"
    and label_witness2 :: "'lbl"
    and P :: "('fun, 'atom, 'sets, 'lbl) prot_transaction list"
    and
    FP_OCC_TI ::
      "(('fun, 'atom, 'sets) prot_fun,
        (('fun, 'atom, 'sets) prot_fun, 'atom prot_atom) Term.term *
        nat) Term.term list *
       'sets set list * ('sets set * 'sets set) list"
    and
    P_SMP ::
      "(('fun, 'atom, 'sets) prot_fun,
        (('fun, 'atom, 'sets) prot_fun, 'atom prot_atom) Term.term *
        nat) Term.term list"
  assumes
    "secure_stateful_protocol arity\<^sub>f arity\<^sub>s public\<^sub>f
      Ana\<^sub>f \<Gamma>\<^sub>f label_witness1 label_witness2 P FP_OCC_TI
      P_SMP"
locale secure_stateful_protocol'
  fixes arity\<^sub>f :: "'fun => nat"
    and arity\<^sub>s :: "'sets => nat"
    and public\<^sub>f :: "'fun => bool"
    and
    Ana\<^sub>f ::
      "'fun
       => (('fun, 'atom, 'sets) prot_fun, nat) Term.term list * nat list"
    and \<Gamma>\<^sub>f :: "'fun => 'atom option"
    and label_witness1 :: "'lbl"
    and label_witness2 :: "'lbl"
    and P :: "('fun, 'atom, 'sets, 'lbl) prot_transaction list"
    and
    FP_OCC_TI ::
      "(('fun, 'atom, 'sets) prot_fun,
        (('fun, 'atom, 'sets) prot_fun, 'atom prot_atom) Term.term *
        nat) Term.term list *
       'sets set list * ('sets set * 'sets set) list"
  assumes
    "secure_stateful_protocol' arity\<^sub>f arity\<^sub>s public\<^sub>f
      Ana\<^sub>f \<Gamma>\<^sub>f label_witness1 label_witness2 P
      FP_OCC_TI"
locale secure_stateful_protocol''
  fixes arity\<^sub>f :: "'fun => nat"
    and arity\<^sub>s :: "'sets => nat"
    and public\<^sub>f :: "'fun => bool"
    and
    Ana\<^sub>f ::
      "'fun
       => (('fun, 'atom, 'sets) prot_fun, nat) Term.term list * nat list"
    and \<Gamma>\<^sub>f :: "'fun => 'atom option"
    and label_witness1 :: "'lbl"
    and label_witness2 :: "'lbl"
    and P :: "('fun, 'atom, 'sets, 'lbl) prot_transaction list"
  assumes
    "secure_stateful_protocol'' arity\<^sub>f arity\<^sub>s public\<^sub>f
      Ana\<^sub>f \<Gamma>\<^sub>f label_witness1 label_witness2 P"
locale secure_stateful_protocol'''
  fixes arity\<^sub>f :: "'fun => nat"
    and arity\<^sub>s :: "'sets => nat"
    and public\<^sub>f :: "'fun => bool"
    and
    Ana\<^sub>f ::
      "'fun
       => (('fun, 'atom, 'sets) prot_fun, nat) Term.term list * nat list"
    and \<Gamma>\<^sub>f :: "'fun => 'atom option"
    and label_witness1 :: "'lbl"
    and label_witness2 :: "'lbl"
    and P :: "('fun, 'atom, 'sets, 'lbl) prot_transaction list"
    and
    FP_OCC_TI ::
      "(('fun, 'atom, 'sets) prot_fun,
        (('fun, 'atom, 'sets) prot_fun, 'atom prot_atom) Term.term *
        nat) Term.term list *
       'sets set list * ('sets set * 'sets set) list"
    and
    P_SMP ::
      "(('fun, 'atom, 'sets) prot_fun,
        (('fun, 'atom, 'sets) prot_fun, 'atom prot_atom) Term.term *
        nat) Term.term list"
  assumes
    "secure_stateful_protocol''' arity\<^sub>f arity\<^sub>s public\<^sub>f
      Ana\<^sub>f \<Gamma>\<^sub>f label_witness1 label_witness2 P FP_OCC_TI
      P_SMP"
locale secure_stateful_protocol''''
  fixes arity\<^sub>f :: "'fun => nat"
    and arity\<^sub>s :: "'sets => nat"
    and public\<^sub>f :: "'fun => bool"
    and
    Ana\<^sub>f ::
      "'fun
       => (('fun, 'atom, 'sets) prot_fun, nat) Term.term list * nat list"
    and \<Gamma>\<^sub>f :: "'fun => 'atom option"
    and label_witness1 :: "'lbl"
    and label_witness2 :: "'lbl"
    and P :: "('fun, 'atom, 'sets, 'lbl) prot_transaction list"
    and
    FP_OCC_TI ::
      "(('fun, 'atom, 'sets) prot_fun,
        (('fun, 'atom, 'sets) prot_fun, 'atom prot_atom) Term.term *
        nat) Term.term list *
       'sets set list * ('sets set * 'sets set) list"
  assumes
    "secure_stateful_protocol'''' arity\<^sub>f arity\<^sub>s public\<^sub>f
      Ana\<^sub>f \<Gamma>\<^sub>f label_witness1 label_witness2 P
      FP_OCC_TI"
locale stateful_protocol_model
  fixes arity\<^sub>f :: "'fun => nat"
    and arity\<^sub>s :: "'sets => nat"
    and public\<^sub>f :: "'fun => bool"
    and
    Ana\<^sub>f ::
      "'fun
       => (('fun, 'atom, 'sets) prot_fun, nat) Term.term list * nat list"
    and \<Gamma>\<^sub>f :: "'fun => 'atom option"
    and label_witness1 :: "'lbl"
    and label_witness2 :: "'lbl"
  assumes
    "stateful_protocol_model arity\<^sub>f public\<^sub>f Ana\<^sub>f
      \<Gamma>\<^sub>f label_witness1 label_witness2"
### theory "Draft.Stateful_Protocol_Verification"
### 68.229s elapsed time, 111.546s cpu time, 66.044s GC time
Loading theory "Draft.PSPSP" (required by "Draft.ExamplesTemplates" via "Draft.Examples" via "Draft.Keyserver")
### theory "Draft.PSPSP"
### 0.228s elapsed time, 0.249s cpu time, 0.000s GC time
Loading theory "Draft.Keyserver" (required by "Draft.ExamplesTemplates" via "Draft.Examples")
Loading theory "Draft.Keyserver2" (required by "Draft.ExamplesTemplates" via "Draft.Examples")
Loading theory "Draft.Keyserver_Composition" (required by "Draft.ExamplesTemplates" via "Draft.Examples")
Loading theory "Draft.PKCS_Model03" (required by "Draft.ExamplesTemplates" via "Draft.Examples")
Inst enum: ATTACK_UNSET_atom
Inst enum: keyserver_atom
Inst enum: keyserver2_atom
Inst enum: kscomp_atom
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
### preprocessing equations
### 1.127s elapsed time, 3.673s cpu time, 0.712s GC time
### preprocessing equations
### 0.972s elapsed time, 3.163s cpu time, 0.613s GC time
### translating term
### 67.594s elapsed time, 203.634s cpu time, 201.445s GC time
### preprocessing equations
### 67.942s elapsed time, 204.830s cpu time, 201.654s GC time
### compiling ML
### 0.142s elapsed time, 0.574s cpu time, 0.000s GC time
### running ML
### 0.007s elapsed time, 0.030s cpu time, 0.000s GC time
### postprocessing term
### 0.001s elapsed time, 0.005s cpu time, 0.000s GC time
### translating term
### 68.293s elapsed time, 206.283s cpu time, 201.704s GC time
### compiling ML
### 0.703s elapsed time, 2.730s cpu time, 0.400s GC time
### postprocessing term
### 0.001s elapsed time, 0.001s cpu time, 0.000s GC time
### translating term
### 1.399s elapsed time, 5.424s cpu time, 0.765s GC time
### compiling ML
### 0.412s elapsed time, 1.603s cpu time, 0.232s GC time
### running ML
### 0.001s elapsed time, 0.003s cpu time, 0.000s GC time
### postprocessing term
### 0.001s elapsed time, 0.013s cpu time, 0.000s GC time
### preprocessing equations
### 0.897s elapsed time, 3.461s cpu time, 0.579s GC time
### translating term
### 0.614s elapsed time, 2.371s cpu time, 0.362s GC time
### compiling ML
### 0.172s elapsed time, 0.648s cpu time, 0.179s GC time
### running ML
### 0.000s elapsed time, 0.012s cpu time, 0.000s GC time
### preprocessing equations
### 1.178s elapsed time, 4.554s cpu time, 0.652s GC time
### translating term
### 1.198s elapsed time, 4.572s cpu time, 0.815s GC time
### building simpset
### 0.019s elapsed time, 0.079s cpu time, 0.000s GC time
### theory "Draft.Keyserver_Composition"
### 113.165s elapsed time, 368.372s cpu time, 255.135s GC time
Loading theory "Draft.PKCS_Model07" (required by "Draft.ExamplesTemplates" via "Draft.Examples")
### theory "Draft.Keyserver"
### 113.175s elapsed time, 368.413s cpu time, 255.135s GC time
Loading theory "Draft.PKCS_Model09" (required by "Draft.ExamplesTemplates" via "Draft.Examples")
Inst enum: LOSS_KEY_ATT_atom
Inst enum: RE_IMPORT_ATT_atom
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
### theory "Draft.PKCS_Model03"
### 120.002s elapsed time, 396.987s cpu time, 267.221s GC time
ALL \<A>:spm.reachable_constraints kscomp_protocol.
   \<nexists>\<I>.
      spm.constraint_model \<I>
       (\<A> @ [(?l, send\<langle>attack\<langle>?n\<rangle>\<rangle>)])
ALL kscomp_enum_consts.
   kscomp_enum_consts = a |
   kscomp_enum_consts = b | kscomp_enum_consts = c | kscomp_enum_consts = i
ALL kscomp_sets.
   (EX x1. kscomp_sets = ring x1) |
   (EX x2. kscomp_sets = valid x2) |
   (EX x3. kscomp_sets = revoked x3) |
   (EX x4. kscomp_sets = deleted x4) |
   (EX x5. kscomp_sets = ring' x5) |
   (EX x6. kscomp_sets = seen x6) | kscomp_sets = pubkeys
ALL kscomp_fun.
   kscomp_fun = h |
   kscomp_fun = sign |
   kscomp_fun = crypt |
   kscomp_fun = scrypt |
   kscomp_fun = pair |
   kscomp_fun = update |
   kscomp_fun = kscomp_fun.inv |
   kscomp_fun = pw |
   kscomp_fun = PrivFunSec | (EX x10. kscomp_fun = enum x10)
ALL kscomp_atom. kscomp_atom = EnumType | kscomp_atom = SecretType
kscomp_arity h = Suc 0
kscomp_arity sign = Suc (Suc 0)
kscomp_arity crypt = Suc (Suc 0)
kscomp_arity scrypt = Suc (Suc 0)
kscomp_arity pair = Suc (Suc 0)
kscomp_arity update = Suc (Suc (Suc 0))
kscomp_arity kscomp_fun.inv = Suc (Suc 0)
kscomp_arity pw = Suc (Suc 0)
kscomp_arity PrivFunSec = 0
kscomp_arity (enum ?uu) = 0
kscomp_public PrivFunSec = False
kscomp_public h = True
kscomp_public sign = True
kscomp_public crypt = True
kscomp_public scrypt = True
kscomp_public pair = True
kscomp_public update = True
kscomp_public kscomp_fun.inv = True
kscomp_public pw = True
kscomp_public (enum ?uu) = True
kscomp_\<Gamma> PrivFunSec = Some SecretType
kscomp_\<Gamma> (enum ?uu) = Some EnumType
kscomp_\<Gamma> h = None
kscomp_\<Gamma> sign = None
kscomp_\<Gamma> crypt = None
kscomp_\<Gamma> scrypt = None
kscomp_\<Gamma> pair = None
kscomp_\<Gamma> update = None
kscomp_\<Gamma> kscomp_fun.inv = None
kscomp_\<Gamma> pw = None
kscomp_Ana sign = ([], [Suc 0])
kscomp_Ana crypt =
([Fun (Fu kscomp_fun.inv) [Fun (Fu PrivFunSec) [], Var 0]], [Suc 0])
kscomp_Ana scrypt = ([Var 0], [Suc 0])
kscomp_Ana pair = ([], [0, Suc 0])
kscomp_Ana update = ([], [0, Suc 0, Suc (Suc 0)])
kscomp_Ana h = ([], [])
kscomp_Ana kscomp_fun.inv = ([], [])
kscomp_Ana pw = ([], [])
kscomp_Ana PrivFunSec = ([], [])
kscomp_Ana (enum ?uu) = ([], [])
kscomp_transaction_p1_outOfBand ==
map (%A. transaction\<^sub>1 [] [] new [\<langle>0\<rangle>\<^sub>v] [\<langle>0, insert\<langle>\<langle>0\<rangle>\<^sub>v,\<langle>ring
                     A\<rangle>\<^sub>s\<rangle>\<rangle>,
                                \<langle>\<star>, insert\<langle>\<langle>0\<rangle>\<^sub>v,\<langle>valid
                           A\<rangle>\<^sub>s\<rangle>\<rangle>] [\<langle>0, send\<langle>\<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                            \<langle>\<star>, send\<langle>occurs
                      \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>])
 [a, b, c]
kscomp_transaction_p1_oufOfBandD ==
map (%A. transaction\<^sub>1 [] [] new [\<langle>0\<rangle>\<^sub>v] [\<langle>\<star>, insert\<langle>\<langle>0\<rangle>\<^sub>v,\<langle>valid
                           A\<rangle>\<^sub>s\<rangle>\<rangle>] [\<langle>0, send\<langle>\<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                            \<langle>0, send\<langle>\<langle>kscomp_fun.inv [\<langle>PrivFunSec\<rangle>\<^sub>c,
  \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                            \<langle>\<star>, send\<langle>occurs
                      \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>])
 [i]
kscomp_transaction_p1_updateKey ==
map (%A. transaction\<^sub>1 [\<langle>\<star>, receive\<langle>occurs
                           \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>] [\<langle>0, \<langle>\<langle>0\<rangle>\<^sub>v in \<langle>ring
                       A\<rangle>\<^sub>s\<rangle>\<rangle>] new [\<langle>Suc
0\<rangle>\<^sub>v] [\<langle>0, delete\<langle>\<langle>0\<rangle>\<^sub>v,\<langle>ring
          A\<rangle>\<^sub>s\<rangle>\<rangle>,
                     \<langle>0, insert\<langle>\<langle>0\<rangle>\<^sub>v,\<langle>deleted
          A\<rangle>\<^sub>s\<rangle>\<rangle>,
                     \<langle>0, insert\<langle>\<langle>Suc
                    0\<rangle>\<^sub>v,\<langle>ring
           A\<rangle>\<^sub>s\<rangle>\<rangle>] [\<langle>0, send\<langle>\<langle>sign [\<langle>kscomp_fun.inv [\<langle>PrivFunSec\<rangle>\<^sub>c,
 \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t,
              \<langle>pair [\<langle>enum A\<rangle>\<^sub>c,
                             \<langle>Suc
 0\<rangle>\<^sub>v]\<rangle>\<^sub>t]\<rangle>\<^sub>t\<rangle>\<rangle>,
            \<langle>\<star>, send\<langle>occurs
      \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>])
 [a, b, c]
kscomp_transaction_p1_updateKeyServer ==
map (%A. transaction\<^sub>2 [\<langle>\<star>, receive\<langle>occurs
                           \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                              \<langle>\<star>, receive\<langle>occurs
                           \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                              \<langle>0, receive\<langle>\<langle>sign [\<langle>kscomp_fun.inv [\<langle>PrivFunSec\<rangle>\<^sub>c,
                      \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t,
                                   \<langle>pair [\<langle>enum
                      A\<rangle>\<^sub>c,
            \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
                0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v in \<langle>valid
                A\<rangle>\<^sub>s\<rangle>\<rangle>] @
                       concat
                        [map (%X0. \<langle>\<star>, \<langle>\<langle>Suc
                                  0\<rangle>\<^sub>v not in \<langle>valid
                                X0\<rangle>\<^sub>s\<rangle>\<rangle>)
                          [a, b, c, i],
                         map (%X0. \<langle>0, \<langle>\<langle>Suc
                            0\<rangle>\<^sub>v not in \<langle>revoked
                          X0\<rangle>\<^sub>s\<rangle>\<rangle>)
                          [a, b, c,
                           i]]  [\<langle>\<star>, delete\<langle>\<langle>0\<rangle>\<^sub>v,\<langle>valid
                            A\<rangle>\<^sub>s\<rangle>\<rangle>,
                                 \<langle>0, insert\<langle>\<langle>0\<rangle>\<^sub>v,\<langle>revoked
                      A\<rangle>\<^sub>s\<rangle>\<rangle>,
                                 \<langle>\<star>, insert\<langle>\<langle>Suc
0\<rangle>\<^sub>v,\<langle>valid
                             A\<rangle>\<^sub>s\<rangle>\<rangle>] [\<langle>0, send\<langle>\<langle>kscomp_fun.inv [\<langle>PrivFunSec\<rangle>\<^sub>c,
    \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>])
 [a, b, c, i]
kscomp_transaction_p1_authAttack ==
map (%A. transaction\<^sub>2 [\<langle>\<star>, receive\<langle>occurs
                           \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                              \<langle>0, receive\<langle>\<langle>kscomp_fun.inv [\<langle>PrivFunSec\<rangle>\<^sub>c,
       \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v in \<langle>valid
                           A\<rangle>\<^sub>s\<rangle>\<rangle>]  [] [\<langle>0, send\<langle>attack\<langle>0\<rangle>\<rangle>\<rangle>])
 [a, b, c]
kscomp_transaction_p2_passwordGenD ==
map (%A. transaction\<^sub>2 [] []  [] [\<langle>0, send\<langle>\<langle>pw [\<langle>PrivFunSec\<rangle>\<^sub>c,
  \<langle>enum A\<rangle>\<^sub>c]\<rangle>\<^sub>t\<rangle>\<rangle>])
 [i]
kscomp_transaction_p2_pubkeysGen ==
[transaction\<^sub>1 [] [] new [\<langle>0\<rangle>\<^sub>v] [\<langle>0, insert\<langle>\<langle>0\<rangle>\<^sub>v,\<langle>pubkeys\<rangle>\<^sub>s\<rangle>\<rangle>] [\<langle>0, send\<langle>\<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                   \<langle>\<star>, send\<langle>occurs
             \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>]]
kscomp_transaction_p2_updateKeyPw ==
map (%A. transaction\<^sub>1 [\<langle>\<star>, receive\<langle>occurs
                           \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>] [\<langle>0, \<langle>\<langle>0\<rangle>\<^sub>v in \<langle>pubkeys\<rangle>\<^sub>s\<rangle>\<rangle>] new [\<langle>Suc
     0\<rangle>\<^sub>v] [\<langle>0, insert\<langle>\<langle>Suc
                         0\<rangle>\<^sub>v,\<langle>ring'
                A\<rangle>\<^sub>s\<rangle>\<rangle>] [\<langle>0, send\<langle>\<langle>Suc
              0\<rangle>\<^sub>v\<rangle>\<rangle>,
                 \<langle>0, send\<langle>\<langle>crypt [\<langle>0\<rangle>\<^sub>v,
                    \<langle>update [\<langle>enum A\<rangle>\<^sub>c,
                                     \<langle>Suc 0\<rangle>\<^sub>v,
                                     \<langle>pw [\<langle>PrivFunSec\<rangle>\<^sub>c,
            \<langle>enum
                      A\<rangle>\<^sub>c]\<rangle>\<^sub>t]\<rangle>\<^sub>t]\<rangle>\<^sub>t\<rangle>\<rangle>,
                 \<langle>\<star>, send\<langle>occurs
           \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>])
 [a, b, c]
kscomp_transaction_p2_updateKeyServerPw ==
map (%A. transaction\<^sub>2 [\<langle>\<star>, receive\<langle>occurs
                           \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                              \<langle>\<star>, receive\<langle>occurs
                           \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                              \<langle>0, receive\<langle>\<langle>crypt [\<langle>0\<rangle>\<^sub>v,
                                    \<langle>update [\<langle>enum
                         A\<rangle>\<^sub>c,
               \<langle>Suc 0\<rangle>\<^sub>v,
               \<langle>pw [\<langle>PrivFunSec\<rangle>\<^sub>c,
                            \<langle>enum
A\<rangle>\<^sub>c]\<rangle>\<^sub>t]\<rangle>\<^sub>t]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
         0\<rangle>\<^sub>v\<rangle>\<rangle>,
                 \<langle>0, \<langle>\<langle>0\<rangle>\<^sub>v in \<langle>pubkeys\<rangle>\<^sub>s\<rangle>\<rangle>,
                 \<langle>0, \<langle>\<langle>Suc
          0\<rangle>\<^sub>v not in \<langle>pubkeys\<rangle>\<^sub>s\<rangle>\<rangle>] @
                concat
                 [map (%X0. \<langle>0, \<langle>\<langle>Suc
                     0\<rangle>\<^sub>v not in \<langle>seen
                   X0\<rangle>\<^sub>s\<rangle>\<rangle>)
                   [a, b, c,
                    i]]  [\<langle>\<star>, insert\<langle>\<langle>Suc
                               0\<rangle>\<^sub>v,\<langle>valid
                      A\<rangle>\<^sub>s\<rangle>\<rangle>,
                          \<langle>0, insert\<langle>\<langle>Suc
                         0\<rangle>\<^sub>v,\<langle>seen
                A\<rangle>\<^sub>s\<rangle>\<rangle>] [])
 [a, b, c, i]
kscomp_transaction_p2_authAttack2 ==
map (%A. transaction\<^sub>2 [\<langle>\<star>, receive\<langle>occurs
                           \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                              \<langle>0, receive\<langle>\<langle>kscomp_fun.inv [\<langle>PrivFunSec\<rangle>\<^sub>c,
       \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v in \<langle>valid
                           A\<rangle>\<^sub>s\<rangle>\<rangle>]  [] [\<langle>0, send\<langle>attack\<langle>0\<rangle>\<rangle>\<rangle>])
 [a, b, c]
kscomp_protocol ==
concat
 [kscomp_transaction_p1_outOfBand, kscomp_transaction_p1_oufOfBandD,
  kscomp_transaction_p1_updateKey, kscomp_transaction_p1_updateKeyServer,
  kscomp_transaction_p1_authAttack, kscomp_transaction_p2_passwordGenD,
  kscomp_transaction_p2_pubkeysGen, kscomp_transaction_p2_updateKeyPw,
  kscomp_transaction_p2_updateKeyServerPw,
  kscomp_transaction_p2_authAttack2]
kscomp_fixpoint ==
([\<langle>sign [\<langle>kscomp_fun.inv [\<langle>PrivFunSec\<rangle>\<^sub>c,
    \<langle>{deleted a}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
                 \<langle>pair [\<langle>enum a\<rangle>\<^sub>c,
                                \<langle>{ring
     a}\<rangle>\<^sub>a]\<rangle>\<^sub>t]\<rangle>\<^sub>t,
  \<langle>sign [\<langle>kscomp_fun.inv [\<langle>PrivFunSec\<rangle>\<^sub>c,
    \<langle>{deleted b}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
                 \<langle>pair [\<langle>enum b\<rangle>\<^sub>c,
                                \<langle>{ring
     b}\<rangle>\<^sub>a]\<rangle>\<^sub>t]\<rangle>\<^sub>t,
  \<langle>sign [\<langle>kscomp_fun.inv [\<langle>PrivFunSec\<rangle>\<^sub>c,
    \<langle>{deleted c}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
                 \<langle>pair [\<langle>enum c\<rangle>\<^sub>c,
                                \<langle>{ring
     c}\<rangle>\<^sub>a]\<rangle>\<^sub>t]\<rangle>\<^sub>t,
  \<langle>sign [\<langle>kscomp_fun.inv [\<langle>PrivFunSec\<rangle>\<^sub>c,
    \<langle>{deleted a, valid i}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
                 \<langle>pair [\<langle>enum a\<rangle>\<^sub>c,
                                \<langle>{ring
     a}\<rangle>\<^sub>a]\<rangle>\<^sub>t]\<rangle>\<^sub>t,
  \<langle>sign [\<langle>kscomp_fun.inv [\<langle>PrivFunSec\<rangle>\<^sub>c,
    \<langle>{deleted b, valid i}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
                 \<langle>pair [\<langle>enum b\<rangle>\<^sub>c,
                                \<langle>{ring
     b}\<rangle>\<^sub>a]\<rangle>\<^sub>t]\<rangle>\<^sub>t,
  \<langle>sign [\<langle>kscomp_fun.inv [\<langle>PrivFunSec\<rangle>\<^sub>c,
    \<langle>{deleted c, valid i}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
                 \<langle>pair [\<langle>enum c\<rangle>\<^sub>c,
                                \<langle>{ring
     c}\<rangle>\<^sub>a]\<rangle>\<^sub>t]\<rangle>\<^sub>t,
  \<langle>sign [\<langle>kscomp_fun.inv [\<langle>PrivFunSec\<rangle>\<^sub>c,
    \<langle>{deleted a, seen i,
              valid i}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
                 \<langle>pair [\<langle>enum a\<rangle>\<^sub>c,
                                \<langle>{ring
     a}\<rangle>\<^sub>a]\<rangle>\<^sub>t]\<rangle>\<^sub>t,
  \<langle>sign [\<langle>kscomp_fun.inv [\<langle>PrivFunSec\<rangle>\<^sub>c,
    \<langle>{deleted b, seen i,
              valid i}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
                 \<langle>pair [\<langle>enum b\<rangle>\<^sub>c,
                                \<langle>{ring
     b}\<rangle>\<^sub>a]\<rangle>\<^sub>t]\<rangle>\<^sub>t,
  \<langle>sign [\<langle>kscomp_fun.inv [\<langle>PrivFunSec\<rangle>\<^sub>c,
    \<langle>{deleted c, seen i,
              valid i}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
                 \<langle>pair [\<langle>enum c\<rangle>\<^sub>c,
                                \<langle>{ring
     c}\<rangle>\<^sub>a]\<rangle>\<^sub>t]\<rangle>\<^sub>t,
  \<langle>sign [\<langle>kscomp_fun.inv [\<langle>PrivFunSec\<rangle>\<^sub>c,
    \<langle>{deleted a, valid a}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
                 \<langle>pair [\<langle>enum a\<rangle>\<^sub>c,
                                \<langle>{ring
     a}\<rangle>\<^sub>a]\<rangle>\<^sub>t]\<rangle>\<^sub>t,
  \<langle>sign [\<langle>kscomp_fun.inv [\<langle>PrivFunSec\<rangle>\<^sub>c,
    \<langle>{deleted b, valid b}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
                 \<langle>pair [\<langle>enum b\<rangle>\<^sub>c,
                                \<langle>{ring
     b}\<rangle>\<^sub>a]\<rangle>\<^sub>t]\<rangle>\<^sub>t,
  \<langle>sign [\<langle>kscomp_fun.inv [\<langle>PrivFunSec\<rangle>\<^sub>c,
    \<langle>{deleted c, valid c}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
                 \<langle>pair [\<langle>enum c\<rangle>\<^sub>c,
                                \<langle>{ring
     c}\<rangle>\<^sub>a]\<rangle>\<^sub>t]\<rangle>\<^sub>t,
  \<langle>sign [\<langle>kscomp_fun.inv [\<langle>PrivFunSec\<rangle>\<^sub>c,
    \<langle>{deleted a, seen i, valid i,
              valid a}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
                 \<langle>pair [\<langle>enum a\<rangle>\<^sub>c,
                                \<langle>{ring
     a}\<rangle>\<^sub>a]\<rangle>\<^sub>t]\<rangle>\<^sub>t,
  \<langle>sign [\<langle>kscomp_fun.inv [\<langle>PrivFunSec\<rangle>\<^sub>c,
    \<langle>{deleted b, seen i, valid i,
              valid b}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
                 \<langle>pair [\<langle>enum b\<rangle>\<^sub>c,
                                \<langle>{ring
     b}\<rangle>\<^sub>a]\<rangle>\<^sub>t]\<rangle>\<^sub>t,
  \<langle>sign [\<langle>kscomp_fun.inv [\<langle>PrivFunSec\<rangle>\<^sub>c,
    \<langle>{deleted c, seen i, valid i,
              valid c}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
                 \<langle>pair [\<langle>enum c\<rangle>\<^sub>c,
                                \<langle>{ring
     c}\<rangle>\<^sub>a]\<rangle>\<^sub>t]\<rangle>\<^sub>t,
  \<langle>pair [\<langle>enum a\<rangle>\<^sub>c,
                 \<langle>{ring a}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>pair [\<langle>enum b\<rangle>\<^sub>c,
                 \<langle>{ring b}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>pair [\<langle>enum c\<rangle>\<^sub>c,
                 \<langle>{ring c}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>kscomp_fun.inv [\<langle>PrivFunSec\<rangle>\<^sub>c,
                           \<langle>{deleted a,
                                     revoked
a}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>kscomp_fun.inv [\<langle>PrivFunSec\<rangle>\<^sub>c,
                           \<langle>{deleted b,
                                     revoked
b}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>kscomp_fun.inv [\<langle>PrivFunSec\<rangle>\<^sub>c,
                           \<langle>{deleted c,
                                     revoked
c}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>kscomp_fun.inv [\<langle>PrivFunSec\<rangle>\<^sub>c,
                           \<langle>{valid
i}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>kscomp_fun.inv [\<langle>PrivFunSec\<rangle>\<^sub>c,
                           \<langle>{revoked
i}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>kscomp_fun.inv [\<langle>PrivFunSec\<rangle>\<^sub>c,
                           \<langle>{revoked i,
                                     seen
i}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>kscomp_fun.inv [\<langle>PrivFunSec\<rangle>\<^sub>c,
                           \<langle>{revoked i, seen i, revoked a,
                                     deleted
a}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>kscomp_fun.inv [\<langle>PrivFunSec\<rangle>\<^sub>c,
                           \<langle>{revoked i, seen i, revoked b,
                                     deleted
b}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>kscomp_fun.inv [\<langle>PrivFunSec\<rangle>\<^sub>c,
                           \<langle>{revoked i, seen i, revoked c,
                                     deleted
c}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>kscomp_fun.inv [\<langle>PrivFunSec\<rangle>\<^sub>c,
                           \<langle>{revoked a, deleted a, seen i,
                                     valid
i}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>kscomp_fun.inv [\<langle>PrivFunSec\<rangle>\<^sub>c,
                           \<langle>{revoked b, deleted b, seen i,
                                     valid
i}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>kscomp_fun.inv [\<langle>PrivFunSec\<rangle>\<^sub>c,
                           \<langle>{revoked c, deleted c, seen i,
                                     valid
i}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  occurs \<langle>{ring a}\<rangle>\<^sub>a,
  occurs \<langle>{ring b}\<rangle>\<^sub>a,
  occurs \<langle>{ring c}\<rangle>\<^sub>a,
  occurs \<langle>{valid i}\<rangle>\<^sub>a,
  occurs \<langle>{ring' a}\<rangle>\<^sub>a,
  occurs \<langle>{ring' b}\<rangle>\<^sub>a,
  occurs \<langle>{ring' c}\<rangle>\<^sub>a,
  occurs \<langle>{pubkeys}\<rangle>\<^sub>a,
  occurs \<langle>{valid a, ring a}\<rangle>\<^sub>a,
  occurs \<langle>{valid b, ring b}\<rangle>\<^sub>a,
  occurs \<langle>{valid c, ring c}\<rangle>\<^sub>a,
  \<langle>pw [\<langle>PrivFunSec\<rangle>\<^sub>c,
               \<langle>enum i\<rangle>\<^sub>c]\<rangle>\<^sub>t,
  \<langle>crypt [\<langle>{pubkeys}\<rangle>\<^sub>a,
                  \<langle>update [\<langle>enum a\<rangle>\<^sub>c,
                                   \<langle>{ring' a}\<rangle>\<^sub>a,
                                   \<langle>pw [\<langle>PrivFunSec\<rangle>\<^sub>c,
          \<langle>enum
                    a\<rangle>\<^sub>c]\<rangle>\<^sub>t]\<rangle>\<^sub>t]\<rangle>\<^sub>t,
  \<langle>crypt [\<langle>{pubkeys}\<rangle>\<^sub>a,
                  \<langle>update [\<langle>enum b\<rangle>\<^sub>c,
                                   \<langle>{ring' b}\<rangle>\<^sub>a,
                                   \<langle>pw [\<langle>PrivFunSec\<rangle>\<^sub>c,
          \<langle>enum
                    b\<rangle>\<^sub>c]\<rangle>\<^sub>t]\<rangle>\<^sub>t]\<rangle>\<^sub>t,
  \<langle>crypt [\<langle>{pubkeys}\<rangle>\<^sub>a,
                  \<langle>update [\<langle>enum c\<rangle>\<^sub>c,
                                   \<langle>{ring' c}\<rangle>\<^sub>a,
                                   \<langle>pw [\<langle>PrivFunSec\<rangle>\<^sub>c,
          \<langle>enum
                    c\<rangle>\<^sub>c]\<rangle>\<^sub>t]\<rangle>\<^sub>t]\<rangle>\<^sub>t,
  \<langle>{ring a}\<rangle>\<^sub>a, \<langle>{ring b}\<rangle>\<^sub>a,
  \<langle>{ring c}\<rangle>\<^sub>a, \<langle>{valid i}\<rangle>\<^sub>a,
  \<langle>{ring' a}\<rangle>\<^sub>a, \<langle>{ring' b}\<rangle>\<^sub>a,
  \<langle>{ring' c}\<rangle>\<^sub>a, \<langle>{pubkeys}\<rangle>\<^sub>a,
  \<langle>{valid a, ring a}\<rangle>\<^sub>a,
  \<langle>{valid b, ring b}\<rangle>\<^sub>a,
  \<langle>{valid c, ring c}\<rangle>\<^sub>a],
 [{valid c, ring c}, {valid b, ring b}, {valid a, ring a}, {pubkeys},
  {ring' c}, {ring' b}, {ring' a}, {valid i}, {ring c}, {ring b}, {ring a},
  {seen i, valid i}, {seen i, valid i, ring c}, {seen i, valid i, ring b},
  {seen i, valid i, ring a}, {deleted c, seen i, valid i},
  {deleted b, seen i, valid i}, {deleted a, seen i, valid i},
  {seen i, valid i, valid c, ring c}, {seen i, valid i, valid b, ring b},
  {seen i, valid i, valid a, ring a},
  {revoked i, seen i, revoked c, deleted c},
  {revoked i, seen i, revoked b, deleted b},
  {revoked i, seen i, revoked a, deleted a},
  {deleted c, seen i, valid i, valid c},
  {deleted b, seen i, valid i, valid b},
  {deleted a, seen i, valid i, valid a},
  {revoked c, seen i, valid i, deleted c},
  {revoked b, seen i, valid i, deleted b},
  {revoked a, seen i, valid i, deleted a}, {deleted c, revoked c},
  {deleted b, revoked b}, {deleted a, revoked a}, {revoked i},
  {seen i, revoked i}, {seen i, revoked i, valid i}, {deleted c, valid i},
  {deleted b, valid i}, {deleted a, valid i}, {deleted c, valid c},
  {deleted b, valid b}, {deleted a, valid a}, {deleted c}, {deleted b},
  {deleted a}, {ring c, valid i}, {ring b, valid i}, {ring a, valid i},
  {seen i, valid i, ring' c}, {seen i, valid i, ring' b},
  {seen i, valid i, ring' a}, {ring' c, valid c, seen c, valid i},
  {ring' b, valid b, seen b, valid i}, {ring' a, valid a, seen a, valid i},
  {ring' c, valid c, seen c}, {ring' b, valid b, seen b},
  {ring' a, valid a, seen a}, {ring' c, valid i}, {ring' b, valid i},
  {ring' a, valid i}, {valid i, pubkeys}],
 [({valid i}, {seen i, valid i}),
  ({ring c, valid i}, {seen i, valid i, ring c}),
  ({ring b, valid i}, {seen i, valid i, ring b}),
  ({ring a, valid i}, {seen i, valid i, ring a}),
  ({ring c, valid i}, {deleted c, seen i, valid i}),
  ({ring b, valid i}, {deleted b, seen i, valid i}),
  ({ring a, valid i}, {deleted a, seen i, valid i}),
  ({valid i, deleted c}, {seen i, valid i, deleted c}),
  ({valid i, deleted b}, {seen i, valid i, deleted b}),
  ({valid i, deleted a}, {seen i, valid i, deleted a}),
  ({ring c, valid c}, {seen i, valid i, valid c, ring c}),
  ({ring b, valid b}, {seen i, valid i, valid b, ring b}),
  ({ring a, valid a}, {seen i, valid i, valid a, ring a}),
  ({ring c, valid c}, {revoked i, seen i, revoked c, deleted c}),
  ({ring b, valid b}, {revoked i, seen i, revoked b, deleted b}),
  ({ring a, valid a}, {revoked i, seen i, revoked a, deleted a}),
  ({ring c, valid c}, {deleted c, seen i, valid i, valid c}),
  ({ring b, valid b}, {deleted b, seen i, valid i, valid b}),
  ({ring a, valid a}, {deleted a, seen i, valid i, valid a}),
  ({valid c, deleted c}, {seen i, valid i, valid c, deleted c}),
  ({valid b, deleted b}, {seen i, valid i, valid b, deleted b}),
  ({valid a, deleted a}, {seen i, valid i, valid a, deleted a}),
  ({valid c, deleted c}, {revoked i, seen i, revoked c, deleted c}),
  ({valid b, deleted b}, {revoked i, seen i, revoked b, deleted b}),
  ({valid a, deleted a}, {revoked i, seen i, revoked a, deleted a}),
  ({valid c, deleted c}, {revoked c, seen i, valid i, deleted c}),
  ({valid b, deleted b}, {revoked b, seen i, valid i, deleted b}),
  ({valid a, deleted a}, {revoked a, seen i, valid i, deleted a}),
  ({valid c, deleted c}, {deleted c, revoked c}),
  ({valid b, deleted b}, {deleted b, revoked b}),
  ({valid a, deleted a}, {deleted a, revoked a}), ({valid i}, {revoked i}),
  ({seen i, valid i, valid c, ring c},
   {revoked i, seen i, revoked c, deleted c}),
  ({seen i, valid i, valid b, ring b},
   {revoked i, seen i, revoked b, deleted b}),
  ({seen i, valid i, valid a, ring a},
   {revoked i, seen i, revoked a, deleted a}),
  ({seen i, valid i, valid c, ring c},
   {revoked c, seen i, valid i, deleted c}),
  ({seen i, valid i, valid b, ring b},
   {revoked b, seen i, valid i, deleted b}),
  ({seen i, valid i, valid a, ring a},
   {revoked a, seen i, valid i, deleted a}),
  ({seen i, valid i, valid c, ring c},
   {deleted c, seen i, valid i, valid c}),
  ({seen i, valid i, valid b, ring b},
   {deleted b, seen i, valid i, valid b}),
  ({seen i, valid i, valid a, ring a},
   {deleted a, seen i, valid i, valid a}),
  ({seen i, valid i, ring c}, {deleted c, seen i, valid i}),
  ({seen i, valid i, ring b}, {deleted b, seen i, valid i}),
  ({seen i, valid i, ring a}, {deleted a, seen i, valid i}),
  ({seen i, valid i, revoked i}, {seen i, revoked i}),
  ({seen i, valid i}, {revoked i, seen i}),
  ({seen i, valid i, revoked c, deleted c},
   {revoked i, seen i, revoked c, deleted c}),
  ({seen i, valid i, revoked b, deleted b},
   {revoked i, seen i, revoked b, deleted b}),
  ({seen i, valid i, revoked a, deleted a},
   {revoked i, seen i, revoked a, deleted a}),
  ({seen i, valid i, deleted c, valid c},
   {revoked i, seen i, revoked c, deleted c}),
  ({seen i, valid i, deleted b, valid b},
   {revoked i, seen i, revoked b, deleted b}),
  ({seen i, valid i, deleted a, valid a},
   {revoked i, seen i, revoked a, deleted a}),
  ({seen i, valid i, deleted c, valid c},
   {revoked c, seen i, valid i, deleted c}),
  ({seen i, valid i, deleted b, valid b},
   {revoked b, seen i, valid i, deleted b}),
  ({seen i, valid i, deleted a, valid a},
   {revoked a, seen i, valid i, deleted a}),
  ({revoked c, deleted c}, {seen i, valid i, revoked c, deleted c}),
  ({revoked b, deleted b}, {seen i, valid i, revoked b, deleted b}),
  ({revoked a, deleted a}, {seen i, valid i, revoked a, deleted a}),
  ({revoked c, deleted c}, {revoked i, seen i, revoked c, deleted c}),
  ({revoked b, deleted b}, {revoked i, seen i, revoked b, deleted b}),
  ({revoked a, deleted a}, {revoked i, seen i, revoked a, deleted a}),
  ({revoked i}, {seen i, revoked i, valid i}),
  ({revoked i}, {seen i, revoked i}),
  ({deleted c}, {seen i, valid i, valid c, deleted c}),
  ({deleted b}, {seen i, valid i, valid b, deleted b}),
  ({deleted a}, {seen i, valid i, valid a, deleted a}),
  ({deleted c}, {seen i, valid i, deleted c}),
  ({deleted b}, {seen i, valid i, deleted b}),
  ({deleted a}, {seen i, valid i, deleted a}),
  ({deleted c}, {revoked i, seen i, revoked c, deleted c}),
  ({deleted b}, {revoked i, seen i, revoked b, deleted b}),
  ({deleted a}, {revoked i, seen i, revoked a, deleted a}),
  ({deleted c}, {revoked c, seen i, valid i, deleted c}),
  ({deleted b}, {revoked b, seen i, valid i, deleted b}),
  ({deleted a}, {revoked a, seen i, valid i, deleted a}),
  ({deleted c}, {deleted c, valid i}), ({deleted b}, {deleted b, valid i}),
  ({deleted a}, {deleted a, valid i}), ({deleted c}, {deleted c, valid c}),
  ({deleted b}, {deleted b, valid b}), ({deleted a}, {deleted a, valid a}),
  ({ring c, valid c}, {deleted c, revoked c}),
  ({ring b, valid b}, {deleted b, revoked b}),
  ({ring a, valid a}, {deleted a, revoked a}),
  ({ring c, valid i}, {deleted c, valid i}),
  ({ring b, valid i}, {deleted b, valid i}),
  ({ring a, valid i}, {deleted a, valid i}),
  ({ring c, valid c}, {deleted c, valid c}),
  ({ring b, valid b}, {deleted b, valid b}),
  ({ring a, valid a}, {deleted a, valid a}),
  ({ring c}, {valid c, ring c, seen i, valid i}),
  ({ring b}, {valid b, ring b, seen i, valid i}),
  ({ring a}, {valid a, ring a, seen i, valid i}),
  ({ring c}, {valid c, deleted c, seen i, valid i}),
  ({ring b}, {valid b, deleted b, seen i, valid i}),
  ({ring a}, {valid a, deleted a, seen i, valid i}),
  ({ring c}, {ring c, seen i, valid i}),
  ({ring b}, {ring b, seen i, valid i}),
  ({ring a}, {ring a, seen i, valid i}),
  ({ring c}, {deleted c, seen i, valid i}),
  ({ring b}, {deleted b, seen i, valid i}),
  ({ring a}, {deleted a, seen i, valid i}),
  ({ring c}, {revoked c, deleted c, seen i, revoked i}),
  ({ring b}, {revoked b, deleted b, seen i, revoked i}),
  ({ring a}, {revoked a, deleted a, seen i, revoked i}),
  ({ring c}, {revoked c, deleted c, seen i, valid i}),
  ({ring b}, {revoked b, deleted b, seen i, valid i}),
  ({ring a}, {revoked a, deleted a, seen i, valid i}),
  ({ring c}, {deleted c}), ({ring b}, {deleted b}), ({ring a}, {deleted a}),
  ({ring c}, {ring c, valid i}), ({ring b}, {ring b, valid i}),
  ({ring a}, {ring a, valid i}), ({ring c}, {ring c, valid c}),
  ({ring b}, {ring b, valid b}), ({ring a}, {ring a, valid a}),
  ({ring' c, valid i}, {seen i, valid i, ring' c}),
  ({ring' b, valid i}, {seen i, valid i, ring' b}),
  ({ring' a, valid i}, {seen i, valid i, ring' a}),
  ({ring' c, valid i}, {ring' c, valid c, seen c, valid i}),
  ({ring' b, valid i}, {ring' b, valid b, seen b, valid i}),
  ({ring' a, valid i}, {ring' a, valid a, seen a, valid i}),
  ({ring' c}, {seen i, valid i, ring' c}),
  ({ring' b}, {seen i, valid i, ring' b}),
  ({ring' a}, {seen i, valid i, ring' a}),
  ({ring' c}, {ring' c, valid c, seen c, valid i}),
  ({ring' b}, {ring' b, valid b, seen b, valid i}),
  ({ring' a}, {ring' a, valid a, seen a, valid i}),
  ({ring' c}, {ring' c, valid c, seen c}),
  ({ring' b}, {ring' b, valid b, seen b}),
  ({ring' a}, {ring' a, valid a, seen a}), ({ring' c}, {ring' c, valid i}),
  ({ring' b}, {ring' b, valid i}), ({ring' a}, {ring' a, valid i}),
  ({pubkeys}, {valid i, pubkeys}), ({valid i}, {revoked i, seen i}),
  ({ring c, valid c}, {revoked c, seen i, valid i, deleted c}),
  ({ring b, valid b}, {revoked b, seen i, valid i, deleted b}),
  ({ring a, valid a}, {revoked a, seen i, valid i, deleted a}),
  ({valid i}, {seen i, revoked i, valid i}),
  ({deleted c}, {deleted c, revoked c}),
  ({deleted b}, {deleted b, revoked b}),
  ({deleted a}, {deleted a, revoked a}), ({ring c}, {deleted c, valid i}),
  ({ring c}, {deleted c, valid c}), ({ring b}, {deleted b, valid i}),
  ({ring b}, {deleted b, valid b}), ({ring a}, {deleted a, valid i}),
  ({ring a}, {deleted a, valid a}), ({ring c}, {deleted c, revoked c}),
  ({ring b}, {deleted b, revoked b}), ({ring a}, {deleted a, revoked a})])
ALL \<A>:spm.reachable_constraints ATTACK_UNSET_protocol.
   \<nexists>\<I>.
      spm.constraint_model \<I>
       (\<A> @ [(?l, send\<langle>attack\<langle>?n\<rangle>\<rangle>)])
ALL ATTACK_UNSET_enum_consts. ATTACK_UNSET_enum_consts = token1
ALL ATTACK_UNSET_sets.
   (EX x1. ATTACK_UNSET_sets = extract x1) |
   (EX x2. ATTACK_UNSET_sets = wrap x2) |
   (EX x3. ATTACK_UNSET_sets = decrypt x3) |
   (EX x4. ATTACK_UNSET_sets = sensitive x4)
ALL ATTACK_UNSET_fun.
   ATTACK_UNSET_fun = senc |
   ATTACK_UNSET_fun = h |
   ATTACK_UNSET_fun = ATTACK_UNSET_fun.inv |
   ATTACK_UNSET_fun = PrivFunSec | (EX x5. ATTACK_UNSET_fun = enum x5)
ALL ATTACK_UNSET_atom.
   ATTACK_UNSET_atom = EnumType | ATTACK_UNSET_atom = SecretType
ATTACK_UNSET_arity senc = Suc (Suc 0)
ATTACK_UNSET_arity h = Suc 0
ATTACK_UNSET_arity ATTACK_UNSET_fun.inv = Suc (Suc 0)
ATTACK_UNSET_arity PrivFunSec = 0
ATTACK_UNSET_arity (enum ?uu) = 0
ATTACK_UNSET_public PrivFunSec = False
ATTACK_UNSET_public senc = True
ATTACK_UNSET_public h = True
ATTACK_UNSET_public ATTACK_UNSET_fun.inv = True
ATTACK_UNSET_public (enum ?uu) = True
ATTACK_UNSET_\<Gamma> PrivFunSec = Some SecretType
ATTACK_UNSET_\<Gamma> (enum ?uu) = Some EnumType
ATTACK_UNSET_\<Gamma> senc = None
ATTACK_UNSET_\<Gamma> h = None
ATTACK_UNSET_\<Gamma> ATTACK_UNSET_fun.inv = None
ATTACK_UNSET_Ana senc = ([Var (Suc 0)], [0])
ATTACK_UNSET_Ana h = ([], [])
ATTACK_UNSET_Ana ATTACK_UNSET_fun.inv = ([], [])
ATTACK_UNSET_Ana PrivFunSec = ([], [])
ATTACK_UNSET_Ana (enum ?uu) = ([], [])
ATTACK_UNSET_transaction_iik1 ==
[transaction\<^sub>1 [] [] new [\<langle>0\<rangle>\<^sub>v] [\<langle>0, insert\<langle>\<langle>0\<rangle>\<^sub>v,\<langle>sensitive
             token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                        \<langle>0, insert\<langle>\<langle>0\<rangle>\<^sub>v,\<langle>extract
             token1\<rangle>\<^sub>s\<rangle>\<rangle>] [\<langle>0, send\<langle>\<langle>h [\<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                   \<langle>\<star>, send\<langle>occurs
             \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>]]
ATTACK_UNSET_transaction_iik2 ==
[transaction\<^sub>1 [] [] new [\<langle>0\<rangle>\<^sub>v] [\<langle>0, insert\<langle>\<langle>0\<rangle>\<^sub>v,\<langle>wrap
             token1\<rangle>\<^sub>s\<rangle>\<rangle>] [\<langle>0, send\<langle>\<langle>h [\<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                   \<langle>\<star>, send\<langle>occurs
             \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>]]
ATTACK_UNSET_transaction_wrap ==
concat
 [[transaction\<^sub>2 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
         0\<rangle>\<^sub>v\<rangle>\<rangle>,
                 \<langle>0, \<langle>\<langle>0\<rangle>\<^sub>v in \<langle>extract
   token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                 \<langle>0, \<langle>\<langle>Suc
          0\<rangle>\<^sub>v in \<langle>wrap
    token1\<rangle>\<^sub>s\<rangle>\<rangle>]  [] [\<langle>0, send\<langle>\<langle>senc [\<langle>0\<rangle>\<^sub>v,
                \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>]],
  [transaction\<^sub>2 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>0, \<langle>\<langle>Suc
          0\<rangle>\<^sub>v in \<langle>extract
    token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                 \<langle>0, \<langle>\<langle>Suc
          0\<rangle>\<^sub>v in \<langle>wrap
    token1\<rangle>\<^sub>s\<rangle>\<rangle>]  [] [\<langle>0, send\<langle>\<langle>senc [\<langle>Suc
                          0\<rangle>\<^sub>v,
                \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>]]]
ATTACK_UNSET_transaction_setwrap ==
[transaction\<^sub>2 [\<langle>\<star>, receive\<langle>occurs
                   \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                      \<langle>0, receive\<langle>\<langle>h [\<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>0, \<langle>\<langle>0\<rangle>\<^sub>v not in \<langle>decrypt
    token1\<rangle>\<^sub>s\<rangle>\<rangle>]  [\<langle>0, insert\<langle>\<langle>0\<rangle>\<^sub>v,\<langle>wrap
token1\<rangle>\<^sub>s\<rangle>\<rangle>] []]
ATTACK_UNSET_transaction_setdecrypt ==
[transaction\<^sub>2 [\<langle>\<star>, receive\<langle>occurs
                   \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                      \<langle>0, receive\<langle>\<langle>h [\<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>0, \<langle>\<langle>0\<rangle>\<^sub>v not in \<langle>wrap
    token1\<rangle>\<^sub>s\<rangle>\<rangle>]  [\<langle>0, insert\<langle>\<langle>0\<rangle>\<^sub>v,\<langle>decrypt
token1\<rangle>\<^sub>s\<rangle>\<rangle>] []]
ATTACK_UNSET_transaction_decrypt1 ==
concat
 [[transaction\<^sub>2 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>senc [\<langle>Suc
 0\<rangle>\<^sub>v,
                             \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
           0\<rangle>\<^sub>v\<rangle>\<rangle>,
                   \<langle>0, \<langle>\<langle>0\<rangle>\<^sub>v in \<langle>decrypt
     token1\<rangle>\<^sub>s\<rangle>\<rangle>]  [] [\<langle>0, send\<langle>\<langle>Suc
            0\<rangle>\<^sub>v\<rangle>\<rangle>]],
  [transaction\<^sub>2 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>senc [\<langle>Suc
 0\<rangle>\<^sub>v,
                             \<langle>Suc
 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>0, \<langle>\<langle>Suc
             0\<rangle>\<^sub>v in \<langle>decrypt
       token1\<rangle>\<^sub>s\<rangle>\<rangle>]  [] [\<langle>0, send\<langle>\<langle>Suc
              0\<rangle>\<^sub>v\<rangle>\<rangle>]]]
ATTACK_UNSET_transaction_attack1 ==
[transaction\<^sub>2 [\<langle>\<star>, receive\<langle>occurs
                   \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                      \<langle>0, receive\<langle>\<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>] [\<langle>0, \<langle>\<langle>0\<rangle>\<^sub>v in \<langle>sensitive
        token1\<rangle>\<^sub>s\<rangle>\<rangle>]  [] [\<langle>0, send\<langle>attack\<langle>0\<rangle>\<rangle>\<rangle>]]
ATTACK_UNSET_protocol ==
concat
 [ATTACK_UNSET_transaction_iik1, ATTACK_UNSET_transaction_iik2,
  ATTACK_UNSET_transaction_wrap, ATTACK_UNSET_transaction_setwrap,
  ATTACK_UNSET_transaction_setdecrypt, ATTACK_UNSET_transaction_decrypt1,
  ATTACK_UNSET_transaction_attack1]
ATTACK_UNSET_fixpoint ==
([\<langle>senc [\<langle>{extract token1,
                           sensitive token1}\<rangle>\<^sub>a,
                 \<langle>{wrap token1, extract token1,
                           sensitive
                            token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>senc [\<langle>{decrypt token1, extract token1,
                           sensitive token1}\<rangle>\<^sub>a,
                 \<langle>{wrap token1, extract token1,
                           sensitive
                            token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>senc [\<langle>{wrap token1, extract token1,
                           sensitive token1}\<rangle>\<^sub>a,
                 \<langle>{wrap token1, extract token1,
                           sensitive
                            token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>senc [\<langle>{extract token1,
                           sensitive token1}\<rangle>\<^sub>a,
                 \<langle>{wrap token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>h [\<langle>{extract token1,
                        sensitive
                         token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  occurs \<langle>{extract token1, sensitive token1}\<rangle>\<^sub>a,
  \<langle>h [\<langle>{wrap token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  occurs \<langle>{wrap token1}\<rangle>\<^sub>a],
 [{extract token1, sensitive token1}, {wrap token1},
  {wrap token1, extract token1, sensitive token1},
  {decrypt token1, extract token1, sensitive token1}],
 [({extract token1, sensitive token1},
   {wrap token1, extract token1, sensitive token1}),
  ({extract token1, sensitive token1},
   {decrypt token1, extract token1, sensitive token1})])
ATTACK_UNSET_SMP ==
[\<langle>senc [\<langle>2\<rangle>\<^sub>v,
                \<langle>3\<rangle>\<^sub>v]\<rangle>\<^sub>t,
 \<langle>h [\<langle>2\<rangle>\<^sub>v]\<rangle>\<^sub>t,
 \<langle>senc [\<langle>3\<rangle>\<^sub>v,
                \<langle>2\<rangle>\<^sub>v]\<rangle>\<^sub>t,
 Fun OccursFact [Var (Var OccursSecType, 2), \<langle>3\<rangle>\<^sub>v],
 \<langle>3\<rangle>\<^sub>v, Var (Var OccursSecType, 2),
 Var (Var SetType, 2), Var (Var AttackType, 2)]
### simplifying
### 33.765s elapsed time, 114.016s cpu time, 34.435s GC time
### preprocessing equations
### 0.981s elapsed time, 2.839s cpu time, 0.504s GC time
### translating term
### 4.923s elapsed time, 17.368s cpu time, 13.819s GC time
### compiling ML
### 0.392s elapsed time, 1.165s cpu time, 0.214s GC time
### preprocessing equations
### 1.177s elapsed time, 3.413s cpu time, 0.530s GC time
### running ML
### 6.028s elapsed time, 20.576s cpu time, 14.770s GC time
### postprocessing term
### 0.025s elapsed time, 0.073s cpu time, 0.000s GC time
### theory "Draft.PKCS_Model09"
### 41.827s elapsed time, 140.133s cpu time, 60.767s GC time
ALL LOSS_KEY_ATT_enum_consts. LOSS_KEY_ATT_enum_consts = token1
ALL LOSS_KEY_ATT_sets.
   (EX x1. LOSS_KEY_ATT_sets = extract x1) |
   (EX x2. LOSS_KEY_ATT_sets = wrap x2) |
   (EX x3. LOSS_KEY_ATT_sets = unwrap x3) |
   (EX x4. LOSS_KEY_ATT_sets = decrypt x4) |
   (EX x5. LOSS_KEY_ATT_sets = sensitive x5)
ALL LOSS_KEY_ATT_fun.
   LOSS_KEY_ATT_fun = senc |
   LOSS_KEY_ATT_fun = h |
   LOSS_KEY_ATT_fun = LOSS_KEY_ATT_fun.bind |
   LOSS_KEY_ATT_fun = LOSS_KEY_ATT_fun.inv |
   LOSS_KEY_ATT_fun = PrivFunSec | (EX x6. LOSS_KEY_ATT_fun = enum x6)
ALL LOSS_KEY_ATT_atom.
   LOSS_KEY_ATT_atom = EnumType | LOSS_KEY_ATT_atom = SecretType
LOSS_KEY_ATT_arity senc = Suc (Suc 0)
LOSS_KEY_ATT_arity h = Suc (Suc 0)
LOSS_KEY_ATT_arity LOSS_KEY_ATT_fun.bind = Suc (Suc (Suc 0))
LOSS_KEY_ATT_arity LOSS_KEY_ATT_fun.inv = Suc (Suc 0)
LOSS_KEY_ATT_arity PrivFunSec = 0
LOSS_KEY_ATT_arity (enum ?uu) = 0
LOSS_KEY_ATT_public PrivFunSec = False
LOSS_KEY_ATT_public senc = True
LOSS_KEY_ATT_public h = True
LOSS_KEY_ATT_public LOSS_KEY_ATT_fun.bind = True
LOSS_KEY_ATT_public LOSS_KEY_ATT_fun.inv = True
LOSS_KEY_ATT_public (enum ?uu) = True
LOSS_KEY_ATT_\<Gamma> PrivFunSec = Some SecretType
LOSS_KEY_ATT_\<Gamma> (enum ?uu) = Some EnumType
LOSS_KEY_ATT_\<Gamma> senc = None
LOSS_KEY_ATT_\<Gamma> h = None
LOSS_KEY_ATT_\<Gamma> LOSS_KEY_ATT_fun.bind = None
LOSS_KEY_ATT_\<Gamma> LOSS_KEY_ATT_fun.inv = None
LOSS_KEY_ATT_Ana senc = ([Var (Suc 0)], [0])
LOSS_KEY_ATT_Ana h = ([], [])
LOSS_KEY_ATT_Ana LOSS_KEY_ATT_fun.bind = ([], [])
LOSS_KEY_ATT_Ana LOSS_KEY_ATT_fun.inv = ([], [])
LOSS_KEY_ATT_Ana PrivFunSec = ([], [])
LOSS_KEY_ATT_Ana (enum ?uu) = ([], [])
LOSS_KEY_ATT_transaction_iik1 ==
[transaction\<^sub>1 [] [] new [\<langle>0\<rangle>\<^sub>v,
                                \<langle>Suc
    0\<rangle>\<^sub>v] [\<langle>0, insert\<langle>\<langle>Suc
                        0\<rangle>\<^sub>v,\<langle>sensitive
               token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                         \<langle>0, insert\<langle>\<langle>Suc
                        0\<rangle>\<^sub>v,\<langle>extract
               token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                         \<langle>0, insert\<langle>\<langle>0\<rangle>\<^sub>v,\<langle>sensitive
              token1\<rangle>\<^sub>s\<rangle>\<rangle>] [\<langle>0, send\<langle>\<langle>h [\<langle>Suc
                             0\<rangle>\<^sub>v,
                   \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                    \<langle>\<star>, send\<langle>occurs
              \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, send\<langle>occurs
              \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>]]
LOSS_KEY_ATT_transaction_iik2 ==
[transaction\<^sub>1 [] [] new [\<langle>0\<rangle>\<^sub>v,
                                \<langle>Suc
    0\<rangle>\<^sub>v] [\<langle>0, insert\<langle>\<langle>Suc
                        0\<rangle>\<^sub>v,\<langle>wrap
               token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                         \<langle>0, insert\<langle>\<langle>Suc
                        0\<rangle>\<^sub>v,\<langle>extract
               token1\<rangle>\<^sub>s\<rangle>\<rangle>] [\<langle>0, send\<langle>\<langle>h [\<langle>Suc
                              0\<rangle>\<^sub>v,
                    \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                     \<langle>\<star>, send\<langle>occurs
               \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                     \<langle>\<star>, send\<langle>occurs
               \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>]]
LOSS_KEY_ATT_transaction_iik3 ==
[transaction\<^sub>1 [] [] new [\<langle>0\<rangle>\<^sub>v,
                                \<langle>Suc
    0\<rangle>\<^sub>v] [\<langle>0, insert\<langle>\<langle>Suc
                        0\<rangle>\<^sub>v,\<langle>extract
               token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                         \<langle>0, insert\<langle>\<langle>Suc
                        0\<rangle>\<^sub>v,\<langle>decrypt
               token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                         \<langle>0, insert\<langle>\<langle>0\<rangle>\<^sub>v,\<langle>decrypt
              token1\<rangle>\<^sub>s\<rangle>\<rangle>] [\<langle>0, send\<langle>\<langle>h [\<langle>Suc
                             0\<rangle>\<^sub>v,
                   \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                    \<langle>0, send\<langle>\<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, send\<langle>occurs
              \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, send\<langle>occurs
              \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>]]
LOSS_KEY_ATT_transaction_setwrap ==
[transaction\<^sub>2 [\<langle>\<star>, receive\<langle>occurs
                   \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                      \<langle>\<star>, receive\<langle>occurs
                   \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                      \<langle>0, receive\<langle>\<langle>h [\<langle>0\<rangle>\<^sub>v,
                        \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
          0\<rangle>\<^sub>v\<rangle>\<rangle>,
                  \<langle>0, \<langle>\<langle>0\<rangle>\<^sub>v not in \<langle>sensitive
        token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                  \<langle>0, \<langle>\<langle>0\<rangle>\<^sub>v not in \<langle>decrypt
        token1\<rangle>\<^sub>s\<rangle>\<rangle>]  [\<langle>0, insert\<langle>\<langle>0\<rangle>\<^sub>v,\<langle>wrap
    token1\<rangle>\<^sub>s\<rangle>\<rangle>] []]
LOSS_KEY_ATT_transaction_setunwrap ==
[transaction\<^sub>2 [\<langle>\<star>, receive\<langle>occurs
                   \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                      \<langle>\<star>, receive\<langle>occurs
                   \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                      \<langle>0, receive\<langle>\<langle>h [\<langle>0\<rangle>\<^sub>v,
                        \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
          0\<rangle>\<^sub>v\<rangle>\<rangle>,
                  \<langle>0, \<langle>\<langle>0\<rangle>\<^sub>v not in \<langle>sensitive
        token1\<rangle>\<^sub>s\<rangle>\<rangle>]  [\<langle>0, insert\<langle>\<langle>0\<rangle>\<^sub>v,\<langle>unwrap
    token1\<rangle>\<^sub>s\<rangle>\<rangle>] []]
LOSS_KEY_ATT_transaction_unwrapWrap ==
[transaction\<^sub>1 [\<langle>\<star>, receive\<langle>occurs
                   \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                      \<langle>\<star>, receive\<langle>occurs
                   \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                      \<langle>\<star>, receive\<langle>occurs
                   \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                      \<langle>\<star>, receive\<langle>occurs
                   \<langle>Suc (Suc (Suc
 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                      \<langle>0, receive\<langle>\<langle>senc [\<langle>0\<rangle>\<^sub>v,
                           \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                      \<langle>0, receive\<langle>\<langle>LOSS_KEY_ATT_fun.bind [\<langle>Suc
                (Suc 0)\<rangle>\<^sub>v,
      \<langle>0\<rangle>\<^sub>v,
      \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                      \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                  (Suc (Suc 0))\<rangle>\<^sub>v,
                        \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
          0\<rangle>\<^sub>v\<rangle>\<rangle>,
                  \<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
          (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                  \<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
          (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                  \<langle>\<star>, \<langle>\<langle>Suc
                 0\<rangle>\<^sub>v != \<langle>Suc
           (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                  \<langle>\<star>, \<langle>\<langle>Suc
                 0\<rangle>\<^sub>v != \<langle>Suc
           (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                  \<langle>\<star>, \<langle>\<langle>Suc
                 (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                 (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                  \<langle>0, \<langle>\<langle>Suc
           (Suc 0)\<rangle>\<^sub>v in \<langle>wrap
           token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                  \<langle>0, \<langle>\<langle>Suc
           (Suc (Suc 0))\<rangle>\<^sub>v in \<langle>unwrap
                 token1\<rangle>\<^sub>s\<rangle>\<rangle>] new [\<langle>Suc
                                     (Suc
 (Suc (Suc 0)))\<rangle>\<^sub>v] [\<langle>0, insert\<langle>\<langle>Suc
                                  (Suc (Suc
   (Suc 0)))\<rangle>\<^sub>v,\<langle>wrap
  token1\<rangle>\<^sub>s\<rangle>\<rangle>] [\<langle>0, send\<langle>\<langle>h [\<langle>Suc
                 (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,
       \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
        \<langle>\<star>, send\<langle>occurs
  \<langle>Suc (Suc (Suc (Suc 0)))\<rangle>\<^sub>v\<rangle>\<rangle>]]
LOSS_KEY_ATT_transaction_unwrapSens ==
[transaction\<^sub>1 [\<langle>\<star>, receive\<langle>occurs
                   \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                      \<langle>\<star>, receive\<langle>occurs
                   \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                      \<langle>\<star>, receive\<langle>occurs
                   \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                      \<langle>\<star>, receive\<langle>occurs
                   \<langle>Suc (Suc (Suc
 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                      \<langle>0, receive\<langle>\<langle>senc [\<langle>0\<rangle>\<^sub>v,
                           \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                      \<langle>0, receive\<langle>\<langle>LOSS_KEY_ATT_fun.bind [\<langle>Suc
                (Suc 0)\<rangle>\<^sub>v,
      \<langle>0\<rangle>\<^sub>v,
      \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                      \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                  (Suc (Suc 0))\<rangle>\<^sub>v,
                        \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
          0\<rangle>\<^sub>v\<rangle>\<rangle>,
                  \<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
          (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                  \<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
          (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                  \<langle>\<star>, \<langle>\<langle>Suc
                 0\<rangle>\<^sub>v != \<langle>Suc
           (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                  \<langle>\<star>, \<langle>\<langle>Suc
                 0\<rangle>\<^sub>v != \<langle>Suc
           (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                  \<langle>\<star>, \<langle>\<langle>Suc
                 (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                 (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                  \<langle>0, \<langle>\<langle>Suc
           (Suc 0)\<rangle>\<^sub>v in \<langle>sensitive
           token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                  \<langle>0, \<langle>\<langle>Suc
           (Suc (Suc 0))\<rangle>\<^sub>v in \<langle>unwrap
                 token1\<rangle>\<^sub>s\<rangle>\<rangle>] new [\<langle>Suc
                                     (Suc
 (Suc (Suc 0)))\<rangle>\<^sub>v] [\<langle>0, insert\<langle>\<langle>Suc
                                  (Suc (Suc
   (Suc 0)))\<rangle>\<^sub>v,\<langle>sensitive
  token1\<rangle>\<^sub>s\<rangle>\<rangle>] [\<langle>0, send\<langle>\<langle>h [\<langle>Suc
                 (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,
       \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
        \<langle>\<star>, send\<langle>occurs
  \<langle>Suc (Suc (Suc (Suc 0)))\<rangle>\<^sub>v\<rangle>\<rangle>]]
LOSS_KEY_ATT_transaction_decrypt1Attr ==
[transaction\<^sub>1 [\<langle>\<star>, receive\<langle>occurs
                   \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                      \<langle>\<star>, receive\<langle>occurs
                   \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                      \<langle>\<star>, receive\<langle>occurs
                   \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                      \<langle>\<star>, receive\<langle>occurs
                   \<langle>Suc (Suc (Suc
 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                      \<langle>0, receive\<langle>\<langle>senc [\<langle>0\<rangle>\<^sub>v,
                           \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                      \<langle>0, receive\<langle>\<langle>LOSS_KEY_ATT_fun.bind [\<langle>Suc
                (Suc 0)\<rangle>\<^sub>v,
      \<langle>0\<rangle>\<^sub>v,
      \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                      \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                  (Suc (Suc 0))\<rangle>\<^sub>v,
                        \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
          0\<rangle>\<^sub>v\<rangle>\<rangle>,
                  \<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
          (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                  \<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
          (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                  \<langle>\<star>, \<langle>\<langle>Suc
                 0\<rangle>\<^sub>v != \<langle>Suc
           (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                  \<langle>\<star>, \<langle>\<langle>Suc
                 0\<rangle>\<^sub>v != \<langle>Suc
           (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                  \<langle>\<star>, \<langle>\<langle>Suc
                 (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                 (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                  \<langle>0, \<langle>\<langle>Suc
           (Suc 0)\<rangle>\<^sub>v in \<langle>decrypt
           token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                  \<langle>0, \<langle>\<langle>Suc
           (Suc (Suc 0))\<rangle>\<^sub>v in \<langle>unwrap
                 token1\<rangle>\<^sub>s\<rangle>\<rangle>] new [\<langle>Suc
                                     (Suc
 (Suc (Suc 0)))\<rangle>\<^sub>v] [\<langle>0, insert\<langle>\<langle>Suc
                                  (Suc (Suc
   (Suc 0)))\<rangle>\<^sub>v,\<langle>decrypt
  token1\<rangle>\<^sub>s\<rangle>\<rangle>] [\<langle>0, send\<langle>\<langle>h [\<langle>Suc
                 (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,
       \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
        \<langle>\<star>, send\<langle>occurs
  \<langle>Suc (Suc (Suc (Suc 0)))\<rangle>\<^sub>v\<rangle>\<rangle>]]
LOSS_KEY_ATT_transaction_decrypt2Attr ==
[transaction\<^sub>1 [\<langle>\<star>, receive\<langle>occurs
                   \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                      \<langle>\<star>, receive\<langle>occurs
                   \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                      \<langle>\<star>, receive\<langle>occurs
                   \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                      \<langle>\<star>, receive\<langle>occurs
                   \<langle>Suc (Suc (Suc
 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                      \<langle>0, receive\<langle>\<langle>senc [\<langle>0\<rangle>\<^sub>v,
                           \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                      \<langle>0, receive\<langle>\<langle>LOSS_KEY_ATT_fun.bind [\<langle>Suc
                (Suc 0)\<rangle>\<^sub>v,
      \<langle>0\<rangle>\<^sub>v,
      \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                      \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                  (Suc (Suc 0))\<rangle>\<^sub>v,
                        \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
          0\<rangle>\<^sub>v\<rangle>\<rangle>,
                  \<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
          (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                  \<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
          (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                  \<langle>\<star>, \<langle>\<langle>Suc
                 0\<rangle>\<^sub>v != \<langle>Suc
           (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                  \<langle>\<star>, \<langle>\<langle>Suc
                 0\<rangle>\<^sub>v != \<langle>Suc
           (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                  \<langle>\<star>, \<langle>\<langle>Suc
                 (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                 (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                  \<langle>0, \<langle>\<langle>Suc
           (Suc 0)\<rangle>\<^sub>v not in \<langle>wrap
               token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                  \<langle>0, \<langle>\<langle>Suc
           (Suc 0)\<rangle>\<^sub>v not in \<langle>sensitive
               token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                  \<langle>0, \<langle>\<langle>Suc
           (Suc 0)\<rangle>\<^sub>v not in \<langle>decrypt
               token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                  \<langle>0, \<langle>\<langle>Suc
           (Suc (Suc 0))\<rangle>\<^sub>v in \<langle>unwrap
                 token1\<rangle>\<^sub>s\<rangle>\<rangle>] new [\<langle>Suc
                                     (Suc
 (Suc (Suc 0)))\<rangle>\<^sub>v] [] [\<langle>0, send\<langle>\<langle>h [\<langle>Suc
         (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,
                                     \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
\<langle>\<star>, send\<langle>occurs
                                \<langle>Suc
    (Suc (Suc (Suc 0)))\<rangle>\<^sub>v\<rangle>\<rangle>]]
LOSS_KEY_ATT_transaction_wrap ==
[transaction\<^sub>2 [\<langle>\<star>, receive\<langle>occurs
                   \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                      \<langle>\<star>, receive\<langle>occurs
                   \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                      \<langle>\<star>, receive\<langle>occurs
                   \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                      \<langle>\<star>, receive\<langle>occurs
                   \<langle>Suc (Suc (Suc
 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                      \<langle>0, receive\<langle>\<langle>h [\<langle>0\<rangle>\<^sub>v,
                        \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                      \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                  (Suc 0)\<rangle>\<^sub>v,
                        \<langle>Suc (Suc
 (Suc 0))\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
                   0\<rangle>\<^sub>v\<rangle>\<rangle>,
                           \<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                           \<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
                   (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                           \<langle>\<star>, \<langle>\<langle>Suc
                          0\<rangle>\<^sub>v != \<langle>Suc
                    (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                           \<langle>\<star>, \<langle>\<langle>Suc
                          0\<rangle>\<^sub>v != \<langle>Suc
                    (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                           \<langle>\<star>, \<langle>\<langle>Suc
                          (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                          (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                           \<langle>0, \<langle>\<langle>0\<rangle>\<^sub>v in \<langle>extract
             token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                           \<langle>0, \<langle>\<langle>Suc
                    (Suc 0)\<rangle>\<^sub>v in \<langle>wrap
                    token1\<rangle>\<^sub>s\<rangle>\<rangle>]  [] [\<langle>0, send\<langle>\<langle>senc [\<langle>Suc
    0\<rangle>\<^sub>v,
                                \<langle>Suc
    (Suc (Suc 0))\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                              \<langle>0, send\<langle>\<langle>LOSS_KEY_ATT_fun.bind [\<langle>0\<rangle>\<^sub>v,
           \<langle>Suc 0\<rangle>\<^sub>v,
           \<langle>Suc (Suc (Suc 0))\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>]]
LOSS_KEY_ATT_transaction_bind1 ==
[transaction\<^sub>2 [\<langle>\<star>, receive\<langle>occurs
                   \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                      \<langle>\<star>, receive\<langle>occurs
                   \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                      \<langle>\<star>, receive\<langle>occurs
                   \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                      \<langle>\<star>, receive\<langle>occurs
                   \<langle>Suc (Suc (Suc
 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                      \<langle>0, receive\<langle>\<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                      \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                  0\<rangle>\<^sub>v,
                        \<langle>Suc (Suc
 0)\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
             0\<rangle>\<^sub>v\<rangle>\<rangle>,
                     \<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
             (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                     \<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                     \<langle>\<star>, \<langle>\<langle>Suc
                    0\<rangle>\<^sub>v != \<langle>Suc
              (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                     \<langle>\<star>, \<langle>\<langle>Suc
                    0\<rangle>\<^sub>v != \<langle>Suc
              (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                     \<langle>\<star>, \<langle>\<langle>Suc
                    (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                    (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>]  [] [\<langle>0, send\<langle>\<langle>LOSS_KEY_ATT_fun.bind [\<langle>Suc
                            0\<rangle>\<^sub>v,
                  \<langle>0\<rangle>\<^sub>v,
                  \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>]]
LOSS_KEY_ATT_transaction_bind2 ==
[transaction\<^sub>2 [\<langle>\<star>, receive\<langle>occurs
                   \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                      \<langle>\<star>, receive\<langle>occurs
                   \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                      \<langle>\<star>, receive\<langle>occurs
                   \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                      \<langle>\<star>, receive\<langle>occurs
                   \<langle>Suc (Suc (Suc
 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                      \<langle>0, receive\<langle>\<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                      \<langle>0, receive\<langle>\<langle>Suc
                      (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                      \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                  0\<rangle>\<^sub>v,
                        \<langle>Suc (Suc
 0)\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
             0\<rangle>\<^sub>v\<rangle>\<rangle>,
                     \<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
             (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                     \<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                     \<langle>\<star>, \<langle>\<langle>Suc
                    0\<rangle>\<^sub>v != \<langle>Suc
              (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                     \<langle>\<star>, \<langle>\<langle>Suc
                    0\<rangle>\<^sub>v != \<langle>Suc
              (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                     \<langle>\<star>, \<langle>\<langle>Suc
                    (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                    (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>]  [] [\<langle>0, send\<langle>\<langle>LOSS_KEY_ATT_fun.bind [\<langle>Suc
                            0\<rangle>\<^sub>v,
                  \<langle>Suc (Suc (Suc 0))\<rangle>\<^sub>v,
                  \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                                     \<langle>0, send\<langle>\<langle>LOSS_KEY_ATT_fun.bind [\<langle>Suc
                            0\<rangle>\<^sub>v,
                  \<langle>0\<rangle>\<^sub>v,
                  \<langle>Suc (Suc (Suc
0))\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>]]
LOSS_KEY_ATT_transaction_setdecrypt ==
[transaction\<^sub>2 [\<langle>\<star>, receive\<langle>occurs
                   \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                      \<langle>\<star>, receive\<langle>occurs
                   \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                      \<langle>0, receive\<langle>\<langle>h [\<langle>0\<rangle>\<^sub>v,
                        \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
          0\<rangle>\<^sub>v\<rangle>\<rangle>,
                  \<langle>0, \<langle>\<langle>0\<rangle>\<^sub>v not in \<langle>wrap
        token1\<rangle>\<^sub>s\<rangle>\<rangle>]  [\<langle>0, insert\<langle>\<langle>0\<rangle>\<^sub>v,\<langle>decrypt
    token1\<rangle>\<^sub>s\<rangle>\<rangle>] []]
LOSS_KEY_ATT_transaction_decrypt1 ==
[transaction\<^sub>2 [\<langle>\<star>, receive\<langle>occurs
                   \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                      \<langle>\<star>, receive\<langle>occurs
                   \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                      \<langle>\<star>, receive\<langle>occurs
                   \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                      \<langle>0, receive\<langle>\<langle>h [\<langle>0\<rangle>\<^sub>v,
                        \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                      \<langle>0, receive\<langle>\<langle>senc [\<langle>Suc
                                     (Suc 0)\<rangle>\<^sub>v,
                           \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
             0\<rangle>\<^sub>v\<rangle>\<rangle>,
                     \<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
             (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                     \<langle>\<star>, \<langle>\<langle>Suc
                    0\<rangle>\<^sub>v != \<langle>Suc
              (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                     \<langle>0, \<langle>\<langle>0\<rangle>\<^sub>v in \<langle>decrypt
       token1\<rangle>\<^sub>s\<rangle>\<rangle>]  [] [\<langle>0, send\<langle>\<langle>Suc
              (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>]]
LOSS_KEY_ATT_transaction_attack1 ==
[transaction\<^sub>2 [\<langle>\<star>, receive\<langle>occurs
                   \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                      \<langle>0, receive\<langle>\<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>] [\<langle>0, \<langle>\<langle>0\<rangle>\<^sub>v in \<langle>sensitive
        token1\<rangle>\<^sub>s\<rangle>\<rangle>]  [] [\<langle>0, send\<langle>attack\<langle>0\<rangle>\<rangle>\<rangle>]]
LOSS_KEY_ATT_protocol ==
concat
 [LOSS_KEY_ATT_transaction_iik1, LOSS_KEY_ATT_transaction_iik2,
  LOSS_KEY_ATT_transaction_iik3, LOSS_KEY_ATT_transaction_setwrap,
  LOSS_KEY_ATT_transaction_setunwrap, LOSS_KEY_ATT_transaction_unwrapWrap,
  LOSS_KEY_ATT_transaction_unwrapSens,
  LOSS_KEY_ATT_transaction_decrypt1Attr,
  LOSS_KEY_ATT_transaction_decrypt2Attr, LOSS_KEY_ATT_transaction_wrap,
  LOSS_KEY_ATT_transaction_bind1, LOSS_KEY_ATT_transaction_bind2,
  LOSS_KEY_ATT_transaction_setdecrypt, LOSS_KEY_ATT_transaction_decrypt1,
  LOSS_KEY_ATT_transaction_attack1]
### preprocessing equations
### 0.253s elapsed time, 1.018s cpu time, 0.000s GC time
LOSS_KEY_ATT_fixpoint ==
([\<langle>LOSS_KEY_ATT_fun.bind [\<langle>{extract token1,
      wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{extract token1,
      wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a,
                                  \<langle>{}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{extract token1,
      wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{extract token1,
      wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt
       token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{extract token1,
      wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt
       token1}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{extract token1,
      wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt
       token1}\<rangle>\<^sub>a,
                                  \<langle>{}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{extract token1,
      wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{extract token1,
      wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{extract token1,
      wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{extract token1,
      wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a,
                                  \<langle>{}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{extract token1,
      wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt
       token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{extract token1,
      wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt
       token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{extract token1,
      wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{extract token1,
      wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a,
                                  \<langle>{unwrap token1,
      decrypt token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{extract token1,
      wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{unwrap token1,
      decrypt token1}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{extract token1,
      wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{unwrap token1,
      decrypt token1}\<rangle>\<^sub>a,
                                  \<langle>{}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{extract token1,
      wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a,
                                  \<langle>{unwrap token1,
      decrypt token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{extract token1,
      wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{unwrap token1,
      decrypt token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{unwrap token1, extract token1,
      wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{unwrap token1, extract token1,
      wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a,
                                  \<langle>{}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{unwrap token1, extract token1,
      wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{unwrap token1, extract token1,
      wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt
       token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{unwrap token1, extract token1,
      wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt
       token1}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{unwrap token1, extract token1,
      wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt
       token1}\<rangle>\<^sub>a,
                                  \<langle>{}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{unwrap token1, extract token1,
      wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{unwrap token1, extract token1,
      wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{unwrap token1, extract token1,
      wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{unwrap token1, extract token1,
      wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a,
                                  \<langle>{}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{unwrap token1, extract token1,
      wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt
       token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{unwrap token1, extract token1,
      wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt
       token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{unwrap token1, extract token1,
      wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{unwrap token1, extract token1,
      wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a,
                                  \<langle>{unwrap token1,
      decrypt token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{unwrap token1, extract token1,
      wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{unwrap token1,
      decrypt token1}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{unwrap token1, extract token1,
      wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{unwrap token1,
      decrypt token1}\<rangle>\<^sub>a,
                                  \<langle>{}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{unwrap token1, extract token1,
      wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a,
                                  \<langle>{unwrap token1,
      decrypt token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{unwrap token1, extract token1,
      wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{unwrap token1,
      decrypt token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{extract token1,
      sensitive token1}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{extract token1,
      sensitive token1}\<rangle>\<^sub>a,
                                  \<langle>{}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{extract token1,
      sensitive token1}\<rangle>\<^sub>a,
                                  \<langle>{}\<rangle>\<^sub>a,
                                  \<langle>{}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{extract token1,
      sensitive token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt
       token1}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{extract token1,
      sensitive token1}\<rangle>\<^sub>a,
                                  \<langle>{}\<rangle>\<^sub>a,
                                  \<langle>{decrypt
       token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{extract token1,
      sensitive token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt
       token1}\<rangle>\<^sub>a,
                                  \<langle>{}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{extract token1,
      sensitive token1}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{extract token1,
      sensitive token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{extract token1,
      sensitive token1}\<rangle>\<^sub>a,
                                  \<langle>{}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{extract token1,
      sensitive token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt
       token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{extract token1,
      sensitive token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{extract token1,
      sensitive token1}\<rangle>\<^sub>a,
                                  \<langle>{unwrap token1,
      decrypt token1}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{extract token1,
      sensitive token1}\<rangle>\<^sub>a,
                                  \<langle>{}\<rangle>\<^sub>a,
                                  \<langle>{unwrap token1,
      decrypt token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{extract token1,
      sensitive token1}\<rangle>\<^sub>a,
                                  \<langle>{unwrap token1,
      decrypt token1}\<rangle>\<^sub>a,
                                  \<langle>{}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{extract token1,
      sensitive token1}\<rangle>\<^sub>a,
                                  \<langle>{unwrap token1,
      decrypt token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{decrypt token1, extract token1,
      sensitive token1}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{decrypt token1, extract token1,
      sensitive token1}\<rangle>\<^sub>a,
                                  \<langle>{}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{decrypt token1, extract token1,
      sensitive token1}\<rangle>\<^sub>a,
                                  \<langle>{}\<rangle>\<^sub>a,
                                  \<langle>{}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{decrypt token1, extract token1,
      sensitive token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt
       token1}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{decrypt token1, extract token1,
      sensitive token1}\<rangle>\<^sub>a,
                                  \<langle>{}\<rangle>\<^sub>a,
                                  \<langle>{decrypt
       token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{decrypt token1, extract token1,
      sensitive token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt
       token1}\<rangle>\<^sub>a,
                                  \<langle>{}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{decrypt token1, extract token1,
      sensitive token1}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{decrypt token1, extract token1,
      sensitive token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{decrypt token1, extract token1,
      sensitive token1}\<rangle>\<^sub>a,
                                  \<langle>{}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{decrypt token1, extract token1,
      sensitive token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt
       token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{decrypt token1, extract token1,
      sensitive token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{decrypt token1, extract token1,
      sensitive token1}\<rangle>\<^sub>a,
                                  \<langle>{unwrap token1,
      decrypt token1}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{decrypt token1, extract token1,
      sensitive token1}\<rangle>\<^sub>a,
                                  \<langle>{}\<rangle>\<^sub>a,
                                  \<langle>{unwrap token1,
      decrypt token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{decrypt token1, extract token1,
      sensitive token1}\<rangle>\<^sub>a,
                                  \<langle>{unwrap token1,
      decrypt token1}\<rangle>\<^sub>a,
                                  \<langle>{}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{decrypt token1, extract token1,
      sensitive token1}\<rangle>\<^sub>a,
                                  \<langle>{unwrap token1,
      decrypt token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a,
                                  \<langle>{}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{}\<rangle>\<^sub>a,
                                  \<langle>{}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt
       token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt
       token1}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{}\<rangle>\<^sub>a,
                                  \<langle>{decrypt
       token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt
       token1}\<rangle>\<^sub>a,
                                  \<langle>{}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a,
                                  \<langle>{}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt
       token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt
       token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a,
                                  \<langle>{unwrap token1,
      decrypt token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{unwrap token1,
      decrypt token1}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{}\<rangle>\<^sub>a,
                                  \<langle>{unwrap token1,
      decrypt token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{unwrap token1,
      decrypt token1}\<rangle>\<^sub>a,
                                  \<langle>{}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a,
                                  \<langle>{unwrap token1,
      decrypt token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{unwrap token1,
      decrypt token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{decrypt token1,
      extract token1}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{decrypt token1,
      extract token1}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a,
                                  \<langle>{}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{decrypt token1,
      extract token1}\<rangle>\<^sub>a,
                                  \<langle>{}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{decrypt token1,
      extract token1}\<rangle>\<^sub>a,
                                  \<langle>{}\<rangle>\<^sub>a,
                                  \<langle>{}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{decrypt token1,
      extract token1}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt
       token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{decrypt token1,
      extract token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt
       token1}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{decrypt token1,
      extract token1}\<rangle>\<^sub>a,
                                  \<langle>{}\<rangle>\<^sub>a,
                                  \<langle>{decrypt
       token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{decrypt token1,
      extract token1}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{decrypt token1,
      extract token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{decrypt token1,
      extract token1}\<rangle>\<^sub>a,
                                  \<langle>{}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{decrypt token1,
      extract token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a,
                                  \<langle>{}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{decrypt token1,
      extract token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt
       token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{decrypt token1,
      extract token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt
       token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{decrypt token1,
      extract token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{decrypt token1,
      extract token1}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a,
                                  \<langle>{unwrap token1,
      decrypt token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{decrypt token1,
      extract token1}\<rangle>\<^sub>a,
                                  \<langle>{unwrap token1,
      decrypt token1}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{decrypt token1,
      extract token1}\<rangle>\<^sub>a,
                                  \<langle>{}\<rangle>\<^sub>a,
                                  \<langle>{unwrap token1,
      decrypt token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{decrypt token1,
      extract token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a,
                                  \<langle>{unwrap token1,
      decrypt token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{decrypt token1,
      extract token1}\<rangle>\<^sub>a,
                                  \<langle>{unwrap token1,
      decrypt token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{unwrap token1,
      wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{unwrap token1,
      wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a,
                                  \<langle>{}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{unwrap token1,
      wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{unwrap token1,
      wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{}\<rangle>\<^sub>a,
                                  \<langle>{}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{unwrap token1,
      wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt
       token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{unwrap token1,
      wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt
       token1}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{unwrap token1,
      wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{}\<rangle>\<^sub>a,
                                  \<langle>{decrypt
       token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{unwrap token1,
      wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt
       token1}\<rangle>\<^sub>a,
                                  \<langle>{}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{unwrap token1,
      wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{unwrap token1,
      wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{unwrap token1,
      wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{unwrap token1,
      wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a,
                                  \<langle>{}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{unwrap token1,
      wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt
       token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{unwrap token1,
      wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt
       token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{unwrap token1,
      wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{unwrap token1,
      wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a,
                                  \<langle>{unwrap token1,
      decrypt token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{unwrap token1,
      wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{unwrap token1,
      decrypt token1}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{unwrap token1,
      wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{}\<rangle>\<^sub>a,
                                  \<langle>{unwrap token1,
      decrypt token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{unwrap token1,
      wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{unwrap token1,
      decrypt token1}\<rangle>\<^sub>a,
                                  \<langle>{}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{unwrap token1,
      wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a,
                                  \<langle>{unwrap token1,
      decrypt token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{unwrap token1,
      wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{unwrap token1,
      decrypt token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{unwrap token1, decrypt token1,
      extract token1}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{unwrap token1, decrypt token1,
      extract token1}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a,
                                  \<langle>{}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{unwrap token1, decrypt token1,
      extract token1}\<rangle>\<^sub>a,
                                  \<langle>{}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{unwrap token1, decrypt token1,
      extract token1}\<rangle>\<^sub>a,
                                  \<langle>{}\<rangle>\<^sub>a,
                                  \<langle>{}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{unwrap token1, decrypt token1,
      extract token1}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt
       token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{unwrap token1, decrypt token1,
      extract token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt
       token1}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{unwrap token1, decrypt token1,
      extract token1}\<rangle>\<^sub>a,
                                  \<langle>{}\<rangle>\<^sub>a,
                                  \<langle>{decrypt
       token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{unwrap token1, decrypt token1,
      extract token1}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{unwrap token1, decrypt token1,
      extract token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{unwrap token1, decrypt token1,
      extract token1}\<rangle>\<^sub>a,
                                  \<langle>{}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{unwrap token1, decrypt token1,
      extract token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a,
                                  \<langle>{}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{unwrap token1, decrypt token1,
      extract token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt
       token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{unwrap token1, decrypt token1,
      extract token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt
       token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{unwrap token1, decrypt token1,
      extract token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{unwrap token1, decrypt token1,
      extract token1}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a,
                                  \<langle>{unwrap token1,
      decrypt token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{unwrap token1, decrypt token1,
      extract token1}\<rangle>\<^sub>a,
                                  \<langle>{unwrap token1,
      decrypt token1}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{unwrap token1, decrypt token1,
      extract token1}\<rangle>\<^sub>a,
                                  \<langle>{}\<rangle>\<^sub>a,
                                  \<langle>{unwrap token1,
      decrypt token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{unwrap token1, decrypt token1,
      extract token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a,
                                  \<langle>{unwrap token1,
      decrypt token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{unwrap token1, decrypt token1,
      extract token1}\<rangle>\<^sub>a,
                                  \<langle>{unwrap token1,
      decrypt token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt token1,
      sensitive token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  attack\<langle>0\<rangle>,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{extract token1,
      sensitive token1}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt
       token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{extract token1,
      sensitive token1}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a,
                                  \<langle>{unwrap token1,
      decrypt token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{extract token1,
      wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{}\<rangle>\<^sub>a,
                                  \<langle>{decrypt
       token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{extract token1,
      wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{}\<rangle>\<^sub>a,
                                  \<langle>{unwrap token1,
      decrypt token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>senc [\<langle>{}\<rangle>\<^sub>a,
                 \<langle>{decrypt
                            token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{unwrap token1, extract token1,
      wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{}\<rangle>\<^sub>a,
                                  \<langle>{decrypt
       token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>senc [\<langle>{}\<rangle>\<^sub>a,
                 \<langle>{unwrap token1,
                           decrypt
                            token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{unwrap token1, extract token1,
      wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{}\<rangle>\<^sub>a,
                                  \<langle>{unwrap token1,
      decrypt token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>senc [\<langle>{sensitive token1}\<rangle>\<^sub>a,
                 \<langle>{decrypt
                            token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{decrypt token1, extract token1,
      sensitive token1}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt
       token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>senc [\<langle>{sensitive token1}\<rangle>\<^sub>a,
                 \<langle>{unwrap token1,
                           decrypt
                            token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{decrypt token1, extract token1,
      sensitive token1}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a,
                                  \<langle>{unwrap token1,
      decrypt token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt
       token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt
       token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt
       token1}\<rangle>\<^sub>a,
                                  \<langle>{unwrap token1,
      decrypt token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{unwrap token1,
      decrypt token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt
       token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{unwrap token1,
      decrypt token1}\<rangle>\<^sub>a,
                                  \<langle>{unwrap token1,
      decrypt token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{sensitive
       token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt
       token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt
       token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{sensitive
       token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt
       token1}\<rangle>\<^sub>a,
                                  \<langle>{unwrap token1,
      decrypt token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{sensitive
       token1}\<rangle>\<^sub>a,
                                  \<langle>{unwrap token1,
      decrypt token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt
       token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{sensitive
       token1}\<rangle>\<^sub>a,
                                  \<langle>{unwrap token1,
      decrypt token1}\<rangle>\<^sub>a,
                                  \<langle>{unwrap token1,
      decrypt token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>h [\<langle>{wrap token1}\<rangle>\<^sub>a,
              \<langle>{}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>h [\<langle>{wrap token1}\<rangle>\<^sub>a,
              \<langle>{decrypt token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>h [\<langle>{wrap token1}\<rangle>\<^sub>a,
              \<langle>{unwrap token1,
                        decrypt token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  occurs \<langle>{wrap token1}\<rangle>\<^sub>a,
  \<langle>h [\<langle>{sensitive token1}\<rangle>\<^sub>a,
              \<langle>{sensitive
                         token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>h [\<langle>{sensitive token1}\<rangle>\<^sub>a,
              \<langle>{decrypt token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>h [\<langle>{sensitive token1}\<rangle>\<^sub>a,
              \<langle>{unwrap token1,
                        decrypt token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>h [\<langle>{decrypt token1}\<rangle>\<^sub>a,
              \<langle>{sensitive
                         token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>senc [\<langle>{sensitive token1}\<rangle>\<^sub>a,
                 \<langle>{}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{extract token1,
      sensitive token1}\<rangle>\<^sub>a,
                                  \<langle>{sensitive
       token1}\<rangle>\<^sub>a,
                                  \<langle>{}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>senc [\<langle>{}\<rangle>\<^sub>a,
                 \<langle>{}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{extract token1,
      wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{}\<rangle>\<^sub>a,
                                  \<langle>{}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>senc [\<langle>{decrypt token1}\<rangle>\<^sub>a,
                 \<langle>{}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{decrypt token1,
      extract token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt
       token1}\<rangle>\<^sub>a,
                                  \<langle>{}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{extract token1,
      sensitive token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt
       token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt
       token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{extract token1,
      wrap token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt
       token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt
       token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>LOSS_KEY_ATT_fun.bind [\<langle>{decrypt token1,
      extract token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt
       token1}\<rangle>\<^sub>a,
                                  \<langle>{decrypt
       token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>h [\<langle>{extract token1, sensitive token1}\<rangle>\<^sub>a,
              \<langle>{sensitive
                         token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  occurs \<langle>{sensitive token1}\<rangle>\<^sub>a,
  occurs \<langle>{extract token1, sensitive token1}\<rangle>\<^sub>a,
  \<langle>h [\<langle>{extract token1, wrap token1}\<rangle>\<^sub>a,
              \<langle>{}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  occurs \<langle>{}\<rangle>\<^sub>a,
  occurs \<langle>{extract token1, wrap token1}\<rangle>\<^sub>a,
  \<langle>h [\<langle>{decrypt token1, extract token1}\<rangle>\<^sub>a,
              \<langle>{decrypt token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>{decrypt token1}\<rangle>\<^sub>a,
  occurs \<langle>{decrypt token1}\<rangle>\<^sub>a,
  occurs \<langle>{decrypt token1, extract token1}\<rangle>\<^sub>a,
  \<langle>{}\<rangle>\<^sub>a,
  \<langle>{sensitive token1}\<rangle>\<^sub>a],
 [{sensitive token1}, {extract token1, sensitive token1}, {},
  {extract token1, wrap token1}, {decrypt token1, extract token1},
  {wrap token1}, {unwrap token1}, {decrypt token1},
  {unwrap token1, wrap token1}, {decrypt token1, sensitive token1},
  {unwrap token1, extract token1, wrap token1},
  {unwrap token1, decrypt token1},
  {unwrap token1, decrypt token1, extract token1},
  {decrypt token1, extract token1, sensitive token1}],
 [({}, {unwrap token1, wrap token1}), ({}, {unwrap token1, decrypt token1}),
  ({}, {wrap token1}), ({}, {unwrap token1}), ({}, {decrypt token1}),
  ({wrap token1}, {unwrap token1, wrap token1}),
  ({sensitive token1}, {decrypt token1, sensitive token1}),
  ({extract token1, wrap token1},
   {unwrap token1, extract token1, wrap token1}),
  ({decrypt token1}, {unwrap token1, decrypt token1}),
  ({decrypt token1, extract token1},
   {unwrap token1, decrypt token1, extract token1}),
  ({extract token1, sensitive token1},
   {decrypt token1, extract token1, sensitive token1})])
### translating term
### 1.381s elapsed time, 5.349s cpu time, 0.733s GC time
### translating term
### 7.068s elapsed time, 25.338s cpu time, 15.242s GC time
### compiling ML
### 0.594s elapsed time, 1.808s cpu time, 0.266s GC time
"False"
  :: "bool"
ALL keyserver2_enum_consts.
   keyserver2_enum_consts = a |
   keyserver2_enum_consts = b |
   keyserver2_enum_consts = c | keyserver2_enum_consts = i
ALL keyserver2_sets.
   (EX x1. keyserver2_sets = ring' x1) |
   (EX x2. keyserver2_sets = seen x2) |
   keyserver2_sets = pubkeys | (EX x4. keyserver2_sets = valid x4)
ALL keyserver2_fun.
   keyserver2_fun = h |
   keyserver2_fun = sign |
   keyserver2_fun = crypt |
   keyserver2_fun = scrypt |
   keyserver2_fun = pair |
   keyserver2_fun = update |
   keyserver2_fun = keyserver2_fun.inv |
   keyserver2_fun = pw |
   keyserver2_fun = PrivFunSec | (EX x10. keyserver2_fun = enum x10)
ALL keyserver2_atom.
   keyserver2_atom = EnumType | keyserver2_atom = SecretType
ALL \<A>:spm.reachable_constraints keyserver2_protocol.
   \<nexists>\<I>.
      spm.constraint_model \<I>
       (\<A> @ [(?l, send\<langle>attack\<langle>?n\<rangle>\<rangle>)])
### theory "Draft.Keyserver2"
### 157.508s elapsed time, 517.469s cpu time, 317.143s GC time
keyserver2_arity h = Suc 0
keyserver2_arity sign = Suc (Suc 0)
keyserver2_arity crypt = Suc (Suc 0)
keyserver2_arity scrypt = Suc (Suc 0)
keyserver2_arity pair = Suc (Suc 0)
keyserver2_arity update = Suc (Suc (Suc 0))
keyserver2_arity keyserver2_fun.inv = Suc (Suc 0)
keyserver2_arity pw = Suc (Suc 0)
keyserver2_arity PrivFunSec = 0
keyserver2_arity (enum ?uu) = 0
keyserver2_\<Gamma> PrivFunSec = Some SecretType
keyserver2_\<Gamma> (enum ?uu) = Some EnumType
keyserver2_\<Gamma> h = None
keyserver2_\<Gamma> sign = None
keyserver2_\<Gamma> crypt = None
keyserver2_\<Gamma> scrypt = None
keyserver2_\<Gamma> pair = None
keyserver2_\<Gamma> update = None
keyserver2_\<Gamma> keyserver2_fun.inv = None
keyserver2_\<Gamma> pw = None
keyserver2_public PrivFunSec = False
keyserver2_public h = True
keyserver2_public sign = True
keyserver2_public crypt = True
keyserver2_public scrypt = True
keyserver2_public pair = True
keyserver2_public update = True
keyserver2_public keyserver2_fun.inv = True
keyserver2_public pw = True
keyserver2_public (enum ?uu) = True
keyserver2_Ana sign = ([], [Suc 0])
keyserver2_Ana crypt =
([Fun (Fu keyserver2_fun.inv) [Fun (Fu PrivFunSec) [], Var 0]], [Suc 0])
keyserver2_Ana scrypt = ([Var 0], [Suc 0])
keyserver2_Ana pair = ([], [0, Suc 0])
keyserver2_Ana update = ([], [0, Suc 0, Suc (Suc 0)])
keyserver2_Ana h = ([], [])
keyserver2_Ana keyserver2_fun.inv = ([], [])
keyserver2_Ana pw = ([], [])
keyserver2_Ana PrivFunSec = ([], [])
keyserver2_Ana (enum ?uu) = ([], [])
keyserver2_transaction_passwordGenD ==
map (%A. transaction\<^sub>2 [] []  [] [\<langle>0, send\<langle>\<langle>pw [\<langle>PrivFunSec\<rangle>\<^sub>c,
  \<langle>enum A\<rangle>\<^sub>c]\<rangle>\<^sub>t\<rangle>\<rangle>])
 [i]
keyserver2_transaction_pubkeysGen ==
[transaction\<^sub>1 [] [] new [\<langle>0\<rangle>\<^sub>v] [\<langle>0, insert\<langle>\<langle>0\<rangle>\<^sub>v,\<langle>pubkeys\<rangle>\<^sub>s\<rangle>\<rangle>] [\<langle>0, send\<langle>\<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                   \<langle>\<star>, send\<langle>occurs
             \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>]]
keyserver2_transaction_authAttack2 ==
map (%A. transaction\<^sub>2 [\<langle>\<star>, receive\<langle>occurs
                           \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                              \<langle>0, receive\<langle>\<langle>keyserver2_fun.inv [\<langle>PrivFunSec\<rangle>\<^sub>c,
           \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>0, \<langle>\<langle>0\<rangle>\<^sub>v in \<langle>valid
                         A\<rangle>\<^sub>s\<rangle>\<rangle>]  [] [\<langle>0, send\<langle>attack\<langle>0\<rangle>\<rangle>\<rangle>])
 [a, b, c]
keyserver2_protocol ==
concat
 [keyserver2_transaction_passwordGenD, keyserver2_transaction_pubkeysGen,
  keyserver2_transaction_updateKeyPw,
  keyserver2_transaction_updateKeyServerPw,
  keyserver2_transaction_authAttack2]
keyserver2_transaction_updateKeyPw ==
map (%A. transaction\<^sub>1 [\<langle>\<star>, receive\<langle>occurs
                           \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>] [\<langle>0, \<langle>\<langle>0\<rangle>\<^sub>v in \<langle>pubkeys\<rangle>\<^sub>s\<rangle>\<rangle>] new [\<langle>Suc
     0\<rangle>\<^sub>v] [\<langle>0, insert\<langle>\<langle>Suc
                         0\<rangle>\<^sub>v,\<langle>ring'
                A\<rangle>\<^sub>s\<rangle>\<rangle>] [\<langle>0, send\<langle>\<langle>Suc
              0\<rangle>\<^sub>v\<rangle>\<rangle>,
                 \<langle>0, send\<langle>\<langle>crypt [\<langle>0\<rangle>\<^sub>v,
                    \<langle>update [\<langle>enum A\<rangle>\<^sub>c,
                                     \<langle>Suc 0\<rangle>\<^sub>v,
                                     \<langle>pw [\<langle>PrivFunSec\<rangle>\<^sub>c,
            \<langle>enum
                      A\<rangle>\<^sub>c]\<rangle>\<^sub>t]\<rangle>\<^sub>t]\<rangle>\<^sub>t\<rangle>\<rangle>,
                 \<langle>\<star>, send\<langle>occurs
           \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>])
 [a, b, c]
keyserver2_transaction_updateKeyServerPw ==
map (%A. transaction\<^sub>2 [\<langle>\<star>, receive\<langle>occurs
                           \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                              \<langle>\<star>, receive\<langle>occurs
                           \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                              \<langle>0, receive\<langle>\<langle>crypt [\<langle>0\<rangle>\<^sub>v,
                                    \<langle>update [\<langle>enum
                         A\<rangle>\<^sub>c,
               \<langle>Suc 0\<rangle>\<^sub>v,
               \<langle>pw [\<langle>PrivFunSec\<rangle>\<^sub>c,
                            \<langle>enum
A\<rangle>\<^sub>c]\<rangle>\<^sub>t]\<rangle>\<^sub>t]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
         0\<rangle>\<^sub>v\<rangle>\<rangle>,
                 \<langle>0, \<langle>\<langle>0\<rangle>\<^sub>v in \<langle>pubkeys\<rangle>\<^sub>s\<rangle>\<rangle>,
                 \<langle>0, \<langle>\<langle>Suc
          0\<rangle>\<^sub>v not in \<langle>pubkeys\<rangle>\<^sub>s\<rangle>\<rangle>] @
                concat
                 [map (%X0. \<langle>0, \<langle>\<langle>Suc
                     0\<rangle>\<^sub>v not in \<langle>seen
                   X0\<rangle>\<^sub>s\<rangle>\<rangle>)
                   [a, b, c,
                    i]]  [\<langle>0, insert\<langle>\<langle>Suc
                         0\<rangle>\<^sub>v,\<langle>valid
                A\<rangle>\<^sub>s\<rangle>\<rangle>,
                          \<langle>0, insert\<langle>\<langle>Suc
                         0\<rangle>\<^sub>v,\<langle>seen
                A\<rangle>\<^sub>s\<rangle>\<rangle>] [])
 [a, b, c, i]
keyserver2_fixpoint ==
([\<langle>{ring' a}\<rangle>\<^sub>a,
  \<langle>crypt [\<langle>{pubkeys}\<rangle>\<^sub>a,
                  \<langle>update [\<langle>enum a\<rangle>\<^sub>c,
                                   \<langle>{ring' a}\<rangle>\<^sub>a,
                                   \<langle>pw [\<langle>PrivFunSec\<rangle>\<^sub>c,
          \<langle>enum
                    a\<rangle>\<^sub>c]\<rangle>\<^sub>t]\<rangle>\<^sub>t]\<rangle>\<^sub>t,
  occurs \<langle>{ring' a}\<rangle>\<^sub>a,
  \<langle>{ring' b}\<rangle>\<^sub>a,
  \<langle>crypt [\<langle>{pubkeys}\<rangle>\<^sub>a,
                  \<langle>update [\<langle>enum b\<rangle>\<^sub>c,
                                   \<langle>{ring' b}\<rangle>\<^sub>a,
                                   \<langle>pw [\<langle>PrivFunSec\<rangle>\<^sub>c,
          \<langle>enum
                    b\<rangle>\<^sub>c]\<rangle>\<^sub>t]\<rangle>\<^sub>t]\<rangle>\<^sub>t,
  occurs \<langle>{ring' b}\<rangle>\<^sub>a,
  \<langle>{ring' c}\<rangle>\<^sub>a,
  \<langle>crypt [\<langle>{pubkeys}\<rangle>\<^sub>a,
                  \<langle>update [\<langle>enum c\<rangle>\<^sub>c,
                                   \<langle>{ring' c}\<rangle>\<^sub>a,
                                   \<langle>pw [\<langle>PrivFunSec\<rangle>\<^sub>c,
          \<langle>enum
                    c\<rangle>\<^sub>c]\<rangle>\<^sub>t]\<rangle>\<^sub>t]\<rangle>\<^sub>t,
  occurs \<langle>{ring' c}\<rangle>\<^sub>a,
  \<langle>pw [\<langle>PrivFunSec\<rangle>\<^sub>c,
               \<langle>enum i\<rangle>\<^sub>c]\<rangle>\<^sub>t,
  \<langle>{pubkeys}\<rangle>\<^sub>a,
  occurs \<langle>{pubkeys}\<rangle>\<^sub>a],
 [{ring' a}, {ring' b}, {ring' c}, {pubkeys}, {seen a, valid a, ring' a},
  {seen b, valid b, ring' b}, {seen c, valid c, ring' c},
  {seen i, valid i, ring' a}, {seen i, valid i, ring' b},
  {seen i, valid i, ring' c}],
 [({ring' a}, {seen a, valid a, ring' a}),
  ({ring' b}, {seen b, valid b, ring' b}),
  ({ring' c}, {seen c, valid c, ring' c}),
  ({ring' a}, {seen i, valid i, ring' a}),
  ({ring' b}, {seen i, valid i, ring' b}),
  ({ring' c}, {seen i, valid i, ring' c})])
### compiling ML
### 0.463s elapsed time, 1.130s cpu time, 0.241s GC time
### running ML
### 0.108s elapsed time, 0.245s cpu time, 0.095s GC time
### postprocessing term
### 0.001s elapsed time, 0.001s cpu time, 0.000s GC time
### preprocessing equations
### 0.870s elapsed time, 1.894s cpu time, 0.389s GC time
### translating term
### 2.194s elapsed time, 4.880s cpu time, 1.136s GC time
### compiling ML
### 0.232s elapsed time, 0.567s cpu time, 0.233s GC time
### running ML
### 0.024s elapsed time, 0.047s cpu time, 0.000s GC time
### postprocessing term
### 0.001s elapsed time, 0.001s cpu time, 0.000s GC time
### preprocessing equations
### 1.099s elapsed time, 2.336s cpu time, 0.418s GC time
### translating term
### 2.152s elapsed time, 3.183s cpu time, 0.772s GC time
### compiling ML
### 0.471s elapsed time, 0.597s cpu time, 0.186s GC time
### running ML
### 0.060s elapsed time, 0.072s cpu time, 0.025s GC time
ALL RE_IMPORT_ATT_enum_consts. RE_IMPORT_ATT_enum_consts = token1
ALL RE_IMPORT_ATT_sets.
   (EX x1. RE_IMPORT_ATT_sets = extract x1) |
   (EX x2. RE_IMPORT_ATT_sets = wrap x2) |
   (EX x3. RE_IMPORT_ATT_sets = unwrap x3) |
   (EX x4. RE_IMPORT_ATT_sets = decrypt x4) |
   (EX x5. RE_IMPORT_ATT_sets = sensitive x5)
ALL RE_IMPORT_ATT_atom.
   RE_IMPORT_ATT_atom = EnumType | RE_IMPORT_ATT_atom = SecretType
ALL RE_IMPORT_ATT_fun.
   RE_IMPORT_ATT_fun = senc |
   RE_IMPORT_ATT_fun = h |
   RE_IMPORT_ATT_fun = RE_IMPORT_ATT_fun.bind |
   RE_IMPORT_ATT_fun = RE_IMPORT_ATT_fun.inv |
   RE_IMPORT_ATT_fun = PrivFunSec | (EX x6. RE_IMPORT_ATT_fun = enum x6)
RE_IMPORT_ATT_arity senc = Suc (Suc 0)
RE_IMPORT_ATT_arity h = Suc (Suc 0)
RE_IMPORT_ATT_arity RE_IMPORT_ATT_fun.bind = Suc (Suc 0)
RE_IMPORT_ATT_arity RE_IMPORT_ATT_fun.inv = Suc (Suc 0)
RE_IMPORT_ATT_arity PrivFunSec = 0
RE_IMPORT_ATT_arity (enum ?uu) = 0
RE_IMPORT_ATT_public PrivFunSec = False
RE_IMPORT_ATT_public senc = True
RE_IMPORT_ATT_public h = True
RE_IMPORT_ATT_public RE_IMPORT_ATT_fun.bind = True
RE_IMPORT_ATT_public RE_IMPORT_ATT_fun.inv = True
RE_IMPORT_ATT_public (enum ?uu) = True
RE_IMPORT_ATT_\<Gamma> PrivFunSec = Some SecretType
RE_IMPORT_ATT_\<Gamma> (enum ?uu) = Some EnumType
RE_IMPORT_ATT_\<Gamma> senc = None
RE_IMPORT_ATT_\<Gamma> h = None
RE_IMPORT_ATT_\<Gamma> RE_IMPORT_ATT_fun.bind = None
RE_IMPORT_ATT_\<Gamma> RE_IMPORT_ATT_fun.inv = None
RE_IMPORT_ATT_Ana senc = ([Var (Suc 0)], [0])
RE_IMPORT_ATT_Ana h = ([], [])
RE_IMPORT_ATT_Ana RE_IMPORT_ATT_fun.bind = ([], [])
RE_IMPORT_ATT_Ana RE_IMPORT_ATT_fun.inv = ([], [])
RE_IMPORT_ATT_Ana PrivFunSec = ([], [])
RE_IMPORT_ATT_Ana (enum ?uu) = ([], [])
ALL \<A>:spm.reachable_constraints RE_IMPORT_ATT_protocol.
   \<nexists>\<I>.
      spm.constraint_model \<I>
       (\<A> @ [(?l, send\<langle>attack\<langle>?n\<rangle>\<rangle>)])
### theory "Draft.PKCS_Model07"
### 62.516s elapsed time, 188.017s cpu time, 84.253s GC time
Loading theory "Draft.Examples" (required by "Draft.ExamplesTemplates")
RE_IMPORT_ATT_transaction_iik1 ==
[transaction\<^sub>1 [] [] new [\<langle>0\<rangle>\<^sub>v,
                                \<langle>Suc
    0\<rangle>\<^sub>v] [\<langle>0, insert\<langle>\<langle>Suc
                        0\<rangle>\<^sub>v,\<langle>sensitive
               token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                         \<langle>0, insert\<langle>\<langle>Suc
                        0\<rangle>\<^sub>v,\<langle>extract
               token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                         \<langle>0, insert\<langle>\<langle>0\<rangle>\<^sub>v,\<langle>sensitive
              token1\<rangle>\<^sub>s\<rangle>\<rangle>] [\<langle>0, send\<langle>\<langle>h [\<langle>Suc
                             0\<rangle>\<^sub>v,
                   \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                    \<langle>\<star>, send\<langle>occurs
              \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, send\<langle>occurs
              \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>]]
RE_IMPORT_ATT_transaction_iik2 ==
[transaction\<^sub>1 [] [] new [\<langle>0\<rangle>\<^sub>v,
                                \<langle>Suc
    0\<rangle>\<^sub>v] [\<langle>0, insert\<langle>\<langle>Suc
                        0\<rangle>\<^sub>v,\<langle>wrap
               token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                         \<langle>0, insert\<langle>\<langle>Suc
                        0\<rangle>\<^sub>v,\<langle>extract
               token1\<rangle>\<^sub>s\<rangle>\<rangle>] [\<langle>0, send\<langle>\<langle>h [\<langle>Suc
                              0\<rangle>\<^sub>v,
                    \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                     \<langle>\<star>, send\<langle>occurs
               \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                     \<langle>\<star>, send\<langle>occurs
               \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>]]
RE_IMPORT_ATT_transaction_setwrap ==
concat
 [[transaction\<^sub>2 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>0\<rangle>\<^sub>v,
                          \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
            0\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>0\<rangle>\<^sub>v not in \<langle>sensitive
          token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>0\<rangle>\<^sub>v not in \<langle>decrypt
          token1\<rangle>\<^sub>s\<rangle>\<rangle>]  [\<langle>0, insert\<langle>\<langle>0\<rangle>\<^sub>v,\<langle>wrap
      token1\<rangle>\<^sub>s\<rangle>\<rangle>] []],
  [transaction\<^sub>2 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    0\<rangle>\<^sub>v,
                          \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>0, \<langle>\<langle>Suc
             0\<rangle>\<^sub>v not in \<langle>sensitive
           token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             0\<rangle>\<^sub>v not in \<langle>decrypt
           token1\<rangle>\<^sub>s\<rangle>\<rangle>]  [\<langle>0, insert\<langle>\<langle>Suc
                 0\<rangle>\<^sub>v,\<langle>wrap
        token1\<rangle>\<^sub>s\<rangle>\<rangle>] []]]
RE_IMPORT_ATT_transaction_setunwrap ==
concat
 [[transaction\<^sub>2 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>0\<rangle>\<^sub>v,
                          \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
            0\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>0\<rangle>\<^sub>v not in \<langle>sensitive
          token1\<rangle>\<^sub>s\<rangle>\<rangle>]  [\<langle>0, insert\<langle>\<langle>0\<rangle>\<^sub>v,\<langle>unwrap
      token1\<rangle>\<^sub>s\<rangle>\<rangle>] []],
  [transaction\<^sub>2 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    0\<rangle>\<^sub>v,
                          \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>0, \<langle>\<langle>Suc
             0\<rangle>\<^sub>v not in \<langle>sensitive
           token1\<rangle>\<^sub>s\<rangle>\<rangle>]  [\<langle>0, insert\<langle>\<langle>Suc
                 0\<rangle>\<^sub>v,\<langle>unwrap
        token1\<rangle>\<^sub>s\<rangle>\<rangle>] []]]
RE_IMPORT_ATT_transaction_decrypt1attr ==
concat
 [[transaction\<^sub>1 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>senc [\<langle>0\<rangle>\<^sub>v,
                             \<langle>Suc
 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v,
         \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    (Suc (Suc 0))\<rangle>\<^sub>v,
                          \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
            0\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
            (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
            (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                   (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc 0)\<rangle>\<^sub>v in \<langle>decrypt
             token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v in \<langle>unwrap
                   token1\<rangle>\<^sub>s\<rangle>\<rangle>] new [\<langle>Suc
 (Suc (Suc (Suc 0)))\<rangle>\<^sub>v] [\<langle>0, insert\<langle>\<langle>Suc
 (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,\<langle>decrypt
          token1\<rangle>\<^sub>s\<rangle>\<rangle>] [\<langle>0, send\<langle>\<langle>h [\<langle>Suc
                         (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,
               \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                \<langle>\<star>, send\<langle>occurs
          \<langle>Suc (Suc (Suc (Suc 0)))\<rangle>\<^sub>v\<rangle>\<rangle>]],
  [transaction\<^sub>1 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>senc [\<langle>0\<rangle>\<^sub>v,
                             \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>0\<rangle>\<^sub>v,
         \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>0\<rangle>\<^sub>v,
                          \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>0, \<langle>\<langle>0\<rangle>\<^sub>v in \<langle>decrypt
  token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                \<langle>0, \<langle>\<langle>0\<rangle>\<^sub>v in \<langle>unwrap
  token1\<rangle>\<^sub>s\<rangle>\<rangle>] new [\<langle>Suc
                      (Suc (Suc (Suc 0)))\<rangle>\<^sub>v] [\<langle>0, insert\<langle>\<langle>Suc
                      (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,\<langle>decrypt
                               token1\<rangle>\<^sub>s\<rangle>\<rangle>] [\<langle>0, send\<langle>\<langle>h [\<langle>Suc
        (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,
                                    \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                                     \<langle>\<star>, send\<langle>occurs
                               \<langle>Suc
   (Suc (Suc (Suc 0)))\<rangle>\<^sub>v\<rangle>\<rangle>]],
  [transaction\<^sub>1 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>senc [\<langle>Suc
 0\<rangle>\<^sub>v,
                             \<langle>Suc
 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>Suc
                   (Suc (Suc 0))\<rangle>\<^sub>v,
         \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    (Suc (Suc 0))\<rangle>\<^sub>v,
                          \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v in \<langle>decrypt
                   token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v in \<langle>unwrap
                   token1\<rangle>\<^sub>s\<rangle>\<rangle>] new [\<langle>Suc
 (Suc (Suc (Suc 0)))\<rangle>\<^sub>v] [\<langle>0, insert\<langle>\<langle>Suc
 (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,\<langle>decrypt
          token1\<rangle>\<^sub>s\<rangle>\<rangle>] [\<langle>0, send\<langle>\<langle>h [\<langle>Suc
                         (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,
               \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                \<langle>\<star>, send\<langle>occurs
          \<langle>Suc (Suc (Suc (Suc 0)))\<rangle>\<^sub>v\<rangle>\<rangle>]],
  [transaction\<^sub>1 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>senc [\<langle>Suc
 (Suc 0)\<rangle>\<^sub>v,
                             \<langle>Suc
 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v,
         \<langle>Suc (Suc 0)\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    (Suc 0)\<rangle>\<^sub>v,
                          \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                   0\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc 0)\<rangle>\<^sub>v in \<langle>decrypt
             token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc 0)\<rangle>\<^sub>v in \<langle>unwrap
             token1\<rangle>\<^sub>s\<rangle>\<rangle>] new [\<langle>Suc
                                 (Suc (Suc
  (Suc 0)))\<rangle>\<^sub>v] [\<langle>0, insert\<langle>\<langle>Suc
                              (Suc (Suc (Suc
    0)))\<rangle>\<^sub>v,\<langle>decrypt
                                    token1\<rangle>\<^sub>s\<rangle>\<rangle>] [\<langle>0, send\<langle>\<langle>h [\<langle>Suc
             (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,
   \<langle>Suc (Suc 0)\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
    \<langle>\<star>, send\<langle>occurs
                                    \<langle>Suc
        (Suc (Suc (Suc 0)))\<rangle>\<^sub>v\<rangle>\<rangle>]],
  [transaction\<^sub>1 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>senc [\<langle>0\<rangle>\<^sub>v,
                             \<langle>Suc
 (Suc 0)\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v,
         \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    (Suc 0)\<rangle>\<^sub>v,
                          \<langle>Suc (Suc
   0)\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
               (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                       \<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
               (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                       \<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
               (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                       \<langle>0, \<langle>\<langle>Suc
                (Suc 0)\<rangle>\<^sub>v in \<langle>decrypt
                token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                       \<langle>0, \<langle>\<langle>Suc
                (Suc 0)\<rangle>\<^sub>v in \<langle>unwrap
                token1\<rangle>\<^sub>s\<rangle>\<rangle>] new [\<langle>Suc
                                    (Suc
(Suc (Suc 0)))\<rangle>\<^sub>v] [\<langle>0, insert\<langle>\<langle>Suc
                                 (Suc (Suc
  (Suc 0)))\<rangle>\<^sub>v,\<langle>decrypt
 token1\<rangle>\<^sub>s\<rangle>\<rangle>] [\<langle>0, send\<langle>\<langle>h [\<langle>Suc
                (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,
      \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
       \<langle>\<star>, send\<langle>occurs
 \<langle>Suc (Suc (Suc (Suc 0)))\<rangle>\<^sub>v\<rangle>\<rangle>]],
  [transaction\<^sub>1 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>senc [\<langle>Suc
 (Suc 0)\<rangle>\<^sub>v,
                             \<langle>Suc
 (Suc (Suc 0))\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v,
         \<langle>Suc (Suc 0)\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    (Suc (Suc 0))\<rangle>\<^sub>v,
                          \<langle>Suc (Suc
   (Suc 0))\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>Suc
                            (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                            (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>\<star>, \<langle>\<langle>Suc
                            (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                            (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>\<star>, \<langle>\<langle>Suc
                            (Suc (Suc 0))\<rangle>\<^sub>v != \<langle>Suc
                                  (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>\<star>, \<langle>\<langle>Suc
                            (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                            (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>0, \<langle>\<langle>Suc
                      (Suc 0)\<rangle>\<^sub>v in \<langle>decrypt
                      token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                             \<langle>0, \<langle>\<langle>Suc
                      (Suc (Suc 0))\<rangle>\<^sub>v in \<langle>unwrap
                            token1\<rangle>\<^sub>s\<rangle>\<rangle>] new [\<langle>Suc
          (Suc (Suc (Suc 0)))\<rangle>\<^sub>v] [\<langle>0, insert\<langle>\<langle>Suc
          (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,\<langle>decrypt
                   token1\<rangle>\<^sub>s\<rangle>\<rangle>] [\<langle>0, send\<langle>\<langle>h [\<langle>Suc
                                  (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,
                        \<langle>Suc (Suc
 0)\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                         \<langle>\<star>, send\<langle>occurs
                   \<langle>Suc (Suc (Suc
 (Suc 0)))\<rangle>\<^sub>v\<rangle>\<rangle>]],
  [transaction\<^sub>1 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>senc [\<langle>Suc
 0\<rangle>\<^sub>v,
                             \<langle>Suc
 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v,
         \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    0\<rangle>\<^sub>v,
                          \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                   0\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc 0)\<rangle>\<^sub>v in \<langle>decrypt
             token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             0\<rangle>\<^sub>v in \<langle>unwrap
       token1\<rangle>\<^sub>s\<rangle>\<rangle>] new [\<langle>Suc
                           (Suc (Suc (Suc
 0)))\<rangle>\<^sub>v] [\<langle>0, insert\<langle>\<langle>Suc
                        (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,\<langle>decrypt
                                 token1\<rangle>\<^sub>s\<rangle>\<rangle>] [\<langle>0, send\<langle>\<langle>h [\<langle>Suc
          (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,
\<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
 \<langle>\<star>, send\<langle>occurs
                                 \<langle>Suc
     (Suc (Suc (Suc 0)))\<rangle>\<^sub>v\<rangle>\<rangle>]],
  [transaction\<^sub>1 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>senc [\<langle>Suc
 0\<rangle>\<^sub>v,
                             \<langle>Suc
 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>Suc
                   0\<rangle>\<^sub>v,
         \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    (Suc (Suc 0))\<rangle>\<^sub>v,
                          \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             0\<rangle>\<^sub>v in \<langle>decrypt
       token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v in \<langle>unwrap
                   token1\<rangle>\<^sub>s\<rangle>\<rangle>] new [\<langle>Suc
 (Suc (Suc (Suc 0)))\<rangle>\<^sub>v] [\<langle>0, insert\<langle>\<langle>Suc
 (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,\<langle>decrypt
          token1\<rangle>\<^sub>s\<rangle>\<rangle>] [\<langle>0, send\<langle>\<langle>h [\<langle>Suc
                         (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,
               \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                \<langle>\<star>, send\<langle>occurs
          \<langle>Suc (Suc (Suc (Suc 0)))\<rangle>\<^sub>v\<rangle>\<rangle>]],
  [transaction\<^sub>1 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>senc [\<langle>Suc
 (Suc (Suc 0))\<rangle>\<^sub>v,
                             \<langle>Suc
 (Suc 0)\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v,
         \<langle>Suc (Suc (Suc 0))\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    (Suc (Suc 0))\<rangle>\<^sub>v,
                          \<langle>Suc (Suc
   0)\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>Suc
                      (Suc (Suc 0))\<rangle>\<^sub>v != \<langle>Suc
                            (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                       \<langle>\<star>, \<langle>\<langle>Suc
                      (Suc (Suc 0))\<rangle>\<^sub>v != \<langle>Suc
                            (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                       \<langle>\<star>, \<langle>\<langle>Suc
                      (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                      (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                       \<langle>\<star>, \<langle>\<langle>Suc
                      (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                      (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                       \<langle>0, \<langle>\<langle>Suc
                (Suc 0)\<rangle>\<^sub>v in \<langle>decrypt
                token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                       \<langle>0, \<langle>\<langle>Suc
                (Suc (Suc 0))\<rangle>\<^sub>v in \<langle>unwrap
                      token1\<rangle>\<^sub>s\<rangle>\<rangle>] new [\<langle>Suc
    (Suc (Suc (Suc 0)))\<rangle>\<^sub>v] [\<langle>0, insert\<langle>\<langle>Suc
    (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,\<langle>decrypt
             token1\<rangle>\<^sub>s\<rangle>\<rangle>] [\<langle>0, send\<langle>\<langle>h [\<langle>Suc
                            (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,
                  \<langle>Suc (Suc (Suc
0))\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                   \<langle>\<star>, send\<langle>occurs
             \<langle>Suc (Suc (Suc (Suc
0)))\<rangle>\<^sub>v\<rangle>\<rangle>]],
  [transaction\<^sub>1 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>senc [\<langle>Suc
 0\<rangle>\<^sub>v,
                             \<langle>Suc
 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v,
         \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    (Suc (Suc 0))\<rangle>\<^sub>v,
                          \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                   (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc 0)\<rangle>\<^sub>v in \<langle>decrypt
             token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v in \<langle>unwrap
                   token1\<rangle>\<^sub>s\<rangle>\<rangle>] new [\<langle>Suc
 (Suc (Suc (Suc 0)))\<rangle>\<^sub>v] [\<langle>0, insert\<langle>\<langle>Suc
 (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,\<langle>decrypt
          token1\<rangle>\<^sub>s\<rangle>\<rangle>] [\<langle>0, send\<langle>\<langle>h [\<langle>Suc
                         (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,
               \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                \<langle>\<star>, send\<langle>occurs
          \<langle>Suc (Suc (Suc (Suc 0)))\<rangle>\<^sub>v\<rangle>\<rangle>]],
  [transaction\<^sub>1 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>senc [\<langle>Suc
 (Suc 0)\<rangle>\<^sub>v,
                             \<langle>Suc
 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v,
         \<langle>Suc (Suc 0)\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    (Suc (Suc 0))\<rangle>\<^sub>v,
                          \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                   0\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                   (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                   (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc 0)\<rangle>\<^sub>v in \<langle>decrypt
             token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v in \<langle>unwrap
                   token1\<rangle>\<^sub>s\<rangle>\<rangle>] new [\<langle>Suc
 (Suc (Suc (Suc 0)))\<rangle>\<^sub>v] [\<langle>0, insert\<langle>\<langle>Suc
 (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,\<langle>decrypt
          token1\<rangle>\<^sub>s\<rangle>\<rangle>] [\<langle>0, send\<langle>\<langle>h [\<langle>Suc
                         (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,
               \<langle>Suc (Suc 0)\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                \<langle>\<star>, send\<langle>occurs
          \<langle>Suc (Suc (Suc (Suc 0)))\<rangle>\<^sub>v\<rangle>\<rangle>]],
  [transaction\<^sub>1 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>senc [\<langle>Suc
 (Suc (Suc 0))\<rangle>\<^sub>v,
                             \<langle>Suc
 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v,
         \<langle>Suc (Suc (Suc 0))\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    (Suc (Suc 0))\<rangle>\<^sub>v,
                          \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>Suc
                   (Suc (Suc 0))\<rangle>\<^sub>v != \<langle>Suc
                         0\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   (Suc (Suc 0))\<rangle>\<^sub>v != \<langle>Suc
                         (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                   (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc 0)\<rangle>\<^sub>v in \<langle>decrypt
             token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v in \<langle>unwrap
                   token1\<rangle>\<^sub>s\<rangle>\<rangle>] new [\<langle>Suc
 (Suc (Suc (Suc 0)))\<rangle>\<^sub>v] [\<langle>0, insert\<langle>\<langle>Suc
 (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,\<langle>decrypt
          token1\<rangle>\<^sub>s\<rangle>\<rangle>] [\<langle>0, send\<langle>\<langle>h [\<langle>Suc
                         (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,
               \<langle>Suc (Suc (Suc 0))\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                \<langle>\<star>, send\<langle>occurs
          \<langle>Suc (Suc (Suc (Suc 0)))\<rangle>\<^sub>v\<rangle>\<rangle>]],
  [transaction\<^sub>1 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>senc [\<langle>0\<rangle>\<^sub>v,
                             \<langle>Suc
 (Suc 0)\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v,
         \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    (Suc (Suc 0))\<rangle>\<^sub>v,
                          \<langle>Suc (Suc
   0)\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
               (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                       \<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
               (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                       \<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
               (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                       \<langle>\<star>, \<langle>\<langle>Suc
                      (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                      (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                       \<langle>\<star>, \<langle>\<langle>Suc
                      (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                      (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                       \<langle>0, \<langle>\<langle>Suc
                (Suc 0)\<rangle>\<^sub>v in \<langle>decrypt
                token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                       \<langle>0, \<langle>\<langle>Suc
                (Suc (Suc 0))\<rangle>\<^sub>v in \<langle>unwrap
                      token1\<rangle>\<^sub>s\<rangle>\<rangle>] new [\<langle>Suc
    (Suc (Suc (Suc 0)))\<rangle>\<^sub>v] [\<langle>0, insert\<langle>\<langle>Suc
    (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,\<langle>decrypt
             token1\<rangle>\<^sub>s\<rangle>\<rangle>] [\<langle>0, send\<langle>\<langle>h [\<langle>Suc
                            (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,
                  \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                   \<langle>\<star>, send\<langle>occurs
             \<langle>Suc (Suc (Suc (Suc
0)))\<rangle>\<^sub>v\<rangle>\<rangle>]],
  [transaction\<^sub>1 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>senc [\<langle>0\<rangle>\<^sub>v,
                             \<langle>Suc
 (Suc (Suc 0))\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v,
         \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    (Suc (Suc 0))\<rangle>\<^sub>v,
                          \<langle>Suc (Suc
   (Suc 0))\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
                     (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
                     (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
                     (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>\<star>, \<langle>\<langle>Suc
                            (Suc (Suc 0))\<rangle>\<^sub>v != \<langle>Suc
                                  (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>\<star>, \<langle>\<langle>Suc
                            (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                            (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>0, \<langle>\<langle>Suc
                      (Suc 0)\<rangle>\<^sub>v in \<langle>decrypt
                      token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                             \<langle>0, \<langle>\<langle>Suc
                      (Suc (Suc 0))\<rangle>\<^sub>v in \<langle>unwrap
                            token1\<rangle>\<^sub>s\<rangle>\<rangle>] new [\<langle>Suc
          (Suc (Suc (Suc 0)))\<rangle>\<^sub>v] [\<langle>0, insert\<langle>\<langle>Suc
          (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,\<langle>decrypt
                   token1\<rangle>\<^sub>s\<rangle>\<rangle>] [\<langle>0, send\<langle>\<langle>h [\<langle>Suc
                                  (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,
                        \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                         \<langle>\<star>, send\<langle>occurs
                   \<langle>Suc (Suc (Suc
 (Suc 0)))\<rangle>\<^sub>v\<rangle>\<rangle>]],
  [transaction\<^sub>1 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>senc [\<langle>0\<rangle>\<^sub>v,
                             \<langle>Suc
 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>Suc
                   (Suc (Suc 0))\<rangle>\<^sub>v,
         \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    (Suc (Suc 0))\<rangle>\<^sub>v,
                          \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
            0\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
            (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
            (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v in \<langle>decrypt
                   token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v in \<langle>unwrap
                   token1\<rangle>\<^sub>s\<rangle>\<rangle>] new [\<langle>Suc
 (Suc (Suc (Suc 0)))\<rangle>\<^sub>v] [\<langle>0, insert\<langle>\<langle>Suc
 (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,\<langle>decrypt
          token1\<rangle>\<^sub>s\<rangle>\<rangle>] [\<langle>0, send\<langle>\<langle>h [\<langle>Suc
                         (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,
               \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                \<langle>\<star>, send\<langle>occurs
          \<langle>Suc (Suc (Suc (Suc 0)))\<rangle>\<^sub>v\<rangle>\<rangle>]]]
RE_IMPORT_ATT_transaction_wrapattr ==
concat
 [[transaction\<^sub>1 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>senc [\<langle>0\<rangle>\<^sub>v,
                             \<langle>Suc
 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v,
         \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    (Suc (Suc 0))\<rangle>\<^sub>v,
                          \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
            0\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
            (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
            (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                   (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc 0)\<rangle>\<^sub>v in \<langle>wrap
             token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v in \<langle>unwrap
                   token1\<rangle>\<^sub>s\<rangle>\<rangle>] new [\<langle>Suc
 (Suc (Suc (Suc 0)))\<rangle>\<^sub>v] [\<langle>0, insert\<langle>\<langle>Suc
 (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,\<langle>wrap
          token1\<rangle>\<^sub>s\<rangle>\<rangle>] [\<langle>0, send\<langle>\<langle>h [\<langle>Suc
                         (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,
               \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                \<langle>\<star>, send\<langle>occurs
          \<langle>Suc (Suc (Suc (Suc 0)))\<rangle>\<^sub>v\<rangle>\<rangle>]],
  [transaction\<^sub>1 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>senc [\<langle>0\<rangle>\<^sub>v,
                             \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>0\<rangle>\<^sub>v,
         \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>0\<rangle>\<^sub>v,
                          \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>0, \<langle>\<langle>0\<rangle>\<^sub>v in \<langle>wrap
  token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                \<langle>0, \<langle>\<langle>0\<rangle>\<^sub>v in \<langle>unwrap
  token1\<rangle>\<^sub>s\<rangle>\<rangle>] new [\<langle>Suc
                      (Suc (Suc (Suc 0)))\<rangle>\<^sub>v] [\<langle>0, insert\<langle>\<langle>Suc
                      (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,\<langle>wrap
                               token1\<rangle>\<^sub>s\<rangle>\<rangle>] [\<langle>0, send\<langle>\<langle>h [\<langle>Suc
        (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,
                                    \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                                     \<langle>\<star>, send\<langle>occurs
                               \<langle>Suc
   (Suc (Suc (Suc 0)))\<rangle>\<^sub>v\<rangle>\<rangle>]],
  [transaction\<^sub>1 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>senc [\<langle>Suc
 0\<rangle>\<^sub>v,
                             \<langle>Suc
 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>Suc
                   (Suc (Suc 0))\<rangle>\<^sub>v,
         \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    (Suc (Suc 0))\<rangle>\<^sub>v,
                          \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v in \<langle>wrap
                   token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v in \<langle>unwrap
                   token1\<rangle>\<^sub>s\<rangle>\<rangle>] new [\<langle>Suc
 (Suc (Suc (Suc 0)))\<rangle>\<^sub>v] [\<langle>0, insert\<langle>\<langle>Suc
 (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,\<langle>wrap
          token1\<rangle>\<^sub>s\<rangle>\<rangle>] [\<langle>0, send\<langle>\<langle>h [\<langle>Suc
                         (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,
               \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                \<langle>\<star>, send\<langle>occurs
          \<langle>Suc (Suc (Suc (Suc 0)))\<rangle>\<^sub>v\<rangle>\<rangle>]],
  [transaction\<^sub>1 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>senc [\<langle>Suc
 (Suc 0)\<rangle>\<^sub>v,
                             \<langle>Suc
 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v,
         \<langle>Suc (Suc 0)\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    (Suc 0)\<rangle>\<^sub>v,
                          \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                   0\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc 0)\<rangle>\<^sub>v in \<langle>wrap
             token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc 0)\<rangle>\<^sub>v in \<langle>unwrap
             token1\<rangle>\<^sub>s\<rangle>\<rangle>] new [\<langle>Suc
                                 (Suc (Suc
  (Suc 0)))\<rangle>\<^sub>v] [\<langle>0, insert\<langle>\<langle>Suc
                              (Suc (Suc (Suc
    0)))\<rangle>\<^sub>v,\<langle>wrap
                                    token1\<rangle>\<^sub>s\<rangle>\<rangle>] [\<langle>0, send\<langle>\<langle>h [\<langle>Suc
             (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,
   \<langle>Suc (Suc 0)\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
    \<langle>\<star>, send\<langle>occurs
                                    \<langle>Suc
        (Suc (Suc (Suc 0)))\<rangle>\<^sub>v\<rangle>\<rangle>]],
  [transaction\<^sub>1 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>senc [\<langle>0\<rangle>\<^sub>v,
                             \<langle>Suc
 (Suc 0)\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v,
         \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    (Suc 0)\<rangle>\<^sub>v,
                          \<langle>Suc (Suc
   0)\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
               (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                       \<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
               (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                       \<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
               (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                       \<langle>0, \<langle>\<langle>Suc
                (Suc 0)\<rangle>\<^sub>v in \<langle>wrap
                token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                       \<langle>0, \<langle>\<langle>Suc
                (Suc 0)\<rangle>\<^sub>v in \<langle>unwrap
                token1\<rangle>\<^sub>s\<rangle>\<rangle>] new [\<langle>Suc
                                    (Suc
(Suc (Suc 0)))\<rangle>\<^sub>v] [\<langle>0, insert\<langle>\<langle>Suc
                                 (Suc (Suc
  (Suc 0)))\<rangle>\<^sub>v,\<langle>wrap
 token1\<rangle>\<^sub>s\<rangle>\<rangle>] [\<langle>0, send\<langle>\<langle>h [\<langle>Suc
                (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,
      \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
       \<langle>\<star>, send\<langle>occurs
 \<langle>Suc (Suc (Suc (Suc 0)))\<rangle>\<^sub>v\<rangle>\<rangle>]],
  [transaction\<^sub>1 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>senc [\<langle>Suc
 (Suc 0)\<rangle>\<^sub>v,
                             \<langle>Suc
 (Suc (Suc 0))\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v,
         \<langle>Suc (Suc 0)\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    (Suc (Suc 0))\<rangle>\<^sub>v,
                          \<langle>Suc (Suc
   (Suc 0))\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>Suc
                            (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                            (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>\<star>, \<langle>\<langle>Suc
                            (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                            (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>\<star>, \<langle>\<langle>Suc
                            (Suc (Suc 0))\<rangle>\<^sub>v != \<langle>Suc
                                  (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>\<star>, \<langle>\<langle>Suc
                            (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                            (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>0, \<langle>\<langle>Suc
                      (Suc 0)\<rangle>\<^sub>v in \<langle>wrap
                      token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                             \<langle>0, \<langle>\<langle>Suc
                      (Suc (Suc 0))\<rangle>\<^sub>v in \<langle>unwrap
                            token1\<rangle>\<^sub>s\<rangle>\<rangle>] new [\<langle>Suc
          (Suc (Suc (Suc 0)))\<rangle>\<^sub>v] [\<langle>0, insert\<langle>\<langle>Suc
          (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,\<langle>wrap
                   token1\<rangle>\<^sub>s\<rangle>\<rangle>] [\<langle>0, send\<langle>\<langle>h [\<langle>Suc
                                  (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,
                        \<langle>Suc (Suc
 0)\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                         \<langle>\<star>, send\<langle>occurs
                   \<langle>Suc (Suc (Suc
 (Suc 0)))\<rangle>\<^sub>v\<rangle>\<rangle>]],
  [transaction\<^sub>1 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>senc [\<langle>Suc
 0\<rangle>\<^sub>v,
                             \<langle>Suc
 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v,
         \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    0\<rangle>\<^sub>v,
                          \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                   0\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc 0)\<rangle>\<^sub>v in \<langle>wrap
             token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             0\<rangle>\<^sub>v in \<langle>unwrap
       token1\<rangle>\<^sub>s\<rangle>\<rangle>] new [\<langle>Suc
                           (Suc (Suc (Suc
 0)))\<rangle>\<^sub>v] [\<langle>0, insert\<langle>\<langle>Suc
                        (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,\<langle>wrap
                                 token1\<rangle>\<^sub>s\<rangle>\<rangle>] [\<langle>0, send\<langle>\<langle>h [\<langle>Suc
          (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,
\<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
 \<langle>\<star>, send\<langle>occurs
                                 \<langle>Suc
     (Suc (Suc (Suc 0)))\<rangle>\<^sub>v\<rangle>\<rangle>]],
  [transaction\<^sub>1 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>senc [\<langle>Suc
 0\<rangle>\<^sub>v,
                             \<langle>Suc
 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>Suc
                   0\<rangle>\<^sub>v,
         \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    (Suc (Suc 0))\<rangle>\<^sub>v,
                          \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             0\<rangle>\<^sub>v in \<langle>wrap
       token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v in \<langle>unwrap
                   token1\<rangle>\<^sub>s\<rangle>\<rangle>] new [\<langle>Suc
 (Suc (Suc (Suc 0)))\<rangle>\<^sub>v] [\<langle>0, insert\<langle>\<langle>Suc
 (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,\<langle>wrap
          token1\<rangle>\<^sub>s\<rangle>\<rangle>] [\<langle>0, send\<langle>\<langle>h [\<langle>Suc
                         (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,
               \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                \<langle>\<star>, send\<langle>occurs
          \<langle>Suc (Suc (Suc (Suc 0)))\<rangle>\<^sub>v\<rangle>\<rangle>]],
  [transaction\<^sub>1 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>senc [\<langle>Suc
 (Suc (Suc 0))\<rangle>\<^sub>v,
                             \<langle>Suc
 (Suc 0)\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v,
         \<langle>Suc (Suc (Suc 0))\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    (Suc (Suc 0))\<rangle>\<^sub>v,
                          \<langle>Suc (Suc
   0)\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>Suc
                      (Suc (Suc 0))\<rangle>\<^sub>v != \<langle>Suc
                            (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                       \<langle>\<star>, \<langle>\<langle>Suc
                      (Suc (Suc 0))\<rangle>\<^sub>v != \<langle>Suc
                            (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                       \<langle>\<star>, \<langle>\<langle>Suc
                      (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                      (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                       \<langle>\<star>, \<langle>\<langle>Suc
                      (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                      (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                       \<langle>0, \<langle>\<langle>Suc
                (Suc 0)\<rangle>\<^sub>v in \<langle>wrap
                token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                       \<langle>0, \<langle>\<langle>Suc
                (Suc (Suc 0))\<rangle>\<^sub>v in \<langle>unwrap
                      token1\<rangle>\<^sub>s\<rangle>\<rangle>] new [\<langle>Suc
    (Suc (Suc (Suc 0)))\<rangle>\<^sub>v] [\<langle>0, insert\<langle>\<langle>Suc
    (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,\<langle>wrap
             token1\<rangle>\<^sub>s\<rangle>\<rangle>] [\<langle>0, send\<langle>\<langle>h [\<langle>Suc
                            (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,
                  \<langle>Suc (Suc (Suc
0))\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                   \<langle>\<star>, send\<langle>occurs
             \<langle>Suc (Suc (Suc (Suc
0)))\<rangle>\<^sub>v\<rangle>\<rangle>]],
  [transaction\<^sub>1 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>senc [\<langle>Suc
 0\<rangle>\<^sub>v,
                             \<langle>Suc
 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v,
         \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    (Suc (Suc 0))\<rangle>\<^sub>v,
                          \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                   (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc 0)\<rangle>\<^sub>v in \<langle>wrap
             token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v in \<langle>unwrap
                   token1\<rangle>\<^sub>s\<rangle>\<rangle>] new [\<langle>Suc
 (Suc (Suc (Suc 0)))\<rangle>\<^sub>v] [\<langle>0, insert\<langle>\<langle>Suc
 (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,\<langle>wrap
          token1\<rangle>\<^sub>s\<rangle>\<rangle>] [\<langle>0, send\<langle>\<langle>h [\<langle>Suc
                         (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,
               \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                \<langle>\<star>, send\<langle>occurs
          \<langle>Suc (Suc (Suc (Suc 0)))\<rangle>\<^sub>v\<rangle>\<rangle>]],
  [transaction\<^sub>1 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>senc [\<langle>Suc
 (Suc 0)\<rangle>\<^sub>v,
                             \<langle>Suc
 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v,
         \<langle>Suc (Suc 0)\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    (Suc (Suc 0))\<rangle>\<^sub>v,
                          \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                   0\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                   (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                   (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc 0)\<rangle>\<^sub>v in \<langle>wrap
             token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v in \<langle>unwrap
                   token1\<rangle>\<^sub>s\<rangle>\<rangle>] new [\<langle>Suc
 (Suc (Suc (Suc 0)))\<rangle>\<^sub>v] [\<langle>0, insert\<langle>\<langle>Suc
 (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,\<langle>wrap
          token1\<rangle>\<^sub>s\<rangle>\<rangle>] [\<langle>0, send\<langle>\<langle>h [\<langle>Suc
                         (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,
               \<langle>Suc (Suc 0)\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                \<langle>\<star>, send\<langle>occurs
          \<langle>Suc (Suc (Suc (Suc 0)))\<rangle>\<^sub>v\<rangle>\<rangle>]],
  [transaction\<^sub>1 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>senc [\<langle>Suc
 (Suc (Suc 0))\<rangle>\<^sub>v,
                             \<langle>Suc
 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v,
         \<langle>Suc (Suc (Suc 0))\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    (Suc (Suc 0))\<rangle>\<^sub>v,
                          \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>Suc
                   (Suc (Suc 0))\<rangle>\<^sub>v != \<langle>Suc
                         0\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   (Suc (Suc 0))\<rangle>\<^sub>v != \<langle>Suc
                         (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                   (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc 0)\<rangle>\<^sub>v in \<langle>wrap
             token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v in \<langle>unwrap
                   token1\<rangle>\<^sub>s\<rangle>\<rangle>] new [\<langle>Suc
 (Suc (Suc (Suc 0)))\<rangle>\<^sub>v] [\<langle>0, insert\<langle>\<langle>Suc
 (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,\<langle>wrap
          token1\<rangle>\<^sub>s\<rangle>\<rangle>] [\<langle>0, send\<langle>\<langle>h [\<langle>Suc
                         (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,
               \<langle>Suc (Suc (Suc 0))\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                \<langle>\<star>, send\<langle>occurs
          \<langle>Suc (Suc (Suc (Suc 0)))\<rangle>\<^sub>v\<rangle>\<rangle>]],
  [transaction\<^sub>1 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>senc [\<langle>0\<rangle>\<^sub>v,
                             \<langle>Suc
 (Suc 0)\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v,
         \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    (Suc (Suc 0))\<rangle>\<^sub>v,
                          \<langle>Suc (Suc
   0)\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
               (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                       \<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
               (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                       \<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
               (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                       \<langle>\<star>, \<langle>\<langle>Suc
                      (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                      (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                       \<langle>\<star>, \<langle>\<langle>Suc
                      (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                      (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                       \<langle>0, \<langle>\<langle>Suc
                (Suc 0)\<rangle>\<^sub>v in \<langle>wrap
                token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                       \<langle>0, \<langle>\<langle>Suc
                (Suc (Suc 0))\<rangle>\<^sub>v in \<langle>unwrap
                      token1\<rangle>\<^sub>s\<rangle>\<rangle>] new [\<langle>Suc
    (Suc (Suc (Suc 0)))\<rangle>\<^sub>v] [\<langle>0, insert\<langle>\<langle>Suc
    (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,\<langle>wrap
             token1\<rangle>\<^sub>s\<rangle>\<rangle>] [\<langle>0, send\<langle>\<langle>h [\<langle>Suc
                            (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,
                  \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                   \<langle>\<star>, send\<langle>occurs
             \<langle>Suc (Suc (Suc (Suc
0)))\<rangle>\<^sub>v\<rangle>\<rangle>]],
  [transaction\<^sub>1 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>senc [\<langle>0\<rangle>\<^sub>v,
                             \<langle>Suc
 (Suc (Suc 0))\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v,
         \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    (Suc (Suc 0))\<rangle>\<^sub>v,
                          \<langle>Suc (Suc
   (Suc 0))\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
                     (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
                     (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
                     (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>\<star>, \<langle>\<langle>Suc
                            (Suc (Suc 0))\<rangle>\<^sub>v != \<langle>Suc
                                  (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>\<star>, \<langle>\<langle>Suc
                            (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                            (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>0, \<langle>\<langle>Suc
                      (Suc 0)\<rangle>\<^sub>v in \<langle>wrap
                      token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                             \<langle>0, \<langle>\<langle>Suc
                      (Suc (Suc 0))\<rangle>\<^sub>v in \<langle>unwrap
                            token1\<rangle>\<^sub>s\<rangle>\<rangle>] new [\<langle>Suc
          (Suc (Suc (Suc 0)))\<rangle>\<^sub>v] [\<langle>0, insert\<langle>\<langle>Suc
          (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,\<langle>wrap
                   token1\<rangle>\<^sub>s\<rangle>\<rangle>] [\<langle>0, send\<langle>\<langle>h [\<langle>Suc
                                  (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,
                        \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                         \<langle>\<star>, send\<langle>occurs
                   \<langle>Suc (Suc (Suc
 (Suc 0)))\<rangle>\<^sub>v\<rangle>\<rangle>]],
  [transaction\<^sub>1 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>senc [\<langle>0\<rangle>\<^sub>v,
                             \<langle>Suc
 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>Suc
                   (Suc (Suc 0))\<rangle>\<^sub>v,
         \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    (Suc (Suc 0))\<rangle>\<^sub>v,
                          \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
            0\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
            (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
            (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v in \<langle>wrap
                   token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v in \<langle>unwrap
                   token1\<rangle>\<^sub>s\<rangle>\<rangle>] new [\<langle>Suc
 (Suc (Suc (Suc 0)))\<rangle>\<^sub>v] [\<langle>0, insert\<langle>\<langle>Suc
 (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,\<langle>wrap
          token1\<rangle>\<^sub>s\<rangle>\<rangle>] [\<langle>0, send\<langle>\<langle>h [\<langle>Suc
                         (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,
               \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                \<langle>\<star>, send\<langle>occurs
          \<langle>Suc (Suc (Suc (Suc 0)))\<rangle>\<^sub>v\<rangle>\<rangle>]]]
RE_IMPORT_ATT_transaction_unwrapsensitive ==
concat
 [[transaction\<^sub>1 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>senc [\<langle>0\<rangle>\<^sub>v,
                             \<langle>Suc
 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v,
         \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    (Suc (Suc 0))\<rangle>\<^sub>v,
                          \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
            0\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
            (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
            (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                   (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc 0)\<rangle>\<^sub>v in \<langle>sensitive
             token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v in \<langle>unwrap
                   token1\<rangle>\<^sub>s\<rangle>\<rangle>] new [\<langle>Suc
 (Suc (Suc (Suc 0)))\<rangle>\<^sub>v] [\<langle>0, insert\<langle>\<langle>Suc
 (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,\<langle>sensitive
          token1\<rangle>\<^sub>s\<rangle>\<rangle>] [\<langle>0, send\<langle>\<langle>h [\<langle>Suc
                         (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,
               \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                \<langle>\<star>, send\<langle>occurs
          \<langle>Suc (Suc (Suc (Suc 0)))\<rangle>\<^sub>v\<rangle>\<rangle>]],
  [transaction\<^sub>1 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>senc [\<langle>0\<rangle>\<^sub>v,
                             \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>0\<rangle>\<^sub>v,
         \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>0\<rangle>\<^sub>v,
                          \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>0, \<langle>\<langle>0\<rangle>\<^sub>v in \<langle>sensitive
  token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                \<langle>0, \<langle>\<langle>0\<rangle>\<^sub>v in \<langle>unwrap
  token1\<rangle>\<^sub>s\<rangle>\<rangle>] new [\<langle>Suc
                      (Suc (Suc (Suc 0)))\<rangle>\<^sub>v] [\<langle>0, insert\<langle>\<langle>Suc
                      (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,\<langle>sensitive
                               token1\<rangle>\<^sub>s\<rangle>\<rangle>] [\<langle>0, send\<langle>\<langle>h [\<langle>Suc
        (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,
                                    \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                                     \<langle>\<star>, send\<langle>occurs
                               \<langle>Suc
   (Suc (Suc (Suc 0)))\<rangle>\<^sub>v\<rangle>\<rangle>]],
  [transaction\<^sub>1 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>senc [\<langle>Suc
 0\<rangle>\<^sub>v,
                             \<langle>Suc
 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>Suc
                   (Suc (Suc 0))\<rangle>\<^sub>v,
         \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    (Suc (Suc 0))\<rangle>\<^sub>v,
                          \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v in \<langle>sensitive
                   token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v in \<langle>unwrap
                   token1\<rangle>\<^sub>s\<rangle>\<rangle>] new [\<langle>Suc
 (Suc (Suc (Suc 0)))\<rangle>\<^sub>v] [\<langle>0, insert\<langle>\<langle>Suc
 (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,\<langle>sensitive
          token1\<rangle>\<^sub>s\<rangle>\<rangle>] [\<langle>0, send\<langle>\<langle>h [\<langle>Suc
                         (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,
               \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                \<langle>\<star>, send\<langle>occurs
          \<langle>Suc (Suc (Suc (Suc 0)))\<rangle>\<^sub>v\<rangle>\<rangle>]],
  [transaction\<^sub>1 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>senc [\<langle>Suc
 (Suc 0)\<rangle>\<^sub>v,
                             \<langle>Suc
 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v,
         \<langle>Suc (Suc 0)\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    (Suc 0)\<rangle>\<^sub>v,
                          \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                   0\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc 0)\<rangle>\<^sub>v in \<langle>sensitive
             token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc 0)\<rangle>\<^sub>v in \<langle>unwrap
             token1\<rangle>\<^sub>s\<rangle>\<rangle>] new [\<langle>Suc
                                 (Suc (Suc
  (Suc 0)))\<rangle>\<^sub>v] [\<langle>0, insert\<langle>\<langle>Suc
                              (Suc (Suc (Suc
    0)))\<rangle>\<^sub>v,\<langle>sensitive
                                    token1\<rangle>\<^sub>s\<rangle>\<rangle>] [\<langle>0, send\<langle>\<langle>h [\<langle>Suc
             (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,
   \<langle>Suc (Suc 0)\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
    \<langle>\<star>, send\<langle>occurs
                                    \<langle>Suc
        (Suc (Suc (Suc 0)))\<rangle>\<^sub>v\<rangle>\<rangle>]],
  [transaction\<^sub>1 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>senc [\<langle>0\<rangle>\<^sub>v,
                             \<langle>Suc
 (Suc 0)\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v,
         \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    (Suc 0)\<rangle>\<^sub>v,
                          \<langle>Suc (Suc
   0)\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
               (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                       \<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
               (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                       \<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
               (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                       \<langle>0, \<langle>\<langle>Suc
                (Suc 0)\<rangle>\<^sub>v in \<langle>sensitive
                token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                       \<langle>0, \<langle>\<langle>Suc
                (Suc 0)\<rangle>\<^sub>v in \<langle>unwrap
                token1\<rangle>\<^sub>s\<rangle>\<rangle>] new [\<langle>Suc
                                    (Suc
(Suc (Suc 0)))\<rangle>\<^sub>v] [\<langle>0, insert\<langle>\<langle>Suc
                                 (Suc (Suc
  (Suc 0)))\<rangle>\<^sub>v,\<langle>sensitive
 token1\<rangle>\<^sub>s\<rangle>\<rangle>] [\<langle>0, send\<langle>\<langle>h [\<langle>Suc
                (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,
      \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
       \<langle>\<star>, send\<langle>occurs
 \<langle>Suc (Suc (Suc (Suc 0)))\<rangle>\<^sub>v\<rangle>\<rangle>]],
  [transaction\<^sub>1 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>senc [\<langle>Suc
 (Suc 0)\<rangle>\<^sub>v,
                             \<langle>Suc
 (Suc (Suc 0))\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v,
         \<langle>Suc (Suc 0)\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    (Suc (Suc 0))\<rangle>\<^sub>v,
                          \<langle>Suc (Suc
   (Suc 0))\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>Suc
                            (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                            (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>\<star>, \<langle>\<langle>Suc
                            (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                            (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>\<star>, \<langle>\<langle>Suc
                            (Suc (Suc 0))\<rangle>\<^sub>v != \<langle>Suc
                                  (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>\<star>, \<langle>\<langle>Suc
                            (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                            (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>0, \<langle>\<langle>Suc
                      (Suc 0)\<rangle>\<^sub>v in \<langle>sensitive
                      token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                             \<langle>0, \<langle>\<langle>Suc
                      (Suc (Suc 0))\<rangle>\<^sub>v in \<langle>unwrap
                            token1\<rangle>\<^sub>s\<rangle>\<rangle>] new [\<langle>Suc
          (Suc (Suc (Suc 0)))\<rangle>\<^sub>v] [\<langle>0, insert\<langle>\<langle>Suc
          (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,\<langle>sensitive
                   token1\<rangle>\<^sub>s\<rangle>\<rangle>] [\<langle>0, send\<langle>\<langle>h [\<langle>Suc
                                  (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,
                        \<langle>Suc (Suc
 0)\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                         \<langle>\<star>, send\<langle>occurs
                   \<langle>Suc (Suc (Suc
 (Suc 0)))\<rangle>\<^sub>v\<rangle>\<rangle>]],
  [transaction\<^sub>1 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>senc [\<langle>Suc
 0\<rangle>\<^sub>v,
                             \<langle>Suc
 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v,
         \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    0\<rangle>\<^sub>v,
                          \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                   0\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc 0)\<rangle>\<^sub>v in \<langle>sensitive
             token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             0\<rangle>\<^sub>v in \<langle>unwrap
       token1\<rangle>\<^sub>s\<rangle>\<rangle>] new [\<langle>Suc
                           (Suc (Suc (Suc
 0)))\<rangle>\<^sub>v] [\<langle>0, insert\<langle>\<langle>Suc
                        (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,\<langle>sensitive
                                 token1\<rangle>\<^sub>s\<rangle>\<rangle>] [\<langle>0, send\<langle>\<langle>h [\<langle>Suc
          (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,
\<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
 \<langle>\<star>, send\<langle>occurs
                                 \<langle>Suc
     (Suc (Suc (Suc 0)))\<rangle>\<^sub>v\<rangle>\<rangle>]],
  [transaction\<^sub>1 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>senc [\<langle>Suc
 0\<rangle>\<^sub>v,
                             \<langle>Suc
 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>Suc
                   0\<rangle>\<^sub>v,
         \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    (Suc (Suc 0))\<rangle>\<^sub>v,
                          \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             0\<rangle>\<^sub>v in \<langle>sensitive
       token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v in \<langle>unwrap
                   token1\<rangle>\<^sub>s\<rangle>\<rangle>] new [\<langle>Suc
 (Suc (Suc (Suc 0)))\<rangle>\<^sub>v] [\<langle>0, insert\<langle>\<langle>Suc
 (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,\<langle>sensitive
          token1\<rangle>\<^sub>s\<rangle>\<rangle>] [\<langle>0, send\<langle>\<langle>h [\<langle>Suc
                         (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,
               \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                \<langle>\<star>, send\<langle>occurs
          \<langle>Suc (Suc (Suc (Suc 0)))\<rangle>\<^sub>v\<rangle>\<rangle>]],
  [transaction\<^sub>1 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>senc [\<langle>Suc
 (Suc (Suc 0))\<rangle>\<^sub>v,
                             \<langle>Suc
 (Suc 0)\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v,
         \<langle>Suc (Suc (Suc 0))\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    (Suc (Suc 0))\<rangle>\<^sub>v,
                          \<langle>Suc (Suc
   0)\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>Suc
                      (Suc (Suc 0))\<rangle>\<^sub>v != \<langle>Suc
                            (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                       \<langle>\<star>, \<langle>\<langle>Suc
                      (Suc (Suc 0))\<rangle>\<^sub>v != \<langle>Suc
                            (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                       \<langle>\<star>, \<langle>\<langle>Suc
                      (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                      (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                       \<langle>\<star>, \<langle>\<langle>Suc
                      (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                      (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                       \<langle>0, \<langle>\<langle>Suc
                (Suc 0)\<rangle>\<^sub>v in \<langle>sensitive
                token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                       \<langle>0, \<langle>\<langle>Suc
                (Suc (Suc 0))\<rangle>\<^sub>v in \<langle>unwrap
                      token1\<rangle>\<^sub>s\<rangle>\<rangle>] new [\<langle>Suc
    (Suc (Suc (Suc 0)))\<rangle>\<^sub>v] [\<langle>0, insert\<langle>\<langle>Suc
    (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,\<langle>sensitive
             token1\<rangle>\<^sub>s\<rangle>\<rangle>] [\<langle>0, send\<langle>\<langle>h [\<langle>Suc
                            (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,
                  \<langle>Suc (Suc (Suc
0))\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                   \<langle>\<star>, send\<langle>occurs
             \<langle>Suc (Suc (Suc (Suc
0)))\<rangle>\<^sub>v\<rangle>\<rangle>]],
  [transaction\<^sub>1 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>senc [\<langle>Suc
 0\<rangle>\<^sub>v,
                             \<langle>Suc
 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v,
         \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    (Suc (Suc 0))\<rangle>\<^sub>v,
                          \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                   (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc 0)\<rangle>\<^sub>v in \<langle>sensitive
             token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v in \<langle>unwrap
                   token1\<rangle>\<^sub>s\<rangle>\<rangle>] new [\<langle>Suc
 (Suc (Suc (Suc 0)))\<rangle>\<^sub>v] [\<langle>0, insert\<langle>\<langle>Suc
 (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,\<langle>sensitive
          token1\<rangle>\<^sub>s\<rangle>\<rangle>] [\<langle>0, send\<langle>\<langle>h [\<langle>Suc
                         (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,
               \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                \<langle>\<star>, send\<langle>occurs
          \<langle>Suc (Suc (Suc (Suc 0)))\<rangle>\<^sub>v\<rangle>\<rangle>]],
  [transaction\<^sub>1 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>senc [\<langle>Suc
 (Suc 0)\<rangle>\<^sub>v,
                             \<langle>Suc
 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v,
         \<langle>Suc (Suc 0)\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    (Suc (Suc 0))\<rangle>\<^sub>v,
                          \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                   0\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                   (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                   (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc 0)\<rangle>\<^sub>v in \<langle>sensitive
             token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v in \<langle>unwrap
                   token1\<rangle>\<^sub>s\<rangle>\<rangle>] new [\<langle>Suc
 (Suc (Suc (Suc 0)))\<rangle>\<^sub>v] [\<langle>0, insert\<langle>\<langle>Suc
 (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,\<langle>sensitive
          token1\<rangle>\<^sub>s\<rangle>\<rangle>] [\<langle>0, send\<langle>\<langle>h [\<langle>Suc
                         (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,
               \<langle>Suc (Suc 0)\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                \<langle>\<star>, send\<langle>occurs
          \<langle>Suc (Suc (Suc (Suc 0)))\<rangle>\<^sub>v\<rangle>\<rangle>]],
  [transaction\<^sub>1 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>senc [\<langle>Suc
 (Suc (Suc 0))\<rangle>\<^sub>v,
                             \<langle>Suc
 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v,
         \<langle>Suc (Suc (Suc 0))\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    (Suc (Suc 0))\<rangle>\<^sub>v,
                          \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>Suc
                   (Suc (Suc 0))\<rangle>\<^sub>v != \<langle>Suc
                         0\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   (Suc (Suc 0))\<rangle>\<^sub>v != \<langle>Suc
                         (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                   (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc 0)\<rangle>\<^sub>v in \<langle>sensitive
             token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v in \<langle>unwrap
                   token1\<rangle>\<^sub>s\<rangle>\<rangle>] new [\<langle>Suc
 (Suc (Suc (Suc 0)))\<rangle>\<^sub>v] [\<langle>0, insert\<langle>\<langle>Suc
 (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,\<langle>sensitive
          token1\<rangle>\<^sub>s\<rangle>\<rangle>] [\<langle>0, send\<langle>\<langle>h [\<langle>Suc
                         (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,
               \<langle>Suc (Suc (Suc 0))\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                \<langle>\<star>, send\<langle>occurs
          \<langle>Suc (Suc (Suc (Suc 0)))\<rangle>\<^sub>v\<rangle>\<rangle>]],
  [transaction\<^sub>1 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>senc [\<langle>0\<rangle>\<^sub>v,
                             \<langle>Suc
 (Suc 0)\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v,
         \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    (Suc (Suc 0))\<rangle>\<^sub>v,
                          \<langle>Suc (Suc
   0)\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
               (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                       \<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
               (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                       \<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
               (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                       \<langle>\<star>, \<langle>\<langle>Suc
                      (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                      (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                       \<langle>\<star>, \<langle>\<langle>Suc
                      (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                      (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                       \<langle>0, \<langle>\<langle>Suc
                (Suc 0)\<rangle>\<^sub>v in \<langle>sensitive
                token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                       \<langle>0, \<langle>\<langle>Suc
                (Suc (Suc 0))\<rangle>\<^sub>v in \<langle>unwrap
                      token1\<rangle>\<^sub>s\<rangle>\<rangle>] new [\<langle>Suc
    (Suc (Suc (Suc 0)))\<rangle>\<^sub>v] [\<langle>0, insert\<langle>\<langle>Suc
    (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,\<langle>sensitive
             token1\<rangle>\<^sub>s\<rangle>\<rangle>] [\<langle>0, send\<langle>\<langle>h [\<langle>Suc
                            (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,
                  \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                   \<langle>\<star>, send\<langle>occurs
             \<langle>Suc (Suc (Suc (Suc
0)))\<rangle>\<^sub>v\<rangle>\<rangle>]],
  [transaction\<^sub>1 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>senc [\<langle>0\<rangle>\<^sub>v,
                             \<langle>Suc
 (Suc (Suc 0))\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v,
         \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    (Suc (Suc 0))\<rangle>\<^sub>v,
                          \<langle>Suc (Suc
   (Suc 0))\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
                     (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
                     (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
                     (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>\<star>, \<langle>\<langle>Suc
                            (Suc (Suc 0))\<rangle>\<^sub>v != \<langle>Suc
                                  (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>\<star>, \<langle>\<langle>Suc
                            (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                            (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>0, \<langle>\<langle>Suc
                      (Suc 0)\<rangle>\<^sub>v in \<langle>sensitive
                      token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                             \<langle>0, \<langle>\<langle>Suc
                      (Suc (Suc 0))\<rangle>\<^sub>v in \<langle>unwrap
                            token1\<rangle>\<^sub>s\<rangle>\<rangle>] new [\<langle>Suc
          (Suc (Suc (Suc 0)))\<rangle>\<^sub>v] [\<langle>0, insert\<langle>\<langle>Suc
          (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,\<langle>sensitive
                   token1\<rangle>\<^sub>s\<rangle>\<rangle>] [\<langle>0, send\<langle>\<langle>h [\<langle>Suc
                                  (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,
                        \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                         \<langle>\<star>, send\<langle>occurs
                   \<langle>Suc (Suc (Suc
 (Suc 0)))\<rangle>\<^sub>v\<rangle>\<rangle>]],
  [transaction\<^sub>1 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>senc [\<langle>0\<rangle>\<^sub>v,
                             \<langle>Suc
 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>Suc
                   (Suc (Suc 0))\<rangle>\<^sub>v,
         \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    (Suc (Suc 0))\<rangle>\<^sub>v,
                          \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
            0\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
            (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
            (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v in \<langle>sensitive
                   token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v in \<langle>unwrap
                   token1\<rangle>\<^sub>s\<rangle>\<rangle>] new [\<langle>Suc
 (Suc (Suc (Suc 0)))\<rangle>\<^sub>v] [\<langle>0, insert\<langle>\<langle>Suc
 (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,\<langle>sensitive
          token1\<rangle>\<^sub>s\<rangle>\<rangle>] [\<langle>0, send\<langle>\<langle>h [\<langle>Suc
                         (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,
               \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                \<langle>\<star>, send\<langle>occurs
          \<langle>Suc (Suc (Suc (Suc 0)))\<rangle>\<^sub>v\<rangle>\<rangle>]]]
RE_IMPORT_ATT_transaction_setdecrypt ==
concat
 [[transaction\<^sub>2 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>0\<rangle>\<^sub>v,
                          \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
            0\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>0\<rangle>\<^sub>v not in \<langle>wrap
          token1\<rangle>\<^sub>s\<rangle>\<rangle>]  [\<langle>0, insert\<langle>\<langle>0\<rangle>\<^sub>v,\<langle>decrypt
      token1\<rangle>\<^sub>s\<rangle>\<rangle>] []],
  [transaction\<^sub>2 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    0\<rangle>\<^sub>v,
                          \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>0, \<langle>\<langle>Suc
             0\<rangle>\<^sub>v not in \<langle>wrap
           token1\<rangle>\<^sub>s\<rangle>\<rangle>]  [\<langle>0, insert\<langle>\<langle>Suc
                 0\<rangle>\<^sub>v,\<langle>decrypt
        token1\<rangle>\<^sub>s\<rangle>\<rangle>] []]]
RE_IMPORT_ATT_transaction_decrypt1 ==
concat
 [[transaction\<^sub>2 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>0\<rangle>\<^sub>v,
                          \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>senc [\<langle>Suc
 (Suc 0)\<rangle>\<^sub>v,
                             \<langle>Suc
 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
            0\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
            (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>0\<rangle>\<^sub>v in \<langle>decrypt
      token1\<rangle>\<^sub>s\<rangle>\<rangle>]  [\<langle>0, delete\<langle>\<langle>0\<rangle>\<^sub>v,\<langle>decrypt
  token1\<rangle>\<^sub>s\<rangle>\<rangle>] [\<langle>0, send\<langle>\<langle>Suc
     (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>]],
  [transaction\<^sub>2 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    0\<rangle>\<^sub>v,
                          \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>senc [\<langle>Suc
 0\<rangle>\<^sub>v,
                             \<langle>Suc
 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>0, \<langle>\<langle>Suc
             0\<rangle>\<^sub>v in \<langle>decrypt
       token1\<rangle>\<^sub>s\<rangle>\<rangle>]  [\<langle>0, delete\<langle>\<langle>Suc
             0\<rangle>\<^sub>v,\<langle>decrypt
    token1\<rangle>\<^sub>s\<rangle>\<rangle>] [\<langle>0, send\<langle>\<langle>Suc
       0\<rangle>\<^sub>v\<rangle>\<rangle>]],
  [transaction\<^sub>2 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    0\<rangle>\<^sub>v,
                          \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>senc [\<langle>Suc
 (Suc 0)\<rangle>\<^sub>v,
                             \<langle>Suc
 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             0\<rangle>\<^sub>v in \<langle>decrypt
       token1\<rangle>\<^sub>s\<rangle>\<rangle>]  [\<langle>0, delete\<langle>\<langle>Suc
             0\<rangle>\<^sub>v,\<langle>decrypt
    token1\<rangle>\<^sub>s\<rangle>\<rangle>] [\<langle>0, send\<langle>\<langle>Suc
       (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>]],
  [transaction\<^sub>2 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    (Suc 0)\<rangle>\<^sub>v,
                          \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>senc [\<langle>Suc
 (Suc 0)\<rangle>\<^sub>v,
                             \<langle>Suc
 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                   0\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc 0)\<rangle>\<^sub>v in \<langle>decrypt
             token1\<rangle>\<^sub>s\<rangle>\<rangle>]  [\<langle>0, delete\<langle>\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v,\<langle>decrypt
                token1\<rangle>\<^sub>s\<rangle>\<rangle>] [\<langle>0, send\<langle>\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>]],
  [transaction\<^sub>2 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>0\<rangle>\<^sub>v,
                          \<langle>Suc (Suc
   0)\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>senc [\<langle>Suc
 (Suc 0)\<rangle>\<^sub>v,
                             \<langle>Suc
 (Suc 0)\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
                  (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                          \<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
                  (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                          \<langle>0, \<langle>\<langle>0\<rangle>\<^sub>v in \<langle>decrypt
            token1\<rangle>\<^sub>s\<rangle>\<rangle>]  [\<langle>0, delete\<langle>\<langle>0\<rangle>\<^sub>v,\<langle>decrypt
        token1\<rangle>\<^sub>s\<rangle>\<rangle>] [\<langle>0, send\<langle>\<langle>Suc
           (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>]]]
RE_IMPORT_ATT_transaction_attack1 ==
[transaction\<^sub>2 [\<langle>\<star>, receive\<langle>occurs
                   \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                      \<langle>0, receive\<langle>\<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>] [\<langle>0, \<langle>\<langle>0\<rangle>\<^sub>v in \<langle>sensitive
        token1\<rangle>\<^sub>s\<rangle>\<rangle>]  [] [\<langle>0, send\<langle>attack\<langle>0\<rangle>\<rangle>\<rangle>]]
RE_IMPORT_ATT_protocol ==
concat
 [RE_IMPORT_ATT_transaction_iik1, RE_IMPORT_ATT_transaction_iik2,
  RE_IMPORT_ATT_transaction_setwrap, RE_IMPORT_ATT_transaction_setunwrap,
  RE_IMPORT_ATT_transaction_unwrapsensitive,
  RE_IMPORT_ATT_transaction_wrapattr,
  RE_IMPORT_ATT_transaction_decrypt1attr,
  RE_IMPORT_ATT_transaction_decrypt2attr, RE_IMPORT_ATT_transaction_wrap,
  RE_IMPORT_ATT_transaction_setdecrypt, RE_IMPORT_ATT_transaction_decrypt1,
  RE_IMPORT_ATT_transaction_attack1]
RE_IMPORT_ATT_fixpoint ==
([\<langle>h [\<langle>{sensitive token1}\<rangle>\<^sub>a,
              \<langle>{sensitive
                         token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>h [\<langle>{wrap token1}\<rangle>\<^sub>a,
              \<langle>{}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  occurs \<langle>{wrap token1}\<rangle>\<^sub>a,
  \<langle>h [\<langle>{decrypt token1}\<rangle>\<^sub>a,
              \<langle>{sensitive
                         token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  occurs \<langle>{decrypt token1}\<rangle>\<^sub>a,
  \<langle>senc [\<langle>{sensitive token1}\<rangle>\<^sub>a,
                 \<langle>{}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>RE_IMPORT_ATT_fun.bind [\<langle>{extract token1,
       sensitive token1}\<rangle>\<^sub>a,
                                   \<langle>{sensitive
        token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>senc [\<langle>{}\<rangle>\<^sub>a,
                 \<langle>{}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>RE_IMPORT_ATT_fun.bind [\<langle>{extract token1,
       wrap token1}\<rangle>\<^sub>a,
                                   \<langle>{}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  \<langle>h [\<langle>{extract token1, sensitive token1}\<rangle>\<^sub>a,
              \<langle>{sensitive
                         token1}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  occurs \<langle>{sensitive token1}\<rangle>\<^sub>a,
  occurs \<langle>{extract token1, sensitive token1}\<rangle>\<^sub>a,
  \<langle>h [\<langle>{extract token1, wrap token1}\<rangle>\<^sub>a,
              \<langle>{}\<rangle>\<^sub>a]\<rangle>\<^sub>t,
  occurs \<langle>{}\<rangle>\<^sub>a,
  occurs \<langle>{extract token1, wrap token1}\<rangle>\<^sub>a],
 [{wrap token1}, {decrypt token1}, {sensitive token1},
  {extract token1, sensitive token1}, {}, {extract token1, wrap token1},
  {unwrap token1, decrypt token1}, {unwrap token1, wrap token1},
  {decrypt token1, sensitive token1},
  {unwrap token1, extract token1, wrap token1},
  {decrypt token1, extract token1, sensitive token1}],
 [({decrypt token1}, {unwrap token1, decrypt token1}),
  ({wrap token1}, {unwrap token1, wrap token1}),
  ({sensitive token1}, {decrypt token1, sensitive token1}),
  ({extract token1, wrap token1},
   {unwrap token1, extract token1, wrap token1}),
  ({extract token1, sensitive token1},
   {decrypt token1, extract token1, sensitive token1})])
RE_IMPORT_ATT_SMP ==
[\<langle>h [\<langle>6\<rangle>\<^sub>v,
             \<langle>5\<rangle>\<^sub>v]\<rangle>\<^sub>t,
 \<langle>senc [\<langle>8\<rangle>\<^sub>v,
                \<langle>7\<rangle>\<^sub>v]\<rangle>\<^sub>t,
 \<langle>h [\<langle>9\<rangle>\<^sub>v,
             \<langle>6\<rangle>\<^sub>v]\<rangle>\<^sub>t,
 \<langle>RE_IMPORT_ATT_fun.bind [\<langle>7\<rangle>\<^sub>v,
                                  \<langle>5\<rangle>\<^sub>v]\<rangle>\<^sub>t,
 Fun OccursFact [Var (Var OccursSecType, 5), \<langle>9\<rangle>\<^sub>v],
 \<langle>9\<rangle>\<^sub>v, Var (Var OccursSecType, 5),
 Var (Var SetType, 5), Var (Var AttackType, 5)]
RE_IMPORT_ATT_transaction_wrap ==
concat
 [[transaction\<^sub>2 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>0\<rangle>\<^sub>v,
                          \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    (Suc 0)\<rangle>\<^sub>v,
                          \<langle>Suc (Suc
   (Suc 0))\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
                     0\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
                     (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
                     (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>\<star>, \<langle>\<langle>Suc
                            0\<rangle>\<^sub>v != \<langle>Suc
                      (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>\<star>, \<langle>\<langle>Suc
                            0\<rangle>\<^sub>v != \<langle>Suc
                      (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>\<star>, \<langle>\<langle>Suc
                            (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                            (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>0, \<langle>\<langle>0\<rangle>\<^sub>v in \<langle>extract
               token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                             \<langle>0, \<langle>\<langle>Suc
                      (Suc 0)\<rangle>\<^sub>v in \<langle>wrap
                      token1\<rangle>\<^sub>s\<rangle>\<rangle>]  [] [\<langle>0, send\<langle>\<langle>senc [\<langle>Suc
      0\<rangle>\<^sub>v,
                                  \<langle>Suc
      (Suc (Suc 0))\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                                \<langle>0, send\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>0\<rangle>\<^sub>v,
              \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>]],
  [transaction\<^sub>2 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>0\<rangle>\<^sub>v,
                          \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>0\<rangle>\<^sub>v,
                          \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>0, \<langle>\<langle>0\<rangle>\<^sub>v in \<langle>extract
  token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                \<langle>0, \<langle>\<langle>0\<rangle>\<^sub>v in \<langle>wrap
  token1\<rangle>\<^sub>s\<rangle>\<rangle>]  [] [\<langle>0, send\<langle>\<langle>senc [\<langle>0\<rangle>\<^sub>v,
              \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
            \<langle>0, send\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>0\<rangle>\<^sub>v,
                                \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>]],
  [transaction\<^sub>2 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    0\<rangle>\<^sub>v,
                          \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    (Suc (Suc 0))\<rangle>\<^sub>v,
                          \<langle>Suc (Suc
   (Suc 0))\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>Suc
                            0\<rangle>\<^sub>v != \<langle>Suc
                      (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>\<star>, \<langle>\<langle>Suc
                            0\<rangle>\<^sub>v != \<langle>Suc
                      (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>\<star>, \<langle>\<langle>Suc
                            0\<rangle>\<^sub>v != \<langle>Suc
                      (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>\<star>, \<langle>\<langle>Suc
                            0\<rangle>\<^sub>v != \<langle>Suc
                      (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>0, \<langle>\<langle>Suc
                      0\<rangle>\<^sub>v in \<langle>extract
                token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                             \<langle>0, \<langle>\<langle>Suc
                      (Suc (Suc 0))\<rangle>\<^sub>v in \<langle>wrap
                            token1\<rangle>\<^sub>s\<rangle>\<rangle>]  [] [\<langle>0, send\<langle>\<langle>senc [\<langle>Suc
            0\<rangle>\<^sub>v,
  \<langle>Suc (Suc (Suc 0))\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
\<langle>0, send\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>Suc
                              0\<rangle>\<^sub>v,
                    \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>]],
  [transaction\<^sub>2 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    (Suc 0)\<rangle>\<^sub>v,
                          \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    (Suc 0)\<rangle>\<^sub>v,
                          \<langle>Suc (Suc
   0)\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>Suc
                      (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                      0\<rangle>\<^sub>v\<rangle>\<rangle>,
                       \<langle>\<star>, \<langle>\<langle>Suc
                      0\<rangle>\<^sub>v != \<langle>Suc
                (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                       \<langle>\<star>, \<langle>\<langle>Suc
                      0\<rangle>\<^sub>v != \<langle>Suc
                (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                       \<langle>0, \<langle>\<langle>Suc
                (Suc 0)\<rangle>\<^sub>v in \<langle>extract
                token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                       \<langle>0, \<langle>\<langle>Suc
                (Suc 0)\<rangle>\<^sub>v in \<langle>wrap
                token1\<rangle>\<^sub>s\<rangle>\<rangle>]  [] [\<langle>0, send\<langle>\<langle>senc [\<langle>Suc
0\<rangle>\<^sub>v,
                            \<langle>Suc
(Suc 0)\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                          \<langle>0, send\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>Suc
                  (Suc 0)\<rangle>\<^sub>v,
        \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>]],
  [transaction\<^sub>2 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>0\<rangle>\<^sub>v,
                          \<langle>Suc (Suc
   0)\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    (Suc 0)\<rangle>\<^sub>v,
                          \<langle>Suc (Suc
   0)\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
               (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                       \<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
               (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                       \<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
               (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                       \<langle>0, \<langle>\<langle>0\<rangle>\<^sub>v in \<langle>extract
         token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                       \<langle>0, \<langle>\<langle>Suc
                (Suc 0)\<rangle>\<^sub>v in \<langle>wrap
                token1\<rangle>\<^sub>s\<rangle>\<rangle>]  [] [\<langle>0, send\<langle>\<langle>senc [\<langle>Suc
(Suc 0)\<rangle>\<^sub>v,
                            \<langle>Suc
(Suc 0)\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                          \<langle>0, send\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>0\<rangle>\<^sub>v,
        \<langle>Suc (Suc 0)\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>]],
  [transaction\<^sub>2 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    (Suc 0)\<rangle>\<^sub>v,
                          \<langle>Suc (Suc
   (Suc 0))\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    (Suc 0)\<rangle>\<^sub>v,
                          \<langle>Suc (Suc
   (Suc 0))\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>Suc
                            (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                            (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>\<star>, \<langle>\<langle>Suc
                            (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                            (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>\<star>, \<langle>\<langle>Suc
                            (Suc (Suc 0))\<rangle>\<^sub>v != \<langle>Suc
                                  (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>\<star>, \<langle>\<langle>Suc
                            (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                            (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>0, \<langle>\<langle>Suc
                      (Suc 0)\<rangle>\<^sub>v in \<langle>extract
                      token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                             \<langle>0, \<langle>\<langle>Suc
                      (Suc 0)\<rangle>\<^sub>v in \<langle>wrap
                      token1\<rangle>\<^sub>s\<rangle>\<rangle>]  [] [\<langle>0, send\<langle>\<langle>senc [\<langle>Suc
      (Suc (Suc 0))\<rangle>\<^sub>v,
                                  \<langle>Suc
      (Suc (Suc 0))\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                                \<langle>0, send\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>Suc
                        (Suc 0)\<rangle>\<^sub>v,
              \<langle>Suc (Suc (Suc 0))\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>]],
  [transaction\<^sub>2 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    0\<rangle>\<^sub>v,
                          \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    (Suc 0)\<rangle>\<^sub>v,
                          \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                   0\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             0\<rangle>\<^sub>v in \<langle>extract
       token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc 0)\<rangle>\<^sub>v in \<langle>wrap
             token1\<rangle>\<^sub>s\<rangle>\<rangle>]  [] [\<langle>0, send\<langle>\<langle>senc [\<langle>Suc
                                   0\<rangle>\<^sub>v,
                         \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                       \<langle>0, send\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>Suc
               0\<rangle>\<^sub>v,
     \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>]],
  [transaction\<^sub>2 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    0\<rangle>\<^sub>v,
                          \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    0\<rangle>\<^sub>v,
                          \<langle>Suc (Suc
   (Suc 0))\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>Suc
                            0\<rangle>\<^sub>v != \<langle>Suc
                      (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>\<star>, \<langle>\<langle>Suc
                            0\<rangle>\<^sub>v != \<langle>Suc
                      (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>\<star>, \<langle>\<langle>Suc
                            0\<rangle>\<^sub>v != \<langle>Suc
                      (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>0, \<langle>\<langle>Suc
                      0\<rangle>\<^sub>v in \<langle>extract
                token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                             \<langle>0, \<langle>\<langle>Suc
                      0\<rangle>\<^sub>v in \<langle>wrap
                token1\<rangle>\<^sub>s\<rangle>\<rangle>]  [] [\<langle>0, send\<langle>\<langle>senc [\<langle>Suc
0\<rangle>\<^sub>v,
                            \<langle>Suc
(Suc (Suc 0))\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                          \<langle>0, send\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>Suc
                  0\<rangle>\<^sub>v,
        \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>]],
  [transaction\<^sub>2 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    (Suc (Suc 0))\<rangle>\<^sub>v,
                          \<langle>Suc (Suc
   0)\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    (Suc 0)\<rangle>\<^sub>v,
                          \<langle>Suc (Suc
   (Suc 0))\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>Suc
                            (Suc (Suc 0))\<rangle>\<^sub>v != \<langle>Suc
                                  (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>\<star>, \<langle>\<langle>Suc
                            (Suc (Suc 0))\<rangle>\<^sub>v != \<langle>Suc
                                  (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>\<star>, \<langle>\<langle>Suc
                            (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                            (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>\<star>, \<langle>\<langle>Suc
                            (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                            (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>0, \<langle>\<langle>Suc
                      (Suc (Suc 0))\<rangle>\<^sub>v in \<langle>extract
                            token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                             \<langle>0, \<langle>\<langle>Suc
                      (Suc 0)\<rangle>\<^sub>v in \<langle>wrap
                      token1\<rangle>\<^sub>s\<rangle>\<rangle>]  [] [\<langle>0, send\<langle>\<langle>senc [\<langle>Suc
      (Suc 0)\<rangle>\<^sub>v,
                                  \<langle>Suc
      (Suc (Suc 0))\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                                \<langle>0, send\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>Suc
                        (Suc (Suc 0))\<rangle>\<^sub>v,
              \<langle>Suc (Suc 0)\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>]],
  [transaction\<^sub>2 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    0\<rangle>\<^sub>v,
                          \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    (Suc 0)\<rangle>\<^sub>v,
                          \<langle>Suc (Suc
   (Suc 0))\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>Suc
                            0\<rangle>\<^sub>v != \<langle>Suc
                      (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>\<star>, \<langle>\<langle>Suc
                            0\<rangle>\<^sub>v != \<langle>Suc
                      (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>\<star>, \<langle>\<langle>Suc
                            0\<rangle>\<^sub>v != \<langle>Suc
                      (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>\<star>, \<langle>\<langle>Suc
                            0\<rangle>\<^sub>v != \<langle>Suc
                      (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>\<star>, \<langle>\<langle>Suc
                            (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                            (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>0, \<langle>\<langle>Suc
                      0\<rangle>\<^sub>v in \<langle>extract
                token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                             \<langle>0, \<langle>\<langle>Suc
                      (Suc 0)\<rangle>\<^sub>v in \<langle>wrap
                      token1\<rangle>\<^sub>s\<rangle>\<rangle>]  [] [\<langle>0, send\<langle>\<langle>senc [\<langle>Suc
      0\<rangle>\<^sub>v,
                                  \<langle>Suc
      (Suc (Suc 0))\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                                \<langle>0, send\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>Suc
                        0\<rangle>\<^sub>v,
              \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>]],
  [transaction\<^sub>2 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    (Suc 0)\<rangle>\<^sub>v,
                          \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    (Suc 0)\<rangle>\<^sub>v,
                          \<langle>Suc (Suc
   (Suc 0))\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>Suc
                            (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                            0\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>\<star>, \<langle>\<langle>Suc
                            (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                            (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>\<star>, \<langle>\<langle>Suc
                            0\<rangle>\<^sub>v != \<langle>Suc
                      (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>\<star>, \<langle>\<langle>Suc
                            0\<rangle>\<^sub>v != \<langle>Suc
                      (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>\<star>, \<langle>\<langle>Suc
                            (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                            (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>0, \<langle>\<langle>Suc
                      (Suc 0)\<rangle>\<^sub>v in \<langle>extract
                      token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                             \<langle>0, \<langle>\<langle>Suc
                      (Suc 0)\<rangle>\<^sub>v in \<langle>wrap
                      token1\<rangle>\<^sub>s\<rangle>\<rangle>]  [] [\<langle>0, send\<langle>\<langle>senc [\<langle>Suc
      0\<rangle>\<^sub>v,
                                  \<langle>Suc
      (Suc (Suc 0))\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                                \<langle>0, send\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>Suc
                        (Suc 0)\<rangle>\<^sub>v,
              \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>]],
  [transaction\<^sub>2 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    (Suc (Suc 0))\<rangle>\<^sub>v,
                          \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    (Suc 0)\<rangle>\<^sub>v,
                          \<langle>Suc (Suc
   (Suc 0))\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>Suc
                            (Suc (Suc 0))\<rangle>\<^sub>v != \<langle>Suc
                                  0\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>\<star>, \<langle>\<langle>Suc
                            (Suc (Suc 0))\<rangle>\<^sub>v != \<langle>Suc
                                  (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>\<star>, \<langle>\<langle>Suc
                            0\<rangle>\<^sub>v != \<langle>Suc
                      (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>\<star>, \<langle>\<langle>Suc
                            0\<rangle>\<^sub>v != \<langle>Suc
                      (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>\<star>, \<langle>\<langle>Suc
                            (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                            (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>0, \<langle>\<langle>Suc
                      (Suc (Suc 0))\<rangle>\<^sub>v in \<langle>extract
                            token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                             \<langle>0, \<langle>\<langle>Suc
                      (Suc 0)\<rangle>\<^sub>v in \<langle>wrap
                      token1\<rangle>\<^sub>s\<rangle>\<rangle>]  [] [\<langle>0, send\<langle>\<langle>senc [\<langle>Suc
      0\<rangle>\<^sub>v,
                                  \<langle>Suc
      (Suc (Suc 0))\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                                \<langle>0, send\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>Suc
                        (Suc (Suc 0))\<rangle>\<^sub>v,
              \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>]],
  [transaction\<^sub>2 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>0\<rangle>\<^sub>v,
                          \<langle>Suc (Suc
   0)\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    (Suc 0)\<rangle>\<^sub>v,
                          \<langle>Suc (Suc
   (Suc 0))\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
                     (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
                     (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
                     (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>\<star>, \<langle>\<langle>Suc
                            (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                            (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>\<star>, \<langle>\<langle>Suc
                            (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                            (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>0, \<langle>\<langle>0\<rangle>\<^sub>v in \<langle>extract
               token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                             \<langle>0, \<langle>\<langle>Suc
                      (Suc 0)\<rangle>\<^sub>v in \<langle>wrap
                      token1\<rangle>\<^sub>s\<rangle>\<rangle>]  [] [\<langle>0, send\<langle>\<langle>senc [\<langle>Suc
      (Suc 0)\<rangle>\<^sub>v,
                                  \<langle>Suc
      (Suc (Suc 0))\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                                \<langle>0, send\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>0\<rangle>\<^sub>v,
              \<langle>Suc (Suc 0)\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>]],
  [transaction\<^sub>2 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>0\<rangle>\<^sub>v,
                          \<langle>Suc (Suc
   (Suc 0))\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    (Suc 0)\<rangle>\<^sub>v,
                          \<langle>Suc (Suc
   (Suc 0))\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
                     (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
                     (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
                     (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>\<star>, \<langle>\<langle>Suc
                            (Suc (Suc 0))\<rangle>\<^sub>v != \<langle>Suc
                                  (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>\<star>, \<langle>\<langle>Suc
                            (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                            (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>0, \<langle>\<langle>0\<rangle>\<^sub>v in \<langle>extract
               token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                             \<langle>0, \<langle>\<langle>Suc
                      (Suc 0)\<rangle>\<^sub>v in \<langle>wrap
                      token1\<rangle>\<^sub>s\<rangle>\<rangle>]  [] [\<langle>0, send\<langle>\<langle>senc [\<langle>Suc
      (Suc (Suc 0))\<rangle>\<^sub>v,
                                  \<langle>Suc
      (Suc (Suc 0))\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                                \<langle>0, send\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>0\<rangle>\<^sub>v,
              \<langle>Suc (Suc (Suc 0))\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>]],
  [transaction\<^sub>2 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>0\<rangle>\<^sub>v,
                          \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    (Suc (Suc 0))\<rangle>\<^sub>v,
                          \<langle>Suc (Suc
   (Suc 0))\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
                     0\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
                     (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
                     (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>\<star>, \<langle>\<langle>Suc
                            0\<rangle>\<^sub>v != \<langle>Suc
                      (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>\<star>, \<langle>\<langle>Suc
                            0\<rangle>\<^sub>v != \<langle>Suc
                      (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>0, \<langle>\<langle>0\<rangle>\<^sub>v in \<langle>extract
               token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                             \<langle>0, \<langle>\<langle>Suc
                      (Suc (Suc 0))\<rangle>\<^sub>v in \<langle>wrap
                            token1\<rangle>\<^sub>s\<rangle>\<rangle>]  [] [\<langle>0, send\<langle>\<langle>senc [\<langle>Suc
            0\<rangle>\<^sub>v,
  \<langle>Suc (Suc (Suc 0))\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
\<langle>0, send\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>0\<rangle>\<^sub>v,
                    \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>]]]
RE_IMPORT_ATT_transaction_decrypt2attr ==
concat
 [[transaction\<^sub>1 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>senc [\<langle>0\<rangle>\<^sub>v,
                             \<langle>Suc
 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v,
         \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    (Suc (Suc 0))\<rangle>\<^sub>v,
                          \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
            0\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
            (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
            (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                   (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc 0)\<rangle>\<^sub>v not in \<langle>sensitive
                 token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc 0)\<rangle>\<^sub>v not in \<langle>wrap
                 token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc 0)\<rangle>\<^sub>v not in \<langle>decrypt
                 token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v in \<langle>unwrap
                   token1\<rangle>\<^sub>s\<rangle>\<rangle>] new [\<langle>Suc
 (Suc (Suc (Suc 0)))\<rangle>\<^sub>v] [] [\<langle>0, send\<langle>\<langle>h [\<langle>Suc
              (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,
    \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
     \<langle>\<star>, send\<langle>occurs
                                     \<langle>Suc
         (Suc (Suc (Suc 0)))\<rangle>\<^sub>v\<rangle>\<rangle>]],
  [transaction\<^sub>1 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>senc [\<langle>0\<rangle>\<^sub>v,
                             \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>0\<rangle>\<^sub>v,
         \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>0\<rangle>\<^sub>v,
                          \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>0, \<langle>\<langle>0\<rangle>\<^sub>v not in \<langle>sensitive
      token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                \<langle>0, \<langle>\<langle>0\<rangle>\<^sub>v not in \<langle>wrap
      token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                \<langle>0, \<langle>\<langle>0\<rangle>\<^sub>v not in \<langle>decrypt
      token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                \<langle>0, \<langle>\<langle>0\<rangle>\<^sub>v in \<langle>unwrap
  token1\<rangle>\<^sub>s\<rangle>\<rangle>] new [\<langle>Suc
                      (Suc (Suc (Suc 0)))\<rangle>\<^sub>v] [] [\<langle>0, send\<langle>\<langle>h [\<langle>Suc
                                   (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,
                         \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                          \<langle>\<star>, send\<langle>occurs
                    \<langle>Suc (Suc (Suc
  (Suc 0)))\<rangle>\<^sub>v\<rangle>\<rangle>]],
  [transaction\<^sub>1 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>senc [\<langle>Suc
 0\<rangle>\<^sub>v,
                             \<langle>Suc
 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>Suc
                   (Suc (Suc 0))\<rangle>\<^sub>v,
         \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    (Suc (Suc 0))\<rangle>\<^sub>v,
                          \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v not in \<langle>sensitive
                       token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v not in \<langle>wrap
                       token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v not in \<langle>decrypt
                       token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v in \<langle>unwrap
                   token1\<rangle>\<^sub>s\<rangle>\<rangle>] new [\<langle>Suc
 (Suc (Suc (Suc 0)))\<rangle>\<^sub>v] [] [\<langle>0, send\<langle>\<langle>h [\<langle>Suc
              (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,
    \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
     \<langle>\<star>, send\<langle>occurs
                                     \<langle>Suc
         (Suc (Suc (Suc 0)))\<rangle>\<^sub>v\<rangle>\<rangle>]],
  [transaction\<^sub>1 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>senc [\<langle>Suc
 (Suc 0)\<rangle>\<^sub>v,
                             \<langle>Suc
 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v,
         \<langle>Suc (Suc 0)\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    (Suc 0)\<rangle>\<^sub>v,
                          \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                   0\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc 0)\<rangle>\<^sub>v not in \<langle>sensitive
                 token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc 0)\<rangle>\<^sub>v not in \<langle>wrap
                 token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc 0)\<rangle>\<^sub>v not in \<langle>decrypt
                 token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc 0)\<rangle>\<^sub>v in \<langle>unwrap
             token1\<rangle>\<^sub>s\<rangle>\<rangle>] new [\<langle>Suc
                                 (Suc (Suc
  (Suc 0)))\<rangle>\<^sub>v] [] [\<langle>0, send\<langle>\<langle>h [\<langle>Suc
     (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,
                                 \<langle>Suc
     (Suc 0)\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                                  \<langle>\<star>, send\<langle>occurs
                            \<langle>Suc
(Suc (Suc (Suc 0)))\<rangle>\<^sub>v\<rangle>\<rangle>]],
  [transaction\<^sub>1 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>senc [\<langle>0\<rangle>\<^sub>v,
                             \<langle>Suc
 (Suc 0)\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v,
         \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    (Suc 0)\<rangle>\<^sub>v,
                          \<langle>Suc (Suc
   0)\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
               (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                       \<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
               (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                       \<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
               (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                       \<langle>0, \<langle>\<langle>Suc
                (Suc 0)\<rangle>\<^sub>v not in \<langle>sensitive
                    token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                       \<langle>0, \<langle>\<langle>Suc
                (Suc 0)\<rangle>\<^sub>v not in \<langle>wrap
                    token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                       \<langle>0, \<langle>\<langle>Suc
                (Suc 0)\<rangle>\<^sub>v not in \<langle>decrypt
                    token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                       \<langle>0, \<langle>\<langle>Suc
                (Suc 0)\<rangle>\<^sub>v in \<langle>unwrap
                token1\<rangle>\<^sub>s\<rangle>\<rangle>] new [\<langle>Suc
                                    (Suc
(Suc (Suc 0)))\<rangle>\<^sub>v] [] [\<langle>0, send\<langle>\<langle>h [\<langle>Suc
        (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,
                                    \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                                     \<langle>\<star>, send\<langle>occurs
                               \<langle>Suc
   (Suc (Suc (Suc 0)))\<rangle>\<^sub>v\<rangle>\<rangle>]],
  [transaction\<^sub>1 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>senc [\<langle>Suc
 (Suc 0)\<rangle>\<^sub>v,
                             \<langle>Suc
 (Suc (Suc 0))\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v,
         \<langle>Suc (Suc 0)\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    (Suc (Suc 0))\<rangle>\<^sub>v,
                          \<langle>Suc (Suc
   (Suc 0))\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>Suc
                            (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                            (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>\<star>, \<langle>\<langle>Suc
                            (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                            (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>\<star>, \<langle>\<langle>Suc
                            (Suc (Suc 0))\<rangle>\<^sub>v != \<langle>Suc
                                  (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>\<star>, \<langle>\<langle>Suc
                            (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                            (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>0, \<langle>\<langle>Suc
                      (Suc 0)\<rangle>\<^sub>v not in \<langle>sensitive
                          token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                             \<langle>0, \<langle>\<langle>Suc
                      (Suc 0)\<rangle>\<^sub>v not in \<langle>wrap
                          token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                             \<langle>0, \<langle>\<langle>Suc
                      (Suc 0)\<rangle>\<^sub>v not in \<langle>decrypt
                          token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                             \<langle>0, \<langle>\<langle>Suc
                      (Suc (Suc 0))\<rangle>\<^sub>v in \<langle>unwrap
                            token1\<rangle>\<^sub>s\<rangle>\<rangle>] new [\<langle>Suc
          (Suc (Suc (Suc 0)))\<rangle>\<^sub>v] [] [\<langle>0, send\<langle>\<langle>h [\<langle>Suc
                       (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,
             \<langle>Suc (Suc 0)\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
              \<langle>\<star>, send\<langle>occurs
        \<langle>Suc (Suc (Suc (Suc 0)))\<rangle>\<^sub>v\<rangle>\<rangle>]],
  [transaction\<^sub>1 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>senc [\<langle>Suc
 0\<rangle>\<^sub>v,
                             \<langle>Suc
 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v,
         \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    0\<rangle>\<^sub>v,
                          \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                   0\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc 0)\<rangle>\<^sub>v not in \<langle>sensitive
                 token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc 0)\<rangle>\<^sub>v not in \<langle>wrap
                 token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc 0)\<rangle>\<^sub>v not in \<langle>decrypt
                 token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             0\<rangle>\<^sub>v in \<langle>unwrap
       token1\<rangle>\<^sub>s\<rangle>\<rangle>] new [\<langle>Suc
                           (Suc (Suc (Suc
 0)))\<rangle>\<^sub>v] [] [\<langle>0, send\<langle>\<langle>h [\<langle>Suc
                                     (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,
                           \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                            \<langle>\<star>, send\<langle>occurs
                      \<langle>Suc (Suc (Suc
    (Suc 0)))\<rangle>\<^sub>v\<rangle>\<rangle>]],
  [transaction\<^sub>1 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>senc [\<langle>Suc
 0\<rangle>\<^sub>v,
                             \<langle>Suc
 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>Suc
                   0\<rangle>\<^sub>v,
         \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    (Suc (Suc 0))\<rangle>\<^sub>v,
                          \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             0\<rangle>\<^sub>v not in \<langle>sensitive
           token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             0\<rangle>\<^sub>v not in \<langle>wrap
           token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             0\<rangle>\<^sub>v not in \<langle>decrypt
           token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v in \<langle>unwrap
                   token1\<rangle>\<^sub>s\<rangle>\<rangle>] new [\<langle>Suc
 (Suc (Suc (Suc 0)))\<rangle>\<^sub>v] [] [\<langle>0, send\<langle>\<langle>h [\<langle>Suc
              (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,
    \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
     \<langle>\<star>, send\<langle>occurs
                                     \<langle>Suc
         (Suc (Suc (Suc 0)))\<rangle>\<^sub>v\<rangle>\<rangle>]],
  [transaction\<^sub>1 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>senc [\<langle>Suc
 (Suc (Suc 0))\<rangle>\<^sub>v,
                             \<langle>Suc
 (Suc 0)\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v,
         \<langle>Suc (Suc (Suc 0))\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    (Suc (Suc 0))\<rangle>\<^sub>v,
                          \<langle>Suc (Suc
   0)\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>Suc
                      (Suc (Suc 0))\<rangle>\<^sub>v != \<langle>Suc
                            (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                       \<langle>\<star>, \<langle>\<langle>Suc
                      (Suc (Suc 0))\<rangle>\<^sub>v != \<langle>Suc
                            (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                       \<langle>\<star>, \<langle>\<langle>Suc
                      (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                      (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                       \<langle>\<star>, \<langle>\<langle>Suc
                      (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                      (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                       \<langle>0, \<langle>\<langle>Suc
                (Suc 0)\<rangle>\<^sub>v not in \<langle>sensitive
                    token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                       \<langle>0, \<langle>\<langle>Suc
                (Suc 0)\<rangle>\<^sub>v not in \<langle>wrap
                    token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                       \<langle>0, \<langle>\<langle>Suc
                (Suc 0)\<rangle>\<^sub>v not in \<langle>decrypt
                    token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                       \<langle>0, \<langle>\<langle>Suc
                (Suc (Suc 0))\<rangle>\<^sub>v in \<langle>unwrap
                      token1\<rangle>\<^sub>s\<rangle>\<rangle>] new [\<langle>Suc
    (Suc (Suc (Suc 0)))\<rangle>\<^sub>v] [] [\<langle>0, send\<langle>\<langle>h [\<langle>Suc
                 (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,
       \<langle>Suc (Suc (Suc 0))\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
        \<langle>\<star>, send\<langle>occurs
  \<langle>Suc (Suc (Suc (Suc 0)))\<rangle>\<^sub>v\<rangle>\<rangle>]],
  [transaction\<^sub>1 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>senc [\<langle>Suc
 0\<rangle>\<^sub>v,
                             \<langle>Suc
 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v,
         \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    (Suc (Suc 0))\<rangle>\<^sub>v,
                          \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                   (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc 0)\<rangle>\<^sub>v not in \<langle>sensitive
                 token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc 0)\<rangle>\<^sub>v not in \<langle>wrap
                 token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc 0)\<rangle>\<^sub>v not in \<langle>decrypt
                 token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v in \<langle>unwrap
                   token1\<rangle>\<^sub>s\<rangle>\<rangle>] new [\<langle>Suc
 (Suc (Suc (Suc 0)))\<rangle>\<^sub>v] [] [\<langle>0, send\<langle>\<langle>h [\<langle>Suc
              (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,
    \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
     \<langle>\<star>, send\<langle>occurs
                                     \<langle>Suc
         (Suc (Suc (Suc 0)))\<rangle>\<^sub>v\<rangle>\<rangle>]],
  [transaction\<^sub>1 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>senc [\<langle>Suc
 (Suc 0)\<rangle>\<^sub>v,
                             \<langle>Suc
 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v,
         \<langle>Suc (Suc 0)\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    (Suc (Suc 0))\<rangle>\<^sub>v,
                          \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                   0\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                   (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                   (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc 0)\<rangle>\<^sub>v not in \<langle>sensitive
                 token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc 0)\<rangle>\<^sub>v not in \<langle>wrap
                 token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc 0)\<rangle>\<^sub>v not in \<langle>decrypt
                 token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v in \<langle>unwrap
                   token1\<rangle>\<^sub>s\<rangle>\<rangle>] new [\<langle>Suc
 (Suc (Suc (Suc 0)))\<rangle>\<^sub>v] [] [\<langle>0, send\<langle>\<langle>h [\<langle>Suc
              (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,
    \<langle>Suc (Suc 0)\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
     \<langle>\<star>, send\<langle>occurs
                                     \<langle>Suc
         (Suc (Suc (Suc 0)))\<rangle>\<^sub>v\<rangle>\<rangle>]],
  [transaction\<^sub>1 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>senc [\<langle>Suc
 (Suc (Suc 0))\<rangle>\<^sub>v,
                             \<langle>Suc
 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v,
         \<langle>Suc (Suc (Suc 0))\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    (Suc (Suc 0))\<rangle>\<^sub>v,
                          \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>Suc
                   (Suc (Suc 0))\<rangle>\<^sub>v != \<langle>Suc
                         0\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   (Suc (Suc 0))\<rangle>\<^sub>v != \<langle>Suc
                         (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                   (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc 0)\<rangle>\<^sub>v not in \<langle>sensitive
                 token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc 0)\<rangle>\<^sub>v not in \<langle>wrap
                 token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc 0)\<rangle>\<^sub>v not in \<langle>decrypt
                 token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v in \<langle>unwrap
                   token1\<rangle>\<^sub>s\<rangle>\<rangle>] new [\<langle>Suc
 (Suc (Suc (Suc 0)))\<rangle>\<^sub>v] [] [\<langle>0, send\<langle>\<langle>h [\<langle>Suc
              (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,
    \<langle>Suc (Suc (Suc 0))\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
     \<langle>\<star>, send\<langle>occurs
                                     \<langle>Suc
         (Suc (Suc (Suc 0)))\<rangle>\<^sub>v\<rangle>\<rangle>]],
  [transaction\<^sub>1 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>senc [\<langle>0\<rangle>\<^sub>v,
                             \<langle>Suc
 (Suc 0)\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v,
         \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    (Suc (Suc 0))\<rangle>\<^sub>v,
                          \<langle>Suc (Suc
   0)\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
               (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                       \<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
               (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                       \<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
               (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                       \<langle>\<star>, \<langle>\<langle>Suc
                      (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                      (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                       \<langle>\<star>, \<langle>\<langle>Suc
                      (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                      (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                       \<langle>0, \<langle>\<langle>Suc
                (Suc 0)\<rangle>\<^sub>v not in \<langle>sensitive
                    token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                       \<langle>0, \<langle>\<langle>Suc
                (Suc 0)\<rangle>\<^sub>v not in \<langle>wrap
                    token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                       \<langle>0, \<langle>\<langle>Suc
                (Suc 0)\<rangle>\<^sub>v not in \<langle>decrypt
                    token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                       \<langle>0, \<langle>\<langle>Suc
                (Suc (Suc 0))\<rangle>\<^sub>v in \<langle>unwrap
                      token1\<rangle>\<^sub>s\<rangle>\<rangle>] new [\<langle>Suc
    (Suc (Suc (Suc 0)))\<rangle>\<^sub>v] [] [\<langle>0, send\<langle>\<langle>h [\<langle>Suc
                 (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,
       \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
        \<langle>\<star>, send\<langle>occurs
  \<langle>Suc (Suc (Suc (Suc 0)))\<rangle>\<^sub>v\<rangle>\<rangle>]],
  [transaction\<^sub>1 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>senc [\<langle>0\<rangle>\<^sub>v,
                             \<langle>Suc
 (Suc (Suc 0))\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>Suc
                   (Suc 0)\<rangle>\<^sub>v,
         \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    (Suc (Suc 0))\<rangle>\<^sub>v,
                          \<langle>Suc (Suc
   (Suc 0))\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
                     (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
                     (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
                     (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>\<star>, \<langle>\<langle>Suc
                            (Suc (Suc 0))\<rangle>\<^sub>v != \<langle>Suc
                                  (Suc 0)\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>\<star>, \<langle>\<langle>Suc
                            (Suc 0)\<rangle>\<^sub>v != \<langle>Suc
                            (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                             \<langle>0, \<langle>\<langle>Suc
                      (Suc 0)\<rangle>\<^sub>v not in \<langle>sensitive
                          token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                             \<langle>0, \<langle>\<langle>Suc
                      (Suc 0)\<rangle>\<^sub>v not in \<langle>wrap
                          token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                             \<langle>0, \<langle>\<langle>Suc
                      (Suc 0)\<rangle>\<^sub>v not in \<langle>decrypt
                          token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                             \<langle>0, \<langle>\<langle>Suc
                      (Suc (Suc 0))\<rangle>\<^sub>v in \<langle>unwrap
                            token1\<rangle>\<^sub>s\<rangle>\<rangle>] new [\<langle>Suc
          (Suc (Suc (Suc 0)))\<rangle>\<^sub>v] [] [\<langle>0, send\<langle>\<langle>h [\<langle>Suc
                       (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,
             \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
              \<langle>\<star>, send\<langle>occurs
        \<langle>Suc (Suc (Suc (Suc 0)))\<rangle>\<^sub>v\<rangle>\<rangle>]],
  [transaction\<^sub>1 [\<langle>\<star>, receive\<langle>occurs
                     \<langle>0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc 0\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>\<star>, receive\<langle>occurs
                     \<langle>Suc (Suc (Suc
   0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>senc [\<langle>0\<rangle>\<^sub>v,
                             \<langle>Suc
 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>RE_IMPORT_ATT_fun.bind [\<langle>Suc
                   (Suc (Suc 0))\<rangle>\<^sub>v,
         \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
                        \<langle>0, receive\<langle>\<langle>h [\<langle>Suc
                                    (Suc (Suc 0))\<rangle>\<^sub>v,
                          \<langle>Suc 0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>] [\<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
            0\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
            (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>0\<rangle>\<^sub>v != \<langle>Suc
            (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>\<star>, \<langle>\<langle>Suc
                   0\<rangle>\<^sub>v != \<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v not in \<langle>sensitive
                       token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v not in \<langle>wrap
                       token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v not in \<langle>decrypt
                       token1\<rangle>\<^sub>s\<rangle>\<rangle>,
                    \<langle>0, \<langle>\<langle>Suc
             (Suc (Suc 0))\<rangle>\<^sub>v in \<langle>unwrap
                   token1\<rangle>\<^sub>s\<rangle>\<rangle>] new [\<langle>Suc
 (Suc (Suc (Suc 0)))\<rangle>\<^sub>v] [] [\<langle>0, send\<langle>\<langle>h [\<langle>Suc
              (Suc (Suc (Suc 0)))\<rangle>\<^sub>v,
    \<langle>0\<rangle>\<^sub>v]\<rangle>\<^sub>t\<rangle>\<rangle>,
     \<langle>\<star>, send\<langle>occurs
                                     \<langle>Suc
         (Suc (Suc (Suc 0)))\<rangle>\<^sub>v\<rangle>\<rangle>]]]
### theory "Draft.Examples"
### 3.112s elapsed time, 7.676s cpu time, 0.946s GC time
Loading theory "Draft.ExamplesTemplates"
val templateLemmas = []: (string * thm * template) list
### theory "Draft.ExamplesTemplates"
### 2.325s elapsed time, 4.541s cpu time, 0.681s GC time
val it = (): unit
