   [("Roots_of_Algebraic_Poly_Impl.representative_poly_code",
     "representative_poly_complex ?p =
      (case initial_root_problem ?p of
       (mp, triples) =>
         let is = map fst triples; qs = %j. snd (snd (triples ! j))
         in eliminate_aux_vars mp qs is)",
     template_equation
      (template_app (template_hole 10, template_var 0),
       template_app
        (template_app (template_hole 9, t_empty),
         template_app (template_hole 0, template_var 0)))),
    ("Roots_of_Algebraic_Poly_Impl.representative_poly_code",
     "representative_poly_real ?p =
      (case initial_root_problem ?p of
       (mp, triples) =>
         let is = map fst triples; qs = %j. snd (snd (triples ! j))
         in eliminate_aux_vars mp qs is)",
     template_equation
      (template_app (template_hole 10, template_var 0),
       template_app
        (template_app (template_hole 9, t_empty),
         template_app (template_hole 0, template_var 0)))),
    ("Roots_of_Algebraic_Poly_Impl.initial_root_problem_code",
     "initial_root_problem_real ?p =
      (let n = degree ?p; cs = coeffs ?p;
           rcs = remdups (filter (%c. c ~: \<int>) cs);
           pairs = map (%c. (c, min_int_poly c)) rcs;
           spairs = sort_key (%(c, y). degree y) pairs;
           triples = zip [0..<length spairs] spairs;
           mpoly =
             SUM i<=n.
             let c = coeff ?p i
             in MPoly_Type.monom (monomial i 0) 1 *
                (case find (%(j, d, f). d = c) triples of
                 None => Const (to_int c) | Some (j, pair) => Var (Suc j))
       in (mpoly, triples))",
     template_equation
      (template_app (template_hole 41, template_var 0),
       template_app
        (template_app
          (template_hole 40,
           template_app (template_hole 39, template_var 0)),
         t_empty))),
    ("Roots_of_Algebraic_Poly_Impl.initial_root_problem_code",
     "initial_root_problem_complex ?p =
      (let n = degree ?p; cs = coeffs ?p;
           rcs = remdups (filter (%c. c ~: \<int>) cs);
           pairs = map (%c. (c, min_int_poly c)) rcs;
           spairs = sort_key (%(c, y). degree y) pairs;
           triples = zip [0..<length spairs] spairs;
           mpoly =
             SUM i<=n.
             let c = coeff ?p i
             in MPoly_Type.monom (monomial i 0) 1 *
                (case find (%(j, d, f). d = c) triples of
                 None => Const (to_int c) | Some (j, pair) => Var (Suc j))
       in (mpoly, triples))",
     template_equation
      (template_app (template_hole 41, template_var 0),
       template_app
        (template_app
          (template_hole 40,
           template_app (template_hole 39, template_var 0)),
         t_empty)))]
